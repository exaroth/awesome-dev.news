<?xml version="1.0" encoding="utf-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Rust</title><link>https://www.awesome-dev.news</link><description></description><item><title>Which approach to rust is more idiomatic (Helix vs Zed)?</title><link>https://www.reddit.com/r/rust/comments/1iqnats/which_approach_to_rust_is_more_idiomatic_helix_vs/</link><author>/u/No_Penalty2781</author><category>dev</category><category>rust</category><category>reddit</category><pubDate>Sun, 16 Feb 2025 07:50:06 +0000</pubDate><source url="https://www.reddit.com/r/rust/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Rust</source><content:encoded><![CDATA[Hi! I am curious what is the current "meta" (by "meta" I mean the current rust's community  and  way of doing things) of rust programming. I am studying source code of 2 editors I am using: Helix and Zed. And I can see that while they are doing a lot of similar things (like using LSP and parsing it outputs for example) the code is kinda different.It starts from the file structure: in Helix there are not that many folders to look at (like you have helix-core which contains features like "diagnostic", "diff", "history", etc but in Zed every single one of them is a different crate , which approach is more "idiomatic"? To divide every feature as a separate crate or to use more "packed" crates like "core".Then the code itself is kinda different, for example I am currently looking at LSP implementation in both of them and in Helix's case I can follow along and understand the code much more easily (here is the file I am referring to. But in Zed's case it is kinda hard to understand the code because of "type level programming" stuff like this one for example. It also doesn't help that files have a lot of SLOC in them (over 1500 in normal in Zed's repository, is it also how you do rust?) Maybe I am just used to lean functions from other languages (I mainly did TypeScript and Elixir in my career).Other thing I see is that Helix has more comments about "why the thing is doing that in the first place" which I find very helpful (on the other hand in seems that Zed's is abusing a lot of "type level" programming to have a self-documented code but it is harder to reason about at least for me) which approach here you prefer?]]></content:encoded></item><item><title>Fluvio: A Rust-powered streaming platform using WebAssembly for programmable data processing</title><link>https://www.reddit.com/r/rust/comments/1iqgg02/fluvio_a_rustpowered_streaming_platform_using/</link><author>/u/drc1728</author><category>dev</category><category>rust</category><category>reddit</category><pubDate>Sun, 16 Feb 2025 01:00:35 +0000</pubDate><source url="https://www.reddit.com/r/rust/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Rust</source><content:encoded><![CDATA[I am in the process of writing an essay on composable streaming first architecture for data intensive applications. I am thinking of it as a follow up on this article.Quick question for the Rust community:What information would help the Rust community know and experience Fluvio?What would you like to see covered in the essay?   submitted by    /u/drc1728 ]]></content:encoded></item><item><title>Safe elimination of unnecessary bound checks.</title><link>https://www.reddit.com/r/rust/comments/1iqev5s/safe_elimination_of_unnecessary_bound_checks/</link><author>/u/tjientavara</author><category>dev</category><category>rust</category><category>reddit</category><pubDate>Sat, 15 Feb 2025 23:43:26 +0000</pubDate><source url="https://www.reddit.com/r/rust/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Rust</source><content:encoded><![CDATA[Hi, I am working on a Unicode database that is pretty fast, it is a 2 step associated lookup.Here is the code for getting the east-asian-width value of a Unicode code-point. Pay specific attention to the function. This function is a  function and the byte tables that it references are  as well. This will allow you to eventually run the unicode algorithms at both compile and run-time.Since the tables are fixed at compile time, I can proof that all values from the table will result in values that will never break any bounds, so technically the bound checks are unnecessary.There are two bound checks in the assembly output for this function.The check before accessing the EAST_ASIAN_WIDTH_COLUMN table (I use an assert! to do this, otherwise there will be double bound check).And the check on the conversion to the enum.The two bound checks are the two compare + conditional-jump instructions in this code.I could increase the size of the column table to remove one of the bound checks, but I want to keep the table small if possible.Is there a way to safely (I don't want to use the unsafe code) proof to the compiler that those two checks are unnecessary?P.S. technically there is a bound check before the index table a CMOV instruction, but it doubles as a way to also decompress the index table (last entry is repeated), so I feel this is not really a bound check.I was able to concat the two tables, and use a byte offset. So now there is no way to get an out of bound access, and the bound checks are no longer emitted by the compiler.I also added a manual check for out of bound on the enum and return zero instead, this becomes a CMOV and it eliminated all the panic code from the function.]]></content:encoded></item><item><title>Newly Curated 40+ Developer Fixes || Try it now :)</title><link>https://dev.to/0x2e_tech/newly-curated-40-developer-fixes-try-it-now--14fe</link><author>0x2e Tech</author><category>dev</category><category>rust</category><pubDate>Sat, 15 Feb 2025 20:03:25 +0000</pubDate><source url="https://dev.to/t/rust">Dev.to Rust</source><content:encoded><![CDATA[
  
  
  1. Go Testing: Force Retests & Disable Caching
Go Testing: Forcing Retests and Disabling Test Caching  This guide tackles the common issue of stale test results in Go, focusing on how to reliably force retests and disable caching mechanisms.  We'll explore several practical, plug-and-play solutio... Read More
  
  
  2. Flutter Map Key Typing: A Practical Guide for Developers
Flutter Map Key Typing: A Practical Guide for Developers  Let's face it: dealing with map key typing in Flutter can be a real headache if you don't have a clear strategy.  This guide provides a no-nonsense, plug-and-play approach to mastering this as... Read More Flutter Development 
  
  
  3. Multi-task Learning in TensorFlow: A Practical Guide
Multi-task Learning in TensorFlow: A Practical Guide  This guide provides a plug-and-play solution for implementing multi-task learning in TensorFlow.  We'll tackle a common scenario: predicting both the sentiment (positive, negative, neutral) and th... Read More
  
  
  4. Tracking Weight Variance During Neural Network Training
Let's dive into how the variance of weights changes during neural network training.  This is crucial for understanding your model's learning process and diagnosing potential problems.  We'll cover practical methods for tracking this variance and inte... Read More
  
  
  5. Ruby Rescue Best Practices: Why Avoid ?
Hey there, fellow Rubyist! Let's tackle this common pitfall: why rescuing Exception => e is a bad idea and how to do it right.  We'll go beyond the basics and explore practical, plug-and-play solutions.  This is for folks who know some Ruby but want ... Read More
  
  
  6. Expo iOS App Store Transfer Error: "A required agreement is missing"
Decoding the "A required agreement is missing or has expired" Enigma After Expo App Store Transfer (SDK 51.0.0 and beyond)  Let's face it:  That error message is about as helpful as a chocolate teapot.  You've wrestled with your Expo app, successfull... Read More iOS App Development 
  
  
  7. Android Ktor Job Cancellation: A Practical Guide
Android Ktor Job Cancellation: A Practical Guide  Let's tackle that pesky "Job Cancelled" error when using Ktor on Android. This issue often pops up when a long-running Ktor request gets interrupted, perhaps by a configuration problem, user action, o... Read More Android Development 
  
  
  8. Mobile-Unfriendly Laravel Site? Fix it Now!
Alright coder, let's tackle this mobile responsiveness issue head-on.  Your Laravel site's looking great on desktop, but those tiny screens are giving you a headache?  Don't worry, we'll fix it.  This guide is your plug-and-play solution, assuming yo... Read More
  
  
  9. Angular 18 APP_INITIALIZER: Fixing Dependency Injection Issues
Angular 18 APP_INITIALIZER Dependency Injection woes? Let's fix it!  So, you're wrestling with Angular 18's APP_INITIALIZER and its frustrating dependency injection quirks?  Don't worry, you're not alone. This seemingly simple mechanism can turn into... Read More
  
  
  10. Jenkins Token Generation for DevOps: A Practical Guide
Alright, friend! Let's get you a Jenkins API token.  This is crucial for automating tasks and integrating Jenkins with other tools.  Forget the confusing docs – we're going straight to the action.  Understanding the Why:  Before diving in, let's clar... Read More
  
  
  11. Fixing Python's  Error: A Quick Guide
Conquering the AttributeError: module 'pkgutil' has no attribute 'ImpImporter' Beast  Let's face it: that error message is a real mood killer.  It screams, "Your Python environment is a bit of a mess!" But fear not, fellow coder! This isn't some insu... Read More
  
  
  12. Securely Wiping AES XTS Cipher Keys in Go: A Practical Guide
Securely Wiping AES XTS Cipher Key Material in Go: A Practical Guide  This guide provides a clear, actionable solution for securely wiping AES XTS cipher key material in Go.  We'll tackle this problem head-on, avoiding unnecessary jargon and focusing... Read More
  
  
  13. Xamarin Forms: Null Values in IValueConverter? Fix it!
Hey there, fellow Xaml warrior! Let's tackle this pesky null value problem in your Xamarin Forms IValueConverter.  It's a common hiccup, but once you understand the why and the how, you'll be converting values like a pro.   The Usual Suspects: Why Nu... Read More
  
  
  14. Postgres Timestamps: Storing with Time Zone Without UTC Conversion
Storing Timestamps with Time Zone in Postgres Without UTC Conversion: A Practical Guide  This guide provides a clear, actionable solution for storing timestamps with time zones in PostgreSQL without the automatic conversion to UTC.  We'll tackle this... Read More
  
  
  15. Fix "cannot load such file -- utils/popen" on macOS
Alright, friend! Let's tackle this pesky "cannot load such file -- utils/popen" error you're encountering with Homebrew on your macOS system. This usually pops up when Ruby can't find the popen utility, which is crucial for some processes.  We'll wal... Read More
  
  
  16. Flutter Web Self-Signed SSL: A Practical Guide
Flutter Web Self-Signed Certificate Requests: A Straightforward Guide  Let's tackle that pesky self-signed certificate issue in Flutter web development.  You've built your awesome app, connected to your server... but BAM!  That self-signed certificat... Read More Flutter Web Development 
  
  
  17. Docker XRDP Resolution Fix: A Practical Guide
Docker XRDP Resolution Fix: A Practical Guide  Let's face it: wrestling with Docker and XRDP resolution can feel like a black hole of frustration.  You've got your awesome Docker setup, your XRDP server humming, but the display is all wonky.  Fear no... Read More
  
  
  18. Angular Drag-and-Drop: Fixing Nested List Issues
Angular Drag-and-Drop with Deeply Nested Lists: A Practical Guide  Let's face it: drag-and-drop in Angular with deeply nested lists can be a real headache.  The basic functionality often works fine for simple lists, but the moment you add nesting, th... Read More
  
  
  19. MySQL Error 1698: iRedMail Root Access Fix
Alright, friend! Let's tackle this "ERROR 1698 (28000): Access denied for user 'root'@'localhost'" issue head-on.  This is a common problem in MySQL, especially when working with iRedMail.  It basically means your root user, the king of your MySQL ki... Read More
  
  
  20. Docker to Host File Transfer: A Practical Guide
Copying Files from Docker Container to Host: A Practical Guide  This guide provides a no-nonsense, step-by-step approach to copying files from your Docker container to your host machine.  We'll cover various methods, ensuring you have the tools to ta... Read More
  
  
  21. Securely Wiping AES XTS Cipher Keys in Go: A Practical Guide
Securely Wiping AES XTS Cipher Key Material in Go: A Practical Guide  This guide provides a practical, step-by-step solution for securely wiping AES XTS cipher key material in Go.  We'll focus on eliminating sensitive data from memory to prevent pote... Read More
  
  
  22. Doubly-Ended Array Priority Queue: Mastering Node Partnerships
Mastering Node Partnerships in a Doubly-Ended Array-Based Priority Queue (DEAP)  Let's tackle the challenge of correctly managing node partnerships within a Doubly-Ended Array-Based Priority Queue (DEAP).  This isn't your grandma's priority queue; we... Read More Data Structures and Algorithms 
  
  
  23. Node ESM + Log4js: A Practical Guide
Conquering Log4js in Your Node.js ESM Project: A Plug-and-Play Guide  Let's be honest, wrestling with Log4js in an ES module Node.js project can feel like a wrestling match with a greased pig.  But fear not, fellow developer! This guide will walk you... Read More
  
  
  24. Fixing SwiftUI Font Twitching: A Practical Guide
SwiftUI Font Twitching:  A Practical Guide for iOS Developers  Let's be honest, that twitching font in your SwiftUI animation is annoying.  It's like a tiny, digital mosquito buzzing around your otherwise perfect UI. But fear not, fellow developer! W... Read More
  
  
  25. Resize SVG Responsively with D3.js: A Practical Guide
SVG Dimensions on Window Resize: A D3.js Plug-and-Play Solution  This guide provides a straightforward, actionable solution for dynamically resizing SVG elements within a D3.js visualization to match window changes.  We'll ditch the fluff and get str... Read More
  
  
  26. Demystifying Logits & Softmax in TensorFlow: A Practical Guide
Demystifying Logits and Softmax in TensorFlow: A Practical Guide  This guide provides a clear, practical explanation of logits and the difference between softmax and softmax_cross_entropy_with_logits in TensorFlow, focusing on direct application and ... Read More
  
  
  27. JS DevTools: "Function was resolved from bound function" Fix
Alright, detective! Let's crack this 'Function was resolved from bound function' mystery in your JavaScript DevTools.  This cryptic message usually pops up when you're dealing with functions and their context (where they're called from) isn't what yo... Read More
  
  
  28. VueDatePicker + v-mask: A Practical Guide
Mastering the Mashup: VueDatePicker and v-mask  Let's face it:  combining VueDatePicker and v-mask can feel like wrestling a greased pig.  But fear not, fellow developer! This guide will walk you through a smooth, streamlined integration, turning tha... Read More
  
  
  29. Is My Image Gamma Encoded? A NumPy Guide for Image Pros
Hey there, fellow image processing enthusiast!  Let's tackle this gamma encoding mystery. You've loaded your image into NumPy, and now you're wondering: Is it gamma-encoded or not?  Fear not! We'll unravel this with a practical, plug-and-play approac... Read More Image Processing 
  
  
  30. MySQL Functions: Returning Multiple Rows
Returning multiple rows from a MySQL function can be tricky, but it's definitely doable. The key is understanding that MySQL functions, unlike stored procedures, are designed to return a single value.  To get around this limitation, we'll leverage a ... Read More
  
  
  31. Flutter Web Theme Meta Tags: Why Mobile Browsers Ignore Them?
Flutter Web Theme Meta Tags: Why Mobile Browsers Ignore Them?  Let's tackle this head-on.  You've diligently crafted your Flutter web app, meticulously set your theme meta tags, and yet, mobile browsers are ignoring them.  Frustrating, right? This is... Read More Flutter Web Development 
  
  
  32. ASP.NET Pragma Header Won't Go Away?  A Quick Fix
Alright, friend!  Let's tackle this pesky Pragma header that's sticking around in your ASP.NET application even after you've seemingly banished it from your code.  This is a common issue, and it usually boils down to a few sneaky culprits.  We'll go ... Read More
  
  
  33. AWS EC2 Uptime: Node.js & TypeScript Solution
Calculating AWS EC2 Instance Uptime: A Node.js and TypeScript Guide  This guide provides a practical, plug-and-play solution for calculating the uptime of an AWS EC2 instance from the moment it enters the "running" state. We'll leverage the AWS SDK f... Read More
  
  
  34. JS Radio Group Arrow Key Control: A Plug-and-Play Guide
JavaScript Radio Group Navigation: A Plug-and-Play Guide  This guide provides a practical, step-by-step solution to enhance the user experience of multiple radio groups by enabling navigation using the Enter, Up, and Down arrow keys. We'll ditch the ... Read More
  
  
  35. Stop Clicks Under CSS Popovers: A Quick Guide
Stop Clicks Under CSS Popovers: A Quick Guide  This guide provides a straightforward solution to prevent clicks from reaching elements beneath a CSS popover's backdrop.  We'll use JavaScript to handle the event and stop propagation.  This is crucial ... Read More
  
  
  36. Flutter: Align Dynamic Row Element
Flutter: Aligning a Single Element in a Dynamic Height Row  Let's tackle this common Flutter layout challenge: aligning a single element within a row where the row's height changes dynamically.  This often pops up when you have elements of varying si... Read More
  
  
  37. Dark Theme CSS Fix: A Web Developer's Guide
Dark Theme CSS Mayhem? Let's Fix It!   So, your website looks fabulous in light mode, but the second someone flips the switch to dark mode, it's a CSS catastrophe?  Don't worry, you're not alone.  Many developers hit this snag.  This guide will walk ... Read More
  
  
  38. AWS SDK Port Forwarding: Troubleshooting Short-Lived Sessions (C#)
AWS SDK Port Forwarding: Why Your Sessions Die in 30 Seconds (and How to Fix It)  Let's be honest, debugging flaky network connections is nobody's favorite pastime.  But when your AWS SDK port forwarding sessions keep crapping out after less than 30 ... Read More
  
  
  39. Fixing Keras' pad_sequences Import Error: A Quick Guide
Conquering the 'cannot import name 'pad_sequences'' Error in Keras  Let's be honest, import errors are the bane of every programmer's existence.  That frustrating red squiggly line underlining your perfectly crafted code?  Yeah, we've all been there.... Read More
  
  
  40. PHP's ?? Operator: A Practical Guide for Beginners
Hey there, fellow coder! Let's dive into PHP's null coalescing operator, ??.  This little guy is a lifesaver when dealing with potentially null values and will save you from writing tons of tedious if statements.  Think of it as a supercharged way to... Read More
  
  
  41. Spring WebSockets: User-Specific Subscriptions
Alright, let's tackle this Spring WebSocket user subscription puzzle.  The goal?  Get messages to the right user, securely. Forget the fluff, let's get practical.  This solution uses Spring Security for authentication and authorization, ensuring only... Read More Spring WebSockets 
  
  
  42. Angular SSR: Mastering server.ts and main.server.ts
Angular SSR: Demystifying server.ts and main.server.ts  Let's get this straight:  Server-Side Rendering (SSR) in Angular can feel like navigating a labyrinth.  But fear not! We'll cut through the confusion and give you a practical, plug-and-play guid... Read More
  
  
  43. SageMaker Training Stuck? Deep Learning Fixes
Decoding the SageMaker Training Job Enigma: A Practical Guide  So, your SageMaker training job is chilling in a state of suspended animation?  The code compiles, the setup looks good, but nothing's happening in the training phase. Let's troubleshoot ... Read More Amazon SageMaker 
  
  
  44. Braze Connected Content GraphQL: A Practical Guide
Braze "Connected Content" GraphQL Request: A Practical Guide  This guide provides a step-by-step solution for making GraphQL requests to Braze's Connected Content API. We'll cover everything from setting up authentication to handling responses, focus... Read More
  
  
  45. PHP Progress Bar: A Step-by-Step Guide
PHP Progress Bar: A Step-by-Step Guide  This guide provides a practical, plug-and-play solution for creating a dynamic progress bar in PHP, updating in real-time over a period.  We'll cover the PHP backend, HTML frontend, and CSS styling using SASS f... Read More
  
  
  46. Resize Egui Tables by Column: A Rust Guide
Resize Egui Tables by Column: A Rust Guide  This guide provides a practical, plug-and-play solution for creating resizable tables in egui using Rust. We'll build a robust and efficient solution, avoiding unnecessary complexity.  Understanding the Cha... Read More
  
  
  47. C#/.NET: Why avoid inheriting from List? Practical solutions
C#/.NET: Why Avoid Inheriting from List? Practical Solutions  Let's cut to the chase.  You're a C# developer, you've encountered List, and you're thinking, "Hey, I need a specialized list!  Inheriting seems efficient."  Hold your horses, partne... Read More
  
  
  48. Next.js, Antd, Sass/Less: The Ultimate Guide
Next.js, Ant Design, Sass/Less: A Plug-and-Play Guide  This guide provides a no-nonsense, step-by-step approach to integrating Ant Design with Next.js, using either Less, Sass, or CSS Modules.  We'll focus on practicality, offering ready-to-use code ... Read More
  
  
  49. Rust Vector Concatenation: The Ultimate Guide for Programmers
Rust Vector Concatenation: The Ultimate Guide for Programmers  This guide provides a no-nonsense, practical approach to concatenating vectors in Rust.  We'll cover various methods, highlighting their strengths and weaknesses, so you can choose the be... Read More Rust Programming 
  
  
  50. Webpack 5 Breaking Change: Fixing Node.js Module Polyfills
Webpack 5 Breaking Change: Banishing the Node.js Polyfill Gremlins  Let's be honest, that "Webpack 5 breaking change" error message is a real mood killer.  You're cruising along, building your awesome React app, and suddenly BAM!  Webpack throws a ta... Read More
  
  
  💰 Want to Earn 40% Commission?Join our affiliate program and start making money by promoting ! Earn 40% on every sale you refer.  You'll on average around 5$ per sell and for bundled products it will be around 40$ per sale. (So just share it and make money with worrying about product creation and maintanence)]]></content:encoded></item><item><title>Incoming Rust intern need advice?</title><link>https://www.reddit.com/r/rust/comments/1iq9oph/incoming_rust_intern_need_advice/</link><author>/u/Helpful_Ad_9930</author><category>dev</category><category>rust</category><category>reddit</category><pubDate>Sat, 15 Feb 2025 19:52:13 +0000</pubDate><source url="https://www.reddit.com/r/rust/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Rust</source><content:encoded><![CDATA[Hey everyone, I'm a 19-year-old college student who just landed a SWE internship at NVIDIA! My manager has me learning Rust and exploring one of its libraries, and I’m also reading up on operating systems and computer networking. I'm almost done with the OS book and plan to start the networking one next week.I do have a bit of experience with embedded systems I completed two internships during my freshman year. However, so far I’m really enjoying Rust. I am quite a rookie compared to you experienced folks haha! But so far I love how Rust's compiler enforces safety, how Cargo makes dependency management a breeze compared to CMake, and the whole concept of ownership and borrowing is just super cool.At the moment, I’m nearly finished with the Rust book. I am on the concurrency chapter. Guess I am just wondering what next? I really want this return offer and I just want to blow this opportunity out the park. I go too a state school and my manager told me he has high expectations for me after my interviews. I just do not want to let him down you know also plus kind of getting impostor syndrome a bit seeing all the other interns coming from schools such as MIT, Harvard, Standford, etc. Sorry for the vent I guess I just want to prove my worth? and show my manager they made the right choice?What fun, Rust projects have helped you learn a lot?Are there any books you’d recommend that could help me out for the summer?Books I want to read before I start summer:Operating Systems (Three easy pieces)Beej's Guide to Network ProgrammingC++ Concurrency in Action]]></content:encoded></item><item><title>Pushing autovectorization to the limit: utf-8 validator</title><link>https://www.reddit.com/r/rust/comments/1iq7yn2/pushing_autovectorization_to_the_limit_utf8/</link><author>/u/Laiho3</author><category>dev</category><category>rust</category><category>reddit</category><pubDate>Sat, 15 Feb 2025 18:36:40 +0000</pubDate><source url="https://www.reddit.com/r/rust/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Rust</source><content:encoded><![CDATA[   submitted by    /u/Laiho3 ]]></content:encoded></item><item><title>Introducing encode: Encoders/serializers made easy.</title><link>https://www.reddit.com/r/rust/comments/1iq6pz7/introducing_encode_encodersserializers_made_easy/</link><author>/u/Compux72</author><category>dev</category><category>rust</category><category>reddit</category><pubDate>Sat, 15 Feb 2025 17:42:33 +0000</pubDate><source url="https://www.reddit.com/r/rust/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Rust</source><content:encoded><![CDATA[ is a toolbox for building encoders and serializers in Rust. It is heavily inspired by the  and  crates, which are used for building parsers. It is meant to be a companion to these crates, providing a similar level of flexibility and ease of use for reversing the parsing process.The main idea behind  is to provide a set of combinators for building serializers. These combinators can be used to build complex encoders from simple building blocks. This makes it easy to build encoders for different types of data, without having to write a lot of boilerplate code.Another key feature of  is its support for  environments. This makes it suitable for use in embedded systems, where the standard library (and particularly the [] module) is not available.See the  folder for some examples of how to use . Also, check the  module for a list of all the combinators provided by the crate.Ready to use combinators for minimizing boilerplate.: Enables the  feature.: Enables the use of the standard library.: Enables the use of the  crate.: Implements [] for [].Why the  trait instead of ?A buffer stores bytes in memory such that write operations are . The underlying storage may or may not be in contiguous memory. A BufMut value is a cursor into the buffer. Writing to BufMut advances the cursor position.The bytes crate was never designed with falible writes nor  targets in mind. This means that targets with little memory are forced to crash when memory is low, instead of gracefully handling errors.Why the  trait instead of ?Because there is no alternative, at least that i know of, that supports  properlyBecause it's easier to work with than  and Because using  with binary data often leads to a lot of boilerplate]]></content:encoded></item><item><title>Rust and the Null Paradigm: Exploring Safety and Alternatives</title><link>https://dev.to/dedsecrattle/rust-and-the-null-paradigm-exploring-safety-and-alternatives-47b</link><author>Prabhat Kumar</author><category>dev</category><category>rust</category><pubDate>Sat, 15 Feb 2025 17:36:44 +0000</pubDate><source url="https://dev.to/t/rust">Dev.to Rust</source><content:encoded><![CDATA[Rust is a systems programming language known for its focus on memory safety, concurrency, and performance. One of the key decisions made by the Rust team is the choice to not support the null paradigm. While this design choice leads to safer, more reliable code, it raises an important question for developers: How do we handle the absence of a value?In many programming languages, the concept of  or  (depending on the language) is used to represent the absence of a value. This approach, however, introduces a number of issues:Null Pointer Dereferencing: Accessing a  pointer can lead to runtime errors that are often hard to debug. values can lead to subtle bugs when programmers forget to check for them, causing unexpected behaviors in applications.Rust decided to leave behind this problematic paradigm in favor of alternatives that promote safety at compile-time.
  
  
  Rust's Approach: Rust takes a unique approach to handling the absence of a value: it uses the  enum. This powerful construct allows developers to explicitly handle the presence or absence of a value.The  type is defined as: represents the presence of a value. represents the absence of a value.This makes  a much safer alternative to . The compiler forces you to explicitly handle both cases ( and ), reducing the risk of null pointer exceptions.Here's a simple example of how you might use  to handle optional values:In this example, instead of returning  when the user isn't found, we return , and the caller must handle the potential absence of a value.
  
  
  Why  Is Better Than  With , Rust ensures that you never have to deal with null values unless you explicitly decide to. This eliminates the common pitfalls of null pointer dereferencing. Rust’s borrow checker ensures that you handle all  cases correctly, even when dealing with complex ownership and lifetime semantics. Rust’s pattern matching syntax makes it easy to express the logic of handling  and  values, leading to clean and readable code.
  
  
  Other Alternatives:  for Error Handling
In addition to , Rust also offers the  enum for handling operations that might fail. The  type is especially useful when a function might produce either a valid result or an error, combining both success and failure cases into a single, explicit structure.Just like , the  type forces developers to handle both cases explicitly, improving robustness and error recovery in your programs.
  
  
  Conclusion: Embracing Safety and Clarity
Rust’s rejection of the  paradigm and adoption of types like  is a conscious choice to create safer, more reliable code. By forcing developers to handle the possibility of missing or invalid data explicitly, Rust eliminates the risks and headaches often associated with .While this approach might feel unfamiliar to developers coming from languages with , it quickly becomes a strength of the language. Embracing  (and ) in your code not only prevents bugs but also promotes a more clear, understandable way of thinking about data and operations in your applications.]]></content:encoded></item><item><title>Rust - Ownership Model</title><link>https://dev.to/dedsecrattle/rust-ownership-model-1l6j</link><author>Prabhat Kumar</author><category>dev</category><category>rust</category><pubDate>Sat, 15 Feb 2025 17:34:49 +0000</pubDate><source url="https://dev.to/t/rust">Dev.to Rust</source><content:encoded><![CDATA[Rust’s ownership model is one of its most powerful and defining features. It provides memory safety without needing a garbage collector, making Rust highly efficient and reliable. If you're coming from languages like C++, Java, or Python, understanding Rust’s ownership system might feel daunting at first. In this post, we'll break it down step by step.What is Ownership in Rust?Ownership is Rust’s unique way of managing memory. Instead of using garbage collection or manual memory management, Rust enforces strict ownership rules at compile time. These rules ensure memory safety and prevent data races in concurrent programs.The three key ownership rules are:Each value in Rust has a single owner.When the owner goes out of scope, Rust automatically deallocates the value.Ownership can be transferred (moved) or borrowed (immutably or mutably).
  
  
  Moving, Copying, and Cloning
When assigning a value from one variable to another, ownership is transferred. Consider this example:Since  is allocated on the heap, Rust prevents double-free errors by invalidating  when ownership moves to .Certain types implement the  trait, meaning they are duplicated instead of moved. Examples include:Primitive types (integers, floats, booleans, etc.) implement , so they don’t follow move semantics.If you need to duplicate heap-allocated data, use :Cloning explicitly creates a separate copy in memory, avoiding move-related issues.Rust allows borrowing instead of transferring ownership. Borrowing enables passing data without giving up ownership.A reference () allows read-only access to data without taking ownership:You can have multiple immutable borrows at the same time, but not if there’s a mutable borrow.A mutable reference () allows modification but enforces exclusivity:Rust ensures at compile time that you cannot have multiple mutable references or a mix of mutable and immutable references at the same time.
  
  
  Lifetimes: Ensuring Valid References
Rust’s  prevent dangling references. Consider this example:The  lifetime annotation ensures that the returned reference is valid as long as both input references are valid.
  
  
  Why Rust’s Ownership Model Matters
: No need for garbage collection, yet Rust prevents use-after-free and memory leaks.: Enforces thread safety at compile time.: Eliminates runtime overhead associated with memory management.: Code is predictable and free from subtle memory bugs.Rust’s ownership model might take some getting used to, but once you grasp it, you gain the power to write efficient and safe code without worrying about memory leaks. By understanding moves, copies, borrowing, and lifetimes, you can write highly performant Rust applications while maintaining safety guarantees.Are you currently learning Rust? Let me know what aspects of ownership you find the most challenging in the comments below!]]></content:encoded></item><item><title>Transition from C++ to Rust</title><link>https://www.reddit.com/r/rust/comments/1iq67vq/transition_from_c_to_rust/</link><author>/u/Dvorakovsky</author><category>dev</category><category>rust</category><category>reddit</category><pubDate>Sat, 15 Feb 2025 17:20:14 +0000</pubDate><source url="https://www.reddit.com/r/rust/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Rust</source><content:encoded><![CDATA[Guys, are here any people who were learning/coding in C++ and switched to Rust. How do you feel? I mean I could easily implement linked lists: singly, doubly in c++, but when I saw how it is implemented in Rust I'd say I got lost completely. I'm only learning rust... So yeah, I really like ownership model even tho it puts some difficulties into learning, but I think it's a benefit rather than a downside. Even tho compared to C++ syntax is a bit messy for me]]></content:encoded></item><item><title>Rust - Ownership Model</title><link>https://dev.to/dedsecrattle/rust-ownership-model-2bak</link><author>Prabhat Kumar</author><category>dev</category><category>rust</category><pubDate>Sat, 15 Feb 2025 15:05:14 +0000</pubDate><source url="https://dev.to/t/rust">Dev.to Rust</source><content:encoded><![CDATA[Rust’s ownership model is one of its most powerful and defining features. It provides memory safety without needing a garbage collector, making Rust highly efficient and reliable. If you're coming from languages like C++, Java, or Python, understanding Rust’s ownership system might feel daunting at first. In this post, we'll break it down step by step.What is Ownership in Rust?Ownership is Rust’s unique way of managing memory. Instead of using garbage collection or manual memory management, Rust enforces strict ownership rules at compile time. These rules ensure memory safety and prevent data races in concurrent programs.The three key ownership rules are:Each value in Rust has a single owner.When the owner goes out of scope, Rust automatically deallocates the value.Ownership can be transferred (moved) or borrowed (immutably or mutably).
  
  
  Moving, Copying, and Cloning
When assigning a value from one variable to another, ownership is transferred. Consider this example:Since  is allocated on the heap, Rust prevents double-free errors by invalidating  when ownership moves to .Certain types implement the  trait, meaning they are duplicated instead of moved. Examples include:Primitive types (integers, floats, booleans, etc.) implement , so they don’t follow move semantics.If you need to duplicate heap-allocated data, use :Cloning explicitly creates a separate copy in memory, avoiding move-related issues.Rust allows borrowing instead of transferring ownership. Borrowing enables passing data without giving up ownership.A reference () allows read-only access to data without taking ownership:You can have multiple immutable borrows at the same time, but not if there’s a mutable borrow.A mutable reference () allows modification but enforces exclusivity:Rust ensures at compile time that you cannot have multiple mutable references or a mix of mutable and immutable references at the same time.
  
  
  Lifetimes: Ensuring Valid References
Rust’s  prevent dangling references. Consider this example:The  lifetime annotation ensures that the returned reference is valid as long as both input references are valid.
  
  
  Why Rust’s Ownership Model Matters
: No need for garbage collection, yet Rust prevents use-after-free and memory leaks.: Enforces thread safety at compile time.: Eliminates runtime overhead associated with memory management.: Code is predictable and free from subtle memory bugs.Rust’s ownership model might take some getting used to, but once you grasp it, you gain the power to write efficient and safe code without worrying about memory leaks. By understanding moves, copies, borrowing, and lifetimes, you can write highly performant Rust applications while maintaining safety guarantees.Are you currently learning Rust? Let me know what aspects of ownership you find the most challenging in the comments below!]]></content:encoded></item><item><title>Building the MagicMirror in Rust with iced GUI Library 🦀</title><link>https://www.reddit.com/r/rust/comments/1ipzubj/building_the_magicmirror_in_rust_with_iced_gui/</link><author>/u/amindiro</author><category>dev</category><category>rust</category><category>reddit</category><pubDate>Sat, 15 Feb 2025 11:56:35 +0000</pubDate><source url="https://www.reddit.com/r/rust/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Rust</source><content:encoded><![CDATA[I recently embarked on a journey to build a custom MagicMirror using the Rust programming language, and I’d like to share my experiences. I wrost a blog post titled "software you can love: miroir Ô mon beau miroir" this project was my attempt to create a stable, resource-efficient application for the Raspberry Pi 3A.Here's what I loved about using Rust and the iced GUI library:Elm Architecture + Rust is a match made in heaven: iced was perfect for my needs with its Model, View, and Update paradigms. It helped keep my state management concise and leverage Rust type system Opting for this lightweight rendering library reduced the size of the binary significantly, ending with a 9MB binary. Although troublesome at first, I used ‘cross’ to cross compile Rust for armv7.If anyone is keen, I’m thinking of open-sourcing this project and sharing it with the community. Insights on enhancing the project's functionality or any feedback would be much appreciated!Feel free to reach out if you're interested in the technical nitty-gritty or my experience with Rust GUI libraries in general.]]></content:encoded></item><item><title>async-arp: library for probing hosts and sending advanced ARP (Address Resolution Protocol) requests.</title><link>https://www.reddit.com/r/rust/comments/1ipywbp/asyncarp_library_for_probing_hosts_and_sending/</link><author>/u/arcycar</author><category>dev</category><category>rust</category><category>reddit</category><pubDate>Sat, 15 Feb 2025 10:48:25 +0000</pubDate><source url="https://www.reddit.com/r/rust/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Rust</source><content:encoded><![CDATA[After a few months of exploring and working with Rust, I am happy to share my first small Rust crate,  and I’d love to hear your thoughts! 🚀This library provides an  way to send and receive , making it useful for network discovery, debugging, and custom networking applications.🏎  Built on Tokio for non-blocking network operations🔍  Easily detect active devices in a subnet⚙️  Craft and send ARP packets dynamicallyYou can find usage examples and API documentation here: 📖 Since this is my first crate, I’d really appreciate any feedback on:📌  – Is the interface intuitive and ergonomic?🚀  – Does it fit well into async Rust workflows?🔍  – Any improvements or best practices I may have missed?🦀  – Suggestions to make it more "Rustacean"?If you have further ideas, issues, or want to contribute, check it out on GitHub:Thanks for checking it out—let me know what you think! 🦀]]></content:encoded></item><item><title>Macro-Less, Highly Integrated OpenAPI Document Generation in Rust with Ohkami</title><link>https://dev.to/kanarus/macro-less-highly-integrated-openapi-document-generation-in-rust-with-ohkami-9b2</link><author>kanarus</author><category>dev</category><category>rust</category><pubDate>Sat, 15 Feb 2025 08:49:29 +0000</pubDate><source url="https://dev.to/t/rust">Dev.to Rust</source><content:encoded><![CDATA[This is a cross post from Medium.In Rust web dev, utoipa is the most popular crate for generating OpenAPI document from server code. While it’s a great tool, it can be frustrating due to excessive macro use.A new web framework Ohkami offers a macro-less, highly integrated way to generate OpenAPI document with its  feature.Let’s take following code as an example. It’s the same sample from the “openapi” section of the README, but with openapi-related parts removed:While this compiles and works as a pseudo user management server, activating  feature causes a compile error, telling that  and  don’t implement .As indicated by this, Ohkami with  feature effectively handles type information and intelligently collects its endpoints’ metadata. It allows code like:to assemble metadata into an OpenAPI document and output it to a file .Then, how we implement ? Actually we can easily  by hand, or just  is available! In this case, derive is enough:That’s it! Just adding these derives allows  to output following file:Additionally, it’s easy to define the  schema as a component instead of duplicating inline schemas.
In derive, just add  helper attribute:And  attribute is available to set , , and override  and each response’s :Let’s take a look at how this document generation works!First, the s are expanded as following:The organized DSL enables to easily impl manually. trait links the struct to an item of type called .
  
  
  2.  hooks of , , They're Ohkami’s core traits appeared in the handler bound:When  feature is activated, they additionally have following methods:Ohkami leverages these methods in  to generate consistent , reflecting the actual handler signature like this.Moreover, Ohkami properly propagates schema information in common cases like this, allowing users to focus only on the types and schemas of their app.
  
  
  3.  metadata of Router
In Ohkami, what’s called  has  property that stores all the routes belonging to an Ohkami instance. This is returned alongside  from  step, and is used to assemble metadata of all endpoints.What  itself does is just to serialize an item of type openapi::document::Document and write it to a file.The openapi::document::Document item is created by  of , summarized as follows:That’s how Ohkami generates OpenAPI document!
  
  
  Appendix: Cloudflare Workers
There is, however, a problem in , Cloudflare Workers: where Ohkami is loaded to Miniflare or Cloudflare Workers as WASM, so it can only generate OpenAPI document as data and cannot write it to the user’s local file system.generates OpenAPI document!Thank you for reading. If you’re interested in Ohkami, check out the GitHub repo and start coding!]]></content:encoded></item><item><title>Bringing Nest.js to Rust: Meet Toni.rs, the Framework You’ve Been Waiting For! 🚀</title><link>https://www.reddit.com/r/rust/comments/1iprsmo/bringing_nestjs_to_rust_meet_tonirs_the_framework/</link><author>/u/Mysterious-Rust</author><category>dev</category><category>rust</category><category>reddit</category><pubDate>Sat, 15 Feb 2025 02:42:18 +0000</pubDate><source url="https://www.reddit.com/r/rust/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Rust</source><content:encoded><![CDATA[As a Rust developer coming from TypeScript, I’ve been missing a Nest.js-like framework — its modularity, dependency injection, and CLI superpowers. But since the Rust ecosystem doesn’t have a direct counterpart (yet!), I decided to build one myself! 🛠️Introducing… Toni.rs — a Rust framework inspired by the Nest.js architecture, designed to bring the same developer joy to our favorite language. And it’s live in beta! 🎉Here’s what makes this project interesting:Scalable maintainability 🧩:A modular architecture keeps your business logic decoupled and organized. Say goodbye to spaghetti code — each module lives in its own context, clean and focused.Need a complete CRUD setup? Just run a single CLI command. And I have lots of ideas for CLI ease. Who needs copy and paste?Automatic Dependency Injection 🤖:Stop wasting time wiring dependencies. Declare your providers, add them to your structure, and let the framework magically inject them. Less boilerplate, more coding.Leave your thoughts below — suggestions, questions, or even just enthusiasm! 🚀 ]]></content:encoded></item><item><title>Tabiew 0.8.4 Released</title><link>https://www.reddit.com/r/rust/comments/1ipp72r/tabiew_084_released/</link><author>/u/shshemi</author><category>dev</category><category>rust</category><category>reddit</category><pubDate>Sat, 15 Feb 2025 00:21:42 +0000</pubDate><source url="https://www.reddit.com/r/rust/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Rust</source><content:encoded><![CDATA[Tabiew is a lightweight TUI application that allows users to view and query tabular data files, such as CSV, Parquet, Arrow, Sqlite, and ...📊 Support for CSV, Parquet, JSON, JSONL, Arrow, FWF, and Sqlite🗂️ Multi-table functionalityUI is updated to be more modern and responsiveHorizontally scrollable tablesVisible data frame can be referenced with name "_"Compatibility with older versions of glibcTwo new themes (Tokyo Night and Catppuccin)]]></content:encoded></item><item><title>Generate a Momento Disposable Token with Rust and Lambda</title><link>https://dev.to/aws-builders/generate-a-momento-disposable-token-with-rust-and-lambda-1a58</link><author>Benjamen Pyle</author><category>dev</category><category>rust</category><pubDate>Fri, 14 Feb 2025 16:57:29 +0000</pubDate><source url="https://dev.to/t/rust">Dev.to Rust</source><content:encoded><![CDATA[Working with browser hosted code (UI) requires a developer to be cautious about exposing secrets and tokens.  A less than trustworthy person could take these secrets and do things that the user doesn't intend.  And while we are all responsible for our internet usage, token and secrets security from an application standpoint falls squarely on a developer's shoulders.  This is why when using Momento, I like to take advantage of the Authorization API.  What the Authorization API allows me to do is create a disposable token from a secure location, so that my UI clients can just refresh them as needed to work with Topics or Caches.  Thus, not having the credential leak up into the "easy to see" JavaScript code.  Let's dive into a Lambda Function coded in Rust that implements this Token Vending Machine concept with Momento.I usually like to work backwards to forwards, meaning I establish what I want in the end and then build from there.  When looking at a sample implementation, that means starting from the diagram and walking through what I'm building.A user's session will need to establish an authenticated and authorized connection to Momento by way of the JavaScript client SDK.  Every call to Momento is over an HTTP API request so it's going to get authenticated and authorized.  Which is a good thing!  However, doing this, requires a token which is what I'll be fetching from the Rust Lambda Function that will be demonstrated throughout the article.  The flow goes like this:1) User requires a token to connect to Momento
2) Browser makes a request to an endpoint backed by a Lambda Function
3) Rust Lambda Function uses a long-lived and secure API Token that has permissions to create short-lived disposable tokens
4) Rust Function uses the Momento SDK to request a token with the supplied Topic and Cache names with scopes to publish and subscribe
5) A token is returned from the Lambda Function where the client code can use to subscribe to a Momento topic.
6) The token has an expiration timestamp represented as a Unix Epoch so that the client can refresh before the token has a chance to expireSo let's walk through those steps above and explore the implementation.
  
  
  Implementing a Momento Token Vending Machine with Rust
I know I'm focusing on Lambda, Momento, and Rust, but there are many other components that go into what I'd consider a quality Lambda Function build.  To address those, let's have a look at the CDK code and what all gets shipped to AWS.TypeScript has become my goto when it comes to creating AWS infrastructure.  I like the CDK, and I especially like having the ability to use the Cargo Lambda CDK Construct.  If you haven't used it before, check out the repository and jump into the documentation.  It's straightforward and the classes inherit from AWS bases.  In addition to Cargo Lambda, I like to include the Datadog Lambda Extension.  This piece of goodness allows me to collect my OpenTelemetry traces into the Datadog UI for easy assessment of performance and any latency or error issues.  I'll highlight further as the article evolves.Here we go! The below is the CDK code that brings the above together.
  
  
  Adding the Datadog Extension
Pay special attention to the following when adding the Datadog extension.Region: I'm using the region my Lambda function is hosted inARM/x64: I'm picking the chip architecture that my Lambda Function is compiled for.
Version: 68 in this case, but  can also be used.
I'm going to use a long-lived API key with Momento so that this Lambda Function can make requests without worrying about expiration.  This is completely acceptable solution.  Think of it like a scoped API key essentially.  To set that up, I'm using AWS SecretsManager.
  
  
  Cargo Lambda Rust Function
Wrapping up the infrastructure components is the definition of the Rust Lambda Function and granting its ability to read from the secret defined above in SecretsManager.  Additionally, I'm exposing the function over a FunctionURL.  This of course could be internal behind an Application Load Balancer or exposed behind a variety of API Gateway setups.  The FunctionURL just makes this example simple to pull together.Key things to point out in the  are:Architecture: set to ARM because I prefer to run on the AWS Graviton chipsEnvironment: 

Setting RUST_LOG allows me to control crate log levels (this is a convention)
At this point, using CDK, I can easily run a  and my code will be live in AWS in just a couple of minutes.  However, I'd like to dive in further on the Rust and Lambda code, specifically addressing the Momento Auth piecesAll Rust code (unless it's a lib) starts out with a  function.  Even Lambda Functions must have a .  In my  below, I'm setting up Momento, Datadog, OpenTelemetry, and other reusable components.  Since my handler is what is called over and over, I want to have things warm and in memory, ready to use as events come in.To initialize the OpenTelemetry, I'm establishing a telemetry layer which I'm registering.The next pieces of  are about fetching the Momento API key from the AWS secret I defined in the infrastructure.  And with that secret, I'll construct an instance of the Momento Auth client so that I can communicate with the Auth API and create the disposable tokens.With all Lambda Functions, I need to define a function that will be called when the Lambda Function is supplied events.  For web APIs, that event is a request from an external client.   My  establishes this connection by the following code.As exposed, I need to send a Momento client, the expiration in minutes I want to let the token be valid for, and the event which is the web request.The Lambda Function handler does the following.Parse the body of the request 

Body in the correct format then generate the tokenIf not, return a 400 BAD REQUESTFor the request body, I'm expecting it to look like this.The Rust structure that this serializes into has the following definition.Now with a struct populated with my request data, I can look at how to generate the disposable token.  It's much easier than I thought it might be.
  
  
  Generating the Disposable Token
This disposable token logic is the heart of this Lambda Function's existence.  Remember, Client code or the UI is going to request a token that I want to scope down to the cache and topic supplied in the payload.  This will guarantee that the client has access to what's needed for the duration defined the environment variable discussed above.Let's break the above down just a little.  First up is the  and .The  plugs into OpenTelemetry that allows me to time the Momento operations by way of the Rust Instrument trait.  I highly recommend any Rust code you write take advantage of these opportunities.  Tracing in the spirit of observability will make finding errors and poor user experiences so much easier when you start to get some volume.The next piece of this function is to create the Disposable token.   are a required parameter to the generate_disposable_token function.  For my example, I'm giving the token access to Publish and Subscribe to the Cache/Topic combination.  And notice that the  parameter is finally being used to round out the function call.The last piece of the function is to create the .  The values returned from the Momento function call are used to populate the struct.
  
  
  Measuring Performance with Datadog and OpenTelemetry
So I can't end an article just demonstrating how to fetch disposable tokens written in Rust and deployed in a Lambda Function without talking about performance.  I am always blown away at the speed of Momento's services.  I hadn't done much work with the Auth API so I wanted to see if the timings that I've been accustomed to with Cache and Topics also held true with Auth.  With the observability code using OpenTelemetry that I've shown above, I'm able to not only track the Lambda Function's execution timings, but also the Momento specific API calls via the  trait that I showed above.  I bring this metrics and traces together via Datadog because there isn't a better tool on the market to help me observe my Lambda Functions as well as other cloud resources.
  
  
  High Level Function Latency
First up is looking at the high level Lambda Function latency. I'm graphing the 50th, 75th, 90th, and 95th percentiles with this Datadog line graph.I've written about Rust and Lambda performance quite a bit over the past 18 months, but I'm always amazed at how quickly and consistently my function code performs with Rust. I can also make the same statements when it comes to pairing Rust with Momento.  Time and time again, their platform performs consistently, regardless of the load and requests I throw at it.  The same can be said about the Auth API that I'm exercising here.  Consistent p95 latency at the 3ms is just fantastic and not going to be noticeable by an end user.High level tracing is great and something that I love about using Datadog, but since I took advantage of the  trait further up, let's have a look at exactly how the Momento Auth operations play into the overall function latency.This table shows the two spans that are included in the overall latency of the Lambda Functions execution.  If you remember from the code well above, I called the Momento Auth span .  I'm happy all day long with an average latency of 1.25ms and a tail p99 latency of 2.19ms.  I can't recommend their Rust SDK enough.  It is my first and preferred way to work with Momento.Working with client code that is insecure by nature that also needs to authenticate with the Momento API for things like Topic subscriptions can be a challenge.  However, by implementing a token vending machine with Rust, deployed with Lambda, and monitored with Datadog produces a solution that is fast, reliable, and observable.  I've been saying this for a while, but I truly believe that building Lambda Functions with Rust is the way to go.  And I love seeing companies like Momento invest in Rust specific SDKs.  This feature to build disposable tokens was just added in 2025 and will unlock developers to implement this vending machine pattern in Rust like I've shown the article.  Thanks for reading and happy building!]]></content:encoded></item><item><title>Upskilling to Rust from Python</title><link>https://dev.to/rustds/upskilling-to-rust-from-python-mok</link><author>Michael Gonzalez</author><category>dev</category><category>rust</category><pubDate>Fri, 14 Feb 2025 16:29:55 +0000</pubDate><source url="https://dev.to/t/rust">Dev.to Rust</source><content:encoded><![CDATA[I’m a long-time data analyst with some data engineering experience. My overall stack time is about:Tableau Desktop – 10 yearsA few years ago, I embarked on a mission to be full stack. I picked up Python and learned how to do ETL operations on my own. I’ve heard great things about the speed and efficiency benefits of Rust over Python, so I wanted to put it to the test.The basic question I have is: what is the absolute furthest that I can take Rust in the direction of data science (to include AI applications) and data engineering? The library environment for data science is extremely robust for Python and I know it’s substantially smaller for Rust, but I’m still interested in taking it as far as I can. Over the next few months, I’m going to be upskilling in Rust and seeing where Rust for DS goes.I’m very aware of structural differences of Rust compared to Python. Memory management and static typing are elements that I’ve never had to care about, but it’s going to need to be a consideration moving forward. Ultimately, I think giving Rust a try will make me a more consciencious developer in that there are a lot of things I just took for granted with Python and SQL.I know absolutely no Rust right now, so I’m leaning on Duke University’s Rust Fundamentals course through Coursera to get me up to speed on the basics.The first week of the course revolved around setting up the VS Code environment for Rust, deploying GitHub Copilot, setting up the dev container, and dockerizing it.I’m very familiar with VS Code for local development, but actually using Docker and working in a containerized environment is new. I’ve been wanting to containerize my org’s Python development environment for at least a year (it’s further down the to-do list), so spending some time on this is gonna pay off later on.No actual Rust development work yet. Looking ahead, it appears that week 2 of the course jumps right into for and while loops. Ech, not a favorite topic of mine, but essential nonetheless.Anyone else using Rust for data operations?]]></content:encoded></item><item><title>1BRC in PHP FFI + Rust</title><link>https://dev.to/gfabrizi/1brc-in-php-ffi-rust-5ed9</link><author>Gianluca Fabrizi</author><category>dev</category><category>rust</category><pubDate>Fri, 14 Feb 2025 09:13:00 +0000</pubDate><source url="https://dev.to/t/rust">Dev.to Rust</source><content:encoded><![CDATA[We have tried multi-threading in PHP to speed up execution time; the results are good, but far from perfect. Is there another way we can improve PHP's performance?In the previous post, we gave an overview of 1BRC, tried to push the limits of PHP when discussing performance optimization, and ran our best PHP script on an EC2 instance.The results were not bad, but not noteworthy either: 17.0636 seconds (the fastest Java code took 1.535 seconds).So what are we supposed to do? Call it a day and get on with our lives? No, obviously not!
We could "cheat" our way to a better score, by abusing one of Python's winning strategies: letting external libraries do the heavy lifting job!
  
  
  Foreign Function Interface
One of the ways to optimize an interpreted language is by moving the slow operations in an external module, usually written in a low-level language.
In PHP you can write system-wide modules and enable them in ; this is useful for generic functions or for code that is not specific to one application.
Since version 7.4 PHP introduced a new feature: Foreign Function Interface (FFI).
FFI is a method for calling external libraries in your PHP coding, without changing global PHP configuration.
This method is more flexible than dealing with modules, but configuring it could be a bit daunting at first.Let's try to wrap a Rust solution of 1BRC in a PHP script (yes, ok, we are definitely cheating).To keep things simple we need a Rust solution that:it's written in a clear wayit's composed of a few filesThere's no need to explain point ; points  and  are needed because we are going to modify the code to make it work as a module.
I love Rust, but I'm not a Rust programmer, so the simpler the code the better.  First of all, we clone the repository, then we edit the  file to add some options:In the  section, we enabled additional performance optimizations (, , ); we added the  section, where we specify that we want to compile the source as a  library (shared libraries that can be linked into external programs).   file is used just to call ; we remove this file and add a  method in : disables the mangle (in short: it keeps the function's name in the exported library) and marks this function as "to export".  We are cheating, but in a responsible way 😅: from PHP code, we pass the weather data filename to the Rust module. Then the Rust module returns the station's aggregated data to be displayed.
PHP is a loosely-typed language, while Rust is a strongly-typed language, so moving data between the two can be a bit of a challenge-in-the-challenge. We need  crate and  from .  The code needed to convert from PHP String to Rust string slice has been taken from ; using it's words:Getting a Rust string slice (&str) requires a few steps:We need to make sure that the C pointer is not  as Rust references are not allowed to be .Use  to wrap the pointer.  will compute the string's length based on the terminating . This requires an  block as we will be dereferencing a raw pointer, which the Rust compiler cannot verify meets all the safety guarantees so the programmer must do it instead.Ensure the C string is valid UTF-8 and convert it to a Rust string slice.In  we use this code:to return a JSON string to the PHP script.  That's it for Rust; we can compile the library with:On the PHP side first of all we need a class to manage the input and output of th Rust module. Let's create a file called :The constructor's code uses  to import the Rust function from the  file.
Here we have to declare the extern function's signature using C code, so the Rust  parameters, become .: it's also possible to use a  header file to specify the function(s) that PHP needs to know about; since we only need one simple function, it is easier to declare it inline in PHP code.The  method invokes the  method of the Rust module (self::$ffi->run($filename)). We called both this wrapper method and the Rust function with the same name (); this is only a coincidence (...or lack of fantasy); it's not mandatory. converts the pointer to a String usable in PHP.We also need an  file to instantiate this  class and to print the results:Nothing interesting here: we call our  method, passing it the measurements filename.
The JSON string from Rust contains temperatures as integers, so we need to divide them by 10 and calculate the average temperature for each station.Let's run this code on the EC2 instance. The configuration is the same as last time: an  with 32 vCPUs and 128GB of memory. For the hard disk, I opted for a 200GB io1 volume (to reach 10,000 IOPS).perf  1B-ffi.log  10  php app/index.php
and these are the results: Performance counter stats for 'php app/index.php' (10 runs):

          58802.93 msec task-clock                       #   29.718 CPUs utilized            ( +-  0.26% )
              4736      context-switches                 #   80.191 /sec                     ( +-  3.80% )
                57      cpu-migrations                   #    0.965 /sec                     ( +- 13.37% )
             52703      page-faults                      #  892.378 /sec                     ( +-  1.33% )
   <not supported>      cycles                                                      
   <not supported>      instructions                                                
   <not supported>      branches                                                    
   <not supported>      branch-misses                                               
   <not supported>      L1-dcache-loads                                             
   <not supported>      L1-dcache-load-misses                                       
   <not supported>      LLC-loads                                                   
   <not supported>      LLC-load-misses                                             

            1.9787 +- 0.0197 seconds time elapsed  ( +-  1.00% )
1.9787 seconds! 🥳 🎉
This is a surprising result, considering the overhead of calling an external module and the fact that we are still making some calculations on the PHP side of the app.After this 2-parts-journey we can affirm that:PHP is slow, but the performance improves significantly when using threadsPerformance tuning is a game of trade-offs: you can improve the speed of a task by saturating all the CPU cores, but your system will become unresponsive. In PHP this is a problem if your application needs to accept more than one connection at a timeFor heavy tasks, you can delegate to optimized external librariesI hope you enjoyed the post!]]></content:encoded></item><item><title>How I Built Open Source Fastest URL Shortener Ever With Rust</title><link>https://dev.to/abdibrokhim/how-i-built-open-source-fastest-url-shortener-ever-with-rust-4ggm</link><author>Ibrohim Abdivokhidov</author><category>dev</category><category>rust</category><pubDate>Fri, 14 Feb 2025 06:53:49 +0000</pubDate><source url="https://dev.to/t/rust">Dev.to Rust</source><content:encoded><![CDATA[In this tutorial, I’ll be walking you thro building notlink - an open source, blazingly fast URL shortener ever. If you are Rust luver. You should definitely check this out. ✨Shuttle (cloud deployment)Actix Web (backend framework)Neon (serverless PostgreSQL)Diesel (ORM for database magic)What we’ll be covering:
✅ Setting up a Rust project from scratch
✅ Integrating Diesel ORM with PostgreSQL (Neon)
✅ Building API endpoints (URL shortening/redirection)
✅ Database migrations, models, and helper functions (crypto, random code generation)
✅ Shuttle deployment hacks (including fixing libpq.so.5 issues with a custom script!)
✅ Testing with curl and troubleshootingInstructor:
Hi, I'm Ibrohim. I build things and make content about it. Known mostly for 70+ Hackathons, 400+ Fails, 4+ Papers, 200K+ Creators, 2+ OS Contributions and $OC, $TROC Meme Coins. 👻Chapters:
00:00 introduction
01:13 getting started with backend
02:54 creating a new Rust project
04:00 Diesel ORM integration
08:15 testing simple app
09:48 DB migration and creating tables
11:55 creating models
13:25 DB operations
15:50 encryption and decryption
19:00 main.rs
19:45 running and testing the app
20:38 deploy to Shuttle and testing real url
22:00 looking thro Neon DB tables and data
22:30 final notes. wrap up.
27:45 outro. my message to ya'll]]></content:encoded></item><item><title>5 Learnings from sharing Kafka vs Fluvio Benchmarks on Reddit</title><link>https://dev.to/debadyuti/5-learnings-from-sharing-kafka-vs-fluvio-benchmarks-on-reddit-34</link><author>Deb</author><category>dev</category><category>rust</category><pubDate>Fri, 14 Feb 2025 00:22:53 +0000</pubDate><source url="https://dev.to/t/rust">Dev.to Rust</source><content:encoded><![CDATA[To have a readable blog, all the links are at the bottom except the link to the Fluvio project.Yesterday, I shared a blog on benchmarking results comparing Fluvio, our next-generation streaming engine, with Apache Kafka. The response from the Rust community was encouraging, with over 30,000 impressions, 80+ upvotes, and 40+ comments in just 24 hours. The feedback was invaluable, and I want to share the 5 things I learned from all the developer feedback.Fluvio is a distributed streaming engine built in Rust over the past six years. While it follows Apache Kafka's conceptual patterns, it introduces programmable design patterns through Rust and WebAssembly-based stream processing called Stateful DataFlow (SDF). This makes Fluvio a complete platform for event streaming.
  
  
  1. Developers care a lot about the benchmark environment.
The community emphasized the importance of comprehensive testing environments:Need for bare metal servers to eliminate virtualization artifactsProduction-grade setups with proper replication (factor of 3)Large-scale validation with terabyte-scale live dataThe ideal benchmarks will be using real-world data from Blockchain, High-Frequency Trading, or Ad-Tech on bare metal servers and compare multiple systems like Kafka, RedPanda, Pulsar.
  
  
  2. Intelligent developers know about the trade-offs of using different hardware.
Developers highlighted several hardware-specific considerations:ARM Graviton chips' latency variations in virtualized environmentsImportance of testing across different CPU architectures including x86Thermal throttling differences between consumer laptops and server-grade hardware
  
  
  3. Seasoned developers want production-ready configuration for each solution being configured
Runtime mechanics need to reflect real-world scenarios:Specific JVM and Garbage Collector configurations for Kafka benchmarkingResource utilization patterns under various loadsMulti-node deployment testing at scale
  
  
  4. While benchmarks are great benchmarking in mature categories require mention of table-stakes features
Key functionality developers look for:Consumer groups for ordered delivery per partitionStream and batch processing capabilitiesRobust delivery guarantees
  
  
  5. Benchmarks also immediately makes developers think of reliability and debugging experience
Critical operational features:Dead letter queue implementationsRetry strategies for network issuesDelivery proof mechanisms beyond best-effort
  
  
  The New Streaming Paradigm
Event streaming is a basic pattern in a world filled with agents.Wise developers focus on:Practical performance over theoretical maximaTransparent benchmarking methodologyIntuitive deployment and management
  
  
  Our Vision for Next Generation Data Intensive Applications
We believe the next wave of intelligent applications will come from builders who:Challenge traditional infrastructure assumptionsRequire millisecond latencies at scalePrioritize resource efficiencyWe don't just need faster systems - we need smarter ones that don't drain budgets or sanity.The future belongs to systems that balance raw performance with operational wisdom. The question isn't just about speed—it's about enabling rapid innovation delivering an intuitive developer ergonomics while maintaining efficiency and reliability.]]></content:encoded></item><item><title>Why We Built an AI Gateway in Rust: A Performance-Centric Decision</title><link>https://dev.to/langdb/why-we-built-an-ai-gateway-in-rust-a-performance-centric-decision-2nb8</link><author>Mrunmay Shelar</author><category>dev</category><category>rust</category><pubDate>Thu, 13 Feb 2025 18:44:14 +0000</pubDate><source url="https://dev.to/t/rust">Dev.to Rust</source><content:encoded><![CDATA[When building our AI gateway, we knew performance would be a critical factor. Unlike most AI software written in Python, an AI gateway acts as the  between users and inference engines. This gateway must handle , , and  efficiently. Python, while dominant in the AI ecosystem, struggles under these demands due to its  and limitations with concurrency.To demonstrate why we chose , we benchmarked three popular programming environments—, , and —to evaluate their performance under high-load conditions. Rust emerged as the clear winner, offering predictable and stable performance even at scale.
  
  
  Benchmark Setup: Simulating Real-World AI Traffic
We built an  and a corresponding client to mimic real-world AI workloads. Here’s how the setup worked:Streams tokens at a fixed inter-token latency of 25ms, similar to the tokenized output of an AI inference engine.Uses HTTP/2 to deliver tokenized data efficiently to multiple clients.Implements asynchronous programming to support thousands of connections concurrently.Gradually establishes up to 15,000 simultaneous connections to the server.Measures the —the time between consecutive tokens received from the server. This metric reflects the server’s ability to scale under increasing load.Ensures that connections remain stable and records latency for each connection.The server was implemented in , , and  to ensure a fair comparison.The client progressively increased the number of active connections, starting with a small number and scaling up to 15,000.Intra-token latency measurements were collected for each implementation to evaluate performance under load.
  
  
  Results: Rust vs. Python vs. JavaScript (Node.js)
The chart below illustrates the  (in milliseconds) as the number of concurrent connections increases:Rust exhibited the most stable performance, maintaining a near-linear increase in latency as connections scaled.At , Rust's intra-token latency reached approximately , only 3x the baseline inter-token latency of 25ms.Rust’s efficiency highlights its ability to handle high concurrency without significant degradation.Python's intra-token latency grew exponentially, exceeding 200ms at 15,000 connections.This exponential growth demonstrates Python's inherent limitations in managing large-scale concurrency and resource contention.Node.js initially performed better than Python, maintaining lower latency up to .However, its performance began to degrade significantly beyond this point, reaching over 150ms at 15,000 connections.This result underscores Node.js’s event-driven model, which works well for moderate concurrency but struggles under extreme loads.
  
  
  Why Rust is the Best Choice for an AI Gateway
Predictable, Scalable Performance:Rust’s ability to maintain 75ms latency at 15,000 connections demonstrates its scalability. Its near-linear latency growth makes it ideal for high-concurrency systems.Concurrency Without Compromise:Rust’s async programming model (e.g., Tokio) efficiently manages thousands of simultaneous connections. Unlike Python, Rust avoids the bottlenecks of the Global Interpreter Lock (GIL) and utilizes system resources optimally.Rust compiles directly to machine code, ensuring minimal runtime overhead. Its memory safety and zero-cost abstractions allow for predictable and efficient resource management.Rust provides fine-grained control over threading and memory, making it the best choice for performance-critical applications like AI gateways.
  
  
  Why Python and JavaScript Fall Short
: The GIL prevents true multi-threading, causing severe bottlenecks under high load.: Python's interpreted nature adds significant latency, making it unsuitable for latency-sensitive applications.: As connections increase, Python's performance deteriorates rapidly, with latency exceeding acceptable thresholds.: Node.js performs well under moderate concurrency but struggles as the number of simultaneous connections grows beyond 7,500.: While Node.js handles asynchronous I/O well, it lacks the low-level control offered by Rust, leading to degraded performance at scale.
  
  
  Why AI Gateways Must Be Built with Performance in Mind
An AI gateway is more than a simple intermediary. It plays a critical role in ensuring: Users expect tokenized outputs to arrive with minimal delay, making low latency essential. AI gateways must handle thousands or tens of thousands of simultaneous connections to accommodate large-scale applications. Inconsistent performance or connection drops can severely impact user experience and application reliability.Rust excels in all these areas, delivering predictable, stable performance at scale, making it the ideal language for building high-performance AI gateways.
  
  
  The Takeaway: Rust is the Future of AI Gateways
Our benchmark results clearly show that while Python and JavaScript (Node.js) have their strengths, they are ill-suited for building performance-critical AI gateways: struggles with concurrency and runtime overhead, leading to exponential latency growth. performs better but falters under extreme loads, making it unreliable for high-concurrency scenarios., on the other hand, delivers consistent, scalable performance with low latency, even at . By choosing Rust for our AI gateway, we’ve built an infrastructure that can handle the demands of modern AI applications with ease.If you’re building an AI gateway or any performance-critical infrastructure, Rust isn’t just an option—it’s the solution. When every millisecond matters, Rust is the language that ensures you meet the challenge head-on.]]></content:encoded></item><item><title>Sprint 2 - Picking Up the Pace</title><link>https://dev.to/theoforger/sprint-2-picking-up-the-pace-420a</link><author>TheoForger</author><category>dev</category><category>rust</category><pubDate>Thu, 13 Feb 2025 15:37:18 +0000</pubDate><source url="https://dev.to/t/rust">Dev.to Rust</source><content:encoded><![CDATA[This is the end of Sprint 2. This Sprint has gotten me into a lot of joy and pain, and let me tell you all about it.A proposal to add an  queryGET https://foo.com
HTTP 200
[Asserts]
ip == "192.168.0.1"
GET https://foo.com
HTTP 200
[Asserts]
ip matches /2001:0000:130F:0000:0000:09C0:876A:\d*/
There is also a  but I've the impression that user expectation is more on primary ip.Question: what's about port ? Does the query  exctract the IP address and the port (), or do we have a separate  query that we can do latter?GET https://foo.com
HTTP 200
[Asserts]
ip == "192.168.0.1"
port == 8080
With /as separated queries, we can also have  and  predicates:GET https://foo.com
HTTP 200
[Asserts]
ip isIPv6

This week I've been working to implement this feature to enable hurl users to assert on IP addresses for each request. Since there were quite a few things to do, I decided to break it into multiple PRs.

  
  
  Add ip address to http::Response (Link)
This was a continuation from last week's research. To make the asserts work, first I had to capture that from libcurl and include it in Hurl's  module.To achieve that, I used the method  provided by the  crate. There was some issues regarding the return type of this method and the implementation of type conversions, but we worked it out during the previous Sprint.Other than that, nothing much happened in this PR. There was some changes regarding names and documentation, but it was merged quickly after.
  
  
  Allow assert on ip address (Link)
After last week's discussion, we decided to simply use the  type to handle ip address queries in the Hurl file. At that point I didn't really understand much of the code, but I was able to find a similar query option : . Imitating the code, I was able to create a new query entry.To my surprise, when I tested it afterwards, everything worked! ,  or ... All the keywords was properly working. Turned out Hurl already had the code to handle all string typed queries generically, so all I had to do was creating the query and plugging it right in. Super cool!
  
  
  Allow asserts on ip versions (Link)
This was technically a different feature but it was still a part of the original issue. In this PR, instead of treating the IP address as a string and query on the text content, I had to figure out way to evaluate the IP version.The maintainer suggested to simply take the IP query strings and convert them to . Since this is an enum built-in with the  and  variants, if the conversion succeeds, I could match the pattern to get the IP version.However, this task was not nearly as straightforward as the last PR. Since I didn't fully understand the code, I had a very difficult time locating where I even implement this conversion.First I was determined to figure this out myself. I sat down and carefully read the code, I drafted a few diagrams to help me understand the workflow. However, in Hurl's file parser, whenever I tried to print something, or use the debugger to display something, I would get a strange-looking structure instead of actual text like so:I was beyond confused. I had to ask the maintainer about this. Turned out they were using something called an AST (abstract syntax tree). This structure maps the relative locations of each section of the file without actually parsing them. You can read more in the maintainer's comment.With that knowledge in mind and a bit more research, I finally was able to implement this feature. Now I'm still going back and forth with the maintainer regarding error handling, but I'm sure this feature will land soon!
  
  
  Update @aws-sdk/client-route-53 (Link)
I was looking at Starchart yesterday and saw a list of pull requests opened by , one of which had a failed CI check. I decided to look in a little further. This pull request attempted to update the package  from 3.360.0 to 3.744.0. That's quite a bit gap in version numbers.The CI pipeline failed because of a type mismatch. I started by checking the changelog but I didn't notice any changes regarding types.Fortunately, my IDE was able to help me with locate two new types introduced in the new version:/**
 * @public
 * @enum
 */
export declare const RRType: {
    readonly A: "A";
    readonly AAAA: "AAAA";
    readonly CAA: "CAA";
    readonly CNAME: "CNAME";
    readonly DS: "DS";
    readonly HTTPS: "HTTPS";
    readonly MX: "MX";
    readonly NAPTR: "NAPTR";
    readonly NS: "NS";
    readonly PTR: "PTR";
    readonly SOA: "SOA";
    readonly SPF: "SPF";
    readonly SRV: "SRV";
    readonly SSHFP: "SSHFP";
    readonly SVCB: "SVCB";
    readonly TLSA: "TLSA";
    readonly TXT: "TXT";
};
/**
 * @public
 */
export type RRType = (typeof RRType)[keyof typeof RRType];

/**
 * @public
 * @enum
 */
export declare const ChangeAction: {
    readonly CREATE: "CREATE";
    readonly DELETE: "DELETE";
    readonly UPSERT: "UPSERT";
};
/**
 * @public
 */
export type ChangeAction = (typeof ChangeAction)[keyof typeof ChangeAction];

This part of the code is responsible for managing DNS records.  defines the type of DNS record and  defines the type of changes to perform on an existing record. While all these types were previously represented by .I changed the code to the new types and filed a PR. Later the review came back, suggesting that I create a utility function to handle the type conversion. And this is where I'm at right now.
  
  
  📝 Conclusion and What's Next
This Sprint felt much more eventful than the last one. In the Hurl project, I was working on a different area of code, which means that more time were spent on search and asking questions. I also made more mistakes because of this unfamiliarity. On the Starchart's side, although I haven't taken much action yet, I suspect there to be more to come:For the next Sprint, I might need to dial back a little on the Hurl project, since the maintainer mentioned that they have stopped taking in new features until the next release (). So my plan is to pick a few bugs to investigate there, while shifting my focus a little more to Starchart.]]></content:encoded></item><item><title>A new tool for visualizing Rust lifetimes</title><link>https://www.youtube.com/watch?v=NV6Xo_el_2o</link><author>Let&apos;s Get Rusty</author><category>dev</category><category>rust</category><category>video</category><category>learning</category><enclosure url="https://www.youtube.com/v/NV6Xo_el_2o?version=3" length="" type=""/><pubDate>Thu, 13 Feb 2025 15:00:34 +0000</pubDate><source url="https://www.youtube.com/channel/UCSp-OaMpsO8K0KkOqyBl7_w">Let&apos;s get Rusty</source><content:encoded><![CDATA[See how RustOwl can help you understand lifetimes in a real Rust codebase. A brand-new tool designed to visualize Rust lifetimes and make learning Rust easier. Check it out and see how it can change the way you write Rust!

Free Rust training: https://letsgetrusty.com/bootcamp

RustOwl: https://github.com/cordx56/rustowl

Corrections:
- Bacon is a CLI tool, not a library. Check it out here: https://github.com/Canop/bacon]]></content:encoded></item><item><title>2024 State of Rust Survey Results</title><link>https://blog.rust-lang.org/2025/02/13/2024-State-Of-Rust-Survey-results.html</link><author>The Rust Survey Team</author><category>dev</category><category>official</category><category>rust</category><pubDate>Thu, 13 Feb 2025 00:00:00 +0000</pubDate><source url="https://blog.rust-lang.org/">Rust Blog</source><content:encoded><![CDATA[The Rust Survey Team is excited to share the results of our 2024 survey on the Rust Programming language, conducted between December 5, 2024 and December 23, 2024.
As in previous years, the 2024 State of Rust Survey was focused on gathering insights and feedback from Rust users, and all those who are interested in the future of Rust more generally.This ninth edition of the survey surfaced new insights and learning opportunities straight from the global Rust language community, which we will summarize below. In addition to this blog post,  containing charts with aggregated results of all questions in the survey.Our sincerest thanks to every community member who took the time to express their opinions and experiences with Rust over the past year. Your participation will help us make Rust better for everyone.There's a lot of data to go through, so strap in and enjoy!As shown above, in 2024, we have received fewer survey views than in the previous year. This was likely caused simply by the fact that the survey ran only for two weeks, while in the previous year it ran for almost a month. However, the completion rate has also dropped, which seems to suggest that the survey might be a bit too long. We will take this into consideration for the next edition of the survey.The State of Rust survey not only gives us excellent insight into how many Rust users around the world are using and experiencing the language but also gives us insight into the makeup of our global community. This information gives us a sense of where the language is being used and where access gaps might exist for us to address over time. We hope that this data and our related analysis help further important discussions about how we can continue to prioritize global access and inclusivity in the Rust community.Same as every year, we asked our respondents in which country they live in. The top 10 countries represented were, in order: United States (22%), Germany (14%), United Kingdom (6%), France (6%), China (5%), Canada (3%), Netherlands (3%), Russia (3%), Australia (2%), and Sweden (2%). We are happy to see that Rust is enjoyed by users from all around the world! You can try to find your country in the chart below:We also asked whether respondents consider themselves members of a marginalized community. Out of those who answered, 74.5% selected no, 15.5% selected yes, and 10% preferred not to say.We have asked the group that selected “yes” which specific groups they identified as being a member of. The majority of those who consider themselves a member of an underrepresented or marginalized group in technology identify as lesbian, gay, bisexual, or otherwise non-heterosexual. The second most selected option was neurodivergent at 46% followed by trans at 35%.Each year, we must acknowledge the diversity, equity, and inclusivity (DEI) related gaps in the Rust community and open source as a whole. We believe that excellent work is underway at the Rust Foundation to advance global access to Rust community gatherings and distribute grants to a diverse pool of maintainers each cycle, which you can learn more about here. Even so, global inclusion and access is just one element of DEI, and the survey working group will continue to advocate for progress in this domain.The number of respondents that self-identify as a Rust user was quite similar to last year, around 92%. This high number is not surprising, since we primarily target existing Rust developers with this survey.Similarly as last year, around 31% of those who did not identify as Rust users cited the perception of difficulty as the primary reason for not using Rust. The most common reason for not using Rust was that the respondents simply haven’t had the chance to try it yet.Of the former Rust users who participated in the 2024 survey, 36% cited factors outside their control as a reason why they no longer use Rust, which is a 10pp decrease from last year. This year, we also asked respondents if they would consider using Rust again if an opportunity comes up, which turns out to be true for a large fraction of the respondents (63%). That is good to hear!Closed answers marked with N/A were not present in the previous version(s) of the survey.Those not using Rust anymore told us that it is because they don't really need it (or the goals of their company changed) or because it was not the right tool for the job. A few reported being overwhelmed by the language or its ecosystem in general or that switching to or introducing Rust would have been too expensive in terms of human effort.Of those who used Rust in 2024, 53% did so on a daily (or nearly daily) basis — an increase of 4pp from the previous year. We can observe an upward trend in the frequency of Rust usage over the past few years, which suggests that Rust is being increasingly used at work. This is also confirmed by other answers mentioned in the Rust at Work section later below.Rust expertise is also continually increasing amongst our respondents! 20% of respondents can write (only) simple programs in Rust (a decrease of 3pp from 2023), while 53% consider themselves productive using Rust — up from 47% in 2023. While the survey is just one tool to measure the changes in Rust expertise overall, these numbers are heartening as they represent knowledge growth for many Rustaceans returning to the survey year over year.Unsurprisingly, the most popular version of Rust is , either the most recent one or whichever comes with the users' Linux distribution. Almost a third of users also use the latest nightly release, due to various reasons (see below). However, it seems that the beta toolchain is not used much, which is a bit unfortunate. We would like to encourage Rust users to use the beta toolchain more (e.g. in CI environments) to help test soon-to-be stabilized versions of Rust.People that use the nightly toolchain mostly do it to gain access to specific unstable language features. Several users have also mentioned that rustfmt works better for them on nightly or that they use the nightly compiler because of faster compilation times.To use Rust, programmers first have to learn it, so we are always interested in finding out how do they approach that. Based on the survey results, it seems that most users learn from Rust documentation and also from The Rust Programming Language book, which has been a favourite learning resource of new Rustaceans for a long time. Many people also seem to learn by reading the source code of Rust crates. The fact that both the documentation and source code of tens of thousands of Rust crates is available on docs.rs and GitHub makes this easier.In terms of answers belonging to the "Other" category, they can be clustered into three categories: people using LLM (large language model) assistants (Copilot, ChatGPT, Claude, etc.), reading the official Rust forums (Discord, URLO) or being mentored while contributing to Rust projects. We would like to extend a big thank you to those making our spaces friendly and welcoming for newcomers, as it is important work and it pays off. Interestingly, a non-trivial number of people "learned by doing" and used rustc error messages and clippy as a guide, which is a good indicator of the quality of Rust diagnostics.In terms of formal education, it seems that Rust has not yet penetrated university curriculums, as this is typically a very slowly moving area. Only a very small number of respondents (around 3%) have taken a university Rust course or used university learning materials.In terms of operating systems used by Rustaceans, Linux was the most popular choice, and it seems that it is getting increasingly popular year after year. It is followed by macOS and Windows, which have a very similar share of usage.As you can see in the wordcloud, there are also a few users that prefer Arch, btw.Rust programmers target a diverse set of platforms with their Rust programs. We saw a slight uptick in users targeting embedded and mobile platforms, but otherwise the distribution of platforms stayed mostly the same as last year. Since the WebAssembly target is quite diverse, we have split it into two separate categories this time. Based on the results it is clear that when using WebAssembly, it is mostly in the context of browsers (23%) rather than other use-cases (7%).We cannot of course forget the favourite topic of many programmers: which IDE (developer environment) they use. Although Visual Studio Code still remains the most popular option, its share has dropped by 5pp this year. On the other hand, the Zed editor seems to have gained considerable traction recently. The small percentage of those who selected "Other" are using a wide range of different tools: from CursorAI to classics like Kate or Notepad++. Special mention to the 3 people using "ed", that's quite an achievement.You can also take a look at the linked wordcloud that summarizes open answers to this question (the "Other" category), to see what other editors are also popular.We were excited to see that more and more people use Rust at work for the majority of their coding, 38% vs 34% from last year. There is a clear upward trend in this metric over the past few years.The usage of Rust within companies also seems to be rising, as 45% of respondents answered that their organisation makes non-trivial use of Rust, which is a 7pp increase from 2023.Once again, the top reason employers of our survey respondents invested in Rust was the ability to build relatively correct and bug-free software. The second most popular reason was Rust’s performance characteristics. 21% of respondents that use Rust at work do so because they already know it, and it's thus their default choice, an uptick of 5pp from 2023. This seems to suggest that Rust is becoming one of the baseline languages of choice for more and more companies.Similarly to the previous year, a large percentage of respondents (82%) report that Rust helped their company achieve its goals. In general, it seems that programmers and companies are quite happy with their usage of Rust, which is great!In terms of technology domains, the situation is quite similar to the previous year. Rust seems to be especially popular for creating server backends, web and networking services and cloud technologies. It also seems to be gaining more traction for embedded use-cases.You can scroll the chart to the right to see more domains. Note that the Automotive domain was not offered as a closed answer in the 2023 survey (it was merely entered through open answers), which might explain the large jump.It is exciting to see the continued growth of professional Rust usage and the confidence so many users feel in its performance, control, security and safety, enjoyability, and more!As always, one of the main goals of the State of Rust survey is to shed light on challenges, concerns, and priorities on Rustaceans’ minds over the past year.We have asked our users about aspects of Rust that limit their productivity. Perhaps unsurprisingly, slow compilation was at the top of the list, as it seems to be a perennial concern of Rust users. As always, there are efforts underway to improve the speed of the compiler, such as enabling the parallel frontend or switching to a faster linker by default. We invite you to test these improvements and let us know if you encounter any issues.Other challenges included subpar support for debugging Rust and high disk usage of Rust compiler artifacts. On the other hand, most Rust users seem to be very happy with its runtime performance, the correctness and stability of the compiler and also Rust's documentation.In terms of specific unstable (or missing) features that Rust users want to be stabilized (or implemented), the most desired ones were async closures and if/let while chains. Well, we have good news! Async closures will be stabilized in the next version of Rust (1.85), and if/let while chains will hopefully follow soon after, once Edition 2024 is released (which will also happen in Rust 1.85).Other coveted features are generators (both sync and async) and more powerful generic const expressions. You can follow the Rust Project Goals to track the progress of these (and other) features.In the open answers to this question, people were really helpful and tried hard to describe the most notable issues limiting their productivity. We have seen mentions of struggles with async programming (an all-time favourite), debuggability of errors (which people generally love, but they are not perfect for everyone) or Rust tooling being slow or resource intensive (rust-analyzer and rustfmt). Some users also want a better IDE story and improved interoperability with other languages.This year, we have also included a new question about the speed of Rust's evolution. While most people seem to be content with the status quo, more than a quarter of people who responded to this question would like Rust to stabilize and/or add features more quickly, and only 7% of respondents would prefer Rust to slow down or completely stop adding new features.Interestingly, when we asked respondents about their main worries for the future of Rust, one of the top answers remained the worry that Rust will become too complex. This seems to be in contrast with the answers to the previous question. Perhaps Rust users still seem to consider the complexity of Rust to be manageable, but they worry that one day it might become too much.We are happy to see that the amount of respondents concerned about Rust Project governance and lacking support of the Rust Foundation has dropped by about 6pp from 2023.Each year, the results of the State of Rust survey help reveal the areas that need improvement in many areas across the Rust Project and ecosystem, as well as the aspects that are working well for our community.If you have any suggestions for the Rust Annual survey, please let us know!We are immensely grateful to those who participated in the 2024 State of Rust Survey and facilitated its creation. While there are always challenges associated with developing and maintaining a programming language, this year we were pleased to see a high level of survey participation and candid feedback that will truly help us make Rust work better for everyone.If you’d like to dig into more details, we recommend you to browse through the full survey report.]]></content:encoded></item><item><title>This Week in Rust 586</title><link>https://this-week-in-rust.org/blog/2025/02/12/this-week-in-rust-586/</link><author>TWiR Contributors</author><category>This week in Rust</category><category>dev</category><category>rust</category><pubDate>Wed, 12 Feb 2025 05:00:00 +0000</pubDate><source url="https://this-week-in-rust.org/">This Week in Rust</source><content:encoded><![CDATA[This week's crate is esp32-mender-client, a client for ESP32 to execute firmware updates and remote commands.Thanks to Kelvin for the self-suggestion!An important step for RFC implementation is for people to experiment with the
implementation and give feedback, especially before stabilization.  The following
RFCs would benefit from user testing before moving forward:No calls for testing were issued this week.No calls for testing were issued this week.No calls for testing were issued this week.If you are a feature implementer and would like your RFC to appear on the above list, add the new 
label to your RFC along with a comment providing testing instructions and/or guidance on which aspect(s) of the feature
need testing.Always wanted to contribute to open-source projects but did not know where to start?
Every week we highlight some tasks from the Rust community for you to pick and get started!Some of these tasks may also have mentors available, visit the task page for more information.No Calls for participation were submitted this week.Are you a new or experienced speaker looking for a place to share something cool? This section highlights events that are being planned and are accepting submissions to join their event as a speaker.No Calls for papers or presentations were submitted this week.A relatively neutral week, with lots of real changes but most small in
magnitude. Most significant change is rustdoc's move of JS/CSS minification to
build time which cut doc generation times on most benchmarks fairly
significantly.3 Regressions, 5 Improvements, 1 Mixed; 2 of them in rollups
32 artifact comparisons made in totalNo RFCs were approved this week.Every week, the team announces the 'final comment period' for RFCs and key PRs
which are reaching a decision. Express your opinions now.No Cargo Tracking Issues or PRs entered Final Comment Period this week.No Language Team Proposals entered Final Comment Period this week.No Language Reference RFCs entered Final Comment Period this week.No Unsafe Code Guideline Tracking Issues or PRs entered Final Comment Period this week.Rusty Events between 2025-02-12 - 2025-03-12 🦀If you are running a Rust event please add it to the calendar to get
it mentioned here. Please remember to add a link to the event too.
Email the Rust Community Team for access.Just because things are useful doesn't mean they are magically sound.]]></content:encoded></item></channel></rss>