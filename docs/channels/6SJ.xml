<?xml version="1.0" encoding="utf-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Go</title><link>https://konrad.website/liveboat-github-runner/</link><description></description><item><title>Go Nullable with Generics v2.0.0 - now supports omitzero</title><link>https://github.com/LukaGiorgadze/gonull</link><author>/u/Money-Relative-1184</author><category>dev</category><category>reddit</category><category>go</category><pubDate>Sat, 15 Feb 2025 11:00:21 +0000</pubDate><source url="https://www.reddit.com/r/golang/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Go</source><content:encoded><![CDATA[]]></content:encoded></item><item><title>what do you use golang for?</title><link>https://www.reddit.com/r/golang/comments/1ipykyd/what_do_you_use_golang_for/</link><author>/u/Notalabel_4566</author><category>dev</category><category>reddit</category><category>go</category><pubDate>Sat, 15 Feb 2025 10:24:28 +0000</pubDate><source url="https://www.reddit.com/r/golang/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Go</source><content:encoded><![CDATA[Is there any other major use than web development?]]></content:encoded></item><item><title>Webassembly and go 2025</title><link>https://www.reddit.com/r/golang/comments/1ipu4wd/webassembly_and_go_2025/</link><author>/u/KosekiBoto</author><category>dev</category><category>reddit</category><category>go</category><pubDate>Sat, 15 Feb 2025 05:00:37 +0000</pubDate><source url="https://www.reddit.com/r/golang/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Go</source><content:encoded><![CDATA[so I found this video and was thinking about doing something similar for my game as a means to implement modding, however I also stumbled upon a 3 y/o post when looking into it essentially stating that it's a bad idea and I wasn't able to really find anything on the state of go wasm, so can someone please enlighten me as to the current state of WASM and Go, thank you   submitted by    /u/KosekiBoto ]]></content:encoded></item><item><title>GOGC &amp; GOMEMLIMIT ?</title><link>https://www.reddit.com/r/golang/comments/1ipnxxk/gogc_gomemlimit/</link><author>/u/mistyrouge</author><category>dev</category><category>reddit</category><category>go</category><pubDate>Fri, 14 Feb 2025 23:19:42 +0000</pubDate><source url="https://www.reddit.com/r/golang/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Go</source><content:encoded><![CDATA[If the GC cost is fixed with regards to the amount of memory being freed up. Why would I not want to put  and  to say 70% of the memory I have available? Specially in an application that is known to be cpu bound.   submitted by    /u/mistyrouge ]]></content:encoded></item><item><title>GitHub - Clivern/Peanut: üê∫ Deploy Databases and Services Easily for Development and Testing Pipelines.</title><link>https://github.com/Clivern/Peanut</link><author>/u/Clivern</author><category>dev</category><category>reddit</category><category>go</category><pubDate>Fri, 14 Feb 2025 21:07:48 +0000</pubDate><source url="https://www.reddit.com/r/golang/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Go</source><content:encoded><![CDATA[]]></content:encoded></item><item><title>Shutdown Go server</title><link>https://www.reddit.com/r/golang/comments/1ipj5zn/shutdown_go_server/</link><author>/u/Kennedy-Vanilla</author><category>dev</category><category>reddit</category><category>go</category><pubDate>Fri, 14 Feb 2025 19:46:42 +0000</pubDate><source url="https://www.reddit.com/r/golang/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Go</source><content:encoded><![CDATA[Hi, recently I saw that many people shutdown their servers like this or similarserverCtx, serverStopCtx serverCtx, serverStopCtx := context.WithCancel(context.Background()) sig := make(chan os.Signal, 1) signal.Notify(sig, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT) go func() { <-sig shutdownCtx, cancelShutdown := context.WithTimeout(serverCtx, 30*time.Second) defer cancelShutdown() go func() { <-shutdownCtx.Done() if shutdownCtx.Err() == context.DeadlineExceeded { log.Fatal("graceful shutdown timed out.. forcing exit.") } }() err := server.Shutdown(shutdownCtx) if err != nil { log.Printf("error shutting down server: %v", err) } serverStopCtx() }() log.Printf("Server starting on port %s...\n", port) err = server.ListenAndServe() if err != nil && err != http.ErrServerClosed { log.Printf("error starting server: %v", err) os.Exit(1) } <-serverCtx.Done() log.Println("Server stopped") } := context.WithCancel(context.Background()) sig := make(chan os.Signal, 1) signal.Notify(sig, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT) go func() { <-sig shutdownCtx, cancelShutdown := context.WithTimeout(serverCtx, 30*time.Second) defer cancelShutdown() go func() { <-shutdownCtx.Done() if shutdownCtx.Err() == context.DeadlineExceeded { log.Fatal("graceful shutdown timed out.. forcing exit.") } }() err := server.Shutdown(shutdownCtx) if err != nil { log.Printf("error shutting down server: %v", err) } serverStopCtx() }() log.Printf("Server starting on port %s...\n", port) err = server.ListenAndServe() if err != nil && err != http.ErrServerClosed { log.Printf("error starting server: %v", err) os.Exit(1) } <-serverCtx.Done() log.Println("Server stopped") Is it necessary? Like it's so many code for the simple operation   submitted by    /u/Kennedy-Vanilla ]]></content:encoded></item><item><title>Extensible Wasm Applications with Go</title><link>https://go.dev/blog/wasmexport</link><author>Cherry Mui</author><category>dev</category><category>official</category><category>go</category><pubDate>Thu, 13 Feb 2025 00:00:00 +0000</pubDate><source url="http://blog.golang.org/feed.atom">Golang Blog</source><content:encoded><![CDATA[
      Cherry Mui
      13 February 2025
      Go 1.24 enhances its WebAssembly (Wasm) capabilities with the
addition of the  directive and the ability to build a reactor
for WebAssembly System Interface (WASI).
These features enable Go developers to export Go functions to Wasm,
facilitating better integration with Wasm hosts and expanding the possibilities
for Go-based Wasm applications.WebAssembly and the WebAssembly System InterfaceWebAssembly (Wasm) is a binary instruction format
that was initially created for web browsers, providing the execution of
high-performance, low-level code at speeds approaching native performance.
Since then, Wasm‚Äôs utility has expanded, and it is now used in various
environments beyond the browser.
Notably, cloud providers offer services that directly execute Wasm
executables, taking advantage of the
WebAssembly System Interface (WASI) system call API.
WASI allows these executables to interact with system resources.Go first added support for compiling to Wasm in the 1.11 release, through the
 port.
Go 1.21 added a new port targeting the WASI preview 1 syscall API through the
new  port.Exporting Go Functions to Wasm with Go 1.24 introduces a new compiler directive, , which allows
developers to export Go functions to be called from outside of the
Wasm module, typically from a host application that runs the Wasm runtime.
This directive instructs the compiler to make the annotated function available
as a Wasm export
in the resulting Wasm binary.To use the  directive, simply add it to a function definition://go:wasmexport add
func add(a, b int32) int32 { return a + b }
With this, the Wasm module will have an exported function named  that
can be called from the host.This is analogous to the cgo  directive,
which makes the function available to be called from C,
though  uses a different, simpler mechanism.A WASI reactor is a WebAssembly module that operates continuously, and
can be called upon multiple times to react on events or requests.
Unlike a ‚Äúcommand‚Äù module, which terminates after its main function finishes,
a reactor instance remains live after initialization, and its exports remain
accessible.With Go 1.24, one can build a WASI reactor with the  build
flag.$ GOOS=wasip1 GOARCH=wasm go build -buildmode=c-shared -o reactor.wasm
The build flag signals to the linker not to generate the  function
(the entry point for a command module), and instead generate an
 function, which performs runtime and package initialization,
along with any exported functions and their dependencies.
The  function must be called before any other exported functions.
The  function will not be automatically invoked.To use a WASI reactor, the host application first initializes it by calling
, then simply invoke the exported functions.
Here is an example using Wazero, a Go-based Wasm runtime
implementation:// Create a Wasm runtime, set up WASI.
r := wazero.NewRuntime(ctx)
defer r.Close(ctx)
wasi_snapshot_preview1.MustInstantiate(ctx, r)

// Configure the module to initialize the reactor.
config := wazero.NewModuleConfig().WithStartFunctions("_initialize")

// Instantiate the module.
wasmModule, _ := r.InstantiateWithConfig(ctx, wasmFile, config)

// Call the exported function.
fn := wasmModule.ExportedFunction("add")
var a, b int32 = 1, 2
res, _ := fn.Call(ctx, api.EncodeI32(a), api.EncodeI32(b))
c := api.DecodeI32(res[0])
fmt.Printf("add(%d, %d) = %d\n", a, b, c)

// The instance is still alive. We can call the function again.
res, _ = fn.Call(ctx, api.EncodeI32(b), api.EncodeI32(c))
fmt.Printf("add(%d, %d) = %d\n", b, c, api.DecodeI32(res[0]))
The  directive and the reactor build mode allow applications to
be extended by calling into Go-based Wasm code.
This is particularly valuable for applications that have adopted Wasm as a
plugin or extension mechanism with well-defined interfaces.
By exporting Go functions, applications can leverage the Go Wasm modules to
provide functionality without needing to recompile the entire application.
Furthermore, building as a reactor ensures that the exported functions can be
called multiple times without requiring reinitialization, making it suitable
for long-running applications or services.Supporting rich types between the host and the clientGo 1.24 also relaxes the constraints on types that can be used as input and
result parameters with  functions.
For example, one can pass a bool, a string, a pointer to an , or a
pointer to a struct which embeds  and contains supported
field types
(see the documentation for detail).
This allows Go Wasm applications to be written in a more natural and ergonomic
way, and removes some unnecessary type conversions.While Go 1.24 has made significant enhancements to its Wasm capabilities,
there are still some notable limitations.Wasm is a single-threaded architecture with no parallelism.
A  function can spawn new goroutines.
But if a function creates a background goroutine, it will not continue
executing when the  function returns, until calling back into
the Go-based Wasm module.While some type restrictions have been relaxed in Go 1.24, there are still
limitations on the types that can be used with  and
 functions.
Due to the unfortunate mismatch between the 64-bit architecture of the client
and the 32-bit architecture of the host, it is not possible to pass pointers in
memory.
For example, a  function cannot take a pointer to a struct that
contains a pointer-typed field.The addition of the ability to build a WASI reactor and export Go functions to
Wasm in Go 1.24 represent a significant step forward for Go‚Äôs WebAssembly
capabilities.
These features empower developers to create more versatile and powerful Go-based
Wasm applications, opening up new possibilities for Go in the Wasm ecosystem.]]></content:encoded></item><item><title>Go 1.24 arrives</title><link>https://golangweekly.com/issues/542</link><author></author><category>dev</category><category>go</category><pubDate>Wed, 12 Feb 2025 00:00:00 +0000</pubDate><source url="https://golangweekly.com/">Golang Weekly</source><content:encoded><![CDATA[DB Fiddle is a handy online database 'sandbox' for playing with various versions of MySQL, Postgres, and SQLite direct from the browser.]]></content:encoded></item><item><title>Go 1.24 is released!</title><link>https://go.dev/blog/go1.24</link><author>Junyang Shao, on behalf of the Go team</author><category>dev</category><category>official</category><category>go</category><pubDate>Tue, 11 Feb 2025 00:00:00 +0000</pubDate><source url="http://blog.golang.org/feed.atom">Golang Blog</source><content:encoded><![CDATA[
      Junyang Shao, on behalf of the Go team
      11 February 2025
      Today the Go team is excited to release Go 1.24,
which you can get by visiting the download page.Go 1.24 comes with many improvements over Go 1.23. Here are some of the notable
changes; for the full list, refer to the release notes.Several performance improvements in the runtime have decreased CPU overhead
by 2‚Äì3% on average across a suite of representative benchmarks. These
improvements include a new builtin  implementation based on
Swiss Tables, more efficient
memory allocation of small objects, and a new runtime-internal mutex
implementation.The  command now provides a mechanism for tracking tool dependencies for a
module. Use  to add a  directive to the current module. Use
 to run the tools declared with the  directive.
Read more on the go command in the release notes.The new  analyzer in  subcommand reports common mistakes in
declarations of tests, fuzzers, benchmarks, and examples in test packages.
Read more on vet in the release notes.Standard library additionsImproved WebAssembly supportGo 1.24 adds a new  directive for Go programs to export
functions to the WebAssembly host, and supports building a Go program as a WASI
reactor/library.
Read more on WebAssembly in the release notes.Please read the Go 1.24 release notes for the complete and
detailed information. Don‚Äôt forget to watch for follow-up blog posts that
will go in more depth on some of the topics mentioned here!Thank you to everyone who contributed to this release by writing code and
documentation, reporting bugs, sharing feedback, and testing the release
candidates. Your efforts helped to ensure that Go 1.24 is as stable as possible.
As always, if you notice any problems, please file an issue.]]></content:encoded></item><item><title>sync/v2 and the &apos;v2&apos;-ification of Go&apos;s standard library</title><link>https://golangweekly.com/issues/541</link><author></author><category>dev</category><category>go</category><pubDate>Wed, 5 Feb 2025 00:00:00 +0000</pubDate><source url="https://golangweekly.com/">Golang Weekly</source><content:encoded><![CDATA[ ‚Äî It uses Linux-only network namespaces for now, but this is a Go-powered process-scoped HTTP tracer you can run  root privileges. It even decrypts TLS traffic by generating a CA on the fly. Handy for debugging or seeing if dependencies or apps are ‚Äòphoning¬†home,‚Äô¬†perhaps..Monastic Academy for the Preservation of Life on Earth ]]></content:encoded></item><item><title>Slow, flaky, and failing</title><link>https://bitfieldconsulting.com/posts/slow-flaky-failing</link><author>John Arundel</author><category>dev</category><category>blog</category><category>go</category><pubDate>Thu, 30 Jan 2025 13:15:00 +0000</pubDate><source url="https://bitfieldconsulting.com/posts/">Bitfield</source><content:encoded><![CDATA[If you find yourself working on a project with quite a few broken
windows, it‚Äôs all too easy to slip into the mindset of ‚ÄúAll the rest of
this code is crap, I‚Äôll just follow suit.‚Äù
‚ÄîDavid Thomas & Andrew Hunt, ‚ÄúThe
Pragmatic Programmer: Your Journey to Mastery‚ÄùIt‚Äôs one minute to ship time, and you hit ‚Äúpush‚Äù on the very last
commit. There it goes: the build is running. Every second counts now,
and you watch the test output with increasing impatience. Why do the
tests take so darned ?And then, to your horror, the first red lights start to appear. ‚ÄúBut
these were passing before, and I haven‚Äôt touched that code!‚Äù you wail.
It‚Äôs no good: your co-workers are already giving you the stink eye for
breaking the build and holding them up.You‚Äôre not going to ship today, for one simple reason: your tests are
slow, flaky, and failing. So what the hell?Flaky tests sometimes fail, sometimes pass, regardless of whether the
system is correct. There are many reasons for flaky tests, so let‚Äôs look
at a couple of them, with some possible solutions. can be a source of flakiness, as you probably
know from experience. In particular, fixed sleeps in tests are a bad
idea (see the next section for more about these). Eliminate these
wherever possible and replace them with code that only waits as long as
strictly necessary.When you need to  timing itself, use the shortest
possible interval. For example, don‚Äôt test a timer function with a
one-second duration when one millisecond would work just as well.In some tests, as crazy as it sounds, the  can
affect the test. One way to eliminate this cause of flakiness is by
turning , and if necessary injecting a fake
 function to return a canned time of day.Flakiness can also sometimes arise from .
Some data structures in Go are inherently unordered: maps, for example.
Comparing these needs special care.For example, iterating over a map comparing its elements is not good
enough: the iteration order of maps is unspecified in Go. Instead, we
can use the  function to compare maps regardless
of iteration order:On the other hand, slices  inherently ordered, and so
 requires this:But sometimes we don‚Äôt actually care about the order. Maybe we get
these results from some concurrent computations, and we don‚Äôt know what
order they will show up in. We just want to know that we 
the right results.To compare two slices for equal , then, regardless
of order, we can use  to sort them before the
comparison:Whatever the cause of a flaky test suite, it‚Äôs a serious problem.
Left untreated, it will continuously erode value from the tests, until
eventually they become useless and ignored by all. It should be a red
flag to hear something like ‚ÄúOh yeah, that test just fails
sometimes.‚ÄùAs soon as you hear that, you know that the test has become useless.
Delete it, if the flakiness really can‚Äôt be fixed. Thou shalt not suffer
a flaky test to live. As soon as it starts flaking, it stops being a
useful source of feedback, and bad tests are worse than no tests.A  test is not the same thing as a flaky test: a
brittle test fails when you change something unrelated, whereas a flaky
test fails when it feels like it. Fixing brittle tests is usually a
matter of decoupling entangled components, or simply reducing the scope
(and thus sharpening the focus) of the test.On the other hand, flaky tests can require some time and effort to
find the underlying cause and address it. Only do this if the test is
really worth it; if not, just delete it.What if some tests aren‚Äôt just flaky, but fail all the time, because
bugs aren‚Äôt being fixed? This is a very dangerous situation, and without
prompt action the tests will rapidly become completely useless.Why? Because if tests are allowed to fail for a while without being
fixed, people soon stop trusting them, or indeed paying 
attention to them: ‚ÄúOh yeah, that test always fails.‚ÄùWe can never have any failing tests, just as we can never have any
bugs:As soon as any test starts failing, fixing it should be everyone‚Äôs
top priority. No one is allowed to deploy any code change that‚Äôs not
about fixing this bug. Once you let one failing test slip through the
net, all the other tests become worthless.This so-called  sounds radical, but
it really isn‚Äôt. After all, what‚Äôs the alternative?The very first version of Microsoft Word for Windows was
considered a ‚Äúdeath march‚Äù project. Managers were so insistent on
keeping to the schedule that programmers simply rushed through the
coding process, writing extremely bad code, because bug-fixing was not a
part of the formal schedule.Indeed, the schedule became merely a checklist of features waiting
to be turned into bugs. In the post-mortem, this was referred to as
‚Äúinfinite defects methodology‚Äù.
‚ÄîJoel Spolsky, ‚ÄúThe
Joel Test: 12 Steps to Better Code‚ÄùFixing bugs now is cheaper, quicker, and makes more business sense
than fixing them later. The product should be ready to ship at all
times, without bugs.If you already  a large backlog of bugs, or failing
tests, but the company‚Äôs still in business, then maybe those bugs aren‚Äôt
really that critical after all. The best way out may be to declare
voluntary : just close all old bugs, or delete
all failing tests. Bugs that people  care about will pretty
soon be re-opened.My book The Power of Go: Tests is all
about how to write  tests: not just box-ticking
exercises to satisfy some bureaucratic manager, but tests that really
add value to the code, and make your work easier and more enjoyable.Even the world‚Äôs greatest test suite does us no good, though, if it
takes too long to run. How long is too long? Well, if we‚Äôre running
tests every few minutes, clearly even a few minutes is too long. We
simply won‚Äôt run the tests often enough to get the fast feedback we need
from them.By running the test suite frequently, at least several times a
day, you‚Äôre able to detect bugs soon after they are introduced, so you
can just look in the recent changes, which makes it much easier to find
them.
‚ÄîMartin Fowler, ‚ÄúSelf-Testing
Code‚ÄùOne way or the other, then, we don‚Äôt want to be more than about five
minutes away from passing tests. So, again, how long is 
long for a test suite to run?Kent Beck suggests that ten minutes is a psychologically significant
length of time:The equivalent of 9.8 m/s¬≤ is the ten-minute test suite. Suites
that take longer than ten minutes inevitably get trimmed, or the
application tuned up, so the suite takes ten minutes again.
‚ÄîKent Beck, ‚ÄúTest-Driven Development
by Example‚ÄùWe may perhaps call this psychological limit the .
Beyond the ten-minute mark, the problem is so obvious to everybody that
people are willing to put effort into speeding up the test suite. Below
that time, people will probably grumble but put up with it.That certainly doesn‚Äôt mean that a ten-minute test suite is okay:
it‚Äôs not, for the reasons we‚Äôve discussed. Let‚Äôs look at a few simple
ways to reduce the overall run-time of the test suite to something more
manageable.. The inability to run certain
tests in parallel is usually a design smell. Refactor so that each test
has its own world, touches no global state, and can thus run in
parallel. Adding parallelism to a suite that doesn‚Äôt have it should
speed it up by about an order of magnitude.Eliminate unnecessary I/O. Once you go off the
chip, things get slow. Do everything on the chip as far as possible,
avoiding I/O operations such as network calls or accessing disk files.
For example, you could use an  as an in-memory
filesystem, and memory-backed s and
s instead of real files.. Instead of calling some
remote API, call a local fake instead. Local networking happens right in
the kernel, and while it‚Äôs still not , it‚Äôs a lot faster
than actually going out onto the wire.Share fixtures between tests. Any time you have
some expensive fixture setup to do, such as loading data into a
database, try to share its cost between as many tests as possible, so
that they can all use it. If necessary, do the setup in a single test
and then run a bunch of subtests against it.However, we need to be careful that the tests don‚Äôt then become flaky
as a result of too much fixture sharing. A flaky test is worse than a
slow test.. A test that can‚Äôt proceed until
some concurrent operation has completed should use the ‚Äúwait for
success‚Äù pattern (loop and retry, with a tiny delay, until the operation
has completed). This minimises wasted time, whereas a long fixed sleep
maximises it (or causes flaky tests, which is also bad).Throw hardware at the problem. When you‚Äôve made
the test suite as fast as it can go and it‚Äôs still slow, just run it on
a faster computer. If the tests are mostly CPU-bound, rent a 256-core
cloud machine and have it pull and run the tests on demand. CPU time
costs a lot less than programmer time, especially since hiring cheap
programmers is a false economy.. This is a last resort,
but it might come to that. If you have a few tests that simply
 be speeded up any more, and they‚Äôre dragging down the
rest of the suite, extract them to a separate ‚Äúslow test‚Äù suite, and run
it on a schedule. Every night, perhaps; certainly no less frequently
than that. Even nightly isn‚Äôt great, but it‚Äôs better than not running
tests at all.]]></content:encoded></item><item><title>A continued focus on the benefits of Go 1.24</title><link>https://golangweekly.com/issues/540</link><author></author><category>dev</category><category>go</category><pubDate>Wed, 29 Jan 2025 00:00:00 +0000</pubDate><source url="https://golangweekly.com/">Golang Weekly</source><content:encoded><![CDATA[SRCL is a neat new suite of React components for creating webapps with a monospaced, terminal-style aesthetic.If you ever need to work with JavaScript server-side, Bun 1.2 is a huge release for an increasingly popular, high performance -based Node-a-like. It 'just works' for a lot of stuff where Node gives me¬†headaches.Take a look at every byte that goes over the network when making a real Postgres query over TLS . Everything is annotated to help you understand the¬†complexity.]]></content:encoded></item><item><title>Go 1.24 Release Candidate 2</title><link>https://golangweekly.com/issues/539</link><author></author><category>dev</category><category>go</category><pubDate>Wed, 22 Jan 2025 00:00:00 +0000</pubDate><source url="https://golangweekly.com/">Golang Weekly</source><content:encoded><![CDATA[VHS 0.9 ‚Äì CLI 'home video recorder'. "Write terminal GIFs as code for integration testing and demoing your CLI¬†tools." v0.9 adds a  keyword for waiting for certain conditions before continuing¬†.ü§ñ Mods 1.7 ‚Äì Charm's pipeline-able AI CLI client. Now with improved GitHub Copilot support and OpenAI o1¬†support.‚òéÔ∏é phonenumbers 1.5 ‚Äì Go port of Google's libphonenumber library for parsing and validating phone¬†numbers.GoReleaser 2.6 ‚Äì Build/release binaries for multiple¬†platforms. v2.6 gains Bun and Deno support.Notify 1.3 ‚Äì Library to send notifications to various¬†services.sqlc 1.28 ‚Äì Generate type-safe Go code from¬†SQL.]]></content:encoded></item></channel></rss>