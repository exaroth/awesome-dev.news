<?xml version="1.0" encoding="utf-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Go</title><link>https://www.awesome-dev.news</link><description></description><item><title>A better pkg.go.dev</title><link>https://dev.to/jacktt/a-better-pkggodev-hip</link><author>JackTT</author><category>dev</category><category>go</category><pubDate>Sun, 16 Feb 2025 12:35:06 +0000</pubDate><source url="https://dev.to/t/go">Dev.to Go</source><content:encoded><![CDATA[I have never been able to read a package's documentation on pkg.go.dev since all the code there is in black & white...
This is the reason I created this repository to make it possible to read.Every time you want to read a package's documentation, you just need to replace pkg.go.dev with pkgo.dev. .We use Nginx as proxy server.Every time a request come in, we forward it to the pkg.go.dev server, then append the highlight.js script to the response before sending it back to the client.Since some README files do not specify the code language, we also update  tags to <code class="language-go"> to enable syntax highlighting.If you don't trust me, no worry, you can deploy it yourself:Append 127.0.0.1       pkg.go.dev.local to Run docker-compose up -d --buildAccess ]]></content:encoded></item><item><title>Why Go‚Äôs Functional Programming is the Ultimate Coding Style</title><link>https://dev.to/leapcell/why-gos-functional-programming-is-the-ultimate-coding-style-53ee</link><author>Leapcell</author><category>dev</category><category>go</category><pubDate>Sun, 16 Feb 2025 11:01:24 +0000</pubDate><source url="https://dev.to/t/go">Dev.to Go</source><content:encoded><![CDATA[When you hear "functional programming," Go usually isn't the first language that comes to mind. You might think of Haskell, with its pure functions and monads (don't panic, we'll explain that in detail later), or JavaScript, which loves to showcase its features with higher - order functions and callbacks. But in fact, you can also do functional programming in Go, and the process is far from dull.First of all, let's talk about higher - order functions. Higher - order functions can work well with other functions, either taking them as parameters or returning them as values. In the world of Go, implementing higher - order functions is not only possible but also quite ingenious.You see, in this example, the  function takes an integer slice and a judgment function , and returns the elements in the slice that meet the judgment conditions. Doesn't it seem a bit like a faster JavaScript?Next up is currying. It is the process of breaking down a function that takes multiple arguments into a series of functions, each taking a single argument. Currying is actually not as complicated as it might seem.In this example, the  function takes an integer  and returns a new function. This new function takes another integer  and returns the result of . Simple, straightforward, and gets the job done without any frills.One of the characteristics of functional programming is immutability. Once something is constructed, it doesn't change. Instead, if you need something different, you build a new one. This might sound wasteful at first, but in fact, it keeps the code clean and reduces side effects.In this example, instead of directly modifying the original , we created a new  and modified it.Pure functions are like tidy friends. They don't touch or modify anything outside their scope. What you pass in is what you use, and what they return is their only effect.In this example, the  function only depends on the passed - in parameter  and doesn't affect any external variables.In the simplest terms, functors are anything that can map a function. Think of the humble array, applying a function to each item and getting a new array. In Go, there is no built - in general  function, but we can build one ourselves.Here, we defined a  function that takes an integer slice and a function and returns a new slice, where each element is the result of processing the original slice element by the function.Now, let's talk about endofunctors. It's just a fancy way of saying a functor that maps a type to the same type. Simply put, starting from a Go slice, you end up with a Go slice of the same type. It's not rocket science, just a matter of type consistency.Taking the previous  as an example, it's a kind of endofunctor in disguise. It takes  and returns  without type conversion.Imagine a party where everyone has to bring a friend. Monoids are like that, but for types. They need two things: an operation that combines two types and a special value, which is like the most likable friend - it gets along with everyone but doesn't change anything about them.In Go, you can see this with slices or numbers. Let's take numbers as an example because they're easier to work with:Here, 0 is our hero, the identity element, which keeps the numbers unchanged."When someone says, 'A monad is a monoid in the category of endofunctors,' they're basically showing off their computer - science vocabulary." To explain in detail: A monad is a programming construct that deals with types and functions in a super - special way - like some people are picky about how their coffee is brewed.In the simplest terms, a monoid is about combining things together using a special rule, which includes a useless element or identity element. Now, add endofunctors, which are like ordinary old functions but stick to transforming things within their own little universe (category). Put it all together, and you'll see that a monad can be seen as a way to chain functions together in a sequence, but in a super - self - contained way while also respecting the original structure of the data. It's like saying, "We're going on a road trip, but we can only take the scenic backroads, and we'll end up back where we started."Monads are all - rounders. They can not only handle values with context (such as errors or lists) but also chain operations together by passing the context. In Go, it might be a bit difficult to mimic this, but let's take a look at error handling, which is a practical use of monads.This makeshift monad can help us handle computations that might go wrong without causing panics and chaos in the code.Functional programming in Go might not be the poster child of the functional paradigm, but it's entirely feasible and can even be fun. Who would have thought, right? Now, you should understand that Go can achieve functional programming just like other languages. With a little effort, you can write clean, efficient, and robust code. Finally, I'd like to recommend a platform that's perfect for deploying Golang code: 
  
  
  1. Multi - Language Support
Develop with JavaScript, Python, Go, or Rust.

  
  
  2. Deploy unlimited projects for free
pay only for usage ‚Äî no requests, no charges.
  
  
  3. Unbeatable Cost Efficiency
Pay - as - you - go with no idle charges.
Example: $25 supports 6.94M requests at a 60ms average response time.

  
  
  4. Streamlined Developer Experience
Intuitive UI for effortless setup.
Fully automated CI/CD pipelines and GitOps integration.
Real - time metrics and logging for actionable insights.

  
  
  5. Effortless Scalability and High Performance
Auto - scaling to handle high concurrency with ease.
Zero operational overhead ‚Äî just focus on building.
]]></content:encoded></item><item><title>Proj Ideas üí° - Willing to lock in for Go (2025)</title><link>https://www.reddit.com/r/golang/comments/1iqp4re/proj_ideas_willing_to_lock_in_for_go_2025/</link><author>/u/ComfortableAcadia839</author><category>dev</category><category>reddit</category><category>go</category><pubDate>Sun, 16 Feb 2025 10:04:12 +0000</pubDate><source url="https://www.reddit.com/r/golang/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Go</source><content:encoded><![CDATA[I'm a full stack JS/TS developer but just recently tried Go, built an in memory key-value Redis clone.. I've realised the language makes me enjoy coding ---> Can y'all recommend some project ideas (intermediate to advanced difficulty)I want to build some solid projects ;)]]></content:encoded></item><item><title>I created a command line SSH tunnel manager to learn Go</title><link>https://github.com/alebeck/boring</link><author>/u/Savings-Square572</author><category>dev</category><category>reddit</category><category>go</category><pubDate>Sun, 16 Feb 2025 09:56:56 +0000</pubDate><source url="https://www.reddit.com/r/golang/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Go</source><content:encoded><![CDATA[]]></content:encoded></item><item><title>I created a telegram bot with dynamic form builder</title><link>https://github.com/MeowSaiGithub/tg-form-builder</link><author>/u/Altruistic_Let_8036</author><category>dev</category><category>reddit</category><category>go</category><pubDate>Sun, 16 Feb 2025 06:33:51 +0000</pubDate><source url="https://www.reddit.com/r/golang/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Go</source><content:encoded><![CDATA[]]></content:encoded></item><item><title>Real-time Updates Made Easy: Building Server-Sent Events with GoFrame üöÄ</title><link>https://dev.to/jones_charles_ad50858dbc0/real-time-updates-made-easy-building-server-sent-events-with-goframe-112b</link><author>Jones Charles</author><category>dev</category><category>go</category><pubDate>Sun, 16 Feb 2025 02:37:08 +0000</pubDate><source url="https://dev.to/t/go">Dev.to Go</source><content:encoded><![CDATA[Hey there, fellow developers! üëã Ever needed to add real-time updates to your Go application but found WebSockets a bit too complex for your needs? Enter Server-Sent Events (SSE) - a simpler alternative that's perfect for one-way server-to-client communication.In this guide, I'll walk you through implementing SSE using GoFrame, taking you from basic implementation all the way to production-ready code. Let's dive in!
  
  
  What are Server-Sent Events? ü§î
SSE is a standard that enables servers to push real-time updates to clients over HTTP. Unlike WebSocket, SSE:Is one-way (server to client only)Automatically reconnects if the connection is lostPerfect for: real-time notifications, live feeds, status updates, and monitoring dashboards!
  
  
  Getting Started: Basic SSE Implementation üå±
Let's start with a simple example. Here's how to create your first SSE endpoint in GoFrame:And here's how to connect from the frontend:
  
  
  Real-World Examples: Let's Build Something Cool! üõ†Ô∏è
Let's build something more practical - a real-time stock price feed:
  
  
  2. Real-time Chat Room Status üí¨
Monitor active users and typing indicators in a chat room:
  
  
  3. System Monitoring Dashboard üìä
Monitor system metrics in real-time:
  
  
  4. Live Order Processing Status ‚ö°
Track order processing status in real-time:
  
  
  5. Live Sports Score Updates üèÜ
Track live game scores and statistics:
  
  
  Making it Production-Ready üõ†Ô∏è
Keep connections alive with periodic pings:Make your frontend resilient:
  
  
  3. Support Different Event Types üîÑ
Handle various types of updates:For distributed systems, use Redis pub/sub to coordinate SSE messages:: When you have frequent updates, batch them together:
: Prevent server overload:
Implement event replay for clients that reconnect:
  
  
  Client Groups and Filtering
Implement client grouping for targeted updates:
  
  
  Rate Limiting and Throttling
Implement rate limiting for high-frequency updates:Use CORS headers in productionAdd authentication for sensitive dataMonitor connection counts and server resourcesTest with different network conditionsSSE is a powerful tool for real-time updates that's often overlooked in favor of WebSockets. For one-way communication, it's simpler, more lightweight, and works great with HTTP/2. With GoFrame, implementing SSE becomes even more straightforward and maintainable.Here's a quick checklist for your SSE implementation:‚úÖ Basic SSE setup with proper headers‚úÖ Error handling and connection management‚úÖ Authentication and authorization‚úÖ Security considerationsYou could extend this implementation by:Adding message persistenceImplementing message replayBuilding client librariesAdding WebSocket fallbackImplementing server-side filteringAdding message prioritizationHave you used SSE in your projects? What challenges did you face? Share your experiences in the comments below! üëáP.S. Want to see the complete code? Check out my GitHub repo [link to be added] for a production-ready implementation!If you found this helpful, follow me for more Go tutorials and real-world examples! ‚ú®]]></content:encoded></item><item><title>Zed for golang</title><link>https://www.reddit.com/r/golang/comments/1iq8jsm/zed_for_golang/</link><author>/u/MrBricole</author><category>dev</category><category>reddit</category><category>go</category><pubDate>Sat, 15 Feb 2025 19:02:36 +0000</pubDate><source url="https://www.reddit.com/r/golang/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Go</source><content:encoded><![CDATA[I am considering using zed for writting go. Is it working out of the box with full syntax high light for noob like me such fmt.Println() ? I mean, I need to have it displaying functions under an import library.Should I give it a try or is it only for advanced users ? ]]></content:encoded></item><item><title>Type safe Go money library beta2!</title><link>https://www.reddit.com/r/golang/comments/1iq5stk/type_safe_go_money_library_beta2/</link><author>/u/HawkSecure4957</author><category>dev</category><category>reddit</category><category>go</category><pubDate>Sat, 15 Feb 2025 17:02:08 +0000</pubDate><source url="https://www.reddit.com/r/golang/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Go</source><content:encoded><![CDATA[Hello, after I released beta1, I received many constructive feedback! mainly lacking of locale support.This update brings locale formatting support and an improved interface for better usability. With Fulus, you can perform monetary operations safely and type-soundly. Plus, you can format money for any locale supported by CLDR. You can even define custom money types tailored specifically to your application's needs! I still need to battle test it against production projects, I have none at the moment. I am aiming next for performance benchmarking and more improvement, and parsing from string!I am open for more feedback. Thank you! ]]></content:encoded></item><item><title>Golang Mastery Exercises</title><link>https://www.reddit.com/r/golang/comments/1iq5k7w/golang_mastery_exercises/</link><author>/u/Temporary-Buy-7562</author><category>dev</category><category>reddit</category><category>go</category><pubDate>Sat, 15 Feb 2025 16:51:47 +0000</pubDate><source url="https://www.reddit.com/r/golang/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Go</source><content:encoded><![CDATA[I made a repository which has a prompt for you to write many exercises, if you complete this, and then drill the exercises, I would be sure you would reach mastery with the core of the language.I initially wanted to make some exercises for drilling syntax since I use copilot and lsps a lot, but ended up with quite a damn comprehensive list of things you would want to do with the language, and I find this more useful than working on leetcode to really adopt the language.]]></content:encoded></item><item><title>GitHub - yaitoo/xun: Xun is an HTTP web framework built on Go&apos;s built-in html/template and net/http package‚Äôs router (1.22).</title><link>https://github.com/yaitoo/xun</link><author>/u/imlangzi</author><category>dev</category><category>reddit</category><category>go</category><pubDate>Sat, 15 Feb 2025 14:15:54 +0000</pubDate><source url="https://www.reddit.com/r/golang/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Go</source><content:encoded><![CDATA[]]></content:encoded></item><item><title>Built a cli tool for generating .gitignore files</title><link>https://www.reddit.com/r/golang/comments/1iq1ivv/built_a_cli_tool_for_generating_gitignore_files/</link><author>/u/SoaringSignificant</author><category>dev</category><category>reddit</category><category>go</category><pubDate>Sat, 15 Feb 2025 13:38:59 +0000</pubDate><source url="https://www.reddit.com/r/golang/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Go</source><content:encoded><![CDATA[I built this mostly as an excuse to play around with Charmbracelet‚Äôs libraries like Bubble Tea and make a nice TUI, but it also solves the annoying problem of constantly looking up .gitignore templates. It‚Äôs a simple CLI tool that lets you grab templates straight from GitHub, TopTal, or even your own custom repository, all from the terminal. You can search through templates using a TUI interface, combine multiple ones like mixing Go and CLion, and even save your own locally so you don‚Äôt have to redo them every time. If you‚Äôre always setting up new projects and find yourself dealing with .gitignore files over and over, this just makes life a bit easier, hopefully. If that sounds useful, check it out here and give it a try. And if you‚Äôve got ideas to make the TUI better or want to add something cool, feel free to open a PR. Always happy to get feedback or contributions!]]></content:encoded></item><item><title>ED25519 Digital Signatures In Go</title><link>https://www.reddit.com/r/golang/comments/1iq1i84/ed25519_digital_signatures_in_go/</link><author>/u/mejaz-01</author><category>dev</category><category>reddit</category><category>go</category><pubDate>Sat, 15 Feb 2025 13:37:59 +0000</pubDate><source url="https://www.reddit.com/r/golang/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Go</source><content:encoded><![CDATA[   submitted by    /u/mejaz-01 ]]></content:encoded></item><item><title>Ordered map</title><link>https://dev.to/kirillscherba/ordered-map-13op</link><author>Kirill Scherba</author><category>dev</category><category>go</category><pubDate>Sat, 15 Feb 2025 11:51:43 +0000</pubDate><source url="https://dev.to/t/go">Dev.to Go</source><content:encoded><![CDATA[Omap is Golang package for working with thread safe ordered maps. The ordered map contains the golang map, list and mutex to execute Ordered Map functions.The Ordered Map is a map that remembers the order of items. The map can be iterated over to retrieve the items in the order they were added.
  
  
  Introduction to the omap Go Package
The omap Go package is a lightweight and efficient library for working with ordered maps in Go. An ordered map is a data structure that combines the benefits of a map and a list, allowing you to store key-value pairs in a specific order.Omap is a Go package that provides an implementation of an ordered map. It is designed to be fast, efficient, and easy to use. Omap is particularly useful when you need to store data in a specific order, such as when working with configuration files, caching, or data processing pipelines.Ordered: omap preserves the order in which key-value pairs are inserted, allowing you to iterate over the map in a specific order.Fast lookups: omap uses a hash table to store key-value pairs, making lookups fast and efficient.Efficient insertion and deletion: omap uses a linked list to store the order of key-value pairs, making insertion and deletion operations efficient.To use omap, you can install it using the following command:go get github.com/kirill-scherba/omap
Here is an example of how to use omap:This code creates a new omap, inserts some key-value pairs, and then iterates over the omap in order, printing out each key-value pair.The omap Go package is a useful library for working with ordered maps in Go. Its fast lookups, efficient insertion and deletion, and ordered iteration make it a great choice for a variety of use cases. Whether you're working with configuration files, caching, or data processing pipelines, omap is definitely worth considering.Configuration files: Use omap to store configuration data in a specific order, making it easy to iterate over the configuration and apply settings in the correct order.Caching: Use omap to store cached data in a specific order, making it easy to iterate over the cache and evict items in the correct order.Data processing pipelines: Use omap to store data in a specific order, making it easy to iterate over the data and process it in the correct order.]]></content:encoded></item><item><title>üåç UTF-8</title><link>https://dev.to/wycliffealphus/utf-8-3edn</link><author>Wycliffe A. Onyango</author><category>dev</category><category>go</category><pubDate>Sat, 15 Feb 2025 11:10:08 +0000</pubDate><source url="https://dev.to/t/go">Dev.to Go</source><content:encoded><![CDATA[Have you ever opened a file or webpage and seen something like this?That‚Äôs an encoding issue, and if you‚Äôve been coding long enough, you‚Äôve probably run into it at some point.But why does this happen? Why do some characters get replaced with weird symbols? And most importantly‚Äîhow do we fix it?The answer is UTF-8, the encoding that powers almost everything today. Let's talk about what it is, why it matters, and how to use it properly in Go (Golang).
  
  
  üî• The Problem UTF-8 Solves
Back in the early days of computing, ASCII was the standard way to represent text. It used 7 bits per character, meaning it could only represent 128 characters (A-Z, a-z, 0-9, and some symbols).That was fine‚Äîuntil computers went global.Suddenly, people needed to store and display languages like Chinese (Ê±âÂ≠ó), Arabic (ÿßŸÑÿπÿ±ÿ®Ÿäÿ©), Hindi (‡§π‡§ø‡§®‡•ç‡§¶‡•Ä), and more. ASCII just couldn‚Äôt handle it.So different countries created their own encodings:ISO-8859-1 for Western EuropeWindows-1252 for Microsoft systemsüíÄ The result? Encoding chaos. A file written in one system might be unreadable in another.Enter , the hero of our story.
  
  
  üèÜ What Makes UTF-8 Special?
UTF-8 was designed in 1992 by Ken Thompson and Rob Pike (yes, the same Rob Pike who helped create Go!). It solved the encoding mess by being:‚úÖ Backwards-compatible with ASCII
‚úÖ Compact for common characters (English stays at 1 byte per character)
‚úÖ Capable of encoding every language and symbol
‚úÖ Error-resistant (invalid bytes won‚Äôt accidentally form valid characters)This is why UTF-8 is now used by 97% of websites and is the default encoding for most programming languages, including Go.
  
  
  üíª UTF-8 in Action (With Go Examples)
Since Go natively supports UTF-8, you don‚Äôt need to do anything special‚Äîit just works. But let‚Äôs dig into some examples to see it in action.1Ô∏è‚É£ Encoding a String as UTF-8 BytesEnglish characters (, ) are 1 byte each.Chinese characters () are 3 bytes each.This variable-length encoding is why UTF-8 is so efficient!2Ô∏è‚É£ Decoding UTF-8 Bytes Back to a Stringüí° No extra libraries‚ÄîGo just handles it. That‚Äôs one of the nice things about UTF-8 in Go.3Ô∏è‚É£ Handling UTF-8 in Web ApplicationsIf you're building a web app, always specify UTF-8 in your response headers:üí° Without , some browsers might misinterpret the text and display garbage characters.4Ô∏è‚É£ Validating UTF-8 DataNot every byte sequence is valid UTF-8. You can check with :‚úÖ Great for validating user input before processing it!5Ô∏è‚É£ Counting Unicode Characters (Runes) in a StringGo strings are byte sequences, not necessarily character sequences.‚ùó Why the difference? Because ‰∏ñÁïå takes 3 bytes each, so len(text) == 13, but there are only 9 characters.6Ô∏è‚É£ Iterating Over Unicode CharactersSince some characters take more than 1 byte, normal indexing won‚Äôt work. Use :‚ùó Notice how ‰∏ñÁïå starts at index 7, not 5, because it uses 3 bytes each.
  
  
  üöÄ Why UTF-8 is the Default Encoding
Before UTF-8:
‚ùå Confusing mess of different encodings
‚ùå Text corruption between systems
‚ùå Websites needed to support multiple charsetsAfter UTF-8:
‚úÖ One encoding for everything
‚úÖ No more garbled text (mojibake)
‚úÖ Supported everywhere‚Äîfrom databases to web APIsIf you‚Äôre dealing with text in Go (or any language), understanding UTF-8 is essential. It ensures your applications work worldwide without encoding issues.]]></content:encoded></item><item><title>Go Nullable with Generics v2.0.0 - now supports omitzero</title><link>https://github.com/LukaGiorgadze/gonull</link><author>/u/Money-Relative-1184</author><category>dev</category><category>reddit</category><category>go</category><pubDate>Sat, 15 Feb 2025 11:00:21 +0000</pubDate><source url="https://www.reddit.com/r/golang/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Go</source><content:encoded><![CDATA[]]></content:encoded></item><item><title>what do you use golang for?</title><link>https://www.reddit.com/r/golang/comments/1ipykyd/what_do_you_use_golang_for/</link><author>/u/Notalabel_4566</author><category>dev</category><category>reddit</category><category>go</category><pubDate>Sat, 15 Feb 2025 10:24:28 +0000</pubDate><source url="https://www.reddit.com/r/golang/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Go</source><content:encoded><![CDATA[Is there any other major use than web development?]]></content:encoded></item><item><title>Concurrency vs Parallelism | Golang | Which is better and Why?</title><link>https://dev.to/gargkunal/concurrency-vs-parallelism-golang-which-is-better-and-why-m5j</link><author>Kunal Garg</author><category>dev</category><category>go</category><pubDate>Sat, 15 Feb 2025 05:38:24 +0000</pubDate><source url="https://dev.to/t/go">Dev.to Go</source><content:encoded><![CDATA[In this video, I‚Äôll dive deep into Concurrency vs Parallelism in Golang, explaining the key differences, when to use each, and which one is better for different scenarios. I'll cover various ways to implement concurrency in Golang, with practical code examples and hands-on demonstrations. Whether you're new to Go or looking to optimize your programs, this video will give you a solid understanding of how to leverage goroutines, channels, and worker pools effectively.üîπ What is Concurrency?
üîπ What is Parallelism?
üîπ Key Differences & Use Cases
üîπ Writing Concurrent Code in Golang
üîπ Live Code Examples & Best Practices]]></content:encoded></item><item><title>Webassembly and go 2025</title><link>https://www.reddit.com/r/golang/comments/1ipu4wd/webassembly_and_go_2025/</link><author>/u/KosekiBoto</author><category>dev</category><category>reddit</category><category>go</category><pubDate>Sat, 15 Feb 2025 05:00:37 +0000</pubDate><source url="https://www.reddit.com/r/golang/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Go</source><content:encoded><![CDATA[so I found this video and was thinking about doing something similar for my game as a means to implement modding, however I also stumbled upon a 3 y/o post when looking into it essentially stating that it's a bad idea and I wasn't able to really find anything on the state of go wasm, so can someone please enlighten me as to the current state of WASM and Go, thank you   submitted by    /u/KosekiBoto ]]></content:encoded></item><item><title>How to Implement Redis Caching in Golang for Beginners: A Step-by-Step Guide(Windows Edition)</title><link>https://dev.to/arijit_das_24c46c6f02b06b/how-to-implement-redis-caching-in-golang-for-beginners-a-step-by-step-guidewindows-edition-1g1a</link><author>Arijit das</author><category>dev</category><category>go</category><pubDate>Sat, 15 Feb 2025 04:15:44 +0000</pubDate><source url="https://dev.to/t/go">Dev.to Go</source><content:encoded><![CDATA[In this post, I'll walk you through how to set up and use Redis caching in a Golang project. This setup helps in reducing  and improving  by caching frequently requested data.  
  
  
  üîπ Why Use Redis for Caching?‚úÖ Reduces database load
‚úÖ Supports expiration & invalidation  
  
  
  üìå Step 1: Install Redis PackageWe use the  package to interact with Redis. Install it using:go get github.com/redis/go-redis/v9

  
  
  üìå Step 2: Initialize Redis ClientCreate a file  and add the following:üîπ If using a local Redis instance, set  and remove .For cloud Redis providers (like Aiven, AWS, etc.), use the TLS setup.  
  
  
  üìå Step 3: Implement Caching FunctionsAdd the following caching functions to manage data in Redis:üîπ  ‚Üí Checks if the key exists, retrieves & unmarshals data. ‚Üí Stores JSON-encoded data with an expiration time. ‚Üí Deletes a cache entry (useful when data updates).  
  
  
  üìå Step 4: Use Redis Cache in Database QueriesModify your database query functions to  before querying the database:üîπ  using ., query the database. for future use with .  
  
  
  üìå Step 5: Invalidate Cache When Data ChangesWhenever new categories are added, remove the outdated cache:üîπ Use this after adding/updating/deleting data to keep cache fresh.  If you want to test Redis caching locally on , follow these steps:
  
  
  ‚úÖ Step 1: Install & Run Redis LocallyDownload Redis for Windows:  (Redis is not natively supported on Windows)Install and run the Redis server. or a , start it using:Check if Redis is Running:
Open  and run:
If Redis is running, it should return:
  
  
  ‚úÖ Step 2: Set & Get Keys in Redis (Local Testing)To manually check your cache for the key , use the following commands in :Check if  exists:If it returns , the key exists. If , it's missing.This should return the cached JSON data.]]></content:encoded></item><item><title>Refactor and cleaup yacc: Making sense of legacy code</title><link>https://dev.to/mbver/refactor-and-clean-up-goyacc-making-sense-of-legacy-code-1pm0</link><author>mbver</author><category>dev</category><category>go</category><pubDate>Sat, 15 Feb 2025 02:04:48 +0000</pubDate><source url="https://dev.to/t/go">Dev.to Go</source><content:encoded><![CDATA[, a widely used LALR(1) parser generator, is efficient but burdened by archaic, unreadable code from the 1970s. Its Go adaptation, , inherits these issues despite the modern language.While exploring compilers, I found  to be a gold mine of insights, though buried under outdated practices. Following Allan Holub‚Äôs , I dissected its code‚Äîclarifying, simplifying, and refactoring convoluted sections. I then tested the revised version in a real-world scenario to ensure it retained its original functionality. The full code is published on github.I aimed to explore real-world open-source code, bridge ideals with reality, and stay sane as a reader. By refining and clarifying it, I made learning smoother and reuse easier.The first issue is poor naming‚Äîcryptic, vague, or misleading names. Here‚Äôs how naming was improved.original | cleanup          | intent
--------------------------------------------------------------------------------------------------
cpfir    | computeFirstsets | compute the first sets for non-terminal symbols
cpemp    | computeEmpty     | compute compute table to check if a non-terminal symbol is nullable
cpres    | computeYields    | compute compute the production yields for non-terminal symbols
curres   | prds             | the productions having the same non-terminal symbol as LHS
wSet     | wItem            | type of a working item generated during closure
wSets    | wSet             | store working items generated during closure
statemem | kernls           | store kernel items
mstate   | statechain       | chain a state's previous state to track where it cames from
pstate   | kernlp           | pointer to a kernel item
putitem  | addKernItem      | add a kernel item
writem   | item.string()    | get the string representation of a kernel item
apack    | packGotosRow     | compress newly goto row after closing state, not action as "a" implies
prectfn  | handleShiftReduceConflict | handle shift-reduce conflict of a state during processing closed states
go2out   | packGotosByCol   | compress goto table by column
go2gen   | computeGotoCol   | compute the goto column for a non-terminal symbol
callopt  | storeShiftsAndGotos | store shift-row for a state or goto column for a non-terminal symbol in action-store
gin      | storeGotoCol     | store a column of compressed goto table for a terminal symbol into action-store
stin     | storeShifts      | store shifts of a row in action table for a state into action-store
setbit   | lkset.set        | set a bit ON
bitset¬†  | lkset.check      | check if a bit is ON (mix up with setbit easily)

The second issue is cramming everything into one place, burying core logic (closure and state generation) under the bulky input parsing.  Refactoring separates it to files by functionality, improving clarity and focus.The third issue is poor organization. A key component, the lookahead set, should have its own type with all related methods grouped together, not lying elsewhere. This improves maintainability and makes adding methods easier. Similarly, the kernel item should define its own string representation method. These structs also include a Clone method for copying instances.The fourth issue is convolution. The  variable determines whether closure is  or  for state generation and  for processing closed states. However, it pops up in unexpected places like kernel item addition, state generation, and packing gotos. Furthermore, it creates twists and turns in the  logic, making it harder to follow.To resolve this, I split  into  for  and closure0 for . While slightly redundant, this separation prevents their logic from getting entangled, making the flow easier to follow. With this change, the confusing  is completely eliminated.Similarly,  determines whether we're handling an  but is tangled with  in closed state processing. By explicitly storing and processing , the confusion caused by  is eliminated.The fifth issue is redundant complications. An example is  -production rules with the same . The code extracts only  to construct the  while calling it  in kernel item. By consistently using full production rules, we remove this friction. It helps to eliminate further redundancies like keeping production number in kernel item for comparison and tricky code to print the dot for a kernel item. Here is the code with comments highlighting the problems.Another example is the redundant outer loop of .Another redundant outer loop is in closure's work item processing.The sixth issue is that several lines can be made more readable by adopting a clearer style. Let's review some snippets.Thanks for reading to the end. Hope this helps on your journey.]]></content:encoded></item><item><title>LangCompiler: A Cloud-Native, High-Performance Code Execution Service</title><link>https://dev.to/bladearya/langcompiler-a-cloud-native-high-performance-code-execution-service-5a2i</link><author>Amit Kumar Rout</author><category>dev</category><category>go</category><pubDate>Fri, 14 Feb 2025 16:07:19 +0000</pubDate><source url="https://dev.to/t/go">Dev.to Go</source><content:encoded><![CDATA[Smooth, secure, and scalable execution of code is of paramount concern in modern software development for a variety of applications, from education systems to enterprise applications. LangCompiler has been created to cater to this demand by providing a cloud-native, high-performance environment for code execution across a variety of programming languages.LangCompiler is an elegantly crafted service that provides secure and scalable code execution across a wide spectrum of programming languages. It currently supports Python, Java, JavaScript, and C++, with further expansion planned in response to community requirements. Its versatility makes it a developer, educator, and enterprise favorite. The service provides code execution across four popular languages (Python, Java, JavaScript, and C++), with further expansion planned.Dynamic Resource Constraints: It is scalable, managing workloads efficiently through resource-aware execution. The service includes extensive logging and debugging to guarantee seamless execution.Comprehensive Execution Metrics: Users can monitor performance, detect inefficiencies, and optimize workloads.Secure and Isolated Execution: It includes security features to prevent unauthorized access and code protection.
  
  
  Built with Golang and Docker
To ensure high performance and reliability, LangCompiler is built using Golang, leveraging its efficiency and concurrency features. Additionally, it is Dockerized to provide an isolated execution environment, ensuring consistent and secure execution across different workloads. The service is hosted on Render, allowing seamless deployment, scaling, and management.We invite developers, educators, and enterprises to explore LangCompiler and take advantage of its robust capabilities. To further enhance API development, we encourage you to check out our premium plans.]]></content:encoded></item><item><title>Top 22 Sites To Buy Verified Binance Accounts personal</title><link>https://dev.to/hiya_tili_6b6c8383c5ae8c4/top-22-sites-to-buy-verified-binance-accounts-personal-41fk</link><author>Hiya Tili</author><category>dev</category><category>go</category><pubDate>Fri, 14 Feb 2025 15:21:24 +0000</pubDate><source url="https://dev.to/t/go">Dev.to Go</source><content:encoded><![CDATA[If you want to more information just contact now.
Telegram: @itzonesmm0
WhatsApp: +1 (989) 513-2521liveitzonesmm@gmail.comBuy Verified Binance Account
Looking to Buy Verified Binance Account? Purchase one for instant access to trading features, securely. If you want to Buy Verified Binance Account then itzonesmm.com is the best option for you.In today‚Äôs fast-paced digital world, online trading platforms like Binance have become increasingly popular among individuals looking to invest in cryptocurrencies. To ensure a smooth entry into the world of crypto trading, having a verified Binance account is essential. By purchasing a verified account, you can bypass the lengthy verification process and start trading immediately.Buy Verified Binance Account
Buy Verified Binance Account
This hassle-free option saves you time and allows you to take advantage of market opportunities swiftly. Additionally, a verified account provides added security and access to advanced trading features. Ready to kickstart your crypto journey? Invest in a verified Binance account today and stay ahead in the ever-evolving crypto market.The Importance Of A Verified Binance Account
Buying and selling cryptocurrencies through a reputable platform like Binance is a popular practice. However, having a verified Binance account is of utmost importance to ensure a secure and advanced trading experience. In this section, we‚Äôll delve into the significance of a verified Binance account and the benefits it offers.Enhanced Security Measures
When you have a verified Binance account, you can benefit from enhanced security measures that add an extra layer of protection to your account. Two-factor authentication and withdrawal whitelisting are just a few examples of the security features available to verified users. This significantly reduces the risk of unauthorized access to your account and provides peace of mind when engaging in cryptocurrency transactions.Access To Advanced Trading Features
A verified Binance account grants access to advanced trading features that are not available to unverified users. These features include higher withdrawal limits, access to futures and margin trading, and participation in token sales. By verifying your account, you can take advantage of these advanced tools and broaden your trading opportunities, allowing for a more diverse and potentially profitable trading experience.The Process Of Verifying A Binance Account
Buying a verified Binance account can be a time-saving option for cryptocurrency enthusiasts. It eliminates the need to go through the rigorous process of account verification. However, if you choose to verify your own Binance account, here is a breakdown of the steps involved.
To start the process, log in to your Binance account and navigate to the user dashboard. Choose the option for account verification and select the type of verification you wish to undergo. You will be asked to provide personal details such as your full name, address, and date of birth. Next, upload a scanned copy of your government-issued ID, such as a driver‚Äôs license or passport. Make sure all details are accurate and match the information on the ID provided.Additional Verification Steps
After submitting your identity verification, Binance may require additional steps to complete the process. This could include providing proof of address, such as a utility bill or bank statement. You may also need to go through facial recognition verification to ensure the account belongs to the rightful owner. Once all steps are completed, await approval from Binance, which typically takes a few business days.Benefits Of Buying A Verified Binance Account
If you are an aspiring cryptocurrency trader, you know how important it is to have a verified Binance account. However, going through the tedious verification process can be a hassle and time-consuming. That‚Äôs why buying a verified Binance account can offer you several benefits, allowing you to focus on what matters most ‚Äì trading.If you want to more information just contact now.
Telegram: @itzonesmm0
WhatsApp: +1 (989) 513-2521liveitzonesmm@gmail.comInstant Access To Trading
When you purchase a verified Binance account, you gain immediate access to the platform‚Äôs trading services. Unlike the traditional account creation and verification method that can take days or even weeks, buying a verified account cuts the waiting time significantly. This means you can start trading and capitalizing on potential market opportunities without delay. Avoiding Verification Hassles
Verification processes can be cumbersome and time-consuming. From providing personal identification documents to answering questionnaires, the process can sometimes feel intrusive. By purchasing a verified Binance account, you eliminate the need to go through this whole process. You can skip the hassle and start trading right away. This is especially beneficial if you are looking to capitalize on time-sensitive market movements or seize profitable trade opportunities.Furthermore, buying a verified account saves you from the frustration of potential verification failures. Sometimes, applicants face rejection due to minor errors or document discrepancies, resulting in extended waiting times. By bypassing the verification process, you eliminate the risk of encountering such setbacks and can focus solely on your trading activities.With the benefits of instant access to trading and avoiding verification hassles, buying a verified Binance account provides a convenient and efficient solution for crypto enthusiasts.
When considering the purchase of a verified Binance account, it‚Äôs essential to understand the potential risks and regulatory considerations involved. This will ensure that you are making an informed decision and taking into account the potential pitfalls that may arise.
Unfortunately, the crypto industry is not immune to scams, and purchasing a verified Binance account comes with its own set of risks. There is the potential for scammers to falsely advertise verified accounts, leading to financial loss and account security issues. It‚Äôs crucial to thoroughly research the seller and verify their legitimacy to avoid falling victim to fraudulent activity.
Additionally, regulatory compliance is a key consideration when purchasing a verified Binance account. It‚Äôs important to ensure that the account has been obtained and verified through legal and compliant means. Failure to comply with regulatory requirements could result in account suspension or legal repercussions, making it essential to verify the authenticity of the account and its compliance with relevant regulations.Choosing A Reliable Service Provider
When finding a service provider to Buy Verified Binance Account, reliability is crucial. Look for reputable sellers with positive customer reviews and a track record of delivering quality, verified accounts. Taking the time to research and choose a reliable service provider can ensure a smooth and secure experience.Reputation And Trustworthiness
Reputable Binance account service providers like itzonesmm have a solid track record and are known for their trustworthiness.Look for providers with a strong reputation in the industry to ensure security and reliability. Then itzonesmm.com is the salutation for you.Customer Reviews And Feedback
Reading customer reviews and feedback can provide insight into the service quality offered by itzonesmm.Positive reviews are a good indicator that the service is reliable and trustworthy.Legal And Ethical Implications
The purchase and use of a verified Binance account raise legal and ethical implications that need to be considered. Compliance with anti-money laundering regulations, data privacy, and identity verification are crucial to ensure a secure and transparent trading environment.The Future Of Binance Account Verification
As the cryptocurrency market continues to expand, so does the need for robust security measures. In this context, the verification process for Binance accounts is evolving rapidly. This not only impacts the trading environment but also sets the stage for a more secure and reliable platform for traders.Evolution Of Verification Procedures
The evolution of Binance account verification procedures reflects the platform‚Äôs commitment to heightened security. The initial verification process mainly focused on email verification and two-factor authentication. However, as the market dynamics and regulatory requirements evolved, Binance introduced enhanced verification levels. This includes personal identification verification, know-your-customer (KYC) procedures, and even address verification. These steps are crucial in protecting user assets and ensuring compliance with industry regulations.Impact On Trading Environment
The impact of these evolving verification procedures is significant for the trading environment. With stricter verification measures in place, Binance creates a safer space for traders to engage in cryptocurrency transactions. Traders can have greater trust in the platform, knowing that stringent verification processes are in place to deter fraudulent activities. Additionally, enhanced verification procedures also pave the way for a more seamless integration with traditional financial systems, making crypto trading more accessible and widely accepted.Market Trends And User Experiences
Verified Binance accounts are becoming increasingly popular due to the heightened security they offer to users.
Users report high levels of satisfaction with verified Binance accountsTrends In Verified Account Ownership
Ownership of verified Binance accounts is on the rise as more users seek secure trading options.Faqs About Verified Binance Accounts
As more traders and investors flock to the world of cryptocurrency, platforms like Binance have gained immense popularity. One way to enhance your experience on Binance is by getting a verified account. In this section, we‚Äôll address some frequently asked questions about verified Binance accounts and provide you with the information you need to make an informed decision.
If you‚Äôre considering getting a verified Binance account, it‚Äôs natural to have questions about security. Binance takes security seriously and implements several measures to protect its users. One of these measures is the Know Your Customer (KYC) process, which requires users to verify their identity and provide relevant documents.With a verified account, you can have peace of mind knowing that your funds and personal information are better protected. The verification process helps ensure that only legitimate users gain access to the platform, reducing the risk of fraudulent activities.Moreover, Binance employs industry-standard security protocols, such as two-factor authentication (2FA) and encryption, to safeguard user accounts. These additional layers of security give you an added level of confidence when trading or storing your cryptocurrencies on the platform.Transferability Of Verified Status
Once you acquire a verified Binance account, you might wonder if the verified status is transferable. The short answer is no. Verification is linked to the individual user account and cannot be transferred to another user.This means that if you‚Äôre looking to purchase a verified Binance account from someone else, it‚Äôs important to tread with caution. The selling or transferring of verified Binance accounts is strictly against Binance‚Äôs terms of service, and engaging in such activities could result in your account being permanently suspended.It‚Äôs important to note that Binance‚Äôs strict stance on verification transferability is in place to protect users‚Äô security and prevent fraudulent activities. By ensuring that each user goes through the verification process individually, Binance maintains a safer trading environment for all its users.while you cannot transfer a verified Binance account, you can easily go through the verification process on your own to enjoy the benefits and added security that come with it.Conclusion And Final Thoughts
Considering the pros and cons, buying a verified Binance account can offer a range of benefits for traders. It provides a streamlined process for account verification, reducing the waiting time and frustrations associated with manual verification. However, it‚Äôs important to weigh these advantages against potential risks and drawbacks. By empowering trading decisions, a verified Binance account allows traders to quickly delve into the world of cryptocurrency and start trading. Whether you‚Äôre a beginner or an experienced trader, having a verified Binance account can give you a competitive edge in the market.Weighing The Pros And Cons
Before purchasing a verified Binance account, it is essential to evaluate the pros and cons. Let‚Äôs take a closer look at what you should consider:Streamlined verification process: By buying a verified Binance account, you can skip the hassle of manual verification, significantly reducing the waiting time and potential frustrations.
Immediate access to trading: With a verified Binance account, you can start trading cryptocurrencies right away, without any delays.
Enhanced security measures: Verified Binance accounts typically come with advanced security features, such as two-factor authentication, providing an added layer of protection for your funds.
Expert support: Some providers of verified Binance accounts offer dedicated customer support to assist you with any inquiries or issues you may encounter.Reliance on a third party: When purchasing a verified Binance account, you need to trust the provider to deliver a legitimate and secure account.
Potential risks: As with any online financial transaction, there is always a risk of encountering fraudulent or scammy providers. It‚Äôs crucial to thoroughly research and choose a reputable provider with positive reviews.Verified Binance accounts may come with a price tag, and it‚Äôs important to evaluate the cost versus the value it adds to your trading experience.
Limited personalization: When buying a verified Binance account, you may not have the option to customize certain account settings or preferences according to your specific needs.
Empowering Trading Decisions
A verified Binance account can empower your trading decisions by providing quick and efficient access to the cryptocurrency market. The streamlined verification process eliminates the frustration of waiting for manual verification, enabling you to take advantage of market opportunities swiftly. Whether you‚Äôre a day trader, swing trader, or long-term investor, having a verified Binance account equips you with the necessary tools to make informed and impactful trading decisions.while buying a verified Binance account comes with its pros and cons, it definitely offers advantages for those looking to expedite the account verification process and start trading cryptocurrencies promptly. However, one must exercise caution when choosing a provider and thoroughly evaluate the potential risks involved.Frequently Asked QuestionsHow To Get Verified In Binance?
To get verified in Binance, go to your account settings, complete identity verification, submit required documents, and wait for approval. Can I Have Two Verified Binance Accounts?
No, Binance allows only one verified account per user. Creating multiple accounts violates their terms of service.What Is A Binance Account?
A Binance account is a digital wallet for trading cryptocurrencies like Bitcoin and Ethereum. It allows users to buy, sell, and store various digital assets. With a Binance account, you can participate in the cryptocurrency market and manage your investments securely.How To Verify Entity Account Binance?
To verify entity accounts on Binance, submit required documents via the website for verification process.Can I Buy Verified Binance Account Online?
Yes, you can Buy Verified Binance Account online from itzonesmm.com What Are The Benefits Of Buying A Verified Binance Account?
Buying a verified Binance account saves time and effort required for the verification process, ensuring immediate access to the platform‚Äôs features and services.Is It Legal To Buy Verified Binance Account?
While buying a verified Binance account is not illegal, it is against Binance‚Äôs terms and conditions, which may result in the account being banned or frozen.Are Verified Binance Accounts Safe To Use?
Verified Binance accounts are generally safe to use, but it is essential to exercise caution and follow Binance‚Äôs security guidelines to protect your account from unauthorized access or hacking attempts.How Do I Find Reputable Sellers Of Verified Binance Accounts?
To find reputable sellers of verified Binance accounts, you can rely on online marketplaces, forums, or seek recommendations from trusted sources within the cryptocurrency community.
Invest in a verified Binance account to enhance your trading journey. Take advantage of security and convenience. Maximize your opportunities and streamline transactions. Don‚Äôt miss out on the benefits of a trusted account. Start your journey to success with Binance today!If you want to more information just contact now.
Telegram: @itzonesmm0
WhatsApp: +1 (989) 513-2521liveitzonesmm@gmail.com]]></content:encoded></item><item><title>Deep Dive into net/netip AddrPort Methods 6/7</title><link>https://dev.to/rezmoss/deep-dive-into-netnetip-addrport-methods-67-3gn3</link><author>Rez Moss</author><category>dev</category><category>go</category><pubDate>Fri, 14 Feb 2025 15:00:00 +0000</pubDate><source url="https://dev.to/t/go">Dev.to Go</source><content:encoded><![CDATA[Hey there! In our previous article, we explored Addr methods in detail. Now let's dive deep into AddrPort methods. AddrPort is a crucial type when working with network services since it combines an IP address with a port number. We'll explore every method with practical examples and real-world use cases.First, let's look at all the ways to work with AddrPort.
  
  
  1. Service Discovery System
Here's a robust service discovery implementation using AddrPort:
  
  
  2. Connection Pool Manager
A connection pool that uses AddrPort for endpoint tracking:
  
  
  3. Load Balancer Implementation
A load balancer using AddrPort for backend management:
Always validate AddrPort before use:

Be careful with string conversions:

Check port numbers when needed:
In our next article, we'll explore Prefix methods in depth, completing our detailed examination of the core types in net/netip. We'll see how to work effectively with CIDR notations and subnet operations.Until then, keep experimenting with AddrPort! It's a fundamental building block for network services in Go.]]></content:encoded></item><item><title>[Boost]</title><link>https://dev.to/jisbruzzi/-2734</link><author>Jos√© Ignacio Sbruzzi</author><category>dev</category><category>go</category><pubDate>Fri, 14 Feb 2025 12:23:06 +0000</pubDate><source url="https://dev.to/t/go">Dev.to Go</source><content:encoded><![CDATA[Advanced RabbitMQ and Go: Tackling Channel Closures in Exclusive Queues]]></content:encoded></item><item><title>Extensible Wasm Applications with Go</title><link>https://go.dev/blog/wasmexport</link><author>Cherry Mui</author><category>dev</category><category>official</category><category>go</category><pubDate>Thu, 13 Feb 2025 00:00:00 +0000</pubDate><source url="http://blog.golang.org/feed.atom">Golang Blog</source><content:encoded><![CDATA[
      Cherry Mui
      13 February 2025
      Go 1.24 enhances its WebAssembly (Wasm) capabilities with the
addition of the  directive and the ability to build a reactor
for WebAssembly System Interface (WASI).
These features enable Go developers to export Go functions to Wasm,
facilitating better integration with Wasm hosts and expanding the possibilities
for Go-based Wasm applications.WebAssembly and the WebAssembly System InterfaceWebAssembly (Wasm) is a binary instruction format
that was initially created for web browsers, providing the execution of
high-performance, low-level code at speeds approaching native performance.
Since then, Wasm‚Äôs utility has expanded, and it is now used in various
environments beyond the browser.
Notably, cloud providers offer services that directly execute Wasm
executables, taking advantage of the
WebAssembly System Interface (WASI) system call API.
WASI allows these executables to interact with system resources.Go first added support for compiling to Wasm in the 1.11 release, through the
 port.
Go 1.21 added a new port targeting the WASI preview 1 syscall API through the
new  port.Exporting Go Functions to Wasm with Go 1.24 introduces a new compiler directive, , which allows
developers to export Go functions to be called from outside of the
Wasm module, typically from a host application that runs the Wasm runtime.
This directive instructs the compiler to make the annotated function available
as a Wasm export
in the resulting Wasm binary.To use the  directive, simply add it to a function definition://go:wasmexport add
func add(a, b int32) int32 { return a + b }
With this, the Wasm module will have an exported function named  that
can be called from the host.This is analogous to the cgo  directive,
which makes the function available to be called from C,
though  uses a different, simpler mechanism.A WASI reactor is a WebAssembly module that operates continuously, and
can be called upon multiple times to react on events or requests.
Unlike a ‚Äúcommand‚Äù module, which terminates after its main function finishes,
a reactor instance remains live after initialization, and its exports remain
accessible.With Go 1.24, one can build a WASI reactor with the  build
flag.$ GOOS=wasip1 GOARCH=wasm go build -buildmode=c-shared -o reactor.wasm
The build flag signals to the linker not to generate the  function
(the entry point for a command module), and instead generate an
 function, which performs runtime and package initialization,
along with any exported functions and their dependencies.
The  function must be called before any other exported functions.
The  function will not be automatically invoked.To use a WASI reactor, the host application first initializes it by calling
, then simply invoke the exported functions.
Here is an example using Wazero, a Go-based Wasm runtime
implementation:// Create a Wasm runtime, set up WASI.
r := wazero.NewRuntime(ctx)
defer r.Close(ctx)
wasi_snapshot_preview1.MustInstantiate(ctx, r)

// Configure the module to initialize the reactor.
config := wazero.NewModuleConfig().WithStartFunctions("_initialize")

// Instantiate the module.
wasmModule, _ := r.InstantiateWithConfig(ctx, wasmFile, config)

// Call the exported function.
fn := wasmModule.ExportedFunction("add")
var a, b int32 = 1, 2
res, _ := fn.Call(ctx, api.EncodeI32(a), api.EncodeI32(b))
c := api.DecodeI32(res[0])
fmt.Printf("add(%d, %d) = %d\n", a, b, c)

// The instance is still alive. We can call the function again.
res, _ = fn.Call(ctx, api.EncodeI32(b), api.EncodeI32(c))
fmt.Printf("add(%d, %d) = %d\n", b, c, api.DecodeI32(res[0]))
The  directive and the reactor build mode allow applications to
be extended by calling into Go-based Wasm code.
This is particularly valuable for applications that have adopted Wasm as a
plugin or extension mechanism with well-defined interfaces.
By exporting Go functions, applications can leverage the Go Wasm modules to
provide functionality without needing to recompile the entire application.
Furthermore, building as a reactor ensures that the exported functions can be
called multiple times without requiring reinitialization, making it suitable
for long-running applications or services.Supporting rich types between the host and the clientGo 1.24 also relaxes the constraints on types that can be used as input and
result parameters with  functions.
For example, one can pass a bool, a string, a pointer to an , or a
pointer to a struct which embeds  and contains supported
field types
(see the documentation for detail).
This allows Go Wasm applications to be written in a more natural and ergonomic
way, and removes some unnecessary type conversions.While Go 1.24 has made significant enhancements to its Wasm capabilities,
there are still some notable limitations.Wasm is a single-threaded architecture with no parallelism.
A  function can spawn new goroutines.
But if a function creates a background goroutine, it will not continue
executing when the  function returns, until calling back into
the Go-based Wasm module.While some type restrictions have been relaxed in Go 1.24, there are still
limitations on the types that can be used with  and
 functions.
Due to the unfortunate mismatch between the 64-bit architecture of the client
and the 32-bit architecture of the host, it is not possible to pass pointers in
memory.
For example, a  function cannot take a pointer to a struct that
contains a pointer-typed field.The addition of the ability to build a WASI reactor and export Go functions to
Wasm in Go 1.24 represent a significant step forward for Go‚Äôs WebAssembly
capabilities.
These features empower developers to create more versatile and powerful Go-based
Wasm applications, opening up new possibilities for Go in the Wasm ecosystem.]]></content:encoded></item><item><title>Go 1.24 arrives</title><link>https://golangweekly.com/issues/542</link><author></author><category>dev</category><category>go</category><pubDate>Wed, 12 Feb 2025 00:00:00 +0000</pubDate><source url="https://golangweekly.com/">Golang Weekly</source><content:encoded><![CDATA[DB Fiddle is a handy online database 'sandbox' for playing with various versions of MySQL, Postgres, and SQLite direct from the browser.]]></content:encoded></item><item><title>Go 1.24 is released!</title><link>https://go.dev/blog/go1.24</link><author>Junyang Shao, on behalf of the Go team</author><category>dev</category><category>official</category><category>go</category><pubDate>Tue, 11 Feb 2025 00:00:00 +0000</pubDate><source url="http://blog.golang.org/feed.atom">Golang Blog</source><content:encoded><![CDATA[
      Junyang Shao, on behalf of the Go team
      11 February 2025
      Today the Go team is excited to release Go 1.24,
which you can get by visiting the download page.Go 1.24 comes with many improvements over Go 1.23. Here are some of the notable
changes; for the full list, refer to the release notes.Several performance improvements in the runtime have decreased CPU overhead
by 2‚Äì3% on average across a suite of representative benchmarks. These
improvements include a new builtin  implementation based on
Swiss Tables, more efficient
memory allocation of small objects, and a new runtime-internal mutex
implementation.The  command now provides a mechanism for tracking tool dependencies for a
module. Use  to add a  directive to the current module. Use
 to run the tools declared with the  directive.
Read more on the go command in the release notes.The new  analyzer in  subcommand reports common mistakes in
declarations of tests, fuzzers, benchmarks, and examples in test packages.
Read more on vet in the release notes.Standard library additionsImproved WebAssembly supportGo 1.24 adds a new  directive for Go programs to export
functions to the WebAssembly host, and supports building a Go program as a WASI
reactor/library.
Read more on WebAssembly in the release notes.Please read the Go 1.24 release notes for the complete and
detailed information. Don‚Äôt forget to watch for follow-up blog posts that
will go in more depth on some of the topics mentioned here!Thank you to everyone who contributed to this release by writing code and
documentation, reporting bugs, sharing feedback, and testing the release
candidates. Your efforts helped to ensure that Go 1.24 is as stable as possible.
As always, if you notice any problems, please file an issue.]]></content:encoded></item></channel></rss>