<?xml version="1.0" encoding="utf-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Blog</title><link>https://www.awesome-dev.news</link><description></description><item><title>Tools: Code Is All You Need</title><link>https://lucumr.pocoo.org/2025/7/3/tools/</link><author>Armin Ronacher</author><category>dev</category><category>blog</category><pubDate>Thu, 3 Jul 2025 00:00:00 +0000</pubDate><source url="https://lucumr.pocoo.org/feed.atom">Armin Ronacher Blog</source><content:encoded><![CDATA[If you've been following me on Twitter, you know I'm not a big fan of MCP right
now.  It's not that I dislike the idea; I just haven't found it to work as
advertised.  In my view, MCP suffers from two major flaws:It isn’t truly composable.  Most composition happens through inference.It demands too much context.  You must supply significant upfront input, and
every tool invocation consumes even more context than simply writing and
running code.A quick experiment makes this clear: try completing a GitHub task with the
GitHub MCP, then repeat it with the  CLI tool.  You'll almost certainly
find the latter uses context far more efficiently and you get to your intended
results quicker.I want to address some of the feedback I've received on my stance on this.  I
evaluated MCP extensively in the context of agentic coding, where its
limitations were easiest to observe.  One piece of feedback is that MCP might
not make a ton of sense for general code generation, because models are already
very good at that but they make a lot of sense for end-user applications, like,
say, automating a domain-specific task in a financial company.  Another one is
that I need to look at the world of the future, where models will be able to
reach many more tools and handle much more complex tasks.My current take is that my data indicates that current MCP will always be harder
to use than writing code, primarily due to the reliance on inference.  If you
look at the approaches today for pushing towards higher tool counts, the
proposals all include a layer of filtering.  You pass all your tools to an LLM
and ask it to filter it down based on the taks at hand.  So far, there hasn't
been much better approaches proposed.The main reason I believe this will most likely also hold true — that you
shouldn't be using MCP in its current form even for non-programming,
domain-specific tasks — is that even in those cases code generation just is the
better choice because of the ability to compose.Replace Yourself With A ShellscriptThe way to think about this problem is that when you don't have an AI, and
you're solving a problem as a software engineer, your tool of choice is code.
Perhaps as a non-software engineer, code is out of reach.  Many many tasks
people do by hand are actually automatable through software.  The challenge is
finding someone to write that software.  If you're working in a niche
environment and you're not a programmer yourself, you might not pick up a
programming book to learn how to code, and you might not find a developer
willing to provide you with a custom piece of software to solve your specific
problem.  And yes, maybe your task requires some inference, but many do need
them all the time.There is a reason we say “to replace oneself with a shell script”, it's because
that has been happening for a long time.  With LLMs and programming, the idea is
that rather than replacing yourself with a shell script, you're replacing
yourself with an LLM.  But you run into three problems: cost, speed, and general
reliability.  All these problems are what we need to deal with before we can
even think of tool usage or MCP.  We need to figure out how to ensure that our
automated task actually works correctly at scale.The key to automation is really to automate things that will happen over and
over.  You're not going to automate a one-shot change that will never recur.
You're going to start automating the things where the machine can truly give you
a productivity boost because you're going to do it once or twice, figure out how
to make it work, and then have the machine repeat it a thousand times.  For that
repetition, there's a very strong argument to be made for always using code.
That's because if we instruct the machine to use inference to do it, it might
work, particularly for small tasks, but it requires validation which can take
almost the same time as doing it in the first place.  Getting an LLM to
calculate for you sort of works, but it's much better for the LLM to write the
Python code to do the calculation.  Why?  First, you can review the formula, not
the calculation.  We can it ourselves or we can use the LLM as a judge to figure
out if the  is correct.  Don't really have to validate that Python
calculates correct, you can rely on that.  So, by opting for code generation for
task solving, we get a little closer to being able to verify and validate the
process ourselves, rather than hoping the LLM inferred correctly.This obviously goes way beyond calculation.  Take, for instance, this blog.  I
converted this entire blob from reStructuredText to Markdown recently.  I put
this conversion off for a really long time, partly because I was a little too
lazy.  But also, when I was lazy enough to consider deploying an LLM for it, I
just didn't trust it to do the conversion itself without regressing somewhere.
I was worried that if it ran out of context, it might start hallucinating text
or change wording slightly.  It's just that I worried about subtle regressions
too much.I still used an LLM for it, but I asked it to do that transformation in a
different way: through code.I asked the LLM to perform the core transformation from reStructuredText to
Markdown but I also asked it to do this in a way that uses the underlying AST
(Abstract Syntax Tree).  So, I instructed it to parse the reStructuredText
into an actual reStructuredText AST, then convert that to a Markdown AST, and
finally render it to HTML, just like it did before. This gave me an intermediate
transformation step and a comparable end result.Then, I asked it to write a script that compares the old HTML with the new HTML,
performs the diffing after some basic cleanup it deemed necessary for
comparison.  I asked it to consider what kind of conversion errors were
actually acceptable.  So, it read through its own scripts to see where it might
not match the original output due to known technical limitations (e.g.,
footnotes render differently between the Markdown library I'm using and the
reStructuredText library, so even if the syntax matches correctly, the HTML
would look different).  I asked it to compensate for this in that script.After that was done, I asked it to create a third script, which I could run
over the output of hundreds of files to analyze the differece to go back into
the agentic loop for another iteration tep.Then I kicked off off this in a loop.  I did not provide all the posts, I
started with 10 until differences were low and then had it do it for all.  It
did this for maybe 30 minutes or so until I came back to it and found it in a
pretty acceptable state.What's key about this transformation is not so much that the LLM was capable of
pulling it off, but that I actually trusted this process at the end because I
could review the approach.  Not only that, I also tried to ask another LLM what
it thinks of the code that another LLM wrote, and the changes.  It gave me much
higher confidence that what was going on would not lose data.  It felt right to
me.  It felt like a mechanical process that was fundamentally correct, and I was
able to observe it and do spot checks.  At worst, the regressions were minor
Markdown syntax errors, but the text itself wouldn't have been corrupted.Another key here is also that because the inference is rather constant, the cost
of inference in this process scales with the number of iteration steps and the
sample size, but it doesn't depend on how many documents I'm wanting to convert
overall.  Eventually, I just had it run over all documents all the time but
running it over 15 docs vs 150 docs is more or less the same effort, because the
final LLM based analysis step did not have that many more things to review (it
already skipped over all minor differences in the files).This is a long-winded way of saying that this entire transformation went through
code.  It's a pipeline that starts with human input, produces code, does an LLM
as a judge step and iterates.  And you can take this transformation and apply it
to a general task as well.To give an example, one MCP you might be using is Playwright.  I find it very
hard to replace Playwright with a code approach  because what
you're essentially doing is remotely controlling your browser.  The task you're
giving it largely involves reading the page, understanding what's on it, and
clicking the next button.  That's the kind of scenario where it's very hard to
eliminate inference at each step.However, if you already know what the page is — for instance, if you're
navigating your own app you're working on — then you can actually start telling
it to write a Playwright Python script instead and run that.  This script can
perform many of those steps sequentially without any inference.  I've noticed
that this approach is significantly quicker, and because it understands your
code, it still generally produces correct results.  It doesn't need to navigate,
read page contents, find a button, or press an input in real-time.  Instead, it
will write a single Python script that automates the entire process in one go,
requiring very little context by comparison. This process is repeatable.  Once the script is written, I can execute it 100,
200, or even 300 times without requiring any further inference.  This is a
significant advantage that an MCP (Multi-Component Pipeline) typically cannot
offer.  It's incredibly challenging to get an LLM to understand generic,
abstract MCP tool calls.  I wish I could, for example, embed an MCP client
directly into a shell script, allowing me to run remote MCP services efficiently
via code generation, but actually doing that is incredibly hard because the
tools are not written with non inference based automation in mind.Also, as ironic as it is: I'm a human, not an MCP client.  I can run and debug a
script, I cannot even figure out how to reliably do MCP calls.  It's always a
gamble and incredibly hard to debug.  I love using the little tools that Claude
Code generates while generating code.  Some of those I had it convert into long
term additions to my development process.I don't know.  But it's an interesting moment to think what we could potentially
do to make code generation for purposeful agentic coding better.  The weird
thing is that MCP is actually pretty great when it works.  But it feels in the
current form too much like a dead end that cannot be scaled up, particularly to
automation at scale because it relies on inference too much.So maybe we need to look at ways to find a better abstraction for what MCP is
great at, and code generation.  For that that we might need to build better
sandboxes and maybe start looking at how we can expose APIs in ways that allow
an agent to do some sort of fan out / fan in for inference.  Effectively we want
to do as much in generated code as we can, but then use the magic of LLMs after
bulk code execution to judge what we did.I can also imagine that it might be quite interesting to do code generation in a
way that also provides enough context for an LLM to explain in human language to
a non programmer what the script is doing.  That might enable these flows to be
used by human users that are not developers themselves.In any case I can only encourage people to bypass MCP and to explore what else
is possible.  LLMs can do so much more if you give them the power to write code.Here are some more posts you might want to read or videos you might want to
watch:Drew Breunig's post “How to fix your context”
which covers some attempts to improve MCP tool selection if you cannot avoid
it.Manuel Odendahl's excellent “MCPs are Boring”
talk from AI Engineer that was one of the first to point to the challenges
with MCP.]]></content:encoded></item><item><title>Why Organizations Need Expert Generalists</title><link>https://martinfowler.com/articles/expert-generalist.html#WhyOrganizationsNeedExpertGeneralists</link><author>Martin Fowler</author><category>dev</category><category>blog</category><pubDate>Wed, 2 Jul 2025 14:05:00 +0000</pubDate><source url="https://martinfowler.com/feed.atom">Martin Fowler</source><content:encoded><![CDATA[In complex environments, the characteristics of Expert Generalists lead
      Gitanjali, and I thus complete our article by summarizing the value of
      them to be particularly valuable in driving tasks to completion. Unmesh,
      this skill.]]></content:encoded></item><item><title>Ubuntu Disables Spectre/Meltdown Protections</title><link>https://www.schneier.com/blog/archives/2025/07/ubuntu-disables-spectre-meltdown-protections.html</link><author>Bruce Schneier</author><category>infosec</category><category>blog</category><pubDate>Wed, 2 Jul 2025 11:02:22 +0000</pubDate><source url="https://www.schneier.com/">Schneider on Security</source><content:encoded><![CDATA[A whole class of speculative execution attacks against CPUs were published in 2018. They seemed pretty catastrophic at the time. But the fixes were as well. Speculative execution was a way to speed up CPUs, and removing those enhancements resulted in significant performance drops.Now, people are rethinking the trade-off. Ubuntu has disabled some protections, resulting in  20% performance boost.After discussion between Intel and Canonical’s security teams, we are in agreement that Spectre no longer needs to be mitigated for the GPU at the Compute Runtime level. At this point, Spectre has been mitigated in the kernel, and a clear warning from the Compute Runtime build serves as a notification for those running modified kernels without those patches. For these reasons, we feel that Spectre mitigations in Compute Runtime no longer offer enough security impact to justify the current performance tradeoff.I agree with this trade-off. These attacks are hard to get working, and it’s not easy to exfiltrate useful data. There are way easier ways to attack systems.]]></content:encoded></item><item><title>Expert Generalists need specialists (and LLMs)</title><link>https://martinfowler.com/articles/expert-generalist.html#ExpertGeneralistsStillNeedSpecialists</link><author>Martin Fowler</author><category>dev</category><category>blog</category><pubDate>Tue, 1 Jul 2025 13:17:00 +0000</pubDate><source url="https://martinfowler.com/feed.atom">Martin Fowler</source><content:encoded><![CDATA[While we've spent this article praising the Expert Generalist, Unmesh,
      Gitanjali, and I simultaneously do not deny the value of specialist
      knowledge. To be the most efficient, a team needs some specialist skill.
      We've also observed that Expert Generalist capabilities are considerably
      more valuable when working with LLMs.]]></content:encoded></item><item><title>Iranian Blackout Affected Misinformation Campaigns</title><link>https://www.schneier.com/blog/archives/2025/07/iranian-blackout-affected-misinformation-campaigns.html</link><author>Bruce Schneier</author><category>infosec</category><category>blog</category><pubDate>Tue, 1 Jul 2025 11:07:51 +0000</pubDate><source url="https://www.schneier.com/">Schneider on Security</source><content:encoded><![CDATA[Dozens of accounts on X that promoted Scottish independence went dark during an internet blackout in Iran.Well, that’s one way to identify fake accounts and misinformation campaigns.]]></content:encoded></item><item><title>How Cybersecurity Fears Affect Confidence in Voting Systems</title><link>https://www.schneier.com/blog/archives/2025/06/cyberattacks-shake-voters-trust-in-elections.html</link><author>Bruce Schneier</author><category>infosec</category><category>blog</category><pubDate>Mon, 30 Jun 2025 11:05:36 +0000</pubDate><source url="https://www.schneier.com/">Schneider on Security</source><content:encoded><![CDATA[American democracy runs on trust, and that trust is cracking.Nearly half of Americans, both Democrats and Republicans, question whether elections are conducted fairly. Some voters accept election results only when their side wins. The problem isn’t just political polarization—it’s a creeping erosion of trust in the machinery of democracy itself.Commentators blame ideological tribalism, misinformation campaigns and partisan echo chambers for this crisis of trust. But these explanations miss a critical piece of the puzzle: a growing unease with the digital infrastructure that now underpins nearly every aspect of how Americans vote.The digital transformation of American elections has been swift and sweeping. Just two decades ago, most people voted using mechanical levers or punch cards. Today, over 95% of ballots are counted electronically. Digital systems have replaced poll books, taken over voter identity verification processes and are integrated into registration, counting, auditing and voting systems.This technological leap has made voting more accessible and efficient, and sometimes more secure. But these new systems are also more complex. And that complexity plays into the hands of those looking to undermine democracy.In recent years, authoritarian regimes have refined a chillingly effective strategy to chip away at Americans’ faith in democracy by relentlessly sowing doubt about the tools U.S. states use to conduct elections. It’s a sustained campaign to fracture civic faith and make Americans believe that democracy is rigged, especially when their side loses.This is not cyberwar in the traditional sense. There’s no evidence that anyone has managed to break into voting machines and alter votes. But cyberattacks on election systems don’t need to succeed to have an effect. Even a single failed intrusion, magnified by sensational headlines and political echo chambers, is enough to shake public trust. By feeding into existing anxiety about the complexity and opacity of digital systems, adversaries create fertile ground for disinformation and conspiracy theories.To test this dynamic, we launched a study to uncover precisely how cyberattacks corroded trust in the vote during the 2024 U.S. presidential race. We surveyed more than 3,000 voters before and after election day, testing them using a series of fictional but highly realistic breaking news reports depicting cyberattacks against critical infrastructure. We randomly assigned participants to watch different types of news reports: some depicting cyberattacks on election systems, others on unrelated infrastructure such as the power grid, and a third, neutral control group.The results, which are under peer review, were both striking and sobering. Mere exposure to reports of cyberattacks undermined trust in the electoral process—regardless of partisanship. Voters who supported the losing candidate experienced the greatest drop in trust, with two-thirds of Democratic voters showing heightened skepticism toward the election results.But winners too showed diminished confidence. Even though most Republican voters, buoyed by their victory, accepted the overall security of the election, the majority of those who viewed news reports about cyberattacks remained suspicious.The attacks didn’t even have to be related to the election. Even cyberattacks against critical infrastructure such as utilities had spillover effects. Voters seemed to extrapolate: “If the power grid can be hacked, why should I believe that voting machines are secure?”Strikingly, voters who used digital machines to cast their ballots were the most rattled. For this group of people, belief in the accuracy of the vote count fell by nearly twice as much as that of voters who cast their ballots by mail and who didn’t use any technology. Their firsthand experience with the sorts of systems being portrayed as vulnerable personalized the threat.It’s not hard to see why. When you’ve just used a touchscreen to vote, and then you see a news report about a digital system being breached, the leap in logic isn’t far.Our data suggests that in a digital society, perceptions of trust—and distrust—are fluid, contagious and easily activated. The cyber domain isn’t just about networks and code. It’s also about emotions: fear, vulnerability and uncertainty.Does this mean we should scrap electronic voting machines? Not necessarily.Every election system, digital or analog, has flaws. And in many respects, today’s high-tech systems have solved the problems of the past with voter-verifiable paper ballots. Modern voting machines reduce human error, increase accessibility and speed up the vote count. No one misses the hanging chads of 2000.But technology, no matter how advanced, cannot instill legitimacy on its own. It must be paired with something harder to code: public trust. In an environment where foreign adversaries amplify every flaw, cyberattacks can trigger spirals of suspicion. It is no longer enough for elections to be secure – voters must also perceive them to be secure.That’s why public education surrounding elections is now as vital to election security as firewalls and encrypted networks. It’s vital that voters understand how elections are run, how they’re protected and how failures are caught and corrected. Election officials, civil society groups and researchers can teach how audits work, host open-source verification demonstrations and ensure that high-tech electoral processes are comprehensible to voters.We believe this is an essential investment in democratic resilience. But it needs to be proactive, not reactive. By the time the doubt takes hold, it’s already too late.Just as crucially, we are convinced that it’s time to rethink the very nature of cyber threats. People often imagine them in military terms. But that framework misses the true power of these threats. The danger of cyberattacks is not only that they can destroy infrastructure or steal classified secrets, but that they chip away at societal cohesion, sow anxiety and fray citizens’ confidence in democratic institutions. These attacks erode the very idea of truth itself by making people doubt that anything can be trusted.If trust is the target, then we believe that elected officials should start to treat trust as a national asset: something to be built, renewed and defended. Because in the end, elections aren’t just about votes being counted—they’re about people believing that those votes count.And in that belief lies the true firewall of democracy.This essay was written with Ryan Shandler and Anthony J. DeMattee, and originally appeared in The Conversation.]]></content:encoded></item><item><title>The New Skill in AI is Not Prompting, It&apos;s Context Engineering</title><link>https://www.philschmid.de/context-engineering</link><author></author><category>dev</category><category>ai</category><category>blog</category><pubDate>Mon, 30 Jun 2025 00:00:00 +0000</pubDate><source url="https://www.philschmid.de/">Phil Shmid</source><content:encoded><![CDATA[Context Engineering is the new skill in AI. It is about providing the right information and tools, in the right format, at the right time.]]></content:encoded></item></channel></rss>