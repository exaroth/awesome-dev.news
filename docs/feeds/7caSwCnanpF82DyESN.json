{"id":"7caSwCnanpF82DyESN","title":"Official News","displayTitle":"Official News","url":"","feedLink":"","isQuery":true,"isEmpty":false,"isHidden":false,"itemCount":7,"items":[{"title":"GitHub Copilot Spaces: Bring the right context to every suggestion","url":"https://github.blog/ai-and-ml/github-copilot/github-copilot-spaces-bring-the-right-context-to-every-suggestion/","date":1750262400,"author":"Andrea Griffiths","guid":161288,"unread":true,"content":"<p>When generative AI tools guess what you need, the magic only lasts as long as the guesses are right. Add an unfamiliar codebase, a security checklist your team keeps in a wiki, or a one‑off Slack thread that explains  something matters, and even the most and even the most powerful model may fill in gaps with assumptions rather than having access to your specific context and knowledge.</p><p><a href=\"https://docs.github.com/en/copilot/using-github-copilot/copilot-spaces/creating-and-using-copilot-spaces\">GitHub Copilot Spaces</a> fixes that problem by letting you <strong>bundle the exact context Copilot should read</strong>—code, docs, transcripts, sample queries, you name it—into a reusable “space.” Once a space is created, every Copilot chat, completion, or command is grounded in that curated knowledge, producing answers that feel like they came from your organization’s resident expert instead of a generic model.<a href=\"https://docs.github.com/copilot/using-github-copilot/copilot-spaces/about-organizing-and-sharing-context-with-copilot-spaces?utm_source=chatgpt.com\"></a></p><p>In this article, we’ll walk through:</p><ul><li>A 5‑minute quick‑start guide to creating your first space</li><li>Tips for personalizing Copilot’s tone, style, and conventions with custom instructions</li><li>Real‑world recipes for accessibility, data queries, and onboarding</li><li>Collaboration, security, and what’s next on the roadmap (spoiler: IDE integration and Issues/PR support)</li></ul><h2>Why context is the new bottleneck for AI‑assisted development</h2><p>Large language models (LLMs) thrive on patterns, but day‑to‑day engineering work is full of patterned edge cases, including:</p><ul><li>A monorepo that mixes modern React with legacy jQuery</li><li>Organizational wisdom buried in Slack threads or internal wikis</li><li>Organization‑specific security guidelines that differ from upstream OSS docs</li></ul><p>Without that context, an AI assistant can only guess. But with Copilot Spaces, you choose which files, documents, or free‑text snippets matter, drop them into a space, and let Copilot use that context to answer questions or write code. As Kelly Henckel, PM for GitHub Spaces, said in our <a href=\"https://www.youtube.com/watch?v=a0LWEWLUt48\">GitHub Checkout</a> episode, “Spaces make it easy to organize and share context, so Copilot acts like a subject matter expert.” The result? Fewer wrong guesses, less copy-pasting, and code that’s commit-ready.</p><h2>What exactly  a Copilot Space?</h2><p>Think of a space as a secure, shareable  plus :</p><figure><table><thead><tr></tr></thead><tbody><tr><td>Code files, entire folders, Markdown docs, transcripts, or any plain text you add</td><td>Gives Copilot the ground truth for answers</td></tr><tr><td>Short system prompts to set tone, coding style, or reviewer expectations</td><td>Lets Copilot match your house rules</td></tr><tr><td>Follows the same role/visibility model you already use on GitHub</td><td>No new access control lists to manage</td></tr><tr><td>Files stay in sync with the branch you referenced</td><td>Your space stays up to date with your codebase</td></tr></tbody></table></figure><p>Spaces are available to <strong>anyone with a Copilot license (Free, Individual, Business, or Enterprise)</strong> while the feature is in public preview. Admins can enable it under <strong>Settings  &gt; Copilot &gt; Preview features</strong>.</p><p>: A space is like pinning your team’s  to the Copilot sidebar and letting everyone query it in plain language.</p><h2>Quick-start guide: How to build your first space in 5 minutes</h2><ol><li>. For example, .</li><li> so teammates know when——to use it.</li></ol><ul><li>From repos: Pull in folders like&nbsp; or individual files such as .</li><li>Free‑text hack: Paste a Slack thread, video transcript, onboarding checklist, or even a JSON schema into the  tab. Copilot treats it like any other attachment.</li></ul><ol start=\"5\"><li><strong>Write custom instructions</strong>. A sentence or two is enough:</li></ol><ul><li>“Respond as a senior React reviewer. Enforce our ESLint rules and tailwind class naming conventions.”</li></ul><ol start=\"6\"><li>. You’re done. Ask Copilot a question in the Space chat—e.g., “Refactor this  component to match our accessibility checklist”—and watch it cite files you just attached.</li></ol><h2>Personalize Copilot’s coding style (and voice, too)&nbsp;</h2><p>Custom instructions are the “personality layer” of a space and where spaces shine because they live  the attachments. This allows you to do powerful things with a single sentence, including:</p><ul><li><ul><li>&nbsp;“Always prefer Vue 3  syntax and Composition API for examples.”</li></ul></li><li><ul><li>“Answer concisely. Include a one‑line summary before code blocks.”</li></ul></li><li><strong>Teach Copilot project‑specific vocabulary</strong><ul><li>&nbsp;“Call it ‘scenario ID’ (SCID), not test case ID.”</li></ul></li></ul><p>During the GitHub Checkout interview, Kelly shared how she built a personal space for a nonprofit side project: She attached only the Vue front‑end folder  instructions on her preferred conventions, and Copilot delivered commit‑ready code snippets that matched her style guide on the first try.</p><h2>Automate your workflow: three real‑world recipes</h2><ul><li>Markdown docs on WCAG criteria and GitHub’s internal “Definition of Done”</li><li>Custom instruction: “When answering, cite the doc section and provide a code diff if changes are required.”</li></ul><p>: Instead of pinging the accessibility lead on Slack, you can use Spaces to ask questions like “What steps are needed for MAS‑C compliance on this new modal?” Copilot summarizes the relevant checkpoints, references the doc anchor, and even suggests ARIA attributes or color‑contrast fixes. GitHub’s own accessibility SME, Katherine, pinned this space in Slack so anyone filing a review gets instant, self‑service guidance.</p><ul><li>YAML schema files for 40+ event tables</li><li>Example KQL snippets saved as  files</li><li>Instruction: “Generate KQL only, no prose explanations unless asked.”</li></ul><p>Product managers and support engineers who  know your database structures can ask, “Average PR review time last 7 days?” Copilot autocompletes a valid KQL query with correct joins and lets them iterate. Result: lets PMs and support self-serve without bugging data science teams.</p><h3>3. Onboarding Hub and knowledge base in one link</h3><ul><li>Key architecture diagrams exported as SVG text</li><li>ADRs and design docs from multiple repos</li><li>Custom instruction: “Answer like a mentor during onboarding; link to deeper docs.”</li></ul><p>New hires type “How does our auth flow handle SAML?” and get a structured answer with links and diagrams, all without leaving GitHub. Because spaces stay in sync with , updates to ADRs propagate automatically—no stale wikis.</p><h2>Collaboration that feels native to GitHub</h2><p>Spaces respect the same permission model you already use:</p><ul><li>: visible only to you unless shared</li><li><strong>Organization‑owned spaces</strong>: use repo or team permissions to gate access</li><li><strong>Read‑only vs. edit‑capable</strong>: let SMEs maintain the canon while everyone else consumes</li></ul><p>Sharing is as simple as sending the space URL or pinning it to a repo README. Anyone with access and a Copilot license can start chatting instantly.</p><h2>What’s next for Copilot Spaces?</h2><p>We’re working to bring Copilot Spaces to more of your workflows, and are currently developing:</p><ul><li><strong>Issues and PR attachments</strong> to bring inline discussions and review notes into the same context bundle.</li><li>: Query Spaces in VS Code for tasks like writing tests to match your team’s patterns.</li><li> to help you browse spaces like you browse repos today, so new engineers can search “Payments SME” and start chatting.</li></ul><p>Head to <strong>github.com/copilot/spaces</strong>, spin up your first space, and let us know how it streamlines your workflow. Here’s how to get it fully set up on your end:&nbsp;</p><ol><li>: <em>Settings &gt; Copilot  &gt;  Preview features &gt; Enable Copilot Spaces.</em></li><li><strong>Create one small, high‑impact space</strong>—maybe your team’s code‑review checklist or a set of common data queries.</li><li> in Slack or a README and watch the pings to subject‑matter experts drop.</li><li>: prune unused attachments, refine instructions, or split a giant space into smaller ones.</li></ol><p>Copilot Spaces is free during the public preview and doesn’t count against your Copilot seat entitlements when you use the base model. We can’t wait to see what you build when Copilot has the  context at its fingertips.</p>","contentLength":7510,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Python 3.14.0 beta 3 is here!","url":"https://pythoninsider.blogspot.com/2025/06/python-3140-beta-3-is-here.html","date":1750185780,"author":"Hugo","guid":159835,"unread":true,"content":"<p><strong>This is a beta preview of Python 3.14</strong></p><p>Python 3.14 is still in development. This release, 3.14.0b3, is the\nthird of four planned beta releases.</p><p>Beta release previews are intended to give the wider community the\nopportunity to test new features and bug fixes and to prepare their\nprojects to support the new feature release.</p><p>We  maintainers of\nthird-party Python projects to \nduring the beta phase and report issues found to <a href=\"https://github.com/python/cpython/issues\">the Python bug\ntracker</a> as soon as possible. While the release is planned to be\nfeature-complete entering the beta phase, it is possible that features\nmay be modified or, in rare cases, deleted up until the start of the\nrelease candidate phase (Tuesday 2025-07-22). Our goal is to have\n after beta 4 and as few code\nchanges as possible after the first release candidate. To achieve that,\nit will be  to get as much\nexposure for 3.14 as possible during the beta phase.</p><p>This includes creating pre-release wheels for 3.14, as it helps other\nprojects to do their own testing. However, we recommend that your\nregular production releases wait until 3.14.0rc1, to avoid the risk of\nABI breaks.</p><p>Please keep in mind that this is a preview release and its use is\n recommended for production\nenvironments.</p><p>Some of the major new features and changes in Python 3.14 are:</p><p><em>Note that PEPs <a href=\"https://discuss.python.org/t/pep-734-multiple-interpreters-in-the-stdlib/41147/36\">734</a>\nand <a href=\"https://discuss.python.org/t/pep-779-criteria-for-supported-status-for-free-threaded-python/84319/123\">779</a>\nare exceptionally new in beta 3!</em></p><p><small>(Hey,  if a feature you\nfind important is missing from this list, let Hugo know.)</small></p><p>For more details on the changes to Python 3.14, see <a href=\"https://docs.python.org/3.14/whatsnew/3.14.html\">What’s new in\nPython 3.14</a>. The next pre-release of Python 3.14 will be the final\nbeta, 3.14.0b4, scheduled for 2025-07-08.</p><ul><li><a href=\"https://docs.python.org/3.14/whatsnew/3.14.html#whatsnew314-pep761\">PEP\n761</a>: Python 3.14 and onwards no longer provides PGP signatures for\nrelease artifacts. Instead, Sigstore is recommended for verifiers.</li></ul><p>The installer we offer for Windows is being replaced by our new\ninstall manager, which can be installed from <a href=\"https://apps.microsoft.com/detail/9NQ7512CXL7T\">the Windows\nStore</a> or <a href=\"https://www.python.org/ftp/python/pymanager/\">our\nFTP page</a>. See <a href=\"https://docs.python.org/3.14/using/windows.html\">our\ndocumentation</a> for more information. The JSON file available for\ndownload below contains the list of all the installable packages\navailable as part of this release, including file URLs and hashes, but\nis not required to install the latest release. The traditional installer\nwill remain available throughout the 3.14 and 3.15 releases.</p><p>Thanks to all of the many volunteers who help make Python Development\nand these releases possible! Please consider supporting our efforts by\nvolunteering yourself or through organisation contributions to the <a href=\"https://www.python.org/psf-landing/\">Python Software\nFoundation</a>.</p><p>Regards from sunny Helsinki with 19 hours of daylight,</p><p>Your release team, \n  Hugo van Kemenade\n  Steve Dower\n  </p>","contentLength":2556,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"5 tips for using GitHub Copilot with issues to boost your productivity","url":"https://github.blog/ai-and-ml/github-copilot/5-tips-for-using-github-copilot-with-issues-to-boost-your-productivity/","date":1750176000,"author":"Klint Finley","guid":159765,"unread":true,"content":"<p>Managing issues in software development can be tedious and time-consuming. But what if your AI peer programmer could streamline this process for you? <a href=\"https://github.com/features/copilot\">GitHub Copilot</a>‘s latest issue management features can help developers create, organize, and even solve issues. Below, we’ll dig into these features and how they can save time, reduce friction, and maintain consistency across your projects.</p><h2>1. Image to issue: Turn screenshots into instant bug reports</h2><p>Writing detailed bug reports is often repetitive and frustrating, leading to inconsistent documentation. Copilot’s image to issue feature significantly reduces this friction.</p><p>Simply paste a screenshot of the bug into Copilot chat with a brief description prompt Copilot to create an issue for you, then Copilot will analyze the image and generate a comprehensive bug report for you. No more struggling to describe visual glitches or UI problems—the image will speak for itself, and Copilot will handle the documentation.</p><p>For example, if you encounter a UI alignment issue or a visual glitch that’s hard to describe, just capture a screenshot, paste it into Copilot, and briefly mention the problem. In the animation above, the user’s prompt was “create me a bug issue because markdown tables are not rendering properly in the comments.” Copilot then automatically drafted a report, including steps to reproduce the bug.</p><p>To get the most out of this feature, consider annotating your screenshots clearly—highlighting or circling the problematic area—to help Copilot generate even more precise issue descriptions.</p><p>Projects quickly become disorganized when team members skip adding proper metadata. Incorrect templates, missing labels, or wrong issue types make tracking and prioritization difficult.</p><p>Copilot solves this by automatically inferring the best template based on your prompt. It also adds appropriate labels and issue types without requiring you to navigate multiple dropdown menus or memorize tagging conventions.</p><p>Need something specific? Simply ask Copilot to add particular labels or switch templates. If you change templates after drafting, Copilot will automatically reformat your content—no manual copying required.</p><h2>3. Stay organized with versioning and milestones</h2><p>Keeping issues updated and properly categorized is crucial for clear communication, maintaining project velocity, and ensuring visibility into progress. But with so much else to do, it’s easy to let this work fall by the wayside.</p><p>With Copilot, adding projects and milestones is as simple as typing a prompt. You can also specify exactly how you want issues organized. For example, ask Copilot to use the “Bug Report” or “Feature Request” template, add labels like , , or , or set the issue type to “Task” or “Epic.” Copilot will apply these details automatically, ensuring your issues are consistently categorized.</p><p>Additionally, Copilot tracks all changes, making them easily referenceable. You can review issue history and revert changes if needed, ensuring nothing important gets lost.</p><h2>4. Batch create multiple issues at once</h2><p>Sometimes you need to log several issues after a customer meeting, user testing session, or bug bash. Traditionally, this means repeating the same creation process multiple times.</p><p>Copilot supports multi-issue drafting, allowing you to create multiple issues in a single conversation. Whether logging feature requests or documenting bugs, batch creation saves significant time.</p><p>Simply prompt Copilot to create the issues, describe each one, and Copilot will draft them all. For example, you could give the following prompt to create two issues at once:</p><pre><code>Create me issues for the following features:\n- Line breaks ignored in rendered Markdown despite double-space\n- Bold and italic Markdown styles not applied when combined</code></pre><p>You will still need to review and finalize each one, but the drafting process is streamlined into a single workflow.</p><h2>5. Let AI help fix your bugs with Copilot coding agent</h2><p><a href=\"https://github.blog/developer-skills/github/how-to-create-issues-and-pull-requests-in-record-time-on-github/\">Creating issues</a> is only half the battle—fixing them is where the real work begins. You can now <a href=\"https://github.blog/ai-and-ml/github-copilot/assigning-and-completing-issues-with-coding-agent-in-github-copilot/\">assign issues</a> directly to Copilot. Just ask <a href=\"https://docs.github.com/en/copilot/using-github-copilot/coding-agent/enabling-copilot-coding-agent\">Copilot coding agent</a> to take ownership of the issue, and your AI coding assistant will start analyzing the bug. Copilot can even suggest draft pull requests with potential fixes.</p><p>This seamless handoff reduces context-switching and accelerates resolution times, allowing your team to focus on more complex challenges.</p><h2>Beyond Copilot: Issues enhancements on GitHub</h2><p>While Copilot is already revolutionizing issue management, we at GitHub are always looking for ways to enhance the overall issues experience. For example, you can now:</p><ul><li>Standardize <a href=\"https://docs.github.com/en/issues/tracking-your-work-with-issues/configuring-issues/managing-issue-types-in-an-organization\">issue types</a> across repositories for consistent tracking and reporting.</li><li>Break down complex tasks into <a href=\"https://docs.github.com/en/issues/tracking-your-work-with-issues/using-issues/adding-sub-issues\">sub-issues</a> for better progress management.</li><li>Use <a href=\"https://docs.github.com/en/issues/tracking-your-work-with-issues/using-issues/filtering-and-searching-issues-and-pull-requests#building-advanced-filters-for-issues\">advanced search</a> capabilities with logical operators to quickly find exactly what you need.</li><li>Manage larger projects with expanded limits supporting up to 50,000 items.</li></ul><h2>Kickstart enhanced issue management today</h2><p>Ready to transform your issue management workflow with GitHub Copilot? Head to <a href=\"https://github.com/copilot\">github.com/copilot</a> and try prompts like:</p><ul><li>“Create me an issue for…”</li><li>Or simply upload a screenshot and mention you want to file a bug.</li></ul><p>Experience firsthand how Copilot makes issue management feel less like administrative overhead and more like a conversation with your AI pair programmer.</p>","contentLength":5370,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Python 201 – All About the TypedDict","url":"https://www.blog.pythonlibrary.org/2025/06/17/python-201-all-about-the-typeddict/","date":1750166753,"author":"Mike","guid":159668,"unread":true,"content":"<p>Python has supported the concept of type hinting for quite a while now. However, unlike other programming languages, Python does not enforce type hints. You must use an external tool, such as Mypy, for that.</p><p>In this tutorial, you will learn all about <a href=\"https://peps.python.org/pep-0589/\"></a>, a special way of adding type hinting to <strong>Heterogeneous dictionaries</strong>. A heterogeneous dictionary is a dictionary that has values that are not all the same type.</p><p>But before you learn how to use the TypedDict, you should review how to type hint a regular dictionary.</p><h2>Type Hinting a Regular Dictionary</h2><p>A regular Python dictionary is defined as follows:</p><pre data-enlighter-language=\"python\">my_dictionary = {\"some_key\": \"some_value\"}</pre><p>You can use any hashable type for the key, such as a string or an integer. The value of a dictionary can be any type whatsoever.</p><p>When you want to type hint a dictionary, you would use the following: <strong>dict[key_type, value_type]</strong></p><p>Now let’s apply that to the example above:</p><pre data-enlighter-language=\"python\">my_dictionary: dict[str, str]&nbsp;=&nbsp;{\"some_key\":&nbsp;\"some_value\"}</pre><p>If you are using a version of Python before 3.9, you will need to do the following instead:</p><pre data-enlighter-language=\"python\">from typing import Dict\n\nmy_dictionary: Dict[str, str] = {\"some_key\": \"some_value\"}</pre><p>Fortunately, modern Python no longer requires that extra import.</p><p>Now you’re ready to learn about how and why you might want to use the TypedDict</p><p>The TypedDict was introduced to Python in 3.8. You can read the full details about it in <a href=\"https://peps.python.org/pep-0589/\">PEP 589</a>. The reason you would use a TypedDict over a regular dictionary is when you have a dictionary with values of different types.</p><pre data-enlighter-language=\"python\">my_dictionary = {\"names\": [\"Mike\", \"Andrea\", \"John\"],\n                 \"type\": \"employee\",\n                 \"code\": 123456\n                }</pre><p>Type hinting this type of dictionary is more complex. You can do something like this, though:</p><pre data-enlighter-language=\"python\">my_dictionary: dict[str, list | str | int] = {\"names\": [\"Mike\", \"Andrea\", \"John\"], \"otype\": \"employee\", \"code\": 123456 }</pre><p>Depending on how your type checker is configured, this might work. However, if you write code that modifies the list, your type checker may complain that a string doesn’t have an append method or vice versa.</p><p>To make the type checker happier, you should use a .</p><p>Here’s how you would use one with this example:</p><pre data-enlighter-language=\"generic\">from typing import TypedDict\n\nclass MultiTypeDict(TypedDict):\n    names: list\n    otype: str\n    code: int\n\nmy_dictionary: MultiTypeDict = {\"names\": [\"Mike\", \"Andrea\", \"John\"], \"otype\": \"employee\", \"code\": 123456 }</pre><p>Isn’t that great? There’s just one problem. What if your dictionary’s keys have spaces in them? You cannot create class attributes with spaces!</p><p>There’s a workaround for that. Check it out in the next section.</p><h2>Creating a TypedDict with Keys that Have Spaces</h2><p>For this example, you will create a new dictionary with four keys, three of which contain spaces.</p><p>To make a TypedDict for this type of dictionary, you need to call the TypedDict constructor instead of subclassing it:</p><pre data-enlighter-language=\"python\">from typing import TypedDict\n\nResults = TypedDict(\"Results\",{\"Animal Habitats\": list,\n                               \"Tested\": bool,\n                               \"Animal Name\": str,\n                               \"Animal Location\": str})\n\nactual_results: Results = {\n    \"Animal Habitats\": [\"Asia\", \"N. America\"],\n    \"Tested\": False,\n    \"Animal Name\": \"Tigris\",\n    \"Animal Location\": \"North Bay\",\n}</pre><p>When you call TypedDict, you pass in the typename (what you would have named the class) and the fields the dictionary should have. You’ll note that the fields are a dictionary. This is where you will put the keys that contain spaces and those without spaces.</p><p>Give it a try and you’ll find it works great!</p><p> is a handy tool for storing a complex dictionary. You will find that sometimes you even have these complex dictionaries inside of lists, tuples or even other dictionaries. Using the TypedDict can make type-hinting these data structures easier and prevent hard-to-detect defects from creeping in.</p>","contentLength":3868,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Highlights from Git 2.50","url":"https://github.blog/open-source/git/highlights-from-git-2-50/","date":1750093947,"author":"Taylor Blau","guid":157485,"unread":true,"content":"<p>The open source Git project just <a href=\"https://lore.kernel.org/git/xmqq1prj1umb.fsf@gitster.g/T/#u\">released Git 2.50</a> with features and bug fixes from 98 contributors, 35 of them new. We last caught up with you on the latest in Git back when <a href=\"https://github.blog/open-source/git/highlights-from-git-2-49/\">2.49 was released</a>.</p><figure><table><tbody><tr><td>💡 Before we get into the details of this latest release, we wanted to remind you that <a href=\"https://git-merge.com\">Git Merge</a>, the conference for Git users and developers is back this year on September 29-30, in San Francisco. Git Merge will feature talks from developers working on Git, and in the Git ecosystem. Tickets are on sale now; check out <a href=\"https://git-merge.com\">the website</a> to learn more.</td></tr></tbody></table></figure><p>With that out of the way, let’s take a look at some of the most interesting features and changes from Git 2.50.</p><h2>Improvements for multiple cruft packs</h2><p>When we covered <a href=\"https://github.blog/open-source/git/highlights-from-git-2-43/#multiple-cruft-packs\">Git 2.43</a>, we talked about newly added support for <a href=\"https://github.blog/open-source/git/highlights-from-git-2-43/#multiple-cruft-packs\">multiple cruft packs</a>. Git 2.50 improves on that with better command-line ergonomics, and some important bugfixes. In case you’re new to the series, need a refresher, or aren’t familiar with <a href=\"https://github.blog/2022-09-13-scaling-gits-garbage-collection/\">cruft packs</a>, here’s a brief overview:</p><p>Git <a href=\"https://git-scm.com/book/en/v2/Git-Internals-Git-Objects\">objects</a> may be either reachable or unreachable. The set of reachable objects is everything you can walk to starting from one of your repository’s <a href=\"https://git-scm.com/book/en/v2/Git-Internals-Git-References\">references</a>: traversing from commits to their parent(s), trees to their sub-tree(s), and so on. Any object that you didn’t visit by repeating that process over all of your references is unreachable.</p><p>In <a href=\"https://github.blog/open-source/git/highlights-from-git-2-37/\">Git 2.37</a>, Git introduced <a href=\"https://git-scm.com/docs/cruft-packs/2.37.0\">cruft packs</a>, a new way to store your repository’s unreachable objects. A cruft pack looks like an ordinary <a href=\"https://git-scm.com/book/en/v2/Git-Internals-Packfiles\">packfile</a> with the addition of an  file, which is used to keep track of when each object was most recently written in order to determine when it is safe to discard it.</p><p>However, updating the cruft pack could be cumbersome–particularly in repositories with many unreachable objects–since a repository’s cruft pack must be rewritten in order to add new objects. Git 2.43 began to address this through a new command-line option: <code>git repack --max-cruft-size</code>. This option was designed to split unreachable objects across multiple packs, each no larger than the value specified by . But there were a couple of problems:</p><ul><li>If you’re familiar with ’s  option, ’s behavior is quite confusing. The former option specifies the maximum size an individual pack can be, while the latter involves how and when to move objects between multiple packs.</li><li>The feature was broken to begin with! Since  imposes on cruft packs the same pack-size constraints as  does on non-cruft packs, it is often impossible to get the behavior you want.</li></ul><p>For example, suppose you had two 100 MiB cruft packs and ran <code>git repack --max-cruft-size=200M</code>. You might expect Git to merge them into a single 200 MiB pack. But since  also dictates the maximum size of the output pack, Git will refuse to combine them, or worse: rewrite the same pack repeatedly.</p><p>Git 2.50 addresses both of these issues with a new option: <code>--combine-cruft-below-size</code>. Instead of specifying the maximum size of the output pack, it determines which existing cruft pack(s) are eligible to be combined. This is particularly helpful for repositories that have accumulated many unreachable objects spread across multiple cruft packs. With this new option, you can gradually reduce the number of cruft packs in your repository over time by combining existing ones together.</p><p>With the introduction of <code>--combine-cruft-below-size</code>, Git 2.50 repurposed  to behave as a cruft pack-specific override for . Now  only determines the size of the outgoing pack, not which packs get combined into it.</p><p>Along the way, a bug was uncovered that prevented objects stored in multiple cruft packs from being “freshened” in <a href=\"https://lore.kernel.org/git/c0c926adde2b7c8f4b53b7a274d5b8c040f77e62.1740680964.git.me@ttaylorr.com/\">certain circumstances</a>. In other words, some unreachable objects don’t have their modification times updated when they are rewritten, leading to them being removed from the repository earlier than they otherwise would have been. Git 2.50 squashes this bug, meaning that you can now efficiently manage multiple cruft packs and freshen their objects to your heart’s content.</p><h2>Incremental multi-pack reachability bitmaps</h2><p>Multi-pack indexes are extremely useful to accelerate object lookup performance in large repositories by binary searching through a single index containing most of your repository’s contents, rather than repeatedly searching through each individual packfile. But multi-pack indexes aren’t just useful for accelerating object lookups. They’re also the basis for multi-pack reachability bitmaps, the MIDX-specific analogue of classic single-pack reachability bitmaps. If neither of those are familiar to you, don’t worry; here’s a brief refresher. Single-pack <a href=\"https://git-scm.com/docs/bitmap-format/2.50.0\">reachability bitmaps</a> store a collection of <a href=\"https://en.wikipedia.org/wiki/Bit_array\">bitmaps</a> corresponding to a selection of commits. Each bit position in a pack bitmap refers to one object in that pack. In each individual commit’s bitmap, the set bits correspond to objects that are reachable from that commit, and the unset bits represent those that are not.</p><p>Multi-pack bitmaps were introduced to take advantage of the substantial performance increase afforded to us by reachability bitmaps. Instead of having bitmaps whose bit positions correspond to the set of objects in a single pack, a multi-pack bitmap’s bit positions correspond to the set of objects in a multi-pack index, which may include objects from arbitrarily many individual packs. If you’re curious to learn more about how multi-pack bitmaps work, you can read our earlier post <a href=\"https://github.blog/2021-04-29-scaling-monorepo-maintenance/\"><em>Scaling monorepo maintenance</em></a>.</p><p>However, like cruft packs above, multi-pack indexes can be cumbersome to update as your repository grows larger, since each update requires rewriting the entire multi-pack index and its corresponding bitmap, regardless of how many objects or packs are being added. In Git 2.47, the file format for multi-pack indexes became incremental, allowing multiple multi-pack index layers to be layered on top of one another forming a chain of MIDXs. This made it much easier to add objects to your repository’s MIDX, but the incremental MIDX format at the time did not yet have support for multi-pack bitmaps.</p><p>Git 2.50 brings support for the multi-pack reachability format to incremental MIDX chains, with each MIDX layer having its own  file. These bitmap layers can be used in conjunction with one another to provide reachability information about selected commits at any layer of the MIDX chain. In effect, this allows extremely large repositories to quickly and efficiently add new reachability bitmaps as new commits are pushed to the repository, regardless of how large the repository is.</p><p>This feature is still considered highly experimental, and support for repacking objects into incremental multi-pack indexes and bitmaps is still fairly bare-bones. This is an active area of development, so we’ll make sure to cover any notable developments to incremental multi-pack reachability bitmaps in this series in the future.</p><h2>The  merge engine replaces </h2><p>This release also saw some exciting updates related to merging. Way back when Git 2.33 was released, we talked about a new merge engine called “ORT” (standing for “Ostensibly Recursive’s Twin”).</p><p>ORT is a from-scratch rewrite of Git’s old merging engine, called “recursive.” ORT is significantly faster, more maintainable, and has many new features that were difficult to implement on top of its predecessor.</p><p>One of those features is the ability for Git to determine whether or not two things are mergeable without actually persisting any new objects necessary to construct the merge in the repository. Previously, the only way to tell whether two things are mergeable was to run <code>git merge-tree --write-tree</code> on them. That works, but in this example  wrote any new objects generated by the merge into the repository. Over time, these can accumulate and cause performance issues. In Git 2.50, you can make the same determination without writing any new objects by using ’s new  mode and relying on its exit code.</p><p>Most excitingly in this release is that ORT has entirely superseded recursive, and recursive is no longer part of Git’s source code. When ORT was first introduced, it was only accessible through ’s  option to select a strategy. In Git 2.34, ORT became <a href=\"http://recursive\">the default choice</a> over , though the latter was still available in case there were bugs or behavior differences between the two. Now, 16 versions and two and a half years later, recursive has been completely removed from Git, with its author, Elijah Newren, <a href=\"https://lore.kernel.org/git/pull.1898.git.1743436279.gitgitgadget@gmail.com/\">writing</a>:</p><blockquote><p>As a wise man once told me, “Deleted code is debugged code!”</p></blockquote><p>As of Git 2.50, recursive has been completely  deleted. For more about ORT’s internals and its development, check out this five part series from Elijah <a href=\"https://blog.palantir.com/optimizing-gits-merge-machinery-1-127ceb0ef2a1\">here</a>, <a href=\"https://blog.palantir.com/optimizing-gits-merge-machinery-2-d81391b97878\">here</a>, <a href=\"https://blog.palantir.com/optimizing-gits-merge-machinery-3-2dc7c7436978\">here</a>, <a href=\"https://blog.palantir.com/optimizing-gits-merge-machinery-part-iv-5bbc4703d050\">here</a>, and <a href=\"https://blog.palantir.com/optimizing-gits-merge-machinery-part-v-46ff3710633e\">here</a>.</p><ul><li><p>If you’ve ever scripted around your repository’s objects, you are likely familiar with , Git’s purpose-built tool to list objects and print their contents.  has many modes, like  (for printing out the contents of objects), or  (for printing out certain information about objects without printing their contents).</p><p>Oftentimes it is useful to dump the set of all objects of a certain type in your repository. For commits,  can easily enumerate a set of commits. But what about, say, trees? In the past, to filter down to just the tree objects from a list of objects, you might have written something like:</p><pre>$ git cat-file --batch-check='%(objecttype) %(objectname)' \\&nbsp; &nbsp; --buffer &lt;in | perl -ne 'print \"$1\\n\" if /^tree ([0-9a-f]+)/'</pre>Git 2.50 brings Git’s object filtering mechanism used in partial clones to , so the above can be rewritten a little more concisely like:<pre>$ git cat-file --batch-check='%(objectname)' --filter='object:type=tree' &lt;in</pre></li><li>While we’re on the topic, let’s discuss a little-known  command-line option: . This arcane option was used with objects that have a type other than , , , or . This is a quirk dating back a little more than <a href=\"https://github.com/git/git/compare/13f4f046929de00a8c16171c5e08cdcae887b54d...5ba9a93b39bef057be54ecf7933386a582981625\">a decade ago</a> that allows  to write objects with arbitrary types. In the time since, this feature has gotten very little use. In fact, <code>git cat-file -p --allow-unknown-type</code> can’t even print out the contents of one of these objects!\n\n<pre>$ oid=\"$(git hash-object -w -t notatype --literally /dev/null)\"\n$ git cat-file -p $oid\nfatal: invalid object type\n</pre><p>This release makes the  option silently do nothing, and removes support from git hash-object to write objects with unknown types in the first place.</p></li><li><p>The  command learned a number of new tricks this release as well. It can now perform a few new different kinds of tasks, like , , and .  mirrors ’s functionality to remove stale or broken Git <a href=\"https://git-scm.com/docs/git-worktree/2.50.0\">worktrees</a>.  also mirrors existing functionality exposed via&nbsp; to expire old  entries from previously recorded <a href=\"https://git-scm.com/docs/git-rerere/2.50.0\">merge conflict resolutions</a>. Finally,  can be used to remove stale unreachable objects from out of the <a href=\"https://git-scm.com/docs/git-reflog/2.50.0\">reflog</a>.</p><p> also ships with new configuration for the existing  task. This task removes lingering loose objects that have since been packed away, and then makes new pack(s) for any loose objects that remain. The size of those packs was previously fixed at a maximum of 50,000, and can now be configured by the <code>maintenance.loose-objects.batchSize</code> configuration.</p></li><li><p>If you’ve ever needed to recover some work you lost, you may be familiar with Git’s <a href=\"https://git-scm.com/docs/git-reflog/2.50.0\">reflog</a> feature, which allows you to track changes to a reference over time. For example, you can go back and revisit earlier versions of your repository’s main branch by doing  (to show  prior to the two most recent updates) or  (to show where your copy of the branch was at a week ago).</p><p>Reflog entries can accumulate over time, and you can reach for  in the event you need to clean them up. But how do you delete the entirety of a branch’s reflog? If you’re not yet running Git 2.50 and thought “surely it’s ”, you’d be wrong! Prior to Git 2.50, the only way to delete a branch’s entire reflog was to do <code>git reflog expire $BRANCH --expire=all</code>.</p><p>In Git 2.50, a new  sub-command was introduced, so you can accomplish the same as above with the much more natural <code>git reflog delete $BRANCH</code>.</p></li><li><p>Speaking of references, Git 2.50 also received some attention to how references are processed and used throughout its codebase. When using the low-level  command, Git used to spend time checking whether or not the proposed refname could also be a valid object ID, making its lookups ambiguous. Since  is such a low-level command, this check is no longer done, delivering some performance benefits to higher-level commands that rely on  for their functionality.</p><p>Git 2.50 also learned how to cache whether or not any prefix of a proposed reference name already exists (for example, you can’t create a reference  if either  or  already exists).</p><p>Finally, in order to make those checks, Git used to create a new reference iterator for each individual prefix. Git 2.50’s reference backends learned how to “seek” existing iterators, saving time by being able to reuse the same iterator when checking each possible prefix.</p></li><li><p>If you’ve ever had to tinker with Git’s low-level <a href=\"https://curl.se/\">curl</a> configuration, you may be familiar with Git’s <a href=\"https://git-scm.com/docs/git-config/2.49.0#Documentation/git-config.txt-httplowSpeedLimithttplowSpeedTime\">configuration options</a> for tuning HTTP connections, like  and  which are used to terminate an HTTP connection that is transferring data too slowly.</p><p>These options can be useful when fine-tuning Git to work in complex networking environments. But what if you want to tweak Git’s <a href=\"https://en.wikipedia.org/wiki/Keepalive#TCP_keepalive\">TCP Keepalive</a> behavior? This can be useful to control when and how often to send keepalive probes, as well as how many to send, before terminating a connection that hasn’t sent data recently.</p><p>Prior to Git 2.50, this wasn’t possible, but this version introduces three new configuration options: , , and  which can be used to control the fine-grained behavior of curl’s TCP probing (provided your operating system supports it).</p></li><li><p>Git is famously portable and runs on a wide variety of operating systems and environments with very few dependencies. Over the years, various parts of Git have been written in Perl, including some commands like <a href=\"https://github.com/git/git/blob/5cde71d64aff03d305099b4d239552679ecfaab6/git-add--interactive.perl\">the original implementation</a> of  . These days, very few remaining Git commands are written in Perl.</p><p>This version reduces Git’s usage of Perl by removing it as a dependency of the test suite and documentation toolchain. Many Perl one-liners from Git’s test suite were rewritten to use other Shell functions or builtins, and some were rewritten as tiny C programs. For the handful of remaining hard dependencies on Perl, those tests will be skipped on systems that don’t have a working Perl.</p></li><li><p>This release also shipped a minor cosmetic update to . When starting a rebase, your  might appear with contents that look something like:\n</p><pre>pick c108101daa foo\npick d2a0730acf bar\npick e5291f9231 baz\n</pre><p>You can edit that list to , , or  (among many others), and Git will happily execute your rebase. But if you change the commit message in your rebase’s TODO script, they won’t actually change!</p><p>That’s because the commit messages shown in the TODO script are just meant to help you identify which commits you’re rebasing. (If you want to rewrite any commit messages along the way, you can use the  command instead). To clarify that these messages are cosmetic, Git will now prefix them with a  comment character like so:\n</p><pre>pick c108101daa # foo\npick d2a0730acf # bar\npick e5291f9231 # baz\n</pre></li><li><p>Long time readers of this series will recall <a href=\"https://github.blog/open-source/git/highlights-from-git-2-36/\">our coverage</a> of Git’s <a href=\"https://git-scm.com/book/en/v2/Git-Tools-Bundling\">feature</a> (when Git added support for partial bundles), though we haven’t covered Git’s <a href=\"https://git-scm.com/docs/bundle-uri/2.50.0\">feature</a>. Git bundles are a way to package your repositories contents: both its objects and the references that point at them into a single  file.</p><p>While Git has had support for bundles since as early as <a href=\"https://github.com/git/git/compare/1db8b60b2a6ef0cc0f7cc7d0783b7cda2ce894ca...64d99e9c5a4a3fb35d803894992764a6e288de5d\">v1.5.1</a> (nearly 18 years ago!), its  feature is <a href=\"https://github.com/git/git/compare/83937e9592832408670da38bfe6e96c90ad63521...89c6e450fe4a919ecb6fa698005a935531c732cf\">much newer</a>. In short, the  feature allows a server to serve part of a clone by first directing the client to download a  file. After the client does so, it will try to perform a fill-in fetch to gather any missing data advertised by the server but not part of the bundle.</p><p>To speed up this fill-in fetch, your Git client will advertise any references that it picked up from the  itself. But in previous versions of Git, this could sometimes result in  clones overall! That’s because up until Git 2.50, Git would only advertise the branches in  when asking the server to send the remaining set of objects.</p><p>Git 2.50 now includes advertises all references it knows about from the  when doing a fill-in fetch on the server, making -enabled clones much faster.</p><p>For more details about these changes, you can check out <a href=\"https://blog.gitbutler.com/going-down-the-rabbit-hole-of-gits-new-bundle-uri/\">this blog post</a> from Scott Chacon.</p></li><li><p>Last but not least,  (and ) now work much more smoothly in <a href=\"https://github.blog/open-source/git/bring-your-monorepo-down-to-size-with-sparse-checkout/\">sparse checkouts</a> by no longer having to expand the <a href=\"https://github.blog/open-source/git/make-your-monorepo-feel-small-with-gits-sparse-index/\">sparse index</a>. This follows in a long line of work that has been gradually adding sparse-index compatibility to Git commands that interact with the index.</p><p>Now you can interactively stage parts of your changes before committing in a sparse checkout without having to wait for Git to populate the sparsified parts of your repository’s index. Give it a whirl on your local sparse checkout today!</p></li></ul>","contentLength":16962,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Rust compiler performance survey 2025","url":"https://blog.rust-lang.org/2025/06/16/rust-compiler-performance-survey-2025/","date":1750032000,"author":"Jakub Beránek","guid":157306,"unread":true,"content":"<p>Long compile times of Rust code are frequently being cited as one of the biggest <a href=\"https://blog.rust-lang.org/2025/02/13/2024-State-Of-Rust-Survey-results/#challenges\">challenges</a> limiting the productivity of Rust developers. Rust compiler contributors are of course aware of that, and they are continuously working to improve the situation, by finding <a href=\"https://nnethercote.github.io/2025/03/19/how-to-speed-up-the-rust-compiler-in-march-2025.html\">new ways</a> of speeding up the compiler, <a href=\"https://github.com/rust-lang/rustc-perf/blob/master/triage/README.md\">triaging performance regressions</a> and <a href=\"https://perf.rust-lang.org/dashboard.html\">measuring</a> our long-term performance improvements. Recently, we also made progress on some <a href=\"https://github.com/rust-lang/rust/pull/140525\">large changes</a> that have been in the making for a long time, which could significantly improve compiler performance by default.</p><p>When we talk about compilation performance, it is important to note that it is not always so simple as determining how long does it take  to compile a crate. There are many diverse development workflows that might have competing trade-offs, and that can be bottlenecked by various factors, such as the integration of the compiler with the used build system.</p><p>In order to better understand these workflows, we have prepared a <a href=\"https://www.surveyhero.com/c/rust-compiler-performance-2025\">Rust Compiler Performance Survey</a>. This survey is focused specifically on compilation performance, which allows us to get more detailed data than what we usually get from the annual State of Rust survey. The data from this survey will help us find areas where we should focus our efforts on improving the productivity of Rust developers.</p><p><strong>You can fill out the survey <a href=\"https://www.surveyhero.com/c/rust-compiler-performance-2025\">here</a>.</strong></p><p>Filling the survey should take you approximately 10 minutes, and the survey is fully anonymous. We will accept submissions until Monday, July 7th, 2025. After the survey ends, we will evaluate the results and post key insights on this blog.</p><p>We invite you to fill the survey, as your responses will help us improve Rust compilation performance. Thank you!</p>","contentLength":1701,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Changes to Kubernetes Slack","url":"https://kubernetes.io/blog/2025/06/16/changes-to-kubernetes-slack/","date":1750032000,"author":"","guid":157132,"unread":true,"content":"<p>: We’ve received notice from Salesforce that our Slack workspace  on June 20th. Stand by for more details, but for now, there is no urgency to back up private channels or direct messages.</p><p>. Sometime later this year, our community may move to a new platform. If you are responsible for a channel or private channel, or a member of a User Group, you will need to take some actions as soon as you can.</p><p>For the last decade, Slack has supported our project with a free customized enterprise account. They have let us know that they can no longer do so, particularly since our Slack is one of the largest and more active ones on the platform. As such, they will be downgrading it to a standard free Slack while we decide on, and implement, other options.</p><p>On Friday, June 20, we will be subject to the <a href=\"https://slack.com/help/articles/27204752526611-Feature-limitations-on-the-free-version-of-Slack\">feature limitations of free Slack</a>. The primary ones which will affect us will be only retaining 90 days of history, and having to disable several apps and workflows which we are currently using. The Slack Admin team will do their best to manage these limitations.</p><p>Responsible channel owners, members of private channels, and members of User Groups should <a href=\"https://github.com/kubernetes/community/blob/master/communication/slack-migration-faq.md#what-actions-do-channel-owners-and-user-group-members-need-to-take-soon\">take some actions</a> to prepare for the upgrade and preserve information as soon as possible.</p><p>The CNCF Projects Staff have proposed that our community look at migrating to Discord. Because of existing issues where we have been pushing the limits of Slack, they have already explored what a Kubernetes Discord would look like. Discord would allow us to implement new tools and integrations which would help the community, such as GitHub group membership synchronization. The Steering Committee will discuss and decide on our future platform.</p>","contentLength":1684,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["official"]}