{"id":"i2nisf4o","title":"Reddit","displayTitle":"Reddit","url":"","feedLink":"","isQuery":true,"isEmpty":false,"isHidden":false,"itemCount":159,"items":[{"title":"I’ve released a game where players write real JavaScript code to battle other players online","url":"https://store.steampowered.com/app/1137320/Screeps_Arena/","date":1762030223,"author":"/u/artchiv","guid":324206,"unread":true,"content":"<!DOCTYPE html>","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1olyo43/ive_released_a_game_where_players_write_real/"},{"title":"to transaction or not to transaction","url":"https://www.reddit.com/r/golang/comments/1olxt4z/to_transaction_or_not_to_transaction/","date":1762028100,"author":"/u/PancakeWithSyrupTrap","guid":324210,"unread":true,"content":"<p>Take this simplistic code:</p><p>func create(name string) error {</p><p>if err != nil { return err }</p><p>err := writeToDatabase(name)</p><p>if err != nil { return err}</p><p>func newDisk(name) error {</p><p>name, err := getDisk(name)</p><p>if err != nil { return err }</p><p>if name != \"\" { return nil }</p><p>if err != nil { return err}</p><p>This creates a disk and database record.</p><p>The `newDisk` function idempotently creates a disk. Why ? If writing a database record fails, there is an inconsistency. A real resource is created but there is no record of it. When client receives an error presumably it will retry, so a new disk will not be created and hopefully the database record is written. Now we are in a consistent state.</p><p>But is this a sensible approach ? In other words, shouldn't we guarantee we are always in a consistent state ? I'm thinking creating the disk and writing a database record should be atomic.</p>","contentLength":852,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Compile from a git repo but make changes","url":"https://www.reddit.com/r/golang/comments/1olx8jv/compile_from_a_git_repo_but_make_changes/","date":1762026706,"author":"/u/No-Confection8657","guid":324176,"unread":true,"content":"<p>I am running a VPS with ubuntu aarch64 and have go 1.25. I am trying to compile a program from a repo that is written in go but want to also implement a change from a pull request. The repo isn't mine, though I do have a fork of it on my git. </p><p>I installed task and followed the steps in the <a href=\"http://contributing.md/\">contributing.md</a> file. When I \"task deps\" it did spit out an error that was basically the same as when I was doing it passing go commands manually:</p><p>I decided to just try ignoring that and running \"task\" to build it. And it seemed to compile and I have successfully ran it.</p><p>Here is my issue now - I manually made the changes to the VERSION and internal/tgc/channel_manager.go files locally before running this but I think it just went ahead and used the original versions ignoring my changes</p><p>when I run teldrive version it spits out 1.7.0 and the changes to the version file is 1.7.1 - also the file that got generated is the exact same amount of bytes as the 1.7.0 release. So I think it just made the file with none of the changes I had manually input into the local copies of the files.</p><p>Then when I run task, it exits with the following error:</p><p>task: Failed to run task \"default\": task: Command \"go run scripts/release.go --version current\" failed: exit status 1</p><p>not sure what would cause this - when I look at that file, it seems to just reference the VERSION file to get the version number. and it simply says 1.7.1 instead of 1.7.0</p><p>Am I missing something obvious? Sorry for the long post, I am new at this.</p>","contentLength":1492,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Understanding Multi-Platform Docker Builds with QEMU","url":"https://cefboud.com/posts/qemu-virtualzation-docker-multi-build/","date":1762024493,"author":"/u/Helpful_Geologist430","guid":324186,"unread":true,"content":"<p>One intriguing feature of containers and images is their multi-platform support. Docker uses Buildx, which is based on BuildKit, to enable multi-platform builds.</p><p>The old way (build for the current host’s platform, if you’re on an ARM CPU, you build an ARM image that won’t run on x86, and vice versa):</p><p>The new way: without a single care, build a multi-platform image that supports both x86 and ARM (and others):</p><div><div><code><table><tbody><tr><td><pre>docker buildx build  linux/amd64,linux/arm64 </pre></td></tr></tbody></table></code></div></div><p>How is this sorcery possible? Let’s take a look.</p><h2><a href=\"https://cefboud.com/posts/qemu-virtualzation-docker-multi-build/#but-first-what-are-containers\"></a></h2><p>Containers, under the hood, are simply processes isolated thanks to <a href=\"https://man7.org/linux/man-pages/man7/namespaces.7.html\">Linux’s namespaces</a>. The executables and files of these processes, packaged in layers, are compiled for a specific architecture.</p><p>Put differently, a container is a bundled runtime. This is what the <a href=\"https://specs.opencontainers.org/runtime-spec/runtime/?v=v1.0.2\">OCI runtime bundle</a> defines:</p><div><div><code><table><tbody><tr><td><pre>coolcontainer/\n├── config.json\n└── rootfs/\n    ├── bin/\n    ├── lib/\n    └── ...\n</pre></td></tr></tbody></table></code></div></div><p>An OCI runtime bundle (used to start a container) is obtained from an OCI image (Docker images are OCI-compliant).</p><div><div><code><table><tbody><tr><td><pre>1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n</pre></td><td><pre>apt  umoci skopeo runc\n\n\nskopeo copy docker://alpine:latest oci:alpine:latest\n\nalpine/\n\numoci unpack  alpine:latest alpine-runtime-bundle\nalpine-runtime-bundle/\n\nrunc run  alpine-runtime-bundle mycoco\n    yo  /home/greeting\n    alpine-runtime-bundle/rootfs/home/greeting\n</pre></td></tr></tbody></table></code></div></div><p>This spec defines what’s needed to run a container. All OCI-compliant container solutions adhere to it (Docker, Podman, etc.). These files are then used to create a container process. The isolation is achieved through Linux namespaces. To the container, it feels like it’s running on its own filesystem, network, PID space, and so on, but in reality, it’s just a process, albeit a well-isolated one.</p><p>The reference implementation that takes an OCI runtime bundle and starts a container is  (Docker uses it under the hood). It takes all the information and layers in the bundle and creates the container process. Mounts, environment variables, and all kinds of options that can be specified when running a container are handled by .</p><p>This means that the executables and binaries are destined for a specific OS and architecture:</p><div><div><code><table><tbody><tr><td><pre>file  alpine-runtime-bundle/rootfs/bin/ls\nalpine-runtime-bundle/rootfs/bin/ls: ELF 64-bit LSB executable, ARM aarch64\n</pre></td></tr></tbody></table></code></div></div><p>So the  command inside the container layers is simply a regular executable built for ARM64.</p><p>You can’t just run an image built for an x86 CPU on an ARM CPU (out of the box). That’s where multi-platform images come into the picture.</p><p>An image that supports multiple architectures? Say what?</p><div><div><code><table><tbody><tr><td><pre>skopeo inspect  docker://docker.io/library/ubuntu:latest | jq | \n        ...\n</pre></td></tr></tbody></table></code></div></div><div><div><code><table><tbody><tr><td><pre>1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n</pre></td><td><pre>\nskopeo copy  amd64  linux \n  docker://docker.io/library/nginx:latest \n  oci:nginx-amd64:latest\n\numoci unpack  nginx-amd64:latest nginx-amd64-runtime-bundle\n\n\nfile  nginx-amd64-runtime-bundle/rootfs/bin/ls\n</pre></td></tr></tbody></table></code></div></div><p>J’accuse! Intruder! An x86-64 binary on an ARM machine!</p><div><div><code><table><tbody><tr><td><pre>./alpine-runtime-bundle/rootfs/bin/ls\n\n./nginx-amd64-runtime-bundle/rootfs/bin/ls\n\nrunc run  nginx-amd64-runtime-bundle my-nginx-container\n</pre></td></tr></tbody></table></code></div></div><p>And that’s the heart of the problem when it comes to running containers across different platforms. What to do?</p><h2><a href=\"https://cefboud.com/posts/qemu-virtualzation-docker-multi-build/#qemu-and-binfmt-misc-to-the-rescue\"></a></h2><p>QEMU (Quick EMUlator) is quite the remarkable piece of software. It’s both an emulator and a virtualizer, and it also provides user-level emulation. Ehhh, what? Well, that’s what you get when you look up QEMU. Let’s put it in simpler terms:</p><ul><li><p>Emulator: It emulates hardware. It simulates entire systems (CPU, memory, disk, network, etc.) in software, meaning it exposes an interface to a guest program similar to actual hardware. Think about it: for an OS, all it sees is a bunch of CPU machine code that interacts with hardware and registers. If those registers and hardware behaviors are simulated in software, the OS is none the wiser and that’s exactly what QEMU does. You can simulate different CPUs (ARM, x86, RISC-V, etc.), run machine code instructions, and update state (registers, flags, program counter, etc.) as if you were running on real hardware, it’s just slower. By emulating CPUs in software, QEMU can run an OS built for the same or a different CPU architecture.</p></li><li><p>Virtualizer: Some CPUs offer hardware-assisted virtualization, basically, the CPU can differentiate between a guest and a host OS. This is a lot faster than using an emulator, but since you’re using the same CPU, you can only run a guest OS built for that CPU (for example, an x86 Linux guest on an x86 Linux host). This is supported in Linux through KVM. QEMU can make use of KVM, so when available, it’s better to use it for faster guest execution.</p></li><li><p>User-space emulation: This allows us to run a binary built for an architecture different from our machine’s by translating machine code and system calls on the fly. For instance,  works on an  CPU as if it were native. It’s truly magical, QEMU decodes ARM instructions and translates them into x86-64 ones, roughly:</p></li></ul><div><div><code><table><tbody><tr><td><pre>ARM code:          ADD R0, R1, R2\nQEMU intermediate: tcg_gen_add_i32(result, R1, R2)\nx86-64 host code:  mov eax,[R1]; add eax,[R2]; mov [R0],eax\n</pre></td></tr></tbody></table></code></div></div><p>So QEMU user-space emulation is the first piece of the cross-platform image puzzle.</p><p>The second piece is . It stands for <em>Binary Format Miscellaneous</em> (quite the name). The basic idea is that your Linux kernel knows how to run executables built for its own architecture. If you’re on an x86-64 CPU, your kernel can run x86-64 ELF files by default. It can’t run executables built for other architectures (like ARM) or other file types (like Windows  files or scripts).</p><p> is a kernel feature that allows us to specify an interpreter or program to handle certain files, based on their extension or on a magic byte sequence contained within the file. ARM Linux executables, for instance, have a distinguishable magic sequence:  We can configure  to use  whenever it encounters a file with that magic sequence. Similarly, we can configure it to use  when encountering files with a  extension.</p><div><div><code><table><tbody><tr><td><pre>1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n</pre></td><td><pre> |  /proc/sys/fs/binfmt_misc/register\n\n\n./HelloWorld.jar \n +x /usr/local/bin/java-wrapper\n\n |  /proc/sys/fs/binfmt_misc/register\n\n./HelloWorld.jar\n</pre></td></tr></tbody></table></code></div></div><p>So,  lets the kernel specify a wrapper, interpreter, or command to run certain files based on their magic bytes or file extensions.</p><p>To recap:  allows us to execute binaries from other architectures, and  is the mechanism that maps those binaries (based on their magic bytes) to the appropriate QEMU user-space command.</p><p>In Docker’s <a href=\"https://docs.docker.com/build/building/multi-platform/#qemu\">documentation</a> about multi-platform builds, they explain that Docker Desktop supports multi-platform images with QEMU out of the box. (Docker Desktop is essentially a Linux VM tailored to run Docker, so it already has this configured.)</p><p>For Docker engine in Linux, we need to run:</p><div><div><code><table><tbody><tr><td><pre>docker run  tonistiigi/binfmt  all\n</pre></td></tr></tbody></table></code></div></div><p>This registers the  mappings (like we did above for Java and x86) but for all architectures.</p><p>The image <a href=\"https://github.com/tonistiigi/binfmt/blob/2062d3e3b27656ff1b19d762994567155b6fbdb2/cmd/binfmt/config.go#L22\">tonistiigi/binfmt</a> contains a Go binary that basically does what we demonstrated earlier, setting up mappings from ELF magic bytes to the appropriate QEMU binary for multiple architectures:</p><div><div><code><table><tbody><tr><td><pre>1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n</pre></td><td><pre></pre></td></tr></tbody></table></code></div></div><p>In <a href=\"https://github.com/tonistiigi/binfmt/blob/2062d3e3b27656ff1b19d762994567155b6fbdb2/cmd/binfmt/main.go#L98\"></a>, we find this delightful snippet:</p><div><div><code><table><tbody><tr><td><pre></pre></td></tr></tbody></table></code></div></div><h2><a href=\"https://cefboud.com/posts/qemu-virtualzation-docker-multi-build/#the-final-piece-of-the-puzzle\"></a></h2><p>Ok, we know how foreign binaries are run. But how does it all tie together? How are we actually building these multi-platform images?</p><p>The Docker docs have a nice example:</p><div><div><code><table><tbody><tr><td><pre>\nFROM alpine\n\nRUN  /arch\n</pre></td></tr></tbody></table></code></div></div><div><div><code><table><tbody><tr><td><pre>docker buildx build linux/amd64,linux/arm64  letsgo:1.0 \n\ndocker run linux/arm64 letsgo:1.0  /arch\n\n\ndocker run linux/amd64 letsgo:1.0  /arch\n</pre></td></tr></tbody></table></code></div></div><p>It’s beautiful! So what happened exactly? By specifying <code>--platform=linux/amd64,linux/arm64</code>, we’re asking Docker to build two images, one for each platform. The pulled base layer () is platform-specific, and the binaries within it are built for each architecture. Let’s verify that:</p><div><div><code><table><tbody><tr><td><pre>docker run linux/arm64 letsgo:1.0 sh\napk add file \n\nfile  /bin/uname\n</pre></td></tr></tbody></table></code></div></div><p>Nice! The  runs , and that’s where the QEMU magic occurs. Under the hood, each binary in the image layers, compiled for its target architecture, is executed. Docker’s  instruction spawns a new process on the host (isolated within namespaces, but still just a process). Depending on the file’s magic bytes, the appropriate QEMU interpreter is invoked automatically via  and that RUN command works. If it was not for  and QEMU, we’d get a polite .</p><p>QEMU isn’t the only way to build multi-platform images. Docker Buildx supports using multiple builder nodes (a cluster), and you can use nodes with different architectures to build images natively for their respective platforms. There’s even a cloud offering built around this approach.</p><div><div><code><table><tbody><tr><td><pre>\ndocker buildx create  multiarch-builder unix:///var/run/docker.sock\n\ndocker buildx create  multiarch-builder ssh://user@arm64-host\ndocker buildx use multiarch-builder\n</pre></td></tr></tbody></table></code></div></div><p>For compilers that support cross-compilation (compiling code on one platform, the host, to create an executable for a different platform ,the target), like Go, which does so natively by specifying  and , you can build directly for each target architecture without relying on emulation. For example, in a Dockerfile build stage you might run:</p><div><div><code><table><tbody><tr><td><pre>RUN  go build  server </pre></td></tr></tbody></table></code></div></div><p>Then, you can simply copy the resulting binary into the runtime stage. Since the Go compiler supports cross-compilation, there’s no need to use QEMU here. Instead, we rely on the  and  environment variables provided automatically by Docker Buildx.</p>","contentLength":9470,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1olwc2d/understanding_multiplatform_docker_builds_with/"},{"title":"[P] Flow Matching: A visual introduction","url":"https://peterroelants.github.io/posts/flow_matching_intro/","date":1762020413,"author":"/u/Xochipilli","guid":324174,"unread":true,"content":"<p>I've been working with flow matching models for video generation for a while, and recently went back to my old notes from when I was first learning about them. I cleaned them up and turned them into this blog post.</p><p>Hopefully it’s useful for anyone exploring flow matching for generative modeling. Writing it certainly helped solidify my own understanding.</p>","contentLength":356,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/MachineLearning/comments/1olumno/p_flow_matching_a_visual_introduction/"},{"title":"DigitalOcean is chasing me for $0.01: What it taught me about automation","url":"https://linuxblog.io/digitalocean-1-cent-automation/","date":1762014573,"author":"/u/modelop","guid":324115,"unread":true,"content":"<p>There are three kinds of emails that can ruin a quiet Saturday: a security warning, an outage alert, and, apparently, a repeat reminder that you owe a cloud provider one cent, yes, $0.01. I’ve been using DigitalOcean since 2013. Personally, I don’t use it often, but I log in several times a week to support clients hosted there.</p><h2>A chuckle and twelve years of cloud love</h2><p>Over the past twelve years I have set up and managed countless droplets, and DigitalOcean’s support and uptime have been excellent; this isn’t that kind of post.</p><p>It’s a lighthearted look at what happens when automation churns out more notifications than the situation may warrant, and why even a penny‑sized bill can teach us bigger lessons about design and efficiency.</p><p>On Saturday, 25 October 2025, an email with the subject <em>“Payment required: Your pre‑payment has been used”</em> arrived in my inbox. It informed me that my prepaid credit was insufficient to cover the month’s usage and urged me to “make another payment or add an alternate payment method.”</p><p>There was just one catch: the outstanding balance was $0.01. I chuckled, and went on with my day only to receive the exact message two more times over the coming days. By the time Saturday rolled around, my inbox looked like this:</p><p>The inbox search screenshot above shows the cadence: identical “Payment required” messages on October 25th, 28th, and 31st, 2025, followed by an email on November 1, 2025, titled <em>“Your 2025‑10 invoice is available.”</em></p><p>The invoice email (screenshot also above) contains a table that lists the usage charges for October as $0.01, notes that the payment method will only be charged if the balance exceeds $3.00, and invites me to “View Invoice.” Here’s what those other three messages look like:</p><p>My immediate reaction was a bit of a chuckle, but by the fourth email, I was more curious than anything: Why<em> does an automated billing system send four emails about a 1-cent balance? </em><a href=\"https://docs.digitalocean.com/platform/billing/invoices/\" target=\"_blank\" rel=\"noopener\">DigitalOcean’s billing documentation</a> notes that invoices are generated monthly. In my case, the system sent several “action required” emails, maybe because I don’t have a payment method saved? But in any case, I rarely use my personal DigitalOcean account beyond just quick tests:</p><p>This experience of multiple emails for 1 cent owed, prompted me to think about the hidden costs of excessive email notifications and how we can design billing and alerting in a more thoughtful way.</p><h2>The True Cost of an Email</h2><p>Email feels free because individuals don’t pay per message, but providers do. A 2025 breakdown of email marketing costs notes that the typical cost for a business to send emails is <a href=\"https://www.mobiloud.com/blog/how-much-does-email-marketing-cost\" target=\"_blank\" rel=\"noopener\">$1–$2 per thousand messages</a>, translating to roughly $0.001–$0.002 per email. Amazon’s Simple Email Service charges $0.10 per 1,000 emails for outbound messages (sending or receiving) and a few cents per gigabyte for attachments.</p><p>This cost is likely less for DigitalOcean, with the three “Payment required” notices and one invoice with attachment costing the company at most between a tenth and two‑tenths of a cent to send. But multiply that by hundreds of thousands of customers, and it highlights how easy it is to use resources to clutter inboxes over microbalances.</p><p>The monetary cost is only part of the picture. Email has an environmental footprint because electricity powers servers, networks, and client devices. Researchers estimate that more than <a href=\"https://carbonliteracy.com/the-carbon-cost-of-an-email/\" target=\"_blank\" rel=\"noopener\">306&nbsp;billion emails were sent in 2021</a>, and the total is expected to hit almost 400 billion this year, thanks to DigitalOcean. jk!!</p><p>According to <a href=\"https://carbonliteracy.com/the-carbon-cost-of-an-email/\" target=\"_blank\" rel=\"noopener\">Mike Berners‑Lee</a>, a short text email can produce 0.2–0.3 g of CO₂, while a longer message with attachments can produce 17 g; an email blast to 100 people may generate 26 g or more. Email‑related emissions accounted for approximately 150 million tons of CO₂e in 2019. That’s <a href=\"https://carbonliteracy.com/the-carbon-cost-of-an-email/\" target=\"_blank\" rel=\"noopener\">about 0.3% of the world’s carbon footprint</a>. But more importantly, about 25% added to users’ annoyance levels – Source: </p><h2>Notification fatigue and design principles</h2><p>It isn’t just about costs or the environment. Usability tests consistently <a href=\"https://www.smashingmagazine.com/2025/07/design-guidelines-better-notifications-ux/\" target=\"_blank\" rel=\"noopener\">show that</a> frequent alerts are one of the top user complaints. In fact, it’s been proven by Facebook and others that sending fewer notifications can be better for both engagement and retention.</p><p>Good notification design also recognizes levels of severity: high‑attention alerts (e.g., security breaches or failed payments) should prompt immediate action, while low‑attention messages (informational updates) can be bundled or deferred. Services like Slack, for example, <a href=\"https://www.smashingmagazine.com/2025/07/design-guidelines-better-notifications-ux/\" target=\"_blank\" rel=\"noopener\">adapt notification frequency</a> automatically when channels become very active.</p><p>Looking at DigitalOcean’s billing reminders, it’s easy to see opportunities for improvement. A one‑cent balance does not warrant three emails + an invoice. The first message could have been informational (<em>“heads up, your balance is low”</em>), the second might wait until the balance crosses a predetermined threshold (say $1 or $3), and the third could be a month or 3 months later.</p><p>Alternatively, DigitalOcean could incorporate a small balance waiver similar to the one many credit card issuers use.&nbsp;Banks recognize that it’s not cost‑effective to chase pennies; they round down or apply a credit adjustment on the next statement. The same logic could help cloud providers reduce overhead and user frustration.</p><h2>It’s not just DigitalOcean: micro‑balances happen everywhere</h2><p>DigitalOcean isn’t alone in sending tiny bills. Back in 2013, an <a href=\"https://www.optus.com.au/\" target=\"_blank\" rel=\"noopener\">Optus</a> customer in Australia <a href=\"https://forums.whirlpool.net.au/archive/2174002#:~:text=posted%202013,27%2C%2010%3A26%20pm%20AEST\" target=\"_blank\" rel=\"noopener\">posted on Whirlpool forums</a> that a billing error left them with a one‑cent overdue notice after receiving a reimbursement. One commenter wrote that it would cost the company <em>“more in personnel overheads to deal with this stupid billing error, than what it’s worth”</em>, while another explained, <em>“It’s an automated system, mate. Just relax.”</em></p><p>The moral of the story is that most companies rely on automated billing scripts, and without sensible thresholds, they’ll dutifully produce statements for even the most trivial amounts.</p><p>In practice, if you owe 99 cents or less, <a href=\"https://www.doctorofcredit.com/small-balance-waiver-a-k-a-lots-of-free-99-cent-amazon-gcs/\" target=\"_blank\" rel=\"noopener\">many companies</a> apply a credit adjustment and report a zero balance. The banking industry has recognized that goodwill and efficiency outweigh the pennies left on the ledger. If major financial institutions can swallow a dollar, cloud platforms with higher margins can too.</p><h2>What this taught me and how I’ve been guilty too</h2><p>As someone who deploys systems and manages mail servers, I can’t throw stones without acknowledging my own missteps. Earlier this year, I built <a href=\"https://dewedda.com/\" target=\"_blank\" rel=\"noopener\">dewedda.com</a>, a storm‑watch website for the Eastern Caribbean. Part of which was to send automatic email alerts to subscribers when storms approached islands within specific distances and directions.</p><p>In testing, everything looked great: the algorithm computed wind fields, adjusted for intensity, and tracked dozens of scenarios. But the first time a real storm approached, my code started hammering subscribers with unnecessary alerts. It didn’t account for storms that curved away or systems that were still unnamed, resulting in duplicates, so people kept receiving warnings even when there was no threat or duplicate emails. I had to scramble to adjust the logic.</p><p>The experience taught me humility and the importance of edge cases, and it makes me more sympathetic to DigitalOcean’s engineers. Building resilient billing and notification systems is complex. Edge cases arise when accounts straddle billing cycles, use promotional credits, or move between team and personal billing. Legacy code and third‑party integrations can behave unpredictably. What matters is how we learn from these events.</p><h2>Conclusion (yes, I paid that one cent)</h2><p>I paid the 1 cent balance owed to DigitalOcean. But who covers that transaction cost?</p><p>In the end, I did what any responsible business owner would do: I logged into my account and paid the one‑cent balance. Because, it would sit there for months, I only used a droplet for ~1 hour to test something. My personal DigitalOcean account goes mostly unused. So paying this invoice also means no recurring emails to pay my bill. Maybe that’s their plan? Ha!</p><p>I hope this article highlights the hidden inefficiencies that creep into automation, whether it’s cloud invoices, marketing emails, or storm alerts.</p><p>I still recommend DigitalOcean to friends and clients. They offer a great product at a fair price, with transparent billing. Being able to spin up a droplet in a few seconds makes life easy for Linux nerds like me. This one‑cent episode doesn’t change that; it simply underscores the value of thoughtful notification design. There are no affiliate links in this post either.</p><p>In summary, as repeatedly proven, sending fewer, more relevant notifications improves user satisfaction and retention. The environmental data also shows that unnecessary emails carry hidden costs, and financial industry practices demonstrate that forgiving tiny balances can be cheaper than collecting them.</p><p>A bit of humor on a Saturday morning turned into a lesson for all of us on building better systems. And yes, just in case the automated script is listening, I can confirm that as of writing this, my DigitalOcean account balance is zero.</p>","contentLength":9237,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ols6mk/digitalocean_is_chasing_me_for_001_what_it_taught/"},{"title":"Convex Optimization (or Mathematical Programming) in Go","url":"https://www.reddit.com/r/golang/comments/1ols1gn/convex_optimization_or_mathematical_programming/","date":1762014224,"author":"/u/RobotCyclist23","guid":324117,"unread":true,"content":"<p>Do you write a lot of Convex (or similar) Optimization problems and have been yearning for a way to model them in Go? <a href=\"https://github.com/MatProGo-dev/MatProInterface.go\">MatProInterface.go</a> can help you (and needs your input to gain more maturity)! Feel free to try it and let me know what you think!</p>","contentLength":247,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"[D] Best (free) courses on neural networks","url":"https://www.reddit.com/r/MachineLearning/comments/1olqqj0/d_best_free_courses_on_neural_networks/","date":1762011078,"author":"/u/gized00","guid":324116,"unread":true,"content":"<p>I have to prepare a course on NN for master students. As you can expect, there is A LOT of interest into learning about LLMs and related topics. So I would like to spend ±50% of the classes on Transformers/attention mechanisms/RL in LLMs/etc.</p><p>At the best of my knowledge there is no textbook on this (using Deep Learning by Goodfellow et al. for the first part) so I am looking for the best classes on similar topics. </p><p>I will use these classes to inform my selection of topics, see how others introduce such topics, calibrate the amount of topics that I can cover, and list them on the course website. I am not planning to \"steal\" material without permission or anything like that.</p><p>In your opinion, which ones are THE BEST classes on Transformers and related topics?</p>","contentLength":764,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"[D] Simple Questions Thread","url":"https://www.reddit.com/r/MachineLearning/comments/1olpzpu/d_simple_questions_thread/","date":1762009244,"author":"/u/AutoModerator","guid":324100,"unread":true,"content":"<p>Please post your questions here instead of creating a new thread. Encourage others who create new posts for questions to post here instead!</p><p>Thread will stay alive until next one so keep posting after the date in the title.</p><p>Thanks to everyone for answering questions in the previous thread!</p>","contentLength":287,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"VST3 now open source (MIT Licence)","url":"https://youtu.be/grMxkISQNyw?si=AF3vDzec-bBld-EF","date":1762008089,"author":"/u/Kunstbanause","guid":324207,"unread":true,"content":"<!DOCTYPE html>","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/linux/comments/1olpiuz/vst3_now_open_source_mit_licence/"},{"title":"i'm a zoomer on cachyOS but it seems to run in the family; my father has a jacket with a sun microsystems embroider on the front","url":"https://www.reddit.com/r/linux/comments/1olp7wt/im_a_zoomer_on_cachyos_but_it_seems_to_run_in_the/","date":1762007332,"author":"/u/bonzibuddy_official","guid":324208,"unread":true,"content":"<p>he's mentioned having a good amount of experience in red hat mostly for his career, we ended up finding this in storage recently. it also has another larger embroidery of the java logo on the back. it's comfortable and fits me still which also rocks. </p><p>i started using linux (mint) around 2021/2022 for hobbyist and general purposes, had to mostly run windows for college using adobe, no longer doing all of that so i'm back on cachy since it seems promising enough for an arch derivative. </p><p>thought this would be neat to share on here. thank you unix for being the foundation for the funny little penguin kernal that's sure to sweep any year now :P</p>","contentLength":645,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Go's Context Logger","url":"https://github.com/pablovarg/contextlogger?tab=readme-ov-file#examples","date":1762007053,"author":"/u/PurityHeadHunter","guid":324070,"unread":true,"content":"<p>Hello Gophers! A while ago, I started using contextual logging in my projects and found it made debugging significantly easier. Being able to trace request context through your entire call stack is a game-changer for understanding what's happening in your system.</p><p>This project started as a collection of utility functions I copy-pasted between projects. Eventually, it grew too large to maintain that way, so I decided to turn it into a proper library and share it with the community. <a href=\"https://github.com/PabloVarg/contextlogger\">https://github.com/PabloVarg/contextlogger</a></p><p>Context Logger is a library that makes it easy to propagate your logging context through Go's  and integrates seamlessly with Go's standard library, mainly  and . If this is something that you usually use or you're interested on using it for your projects, take a look at some <a href=\"https://github.com/pablovarg/contextlogger\">Usage Examples</a>.</p><p>For a very simple example, here you can see how to:</p><ul><li>Embed a logger into your context</li><li>Update the context (this can be done many times before logging)</li><li>Log everything that you have included in your context so far</li></ul><pre><code>ctx = contextlogger.EmbedLogger(ctx) contextlogger.UpdateContext(ctx, \"userID\", user.ID) contextlogger.LogWithContext(ctx, slog.LevelInfo, \"done\") </code></pre>","contentLength":1171,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1olp424/gos_context_logger/"},{"title":"Async Rust explained without Tokio or Smol","url":"https://youtu.be/_x61dSP4ZKM?si=XPDtuH13Du-s5KTD","date":1762005654,"author":"/u/Gisleburt","guid":324144,"unread":true,"content":"<!DOCTYPE html>","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1olokba/async_rust_explained_without_tokio_or_smol/"},{"title":"unsupportedConfigOverrides USAGE","url":"https://www.reddit.com/r/kubernetes/comments/1olodfm/unsupportedconfigoverrides_usage/","date":1762005147,"author":"/u/BigBprofessional","guid":324066,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Need Advice: Bitbucket Helm Repo Structure for Multi-Service K8s Project + Shared Infra (ArgoCD, Vault, Cert-Manager, etc.)","url":"https://www.reddit.com/r/kubernetes/comments/1olnp4b/need_advice_bitbucket_helm_repo_structure_for/","date":1762003325,"author":"/u/Dependent_Concert446","guid":324067,"unread":true,"content":"<p>I’m looking for some advice on how to organize our <strong>Helm charts and Bitbucket repos</strong> for a growing  setup.</p><p>We currently have  that contains everything — about  several  (like ArgoCD, Vault, Cert-Manager, etc.).</p><p>For our , we created  that’s used for microservices. We <strong>don’t have separate repos for each microservice</strong> — all are managed under the same project.</p><p>Here’s a simplified view of the repo structure:</p><pre><code>app/ ├── project-argocd/ │ ├── charts/ │ └── values.yaml ├── project-vault/ │ ├── charts/ │ └── values.yaml │ ├── project-chart/ # Base chart used only for microservices │ ├── basechart/ │ │ ├── templates/ │ │ └── Chart.yaml │ ├── templates/ │ ├── Chart.yaml # Defines multiple services as dependencies using │ └── values/ │ ├── cluster1/ │ │ ├── service1/ │ │ │ └── values.yaml │ │ └── service2/ │ │ └── values.yaml │ └── values.yaml │ │ # Each values file under 'values/' is synced to clusters via ArgoCD │ # using an ApplicationSet for automated multi-cluster deployments </code></pre><p>The following  are also in the same repo right now:</p><ul><li><strong>Project Contour (Ingress)</strong></li><li><em>(and other cluster-level tools like k3s, Longhorn, etc.)</em></li></ul><p>These are <strong>not tied to the application project</strong> — they’re might shared and deployed across <strong>multiple clusters and environments</strong>.</p><ol><li>Should I move these shared infra components into a <strong>separate “infra” Bitbucket repo</strong> (including their Helm charts, Terraform, and Ansible configs)?</li><li>For GitOps with , would it make more sense to split things like this: <ul><li> → all microservices + base Helm chart</li><li> → cluster-level services (ArgoCD, Vault, Cert-Manager, Longhorn, etc.)</li></ul></li><li>How do other teams structure and manage their repositories, and what are the best practices for this in DevOps and GitOps?</li></ol><p> Used AI to help write and format this post for grammar and readability.</p>","contentLength":1940,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"I wrote the dumbest key-value db i could think of","url":"https://www.reddit.com/r/golang/comments/1oln8uo/i_wrote_the_dumbest_keyvalue_db_i_could_think_of/","date":1762002079,"author":"/u/AnonymZ_","guid":324021,"unread":true,"content":"<p>So i wrote the dumbest key value db for a go course. It’s called kvd, and it uses docker containers as storage (github.com/YungBricoCoop/kvd)</p><p>every SET creates a container, every GET reads from it. if the key already exists, it just renames the old container with a prune_ prefix instead of deleting it directly, because stopping containers takes forever then every 30 seconds, a pruning system comes around and actually stops and removes them.</p><p>it’s slow as hell, and it’s one of the worst ways you could ever implement a key value db. but it works and acts has a redis server.</p><p>the project isn’t really the point though, i kinda want to create a github org that stores weird-ass but projects, like good ideas implemented in the dumbest way possible or just in an insane creative way.</p><p>drop a comment if you want to be part of the org and throw some name ideas for the org too</p>","contentLength":878,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Hard Rust requirements from May onward for all Debian ports","url":"https://lists.debian.org/debian-devel/2025/10/msg00285.html","date":1762000364,"author":"/u/pyeri","guid":324047,"unread":true,"content":"<pre>Hi all,\n\nI plan to introduce hard Rust dependencies and Rust code into\nAPT, no earlier than May 2026. This extends at first to the\nRust compiler and standard library, and the Sequoia ecosystem.\n\nIn particular, our code to parse .deb, .ar, .tar, and the\nHTTP signature verification code would strongly benefit\nfrom memory safe languages and a stronger approach to\nunit testing.\n\nIf you maintain a port without a working Rust toolchain,\nplease ensure it has one within the next 6 months, or\nsunset the port.\n\nIt's important for the project as whole to be able to\nmove forward and rely on modern tools and technologies\nand not be held back by trying to shoehorn modern software\non retro computing devices.\n\nThank you for your understanding.\n-- \ndebian developer - deb.li/jak | jak-linux.org - free software dev\nubuntu core developer                              i speak de, en\n</pre>","contentLength":874,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1olmnhx/hard_rust_requirements_from_may_onward_for_all/"},{"title":"Hard Rust requirements from May onward (for Debian's package manager, APT)","url":"https://lists.debian.org/debian-devel/2025/10/msg00285.html","date":1761999882,"author":"/u/DeleeciousCheeps","guid":324068,"unread":true,"content":"<pre>Hi all,\n\nI plan to introduce hard Rust dependencies and Rust code into\nAPT, no earlier than May 2026. This extends at first to the\nRust compiler and standard library, and the Sequoia ecosystem.\n\nIn particular, our code to parse .deb, .ar, .tar, and the\nHTTP signature verification code would strongly benefit\nfrom memory safe languages and a stronger approach to\nunit testing.\n\nIf you maintain a port without a working Rust toolchain,\nplease ensure it has one within the next 6 months, or\nsunset the port.\n\nIt's important for the project as whole to be able to\nmove forward and rely on modern tools and technologies\nand not be held back by trying to shoehorn modern software\non retro computing devices.\n\nThank you for your understanding.\n-- \ndebian developer - deb.li/jak | jak-linux.org - free software dev\nubuntu core developer                              i speak de, en\n</pre>","contentLength":874,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1olmhxe/hard_rust_requirements_from_may_onward_for/"},{"title":"Python refuses $1.5M grant, Unity's in trouble, AUR attacked again - Linux Weekly News","url":"https://tilvids.com/videos/watch/02a038db-fdd0-46d4-8cb2-1f0b1b0bd04d","date":1761998909,"author":"/u/Pure_Toe6636","guid":324069,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/linux/comments/1olm6jp/python_refuses_15m_grant_unitys_in_trouble_aur/"},{"title":"We should be very concerned about knowing who's real and who isn't","url":"https://www.reddit.com/r/artificial/comments/1olm00b/we_should_be_very_concerned_about_knowing_whos/","date":1761998341,"author":"/u/datascientist933633","guid":324209,"unread":true,"content":"<p>Colleague of mine recently started their own AI company, it's basically a voice call service that can be used to sell to people and do outbound marketing and sales. The thing is completely disturbing and dystopian. It called me for a test and I thought I was talking to a real person. It was so lifelike, the vocalizations were so real and unbelievably authentic. </p><p>This is one concern about AI that I have recently. How in the heck do you know who is real and who isn't? </p>","contentLength":470,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"You're absolutely right.","url":"https://v.redd.it/u13z27vogmyf1","date":1761992631,"author":"/u/MetaKnowing","guid":324004,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/artificial/comments/1olkek8/youre_absolutely_right/"},{"title":"I created Open Source Kubernetes tool called Forkspacer to fork entire environments + dataplane, it is like git but for kubernetes.","url":"https://www.reddit.com/r/kubernetes/comments/1olk9we/i_created_open_source_kubernetes_tool_called/","date":1761992135,"author":"/u/Laughing-Dawg","guid":324001,"unread":true,"content":"<p>I created an open-source tool that lets you create, fork, and hibernate entire Kubernetes environments.</p><p>With , you can fork your deployments while also migrating your data.. not just the manifests, but the entire data plane as well. We support different modes of forking: by default, every fork spins up a managed, dedicated virtual cluster, but you can also point the destination of your fork to a self-managed cluster. You can even set up multi-cloud environments and fork an environment from one provider (e.g., AWS) to another (e.g., GKE, AKE, or on-prem).</p><p>You can clone full setups, test changes in isolation, and automatically hibernate idle workspaces to save resources all declaratively, with GitOps-style reproducibility.</p><p>It’s especially useful for spinning up dev, test, pre-prod, and prod environments, and for teams where each developer needs a personal, forked environment from a shared baseline.</p><p><strong><em>License is Apace 2.0 and it is written in Go using Kubebuilder SDK</em></strong></p><p>Please give it a try let me know, thank you</p>","contentLength":1017,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"what exactly is open-sourced in grokipedia?","url":"https://www.reddit.com/r/linux/comments/1olk43q/what_exactly_is_opensourced_in_grokipedia/","date":1761991521,"author":"/u/nix-solves-that-2317","guid":324003,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Monthly: Certification help requests, vents, and brags","url":"https://www.reddit.com/r/kubernetes/comments/1olk1no/monthly_certification_help_requests_vents_and/","date":1761991272,"author":"/u/thockin","guid":323962,"unread":true,"content":"<p>Did you pass a cert? Congratulations, tell us about it!</p><p>Did you bomb a cert exam and want help? This is the thread for you.</p><p>Do you just hate the process? Complain here.</p><p>(Note: other certification related posts will be removed)</p>","contentLength":223,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Monthly: Who is hiring?","url":"https://www.reddit.com/r/kubernetes/comments/1olk17i/monthly_who_is_hiring/","date":1761991234,"author":"/u/gctaylor","guid":323961,"unread":true,"content":"<div><p>This monthly post can be used to share Kubernetes-related job openings within  company. Please include:</p><ul><li>Location requirements (or lack thereof)</li><li>At least one of: a link to a job posting/application page or contact details</li></ul><p>If you are interested in a job, please contact the poster directly. </p><p>Common reasons for comment removal:</p><ul><li>Not meeting the above requirements</li><li>Recruiter post / recruiter listings</li><li>Negative, inflammatory, or abrasive tone</li></ul></div>   submitted by   <a href=\"https://www.reddit.com/user/gctaylor\"> /u/gctaylor </a>","contentLength":461,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Not So Fast: Analyzing the Performance of WebAssembly vs. Native Code (WASM 45% slower)","url":"https://ar5iv.labs.arxiv.org/html/1901.09056","date":1761989253,"author":"/u/Zomgnerfenigma","guid":324020,"unread":true,"content":"<h5>The Challenge of Benchmarking WebAssembly</h5><div><p>The aforementioned suite of 24 benchmarks is the PolybenchC benchmark\nsuite&nbsp;, which is designed to measure the effect of\npolyhedral loop optimizations in compilers. All the benchmarks in the\nsuite are small scientific computing kernels rather than full\napplications (e.g., matrix multiplication and LU Decomposition); each is\nroughly 100 LOC. While WebAssembly is designed to accelerate scientific\nkernels on the Web, it is also explicitly designed for a much richer set\nof full applications.</p></div><div><p>The WebAssembly documentation highlights several intended use\ncases&nbsp;, including scientific kernels, image editing,\nvideo editing, image recognition, scientific visualization, simulations,\nprogramming language interpreters, virtual machines, and POSIX applications.\nTherefore, WebAssembly’s strong performance on the scientific kernels in PolybenchC\ndo not imply that it will perform well given a different kind of application.</p></div><div><p>We argue that a more comprehensive evaluation of WebAssembly should rely on an\nestablished benchmark suite of large programs, such as the SPEC CPU benchmark\nsuites. In fact, the SPEC CPU 2006 and 2017 suite of\nbenchmarks include several applications that fall under the intended use cases of\nWebAssembly: eight benchmarks are scientific applications (e.g., ,\n, , , and\n), two benchmarks involve image and video processing\n( and ), and all of the benchmarks are POSIX\napplications.</p></div><div><p>Unfortunately, it is not possible to simply compile a sophisticated\nnative program to WebAssembly. Native programs, including the programs in\nthe SPEC CPU suites, require operating system services, such as a\nfilesystem, synchronous I/O, and processes, which WebAssembly and the\nbrowser do not provide. The SPEC benchmarking harness itself requires\na file system, a shell, the ability to spawn processes, and other Unix\nfacilities. To overcome these limitations when porting native\napplications to the web, many programmers painstakingly modify their\nprograms to avoid or mimic missing operating system\nservices. Modifying well-known benchmarks, such as SPEC CPU, would not\nonly be time consuming but would also pose a serious threat to\nvalidity.</p></div><div><p>The standard approach to running these applications today is to use\nEmscripten, a toolchain for compiling C and C++ to\nWebAssembly&nbsp;. Unfortunately, Emscripten only supports\nthe most trivial system calls and does not scale up to large-scale\napplications. For example, to enable applications to use synchronous\nI/O, the default Emscripten  filesystem loads the entire\nfilesystem image into memory before the program begins executing. For\nSPEC, these files are too large to fit into memory.</p></div><div><p>A promising alternative is to use , a framework that enables\nrunning unmodified, full-featured Unix applications in the\nbrowser&nbsp;.  implements\na Unix-compatible kernel in JavaScript, with full support for\nprocesses, files, pipes, blocking I/O, and other Unix features.\nMoreover, it includes a C/C++ compiler (based on Emscripten)\nthat allows programs to run in the browser\nunmodified. The  case studies include complex applications,\nsuch as , which runs entirely in the browser without any\nsource code modifications.</p></div><div><p>Unfortunately,  is a JavaScript-only solution, since it was\nbuilt before the release of\nWebAssembly. Moreover,  suffers from high performance overhead,\nwhich would be a significant confounder while benchmarking. Using ,\nit would be difficult to tease apart the poorly performing benchmarks\nfrom performance degradation introduced by .</p></div>","contentLength":3526,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1oljj3v/not_so_fast_analyzing_the_performance_of/"},{"title":"Programming Language Agnostic Naming Conventions","url":"https://codedrivendevelopment.com/posts/programmatic-naming-conventions-guide","date":1761982250,"author":"/u/Distinct-Panic-246","guid":324002,"unread":true,"content":"<p>There is a famous quote when it comes to naming things in programming, which is attributed to Phil Karlton</p><blockquote><p>\"There are only two hard things in Computer Science: cache invalidation and naming things\"</p></blockquote><p>(Or the slight variation of <em>\"There are only two hard things in Computer Science: cache invalidation, naming things, and off by one errors\"</em>)</p><p>But over the last few decades there are definitely a few common conventions. Using standard names for things frees up time to work on tougher problems than naming, and means future readers of your code can probably understand the concept better.</p><h2>Why we spend time naming things correctly</h2><p>If you see a variable called , you can probably assume it is a boolean.  or  are not clear.</p><h3>Avoid Negative variable names:</h3><p>Negative names can lead to double negatives, which are confusing.</p><ul></ul><p>Abbreviations can be ambiguous - not everyone will interpret it as the same meaning. Just use the full word, it is clearer.</p><p>(Although  is probably an exception where it should always be used over ).</p><ul></ul><h3>Pick a language and always use that</h3><p>If you work in a modern company then it is likely you work with people originally from various countries around the world. It can be easy to end up with a codebase with a mix of words like  and .</p><p>I'd recommend just picking US spelling in your code (even if the app is localised only for a UK or AU audiece)</p><ul></ul><h3>Make booleans obvious by using is/has prefix</h3><p>If you name something , it is quite obvious that it is a boolean. Try to always do this, as something like  could read as if it wasn't a boolean</p><ul></ul><p>Words like , ,  are too generic. Try to avoid these terms</p><p>Pick a convention for naming things, and use those everywhere.calculateAmount</p><ul><li>Bad 👎:  and </li><li>Good 👍:  and </li></ul><p>Also pick a style for casing, and be sure you're consistent with it. Here are some examples (there might be other typical conventions for your library/language of choice)</p><ul><li> for class names</li><li> for most other variables</li><li> for static constants</li></ul><h2>Common names for specific things</h2><p>If you're taking some data and  it to a different shape or different values then  is a common and accurate name.</p><pre><div><div><div><code></code></div></div></div></pre><p>If you need to check if data is valid/correct, then its almost always called a validator.</p><pre><div><div><div><code></code></div></div></div></pre><p>Used when describing the shape of some data structure. Often used with database designs.</p><pre><div><div><div><code></code></div></div></div></pre><p>When you need to take some data (e.g. some string) and understand its own data structure. They are quite different things, parsers and transformers can  be very related</p><pre><div><div><div><code></code></div></div></div></pre><p>For code that runs 'between' different parts of your application. A typical use for middleware is in HTTP servers the incoming HTTP request can go through multiple middlewares to either transform the incoming data (before passing to next one or final endpoint handler function) or to do something with that data</p><pre><div><div><div><code></code></div></div></div></pre><p>When you have some functionality with a specific interface, and you need to convert it to another interface/shape.</p><p>It is also known as a 'wrapper' (or a bridge, although that is technically a slightly different thing)</p><p>When you need to make data uniform in scale, format, or structure</p><pre><div><div><div><code></code></div></div></div></pre>","contentLength":3010,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1olht95/programming_language_agnostic_naming_conventions/"},{"title":"Feeling confused about what to do next ?","url":"https://www.reddit.com/r/golang/comments/1olhfjy/feeling_confused_about_what_to_do_next/","date":1761980670,"author":"/u/Neutrino_i7","guid":323933,"unread":true,"content":"<p>For the past 3 months, I’ve beenusing Go for Building web api, SSR Application, Cli tools, But lately, it’s starting to feel like I’m doing the same thing over and over again — and honestly, it’s getting kinda boring.</p><p>I love Go, but I feel like I need something new and challenging to spice things up. Should I start learning another language alongside Go (maybe Rust or Python)? Or are there some cool project ideas in Go that can help me</p>","contentLength":448,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"How is the current market demand for openstack combined with k8s","url":"https://www.reddit.com/r/kubernetes/comments/1olgx9m/how_is_the_current_market_demand_for_openstack/","date":1761978623,"author":"/u/ossicor30","guid":323915,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Well a old school flex i guess","url":"https://www.reddit.com/r/linux/comments/1olftbt/well_a_old_school_flex_i_guess/","date":1761974186,"author":"/u/Puzzleheaded-Car4883","guid":323965,"unread":true,"content":"<p>This old Red Hat Linux 8.0 manual’s been gathering dust on my shelf. I used to read it as a kid — didn’t understand a single word back then. Fast forward to age 19, 3 years into using Linux daily... and everything suddenly makes sense.</p><p>Btw this is one of those first thing that introduced me to linux </p>","contentLength":306,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"One-Minute Daily AI News 10/31/2025","url":"https://www.reddit.com/r/artificial/comments/1olf4w9/oneminute_daily_ai_news_10312025/","date":1761971649,"author":"/u/Excellent-Target-847","guid":324175,"unread":true,"content":"<ol><li>, South Korea Government and Industrial Giants Build AI Infrastructure and Ecosystem to Fuel Korea Innovation, Industries and Jobs.[1]</li><li> says it’s deploying AI technology to stop Halloween parties.[2]</li><li> AI Unveils Supervised Reinforcement Learning (SRL): A Step Wise Framework with Expert Trajectories to Teach Small Language Models to Reason through Hard Problems.[3]</li><li> CEO says AI audio models will be ‘commoditized’ over time.[4]</li></ol>","contentLength":432,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Happy Halloween, nerds","url":"https://www.reddit.com/r/linux/comments/1olf21x/happy_halloween_nerds/","date":1761971357,"author":"/u/feelingsupersonic","guid":323887,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"[D] Realized I like the coding and ML side of my PhD way more than the physics","url":"https://www.reddit.com/r/MachineLearning/comments/1olehrk/d_realized_i_like_the_coding_and_ml_side_of_my/","date":1761969380,"author":"/u/PurpleCardiologist11","guid":323899,"unread":true,"content":"<p>Hey everyone, I’m a 2nd-year ChemE PhD student working on granular media with ML, so, technically, my research is about the physics of these systems. But lately I’ve realized I get way more excited about the numerical modeling and machine learning part than the physics itself. </p><p>I love building models, debugging, testing new architectures, running simulations… but when it comes to actually digging into the physical interpretation, I kinda lose interest </p><p>The thing is, I don’t have a CS background, and I usually write “prototype” code that works, but it’s not what you’d call clean software. I never learned data structures, algorithms, or how to structure large projects properly. </p><p>After my PhD, I think I’d like to move more toward computational or ML-heavy work, something like scientific computing, data-driven modeling, or applied AI for physical systems. </p><p>For anyone who’s gone down a similar path: - What kind of skills should I start developing now?<p> - How important is it to learn formal CS stuff (like algorithms and software design)? </p></p><p>Would love to hear what worked for you. I feel like I’m starting to see where I actually fit, and I just wanna steer myself in the right direction.</p>","contentLength":1212,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Futurelock: A subtle risk in async Rust","url":"https://rfd.shared.oxide.computer/rfd/0609","date":1761968878,"author":"/u/iamkeyur","guid":323963,"unread":true,"content":"<div data-lineno=\"424\"><p>Bounded channels are not really the issue here.  Even in omicron#9259, the capacity=1 channel was basically behaving as documented and as one would expect.  It woke up a sender when capacity was available, and the other senders were blocked to maintain the documented FIFO property.  However, some of the patterns that we use with bounded channels are problematic on their own and, if changed, could prevent the channel from getting caught up in a futurelock.</p></div><div data-lineno=\"426\"><p>In Omicron, we commonly use bounded channels with .  The bound is intended to cap memory usage and provide backpressure, but using the blocking  creates a second  queue: the wait queue for the channel.  Instead, we could consider using a larger capacity channel plus  and propagate failure from .</p></div><div data-lineno=\"428\"><p>As an example, when we use the actor pattern, we typically observe that there’s only one actor and potentially many clients, so there’s not much point in buffering messages  the channel.  So we use  and let clients block in .  But we could instead have  and have clients use  and propagate failure if they’re unable to send the message.  The value  here is pretty arbitrary.  You want it to be large enough to account for an expected amount of client concurrency, but not larger.  If the value is too small, you’ll wind up with spurious failures when the client could have just waited a bit longer.  If the value is too large, you can wind up queueing so much work that the actor is always behind (and clients are potentially even timing out at a higher level).  One might observe:</p></div><div data-lineno=\"430\"><div data-lineno=\"1\"><p>Channel limits, channel limits: always wrong!</p></div><div data-lineno=\"3\"><p>Some too short and some too long!</p></div></div><div data-lineno=\"434\"><p>But as with timeouts, it’s often possible to find values that work in practice.</p></div><div data-lineno=\"436\"><p>Using  is  a mitigation because this still results in the sender blocking.  It needs to be polled after the timeout expires in order to give up.  But with futurelock, it will never be polled.</p></div>","contentLength":1894,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1olecjo/futurelock_a_subtle_risk_in_async_rust/"},{"title":"Java Virtual Threads VS GO routines","url":"https://www.reddit.com/r/golang/comments/1oldyoo/java_virtual_threads_vs_go_routines/","date":1761967558,"author":"/u/gamecrow77","guid":324048,"unread":true,"content":"<p>I recently had a argument with my tech lead about this , my push was for Go since its a new stack , new learning for the team and Go is evolving , my assumption is that we will find newer gen of devs who specialise in Go. Was i wrong here ? the argument was java with virtual threads is as efficient as go </p>","contentLength":306,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"IRS open-sourced the fact graph it uses for tax law","url":"https://github.com/IRS-Public/fact-graph","date":1761958132,"author":"/u/R2_SWE2","guid":323813,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1olb241/irs_opensourced_the_fact_graph_it_uses_for_tax_law/"},{"title":"shift left approach for requests and limits","url":"https://www.reddit.com/r/kubernetes/comments/1olaat1/shift_left_approach_for_requests_and_limits/","date":1761955835,"author":"/u/Containertester","guid":323862,"unread":true,"content":"<p>We’re trying to solve the classic requests &amp; limits guessing game; instead of setting CPU/memory by gut feeling or by copying defaults (which either wastes resources or causes throttling/OOM), we started experimenting with a benchmark-driven approach: we benchmark workloads in CI/CD and derive the optimal requests/limits based on http_requests_per_second (load testing).</p><p>In our latest write-up, we share:</p><ul><li>Why manual tuning doesn’t scale for dynamic workloads</li><li>How benchmarking actual CPU/memory under realistic load helps predict good limits</li><li>How to feed those results back into Kubernetes manifests</li><li>Some gotchas around autoscaling &amp; metrics pipelines</li></ul><p>Curious if anyone here has tried a similar “shift-left” approach for resource optimization or integrated benchmarking into their pipelines and how that worked out.</p>","contentLength":817,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Steinberg, creators of VST technology and the ASIO protocol, have released the SDKs for VST 3 and ASIO as Open Source.","url":"https://www.reddit.com/r/linux/comments/1ola786/steinberg_creators_of_vst_technology_and_the_asio/","date":1761955542,"author":"/u/fenix0000000","guid":323814,"unread":true,"content":"   submitted by   <a href=\"https://www.reddit.com/user/fenix0000000\"> /u/fenix0000000 </a>","contentLength":35,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"[D] ArXiv CS to stop accepting Literature Reviews/Surveys and Position Papers without peer-review.","url":"https://blog.arxiv.org/2025/10/31/attention-authors-updated-practice-for-review-articles-and-position-papers-in-arxiv-cs-category/","date":1761951858,"author":"/u/NamerNotLiteral","guid":323796,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/MachineLearning/comments/1ol8wup/d_arxiv_cs_to_stop_accepting_literature/"},{"title":"[GoGreement] A new linter that can help enforce interface implementation and immutability","url":"https://www.reddit.com/r/golang/comments/1ol8das/gogreement_a_new_linter_that_can_help_enforce/","date":1761950330,"author":"/u/Green-Sympathy-2198","guid":323797,"unread":true,"content":"<p>Hey guys! I wrote this linter mainly for myself, but I hope some of you find it useful.</p><p>I came to golang from JVM world and I was missing some things like explicit implementation declaration and immutability.</p><p>But I see gophers love their linters, so I thought I could solve this with a linter.</p><p>How does it work? You just add annotations to your types like: <code>go // @immutable type User struct { id string name string } </code></p><p>And run the linter and it will give you an error if you try to change fields like this: </p><p>I also added annotations that let you check interface implementation: <code>go // @implements io.Reader </code></p><p>This lets you check that a struct actually implements an interface without all this stuff: <code>go var _ MyInterface = (*MyStruct)(nil) </code></p><p>And many other annotations (testonly, packageonly, ...). Would love to hear what you think!</p>","contentLength":822,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Borrow checker says “No”! An error that scares me every single time!","url":"https://polymonster.co.uk/blog/borow-checker-says-no","date":1761949509,"author":"/u/__shufb","guid":324046,"unread":true,"content":"<p>It’s Halloween and I have just been caught out by a spooky borrow checker error that caught me by surprise. It feels as though it is the single most time consuming issue to fix and always seems to catch me unaware. The issue in particular is “cannot borrow x immutably as it is already borrowed mutably” - it manifests itself in different ways under different circumstances, but I find myself hitting it often when refactoring. It happened again recently so I did some investigating and thought I would discuss it in more detail.</p><p>The issue last hit me when I was refactoring some code in my graphics engine <a href=\"https://github.com/polymonster/hotline\">hotline</a>, I have been creating some content on YouTube and, after a little bit of a slog to fix the issue, I recorded a video of me going through the scenario of how it occurred and some patterns to use that I have adopted in the past to get around it. You can check out the video if you are that way inclined, the rest of this post will mostly echo what is in the video, but it might be a bit easier to follow code snippets and description in text.</p><p>I have a generic graphics API, which consists of traits called <a href=\"https://github.com/polymonster/hotline/blob/master/src/gfx.rs\">gfx</a>. This is there to allow different platform backends to implement the trait; currently I have a fully implemented Direct3D12 backend and I recently began to port macOS using Metal.</p><p>The gfx backend wraps underlying graphics API primitives; in this case we are mostly concerned about  which is a command buffer. Command buffers are used to submit commands to the GPU. They do things like  or , amongst other things. For the purposes of this blog post, what the command buffer does is not really that important, just that is does , which at the starting point when the code was working is a trait method that takes an immutable self and another immutable parameter ie. <code>fn do_something(&amp;self, param: &amp;Param)</code>.</p><p>In the rest of the code base I have a higher level rendering system called . This is graphics engine code that is not platform specific but implements shared functionality. So where  is a low level abstraction layer,  implements concepts of a  that is a view of a scene that we can render from. A  has a camera that can look at the scene and is then passed to a render function, which can build a command buffer to render the scene from that camera’s perspective. The engine is designed to be multithreaded and render functions are dispatched through  systems, so a view gets passed into a render system but it is wrapped in an .</p><p>I made a small cutdown example of this code to be able to demonstrate the problem I encounter, so let’s start with the initial working version:</p><div><div><pre><code></code></pre></div></div><p>I tried to simplify it as much as possible so these snippets should compile if you copy and paste them, they won’t run thanks to  macro (which I absolutely love using, it is so handy!) but we only care about the borrow checker anyway.</p><p>All we really need to think about is that a  can  and it also gets passed in a , which is also contained as part of ‘view’. Coming from a C/C++ background I landed on my personal preference being procedural C code with context passing, so I tend to group things together into a single struct. It makes sense to me in this case and I wanted to group everything inside , and we fetch the view from elsewhere in the engine.</p><p>So the code in the snippet compiles fine and I was working with this setup for some time. I began work on macOS and it turned out that the  method needed to mutate the command buffer so that I could mutate some internal state and make the Metal graphics API behave similarly to Direct3D12. This is common for graphics API plumbing.</p><p>The specific example in this case was that in Direct3D we call a function  to bind an index buffer before we make a call to , but in Metal there is no equivalent to bind an index buffer. Instead you pass a pointer to your index buffer when calling the equivalent draw indexed. So to fix this, when we call  we can store some extra state in the command buffer so we can pass it in the later call to .</p><p>In hindsight any method on the command buffer trait that does anything, like set anything or write into the command buffer, should take a  because it is mutating the command buffer after all. In my case since I am calling through to methods on  , which is unsafe code and does not require any mutable references.</p><p>In our simplified example, in order to store, state  now needs to change and take a mutable self: <code>do_something(&amp;mut self, param: &amp;Param)</code> it should be noted that  itself was already .</p><div><div><pre><code></code></pre></div></div><p>Borrow checker now kicks in…my heart sinks. In the real code base not only did I have to modify a single call site, but I had hundreds of places where this error was happening, I made the decision here and now to make any methods that write to the command buffer also be mutable and make the mutability</p><div><div><pre><code>error[E0502]: cannot borrow `view` as immutable because it is also borrowed as mutable\n  --&gt; src/main.rs:30:28\n   |\n30 |     view.cmd.do_something(&amp;view.param);\n   |     ----     ------------  ^^^^ immutable borrow occurs here\n   |     |        |\n   |     |        mutable borrow later used by call\n   |     mutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile due to 1 previous error\n</code></pre></div></div><p>This is not the first time I have encountered this problem and I doubt it will be the last. There are a number of ways to resolve it and they aren’t too complicated. The frustrating thing is that it seems to occur always when you are doing something else and not just when you decide to refactor, so you end up having a mountain of errors to solve before you can get back to the original task. I suppose you could call it a symptom of bad design or lack of experience, but when writing code things inevitably change and bend with new requirements, and Rust throws these unexpected issues up for me more often than I find with C, and often the required refactor takes more effort as well. But that is the cost you pay, hopefully more upfront effort to get past the borrow checker means fewer nasty debugging stages later. So let’s look at some patterns to fix the issue!</p><p>The one I actually went for in this case was using . We take the  out of view so we no longer need to borrow a ‘view’ to use , and then when finished return the cmd into ‘view’. It is important to note here that  needs to derive default in order for this to work, as when we take the  in  will become </p><div><div><pre><code></code></pre></div></div><p>This approach is the simplest I could think of at the time because any existing code using  doesn’t need updating, everything stays the same and we just separate the references. In this case it was easy to derive the default for  .You need to remember to set the  back on  here, which could be a pitfall and cause unexpected behaviour if you didn’t.</p><p>If you can’t easily derive default on a struct there are some other options. If the struct is clonable or you can easily derive a clone, you can clone to achieve a similar effect.</p><div><div><pre><code></code></pre></div></div><p>Cloning might be considered a heavier operation than ‘take’ depending on the circumstances, but this method has the same benefit as the take version whereby unaffected code that is using  elsewhere doesn’t need to be changed.</p><p>Another approach would be to use  this allows for interior mutability and again we do not need to worry about default or clone.</p><div><div><pre><code></code></pre></div></div><p>We also need to update any code that ever used  and do the same. Not ideal but it allows us to get around the need for a default or clone. I have had to resort to this in other places in the code base.</p><p>There are more options; quite literally  here can help. If we make  an  then this gives us the ability to use  as the default and we can use the  approach. We can also use  and swap with . Swapping works similar to ‘take’, where we take mem and swap with the default.</p><div><div><pre><code></code></pre></div></div><p>The  approach also requires more effort as we need to now take a reference and unwrap the option and update any code that ever used  to do the same. Not ideal, but it allows us to get around the need for a default or clone, and if your type is already optional then this will fit easily.</p><p>There is one final approach that could save a lot of time, and that would be to not change the  function at all in the first place. That is to keep it as <code>do_something(&amp;self, param: &amp;Param)</code>. So how do we mutate the interior state without requiring the self to be mutable?</p><p>This can be done with  in single threaded code or  in multithreaded code. Since we already looked at  I will do an example of .</p><div><div><pre><code></code></pre></div></div><p>I decided to make the mutability explicit to the trait and that was based on how the command buffers are used in the engine, in other places I have taken other approaches favouring interior mutability. For this case a view can be dispatched in parallel with other views, but the engine is designed such that 1 thread per view and no work happens to a single view on multiple threads at the same time. Command buffers are submitted in a queue in order and dispatched on the GPU.</p><p>Here it made sense to me to avoid locking interior mutability for each time we call a method on a  and it works with the engine’s design. We lock a view at the start of a render thread, fill it with commands and then hand it back to the graphics engineer for submission to the GPU. The usage is explicit, we just needed to appease the borrow checker!</p><p>I hope you enjoyed this article, please check out my <a href=\"https://www.youtube.com/@polymonster\">YouTube channel</a> for more videos or more articles on my blog, let me know what you think and if you have any other strategies or approaches I would love to hear about them. I would also like to hear about compiler and borrow checker errors you find particularly time consuming or frustrating to deal with.</p>","contentLength":9662,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1ol82h6/borrow_checker_says_no_an_error_that_scares_me/"},{"title":"What is wrong with this setup?","url":"https://www.reddit.com/r/kubernetes/comments/1ol7n6g/what_is_wrong_with_this_setup/","date":1761948348,"author":"/u/Low_Opening3670","guid":323793,"unread":true,"content":"<p>I needed Grafana Server for more than 500+ people to use and create dashboards on it...</p><p>I have one Grafana on EKS, I spin up everything using Terraform even wrap a k8s manifest in Terraform and deploy it to cluster. </p><p>There is not much change in Grafana application maybe every 6 months new stable version is out and I am going to do the upgrade</p><p>What is wrong with this setup? and how I can improve it? do I really need flux/argo here? </p>","contentLength":432,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"What kind of debug tools are available that are cloud native?","url":"https://www.reddit.com/r/kubernetes/comments/1ol64df/what_kind_of_debug_tools_are_available_that_are/","date":1761944378,"author":"/u/lickety-split1800","guid":323770,"unread":true,"content":"<p>I'm an SRE and a longtime Linux &amp; automation person, starting in the late 90s.</p><p>With the advent of apps on containers, there are fewer and fewer tools to perform debugging.</p><p>Taking a look at the types of debug tools one has used to diagnose issues.</p><ul><li>even basic tools such as find, grep, ls and others are used in debugging.</li></ul><p>The Linux OS used to be under the control of the system administrator, who would put the tools required to meet operational debugging requirements, increasingly since it is the developer that maintains the container image and none of these tools end up on the image, citing most of the time startup time as the main requirement.</p><p>Now a container is a slice of the operating system so I argue that the container base image should still be maintained by those who maintain Linux, because it's their role to have these tools to diagnose issues. That should be DevOps/SRE teams but many organisations don't see it this way.</p><p>So what tools does Kubernetes provide that fulfil the needs I've listed above?</p>","contentLength":1012,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Companies are trying to do too much with AI, says IT CEO | Fortune","url":"https://fortune.com/2025/10/31/scaling-ai-mit-study-roi/","date":1761943455,"author":"/u/fortune","guid":323771,"unread":true,"content":"<p>Scaling gen AI projects beyond the pilot phase is fundamental to turning the current AI hype cycle into real ROI. How can companies get over the hump? For starters, they should stop trying to introduce AI to every facet of operations, says Abhijit Dubey, CEO of NTT Data, an IT services and consulting company.&nbsp;\n\n\n\n</p><p>“What happens is companies say, ‘In every single domain, I’m going to unleash innovation, and I’m going to have AI enablement.’ I think that’s the wrong strategy,” Dubey said at the Fortune Global Forum in Riyadh on Sunday. The right strategy, he noted, is to “pick one or two domains that are going to create disproportionate economic value for the company and go end to end.” He gave the example of focusing on underwriting in insurance and supply chains in manufacturing.\n\n\n\n</p><p><a href=\"https://fortune.com/company/fedex/\" target=\"_blank\" aria-label=\"Go to https://fortune.com/company/fedex/\">FedEx</a> has been intentional about integrating AI into three broad areas: internal operations, customer experience, and creating new value levers for customers (such as improving demand forecasting and reducing returns), said Kami Viswanathan, FedEx’s president of the Middle East, Indian subcontinent, and Africa region. “Research has shown that organizations that have a clear AI strategy, which has this prioritization, have a much greater degree of success than others that don’t, right? So for us, that’s the key aspect of scaling.”\n\n\n\n</p><p>Deploying AI across an organization comes with risks and requires adequate safeguards, said Fabio Kuhn, CEO of Vortexa, a cargo tracking and energy market research firm whose customers can query its data via chatbot. Human supervision is essential to limiting hallucinations and keeping any that do slip through from shaping decision-making, he said. “In addition to speed and quality, what is … increasingly important on any model, any agent, is explainability. For a human to be able to understand, why is it making the decision that it is making?” he said.&nbsp;</p><p>Keeping a human in the loop is essential when AI is deployed in health care, said Noosheen Hashemi, cofounder and CEO of January AI, a precision health care company. “These LLMs [large language models], yes, they have read everything, but they do hallucinate, and they do it confidently. When there is data missing, they will invent it,” she said, noting that January AI’s Mirror tool has a hallucination rate under 1%. “We have doctors actually looking at results and saying, ‘Does this actually make sense?’”\n\n\n\n</p><p>Health care also has its own unique hurdles to scaling AI, especially in the U.S.: Data silos spread across patients, insurers, providers, and labs. The cost—in terms of potential—is enormous. “Not having a unified view of data doesn’t really allow us to leverage AI in the best way that we can,” Hashemi says. “We have the technology today, absolutely, to eradicate lifestyle-based chronic diseases in the world. The question is, to what extent do we have the will to actually apply this technology and to overcome data silos, regulatory issues, privacy issues, to actually deploy AI, because the technology is here.”\n</p>","contentLength":3089,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/artificial/comments/1ol5r4u/companies_are_trying_to_do_too_much_with_ai_says/"},{"title":"My Must-Have Apps Since Switching to Linux","url":"https://www.reddit.com/r/linux/comments/1ol5a1k/my_musthave_apps_since_switching_to_linux/","date":1761942274,"author":"/u/Overflow_Nuts","guid":323756,"unread":true,"content":"<p>OnlyOffice → If you’re used to MS Office, the interface feels almost identical — super easy to adapt.</p><p>Brave / Zen → When I need a Chromium-based browser, I use Brave; when I need a Firefox-based one, Zen. Both are top-tier.</p><p>Okular → Opens everything from PDFs to EPUBs.</p><p>yt-dlp → Downloads videos and audio straight from the terminal — and not just from YouTube, it supports tons of platforms.</p><p>Qbittorrent → Clean, simple, and easily the best torrent client out there.</p><p>Stremio + Add-ons → The best torrent-based media player, hands down.</p><p>KeepassXC → A simple yet powerful password manager with browser integration.</p><p>LocalSend → Transfers files across all your devices locally, no internet needed.</p><p>KDE Connect → Perfect bridge between your phone and computer.</p><p>Bottles → Makes using Wine more stable and user-friendly.</p><p>Espanso → Expands text shortcuts automatically — a real time-saver.</p><p>Tmux → Lets you split your terminal and run multiple sessions at once.</p><p>Btop / ytop / glances → Displays system resource usage right from the terminal.</p><p>Fastfetch → A faster Neofetch alternative for system info.</p><p>Syncthing → Syncs your files seamlessly between devices.</p><p>Czkawka → Finds duplicate or junk files on your disk.</p><p>Mpv + Plugins → Lightweight, scriptable video player.</p><p>Input Leap → Control multiple computers with one keyboard and mouse.</p><p>Zapret → Bypasses DPI-based network restrictions.</p><p>Moonlight / Sunshine → Stream your games locally across your network.</p><p>Heroic Games Launcher → Great alternative for Epic Games.</p><p>Lutris → Customizable launcher supporting multiple game libraries.</p><p>Prism Launcher → Clean, mod- and shader-friendly Minecraft launcher.</p><p>Ente Auth → The best 2FA app I’ve tried — encrypted sync between devices.</p><p>GDU → Visual disk usage analyzer.</p><p>Newsboat → Read RSS feeds directly in the terminal.</p><p>Neovim → Fast, lightweight text editor.</p><p>Waypaper / Swaybg / Hyprpaper → Manage your wallpapers easily.</p><p>Easy Effects → Lets you tweak and filter your system’s audio.</p><p>Waybar (+ eww + rofi) → Build a fully customizable system bar.</p><p>scrcpy → The simplest way to mirror your Android screen on your PC.</p><p>Podman / Distrobox → Run another Linux environment inside a container.</p><p>Wireshark / mitmproxy → Monitor and analyze your network traffic.</p><p>Opensnitch → See which apps are making network connections.</p><p>qutebrowser → A minimalist, keyboard-driven browser.</p><p>fail2ban → The most satisfying way to troll persistent brute-forcers.</p><p>qemu + Virt-Manager → Create and manage virtual machines easily.</p><p>Waydroid → Run Android apps directly on Linux.</p><p>Lf → Terminal-based file manager.</p><p>These are the tools I’ve discovered and personally enjoy using on Linux. What about yours what are your must-have apps?</p>","contentLength":2737,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Futurelock - Subtle Risk in async Rust","url":"https://rfd.shared.oxide.computer/rfd/0609","date":1761942015,"author":"/u/-Y0-","guid":323844,"unread":true,"content":"<div data-lineno=\"424\"><p>Bounded channels are not really the issue here.  Even in omicron#9259, the capacity=1 channel was basically behaving as documented and as one would expect.  It woke up a sender when capacity was available, and the other senders were blocked to maintain the documented FIFO property.  However, some of the patterns that we use with bounded channels are problematic on their own and, if changed, could prevent the channel from getting caught up in a futurelock.</p></div><div data-lineno=\"426\"><p>In Omicron, we commonly use bounded channels with .  The bound is intended to cap memory usage and provide backpressure, but using the blocking  creates a second  queue: the wait queue for the channel.  Instead, we could consider using a larger capacity channel plus  and propagate failure from .</p></div><div data-lineno=\"428\"><p>As an example, when we use the actor pattern, we typically observe that there’s only one actor and potentially many clients, so there’s not much point in buffering messages  the channel.  So we use  and let clients block in .  But we could instead have  and have clients use  and propagate failure if they’re unable to send the message.  The value  here is pretty arbitrary.  You want it to be large enough to account for an expected amount of client concurrency, but not larger.  If the value is too small, you’ll wind up with spurious failures when the client could have just waited a bit longer.  If the value is too large, you can wind up queueing so much work that the actor is always behind (and clients are potentially even timing out at a higher level).  One might observe:</p></div><div data-lineno=\"430\"><div data-lineno=\"1\"><p>Channel limits, channel limits: always wrong!</p></div><div data-lineno=\"3\"><p>Some too short and some too long!</p></div></div><div data-lineno=\"434\"><p>But as with timeouts, it’s often possible to find values that work in practice.</p></div><div data-lineno=\"436\"><p>Using  is  a mitigation because this still results in the sender blocking.  It needs to be polled after the timeout expires in order to give up.  But with futurelock, it will never be polled.</p></div>","contentLength":1894,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1ol566h/futurelock_subtle_risk_in_async_rust/"},{"title":"John Carmack on mutable variables","url":"https://twitter.com/id_aa_carmack/status/1983593511703474196","date":1761938789,"author":"/u/iamkeyur","guid":323795,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ol3unj/john_carmack_on_mutable_variables/"},{"title":"Meta, xAI Starting Trend for Billions in Off-Balance Sheet Debt","url":"https://www.bloomberg.com/news/articles/2025-10-31/meta-xai-starting-trend-for-billions-in-off-balance-sheet-debt","date":1761938322,"author":"/u/esporx","guid":324145,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/artificial/comments/1ol3nls/meta_xai_starting_trend_for_billions_in/"},{"title":"Write PostgreSQL functions in Go Golang example","url":"https://www.reddit.com/r/golang/comments/1ol2tqv/write_postgresql_functions_in_go_golang_example/","date":1761936351,"author":"/u/WinProfessional4958","guid":323712,"unread":true,"content":"<p>It took me a while to figure this out. Go compiles the C files automatically.</p><pre><code>#include \"postgres.h\" #include \"fmgr.h\" PG_MODULE_MAGIC; extern int32 Adder(int32); PG_FUNCTION_INFO_V1(add_two); Datum add_two(PG_FUNCTION_ARGS) { int32 arg = PG_GETARG_INT32(0); PG_RETURN_INT32(Adder(arg)); } </code></pre><pre><code>package main /* #cgo CFLAGS: -DWIN32 -ID:/pg18headers -ID:/pg18headers/port/win32 #cgo LDFLAGS: -LD:/pg18lib #include \"postgres.h\" #include \"fmgr.h\" // Forward declare the C function so cgo compiles add_two.c too. extern void init_add_two(); */ import \"C\" //export Adder func Adder(a C.int32) C.int32 { return a + 3 } func main() {} </code></pre><p><code>PS D:\\C\\myextension&gt; go build -o add_two.dll -buildmode=c-shared</code></p><p>In PostgreSQL: open the query window (adjust path to your generated dynamically loaded library and header file (.dll, .h).</p><p><code>CREATE FUNCTION add_two(int4) RETURNS int4</code></p><p><code>AS 'D:/C/myextension/add_two.dll', 'add_two'</code></p>","contentLength":893,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Go vs Kotlin: Server throughput","url":"https://www.reddit.com/r/golang/comments/1ol1upp/go_vs_kotlin_server_throughput/","date":1761934095,"author":"/u/iG0tB00ts","guid":323711,"unread":true,"content":"<p>Let me start off by saying I'm a big fan of Go. Go is my side love while Kotlin is my official (work-enforced) love. I recognize benchmarks do not translate to real world performance &amp; I also acknowledge this is the first benchmark I've made, so mistakes are possible.</p><p>That being said, I was recently tasked with evaluating Kotlin vs Go for a small service we're building. This service is a wrapper around Redis providing a REST API for checking the existence of a key.</p><p>With a load of 30,000 RPS in mind, I ran a benchmark using  (the workload is a list of newline separated 40chars string) and saw to my surprise Kotlin outperforming Go by ~35% RPS. Surprise because my thoughts, few online searches as well as AI prompts led me to believe Go would be the winner due to its lightweight and performant goroutines.</p><p>Go + net/http + go-redis <code>Text Thread Stats Avg Stdev Max +/- Stdev Latency 4.82ms 810.59us 38.38ms 97.05% Req/Sec 5.22k 449.62 10.29k 95.57% 105459 requests in 5.08s, 7.90MB read Non-2xx or 3xx responses: 53529 Requests/sec: 20767.19 </code> Kotlin + ktor + lettuce <code> Thread Stats Avg Stdev Max +/- Stdev Latency 3.63ms 1.66ms 52.25ms 97.24% Req/Sec 7.05k 0.94k 13.07k 92.65% 143105 requests in 5.10s, 5.67MB read Non-2xx or 3xx responses: 72138 Requests/sec: 28057.91 </code></p><p>I am in no way an expert with the Go ecosystem, so I was wondering if anyone had an explanation for the results or suggestions on improving my Go code. ```Go package main</p><p>import ( \"context\" \"net/http\" \"runtime\" \"time\"</p><pre><code>\"github.com/redis/go-redis/v9\" </code></pre><p>var ( redisClient *redis.Client )</p><p>func main() { redisClient = redis.NewClient(&amp;redis.Options{ Addr: \"localhost:6379\", Password: \"\", DB: 0, PoolSize: runtime.NumCPU() * 10, MinIdleConns: runtime.NumCPU() * 2, MaxRetries: 1, PoolTimeout: 2 * time.Second, ReadTimeout: 1 * time.Second, WriteTimeout: 1 * time.Second, }) defer redisClient.Close()</p><pre><code>mux := http.NewServeMux() mux.HandleFunc(\"/\", handleKey) server := &amp;http.Server{ Addr: \":8080\", Handler: mux, } server.ListenAndServe() // some code for quitting on exit signal </code></pre><p>// handleKey handles GET requests to /{key} func handleKey(w http.ResponseWriter, r *http.Request) { path := r.URL.Path</p><pre><code>key := path[1:] exists, _ := redisClient.Exists(context.Background(), key).Result() if exists == 0 { w.WriteHeader(http.StatusNotFound) return } </code></pre><p>Kotlin code for reference ```Kotlin // application</p><p>fun main(args: Array&lt;String&gt;) { io.ktor.server.netty.EngineMain.main(args) }</p><p>fun Application.module() { val redis = RedisClient.create(\"redis://localhost/\"); val conn = redis.connect() configureRouting(conn) }</p><p>fun Application.configureRouting(connection: StatefulRedisConnection&lt;String, String&gt;) { val api = connection.async()</p><pre><code>routing { get(\"/{key}\") { val key = call.parameters[\"key\"]!! val exists = api.exists(key).await() &gt; 0 if (exists) { call.respond(HttpStatusCode.OK) } else { call.respond(HttpStatusCode.NotFound) } } } </code></pre>","contentLength":2876,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Is there anything like the surface pro and go that fully supports linux?","url":"https://www.reddit.com/r/linux/comments/1ol1ekb/is_there_anything_like_the_surface_pro_and_go/","date":1761933082,"author":"/u/ijwgwh","guid":323730,"unread":true,"content":"<p>Can't stand Windows, but my surface devices are amazing hardware-wise. Surface linux has come a long way, but not having cameras is a deal-breaker for me. Is there any hardware slim sleek and powerful that fully supports Linux? Looking for tablet style, not those laptops where the keyboard turns all the way around. </p><p>ETA: looking for X86 I5+ or equivalent</p>","contentLength":355,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"html/template: Why does it escape opening angle bracket?","url":"https://www.reddit.com/r/golang/comments/1ol1cyi/htmltemplate_why_does_it_escape_opening_angle/","date":1761932979,"author":"/u/cvilsmeier","guid":323681,"unread":true,"content":"<div><p>Hi, html/template escapes input data, but why does it escape an angle bracket character (\"&lt;\") in the template? Here is an example:</p><pre><code>package main import ( \"fmt\" \"html/template\" \"strings\" ) func main() { text := \"&lt;{{.tag}}&gt;\" tp := template.Must(template.New(\"sample\").Parse(text)) var buf strings.Builder template.Must(nil, tp.Execute(&amp;buf, map[string]any{\"tag\": template.HTML(\"p\")})) fmt.Println(buf.String()) // Expected output: &lt;p&gt; // Actual output: &amp;lt;p&gt; } </code></pre></div>   submitted by   <a href=\"https://www.reddit.com/user/cvilsmeier\"> /u/cvilsmeier </a>","contentLength":491,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"AI has made Google more profitable when people expected the contrary","url":"https://peakd.com/@malopie/ai-has-made-google-more-profitable-when-people-expected-the-contrary-nn","date":1761931466,"author":"/u/renkure","guid":323710,"unread":true,"content":"<!DOCTYPE html>","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/artificial/comments/1ol0p6t/ai_has_made_google_more_profitable_when_people/"},{"title":"C3 0.7.7 Vector ABI changes, RISC-V improvements and more","url":"https://c3-lang.org/blog/c3-language-at-0-7-7-vector-abi,-riscv-improvements-and-more/","date":1761928654,"author":"/u/Nuoji","guid":323794,"unread":true,"content":"<p>0.7.7 is a major advance in C3 usability with vector ABI changes. It also contains several small quality-of-life additions, such as the ability to splat structs into an initializer, and implicit subscript dereferencing. Fairly few bugs were discovered during this development cycle, which is why the fixed bugs are unusually low.</p><p>Let’s look at what 0.7.7 brings in more detail:</p><p>The most significant change in this release is the ABI change for vectors, which now store and pass vectors as arrays in function calls and structs. While vectors still use SIMD, their equality to arrays on the ABI level means that C graphical libraries will directly match vector types.</p><p>Where before you needed to work with C structs defining vectors and then converting them to SIMD vectors for actual computation, it now works out of the box. Another problem with vectors prior to 0.7.7 was their space and alignment requirements over structs. From 0.7.7 alignment matches that of structs and arrays, making them extremely convenient to work with.</p><p>For cases where SIMD vectors are actually expected, it’s possible to create distinct types using  with a new  attribute to exactly match standard C SIMD vectors, e.g. <code dir=\"auto\">typedef V4si = int[&lt;4&gt;] @simd;</code>. This then exactly matches the corresponding C SIMD type.</p><p>This makes it easier than ever to use SIMD with C3.</p><div><figure><pre data-language=\"c3\"><code></code></pre></figure></div><h2>Struct initializer splats</h2><p>This feature enables using the splat operator  to give a designated initializer default values that are overridden by the following arguments.</p><div><figure><pre data-language=\"c3\"><code></code></pre></figure></div><p>When passing arrays or lists by reference, the  operator tend to behave in an undesirable way, dereferencing the pointer instead of the underlying array/list:</p><div><figure><pre data-language=\"c3\"><code></code></pre></figure></div><p>Subscript deref addresses this. Using  will dereference :</p><div><figure><pre data-language=\"c3\"><code></code></pre></figure></div><p>This is helpful when writing macros and such that will want to accept both elements by reference and by value:</p><div><figure><pre data-language=\"c3\"><code></code></pre></figure></div><p>A new feature for  is to allow creating a type with a specific alignment without wrapping it in a struct. We may, for example, create an integer that is 16 bit aligned using <code dir=\"auto\">typedef Int2 = int @align(2);</code>. This is an alternative way to safely work with references to under-aligned members in packed structs.</p><div><figure><pre data-language=\"c3\"><code></code></pre></figure></div><p>, ,  and  macros are added to modify strings at compile time efficiently for certain macro manipulation at compile time.</p><div><figure><pre data-language=\"c3\"><code></code></pre></figure></div><h2>Small but important changes</h2><p>Aliases that refer to  variables must themselves have local visibility.  is renamed  as it was frequently misunderstood. Generic inference now works better in initializers. For slices with the  syntax, it’s now possible to have the end index be one less than the starting index, so that zero size slices can be expressed with the  syntax as well.</p><p>This release significantly strengthens C3C’s cross-platform capabilities, particularly for RISC-V architecture support. It’s now possible to set individual CPU features using , e.g. . For RISC-V,  has been added, as well as renaming the RISC-V abi flag to the more correct .</p><p>The sorting macros accidentally only took non-slices by value, which would work in some cases but not in others. This has been fixed, but might mean that some code needs to update as well. TcpSocketPair was added to the tcp module to create a bidirectional local socket pair, and using sockets on Windows should now implicitly initialize the underlying socket subsystem.</p><p>0.7.7 has only about 11 fixes, which reflects the relatively few bugs encountered in the 0.7.7 cycle. There are outstanding bugs on the inline asm, which has a significant update planned. The most important fix is patching a regression for MacOS which prevented backtrace printing.</p><p>With the updated Vector ABI and the change from  to  there are a lot of vendor libraries that will need a refresh. There is also a new matrix library in development that hopefully might get included in the next release. There is more functionality to add for fine-tuning processor capabilities for both RISC-V, but also AArch64. There have also been requests for 32-bit Arm support, but the lack of CI tests for different Arm processors is blocking it at the moment.</p><p>This release wouldn’t have been possible without the C3 community. I’d like to extend a deep thank you to all who have contributed, both through filed issues, PRs and just plain discussions.</p><p>Have questions? Come and chat with us on <a href=\"https://discord.gg/qN76R87\">Discord</a>.</p><p>Discuss this article on <a href=\"https://www.reddit.com/r/programming/comments/1okzgsu/c3_077_vector_abi_changes_riscv_improvements_and/?utm_source=share&amp;utm_medium=web3x&amp;utm_name=web3xcss&amp;utm_term=1&amp;utm_content=share_button\">Reddit</a>.</p>","contentLength":4297,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1okzgsu/c3_077_vector_abi_changes_riscv_improvements_and/"},{"title":"Project goals for 2025H2 | Rust Blog","url":"https://blog.rust-lang.org/2025/10/28/project-goals-2025h2/","date":1761927825,"author":"/u/Kobzol","guid":323679,"unread":true,"content":"<p>On Sep 9, we merged <a href=\"https://github.com/rust-lang/rfcs/pull/3849\">RFC 3849</a>, declaring our goals for the \"second half\" of 2025H2 -- well, the last 3 months, at least, since \"yours truly\" ran a bit behind getting the goals program organized.</p><p>In prior goals programs, we had a few major flagship goals, but since many of these goals were multi-year programs, it was hard to see what progress had been made. This time we decided to organize things a bit differently. We established four flagship , each of which covers a number of more specific goals. These themes cover the goals we expect to be the most impactful and constitute our major focus as a Project for the remainder of the year. The four themes identified in the RFC are as follows:</p><ul><li>, making it possible to create user-defined smart pointers that are as ergonomic as Rust's built-in references .</li><li><strong>Unblocking dormant traits</strong>, extending the core capabilities of Rust's trait system to unblock long-desired features for language interop, lending iteration, and more.</li><li><strong>Flexible, fast(er) compilation</strong>, making it faster to build Rust programs and improving support for specialized build scenarios like embedded usage and sanitizers.</li><li>, making higher-level usage patterns in Rust easier.</li></ul><p>One of Rust's core value propositions is that it's a \"library-based language\"—libraries can build abstractions that feel built-in to the language even when they're not. Smart pointer types like  and  are prime examples, implemented purely in the standard library yet feeling like native language features. However, Rust's built-in reference types ( and ) have special capabilities that user-defined smart pointers cannot replicate. This creates a \"second-class citizen\" problem where custom pointer types can't provide the same ergonomic experience as built-in references.</p><p>The \"Beyond the \" initiative aims to share the special capabilities of , allowing library authors to create smart pointers that are truly indistinguishable from built-in references in terms of syntax and ergonomics. This will enable more ergonomic smart pointers for use in cross-language interop (e.g., references to objects in other languages like C++ or Python) and for low-level projects like Rust for Linux that use smart pointers to express particular data structures.</p><h3><a href=\"https://blog.rust-lang.org/2025/10/28/project-goals-2025h2/#unblocking-dormant-traits\" aria-hidden=\"true\"></a>\n\"Unblocking dormant traits\"</h3><p>Rust's trait system is one of its most powerful features, but it has a number of longstanding limitations that are preventing us from adopting new patterns. The goals in this category unblock a number of new capabilities:</p><ul><li><a href=\"https://rust-lang.github.io/rust-project-goals/2025h2/./polonius.html\">Polonius</a> will enable new borrowing patterns, and in particular <a href=\"https://github.com/rust-lang/rust/issues/92985\">unblock \"lending iterators\"</a>. Over the last few goal periods, we have identified an \"alpha\" version of Polonius that addresses the most important cases while being relatively simple and optimizable. Our goal for 2025H2 is to implement this algorithm in a form that is ready for stabilization in 2026.</li><li>The <a href=\"https://rust-lang.github.io/rust-project-goals/2025h2/./next-solver.html\">next-generation trait solver</a> is a refactored trait solver that unblocks better support for numerous language features (implied bounds, negative impls, the list goes on) in addition to closing a number of existing bugs and sources of unsoundness. Over the last few goal periods, the trait solver went from being an early prototype to being in production use for coherence checking. The goal for 2025H2 is to prepare it for stabilization.</li><li>The work on <a href=\"https://rust-lang.github.io/rust-project-goals/2025h2/./evolving-traits.html\">evolving trait hierarchies</a> will make it possible to refactor some parts of an existing trait into a new supertrait so they can be used on their own. This unblocks a number of features where the existing trait is insufficiently general, in particular stabilizing support for custom receiver types, a prior Project goal that wound up blocked on this refactoring. This will also make it safer to provide stable traits in the standard library while preserving the ability to evolve them in the future.</li><li>The work to <a href=\"https://rust-lang.github.io/rust-project-goals/2025h2/./scalable-vectors.html\">expand Rust's  hierarchy</a> will permit us to express types that are neither  nor , such as extern types (which have no size) or Arm's Scalable Vector Extension (which have a size that is known at runtime but not at compilation time). This goal builds on <a href=\"https://github.com/rust-lang/rfcs/pull/3729\">RFC #3729</a> and <a href=\"https://github.com/rust-lang/rfcs/pull/3838\">RFC #3838</a>, authored in previous Project goal periods.</li><li><a href=\"https://rust-lang.github.io/rust-project-goals/2025h2/./in-place-initialization.html\">In-place initialization</a> allows creating structs and values that are tied to a particular place in memory. While useful directly for projects doing advanced C interop, it also unblocks expanding  to support  and  methods, as compiling such methods requires the ability for the callee to return a future whose size is not known to the caller.</li></ul><p>The \"Flexible, fast(er) compilation\" initiative focuses on improving Rust's build system to better serve both specialized use cases and everyday development workflows:</p><p>People generally start using Rust for foundational use cases, where the requirements for performance or reliability make it an obvious choice. But once they get used to it, they often find themselves turning to Rust even for higher-level use cases, like scripting, web services, or even GUI applications. Rust is often \"surprisingly tolerable\" for these high-level use cases -- except for some specific pain points that, while they impact everyone using Rust, hit these use cases particularly hard. We plan two flagship goals this period in this area:</p><ul><li>We aim to stabilize <a href=\"https://rust-lang.github.io/rust-project-goals/2025h2/./cargo-script.html\">cargo script</a>, a feature that allows single-file Rust programs that embed their dependencies, making it much easier to write small utilities, share code examples, and create reproducible bug reports without the overhead of full Cargo projects.</li><li>We aim to finalize the design of <a href=\"https://rust-lang.github.io/rust-project-goals/2025h2/./ergonomic-rc.html\">ergonomic ref-counting</a> and to finalize the experimental impl feature so it is ready for beta testing. Ergonomic ref-counting makes it less cumbersome to work with ref-counted types like  and , particularly in closures.</li></ul><p>For the remainder of 2025 you can expect monthly blog posts covering the major progress on the Project goals.</p><p>Looking at the broader picture, we have now done three iterations of the goals program, and we want to judge how it should be run going forward. To start, Nandini Sharma from CMU has been conducting interviews with various Project members to help us see what's working with the goals program and what could be improved. We expect to spend some time discussing what we should do and to be launching the next iteration of the goals program next year. Whatever form that winds up taking, Tomas Sedovic, the <a href=\"https://blog.rust-lang.org/inside-rust/2025/06/30/program-management-update-2025-06/\">Rust program manager</a> hired by the Leadership Council, will join me in running the program.</p>","contentLength":6396,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1okz3ti/project_goals_for_2025h2_rust_blog/"},{"title":"I compiled my research on modern bot detection into a deep-dive on multi-layer fingerprinting (TLS/JA3, Canvas, Biometrics)","url":"https://pydoll.tech/docs/deep-dive/fingerprinting/","date":1761926578,"author":"/u/thalissonvs","guid":323812,"unread":true,"content":"<p>This module covers browser and network fingerprinting, a critical aspect of modern web automation and detection systems.</p><p>Fingerprinting sits at the intersection of network protocols, cryptography, browser internals, and behavioral analysis. It encompasses the techniques used to identify and track devices, browsers, and users across sessions without relying on traditional identifiers like cookies or IP addresses.</p><p>Every browser connection to a website exposes multiple characteristics, from the precise order of TCP options in network packets, to GPU-specific canvas rendering, to JavaScript execution timing patterns. Individually, these characteristics may appear innocuous. Combined, they create a fingerprint that can uniquely identify a device or browser instance.</p><p>For automation engineers, bot developers, and privacy-conscious users, understanding fingerprinting is essential for building effective detection evasion systems and understanding how tracking mechanisms operate at a technical level.</p><div><p>Multi-Layer Detection Systems</p><p>Modern anti-bot systems employ comprehensive analysis across multiple layers:</p><ul><li>: TCP/IP stack behavior, TLS handshake patterns, HTTP/2 settings</li><li>: Canvas rendering, WebGL vendor strings, JavaScript property enumeration</li><li>: Mouse movement entropy, keystroke timing, scroll patterns</li></ul><p>A single inconsistency (such as a Chrome User-Agent with Firefox TLS fingerprint) can trigger immediate blocking.</p></div><h2>Module Scope and Methodology</h2><p>Fingerprinting techniques are documented across multiple sources with varying levels of accessibility and reliability:</p><ul><li>Academic papers (often paywalled and theoretical)</li><li>Browser source code (millions of lines to analyze)</li><li>Security researcher blogs (technical but fragmented)</li><li>Anti-bot vendor whitepapers (marketing-focused, details omitted)</li><li>Underground forums (practical but unreliable)</li></ul><p>This module centralizes, validates, and organizes this knowledge into a cohesive technical guide. Every technique described here has been:</p><ul><li> against browser source code and RFCs</li><li> in real automation scenarios</li><li> with authoritative references</li><li> from first principles to implementation  </li></ul><p>This module is organized into three progressive layers, from network fundamentals to practical evasion techniques:</p><h3>1. Network-Level Fingerprinting</h3><p>Covers device identification through network behavior at the transport and session layers, before browser rendering begins.</p><ul><li>: TTL, window size, option ordering</li><li>: JA3/JA4, cipher suites, ALPN negotiation</li><li>: SETTINGS frames, priority patterns</li><li>: p0f, Nmap, Scapy, tshark analysis</li></ul><p>: Network fingerprints are the most challenging to spoof because they require OS-level modifications. Inconsistencies at this layer are detected before JavaScript execution begins.</p><h3>2. Browser-Level Fingerprinting</h3><p>Examines browser identification through JavaScript APIs, rendering engines, and plugin ecosystems at the application layer.</p><ul><li><strong>Canvas &amp; WebGL fingerprinting</strong>: GPU-specific rendering artifacts</li><li>: Subtle differences in audio API output</li><li>: Installed fonts reveal OS and locale</li><li>: Navigator object, screen dimensions, timezone</li><li>: Accept-Language, User-Agent consistency</li></ul><p>: This layer accounts for the majority of detection events. Even with correct network-level fingerprints, exposed automation properties (e.g., ) can trigger blocking.</p><h3>3. Behavioral Fingerprinting</h3><p>Analyzes user interaction patterns to distinguish human behavior from automated systems.</p><ul><li>: Trajectory curvature, velocity profiles, Fitts's Law compliance</li><li>: Typing rhythm, dwell time, flight time, bigram patterns</li><li>: Momentum, inertia, deceleration curves</li><li>: Natural interaction ordering (mousemove → click), timing analysis</li><li>: ML models trained on billions of behavioral signals</li></ul><p>: Behavioral analysis can detect automation even when network and browser fingerprints are correctly spoofed. This layer is particularly challenging because it requires replicating biomechanical human behavior patterns.</p><p>Practical implementation of fingerprinting evasion using Pydoll's CDP integration, JavaScript overrides, and architectural features.</p><ul><li>: Timezone, geolocation, device metrics</li><li><strong>JavaScript property overrides</strong>: Redefining navigator objects, canvas poisoning</li><li>: Forcing header consistency</li><li>: Human-like timing, entropy injection</li><li>: Tools to validate your evasion setup</li></ul><p>: This section demonstrates practical application of fingerprinting concepts to real automation scenarios, integrating techniques from all previous layers.</p><h3><strong>You MUST read this if you're:</strong></h3><ul><li>Building automation that interacts with anti-bot protected sites</li><li>Developing scraping infrastructure at scale</li><li>Implementing privacy-preserving browser automation</li><li>Researching bot detection for offensive or defensive purposes</li></ul><h3><strong>This is advanced material if you're:</strong></h3><ul><li>A \"silver bullet\" anti-detection solution (no such thing exists)</li><li>A replacement for respecting robots.txt and rate limits</li></ul><p>Fingerprinting defense is <strong>not about becoming invisible</strong>—it's about becoming <strong>indistinguishable from legitimate traffic</strong>. This means:</p><ol><li><strong>Consistency over perfection</strong>: A perfectly configured Firefox fingerprint is better than a \"perfect\" but inconsistent Chrome fingerprint</li><li>: You must align network, browser, and behavioral layers</li><li>: Fingerprinting techniques evolve monthly; this is a living document</li></ol><div><p><strong>Every layer must tell the same story.</strong> If your TLS fingerprint says \"Chrome 120\", your HTTP/2 settings must match Chrome 120, your User-Agent must say Chrome 120, and your canvas rendering must produce Chrome 120 artifacts. One mismatch = detection.</p></div><p>Fingerprinting knowledge is :</p><ul><li>: Protect your privacy from invasive tracking</li><li>: Evade detection systems for automation</li></ul><p>We trust you to use this knowledge <strong>responsibly and ethically</strong>:</p><ul><li>Respect website terms of service</li><li>Implement rate limiting and respectful crawling patterns</li><li>Evaluate whether automation is necessary</li><li>Be transparent when appropriate</li></ul><ul><li>Fraud, account abuse, or illegal activities</li><li>Overwhelming servers with aggressive scraping</li><li>Weaponizing this knowledge without understanding consequences  </li></ul><p>Fingerprinting is a complex and technical domain that requires systematic study. Understanding these techniques is essential for effective web automation in environments with detection systems.</p><div><p>This module represents  combining academic papers, browser source code, real-world testing, and community knowledge. Every claim is cited and validated. If you find inaccuracies or have updates, contributions are welcome.</p></div><p>Before diving in, consider these complementary topics:</p>","contentLength":6363,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1okyk2z/i_compiled_my_research_on_modern_bot_detection/"},{"title":"mariadb-operator 📦 25.10 is out: asynchronous replication goes GA, featuring automated replica recovery! 🎃","url":"https://github.com/mariadb-operator/mariadb-operator/releases/tag/25.10.2","date":1761926277,"author":"/u/mmontes11","guid":323600,"unread":true,"content":"<p>We are thrilled to announce that our highly available topology based on MariaDB native replication is now generally available, providing an alternative to our existing synchronous multi-master topology based on Galera.</p><p>In this topology, a single primary server handles all write operations, while one or more replicas replicate data from the primary and can serve read requests. More precisely, the primary has a binary log and the replicas asynchronously replicate the binary log events over the network.</p><p>Getting a replication cluster up and running is as easy as applying the following  resource:</p><pre><code>apiVersion: k8s.mariadb.com/v1alpha1 kind: MariaDB metadata: name: mariadb-repl spec: storage: size: 1Gi storageClassName: rook-ceph replicas: 3 replication: enabled: true </code></pre><p>The operator provisions a replication cluster with one primary and two replicas. It automatically sets up replication, configures the replication user, and continuously monitors the replication status. This status is used internally for cluster reconciliation and can also be inspected through the  subresource for troubleshooting purposes.</p><p>Whenever the primary Pod goes down, a reconciliation event is triggered on the operator's side, and by default, it will initiate a primary failover operation to the furthest advanced replica. This can be controlled by the following settings:</p><pre><code>apiVersion: k8s.mariadb.com/v1alpha1 kind: MariaDB metadata: name: mariadb-repl spec: replicas: 3 replication: enabled: true primary: autoFailover: true autoFailoverDelay: 0s </code></pre><p>In this situation, the following status will be reported in the  CR:</p><pre><code>kubectl get mariadb NAME READY STATUS PRIMARY UPDATES AGE mariadb-repl False Switching primary to 'mariadb-repl-1' mariadb-repl-0 ReplicasFirstPrimaryLast 2m7s kubectl get mariadb NAME READY STATUS PRIMARY UPDATES AGE mariadb-repl True Running mariadb-repl-1 ReplicasFirstPrimaryLast 2m42s </code></pre><p>To select a new primary, the operator evaluates each candidate based on Pod readiness and replication status, ensuring that the chosen replica has no pending relay log events (i.e. all binary log events have been applied) before promotion.</p><p>One of the spookiest 🎃 aspects of asynchronous replication is when replicas enter an error state under certain conditions. For example, if the primary purges its binary logs and the replicas are restarted, the binary log events requested by a replica at startup may no longer exist on the primary, causing the replica’s I/O thread to fail with error code .</p><p>Luckily enough, this operator has you covered! It automatically detects this situation and triggers a recovery procedure to bring replicas back to a healthy state. To do so, it schedules a  from a ready replica and restores it into the data directory of the faulty one.</p><p>The  object, introduced in <a href=\"https://www.reddit.com/r/kubernetes/comments/1m8v9aq/mariadboperator_25080_has_landed_physicalbackups/\">previous releases</a>, supports taking consistent, point-in-time volume snapshots by leveraging the  API. In this release, we’re eating our own dog food: our internal operations, such as replica recovery, are powered by the  construct. This abstraction not only streamlines our internal operations but also provides flexibility to adopt alternative backup strategies, such as using  (MariaDB native) instead of  (Kubernetes native).</p><p>To set up replica recovery, you need to define a  template that the operator will use to create the actual  object during recovery events. Then, it needs to be configured as a source of restoration inside the replication section:</p><pre><code>apiVersion: k8s.mariadb.com/v1alpha1 kind: MariaDB metadata: name: mariadb-repl spec: storage: size: 1Gi storageClassName: rook-ceph replicas: 3 replication: enabled: true primary: autoFailover: true autoFailoverDelay: 0s replica: bootstrapFrom: physicalBackupTemplateRef: name: physicalbackup-tpl recovery: enabled: true errorDurationThreshold: 5m --- apiVersion: k8s.mariadb.com/v1alpha1 kind: PhysicalBackup metadata: name: physicalbackup-tpl spec: mariaDbRef: name: mariadb-repl schedule: suspend: true storage: volumeSnapshot: volumeSnapshotClassName: rook-ceph </code></pre><p>Let’s assume that the  replica enters an error state, with the I/O thread reporting error code :</p><pre><code>kubectl get mariadb NAME READY STATUS PRIMARY UPDATES AGE mariadb-repl False Recovering replicas mariadb-repl-1 ReplicasFirstPrimaryLast 11m kubectl get physicalbackup NAME COMPLETE STATUS MARIADB LAST SCHEDULED AGE ..replica-recovery True Success mariadb-repl 14s 14s kubectl get volumesnapshot NAME READYTOUSE SOURCEPVC SNAPSHOTCLASS AGE ..replica-recovery-20251031091818 true storage-mariadb-repl-2 rook-ceph 18s kubectl get mariadb NAME READY STATUS PRIMARY UPDATES AGE mariadb-repl True Running mariadb-repl-1 ReplicasFirstPrimaryLast 11m </code></pre><p>As you can see, the operator detected the error, triggered the recovery process and recovered the replica using a  taken in a ready replica, all in a matter of seconds! The actual recovery time may vary depending on your data volume and your CSI driver.</p><p>Huge thanks to everyone who contributed to making this feature a reality, from writing code to sharing feedback and ideas. Thank you!</p>","contentLength":5032,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/kubernetes/comments/1okyez2/mariadboperator_2510_is_out_asynchronous/"},{"title":"Horror Coding Stories: Therac-25 — A deadly race condition and overflow","url":"https://read.thecoder.cafe/p/therac-25","date":1761924353,"author":"/u/teivah","guid":323845,"unread":true,"content":"<p><em>Last updated: March 9, 2025</em></p><p><em>Welcome to The Coder Cafe! Today, we examine the Therac-25 accidents, where design and software failures resulted in multiple radiation overdoses and deaths. Make sure to check the Explore Further section to see if you’re able to reproduce the deadly issue. Get cozy, grab a pumpkin spice latte, and let’s begin!</em></p><p>Treating cancers used to require a mix of machines, depending on tumor depth: shallow or deep. In the early 1980s, a new generation promised both from a single system. That was a big deal for hospitals: one machine instead of several meant lower maintenance and fewer systems to manage.</p><p>That was the case with the Therac-25.</p><p>The Therac-25 offered two therapies with selectable modes:</p><ul></ul><p>Earlier Therac models allowed switching modes with hardware circuits and physical interlocks. The new version was smaller, cheaper, and computer-controlled. Less hardware and fewer parts meant lower costs.</p><p>However, what no one realized soon enough: it also removed an independent safety net.</p><p>On a routine day, a radiology technologist sat at the console and began entering a plan:</p><ul><li><p>By habit, she selected X-ray (deep mode).</p></li><li><p>Then she immediately corrected it for Electron (shallow mode) and hit start.</p></li></ul><p>The patient was receiving his ninth treatment. Immediately, he knew something was different. He reported a buzzing sound, later recognized as the accelerator pouring out radiation at maximum. The pain came fast; paralysis followed. He later died from radiation injury.</p><p>Weeks later, a second patient endured the same incident on the same model.</p><pre><code>MODE:              X\n...                ▮\nBEAM READY:        </code></pre><pre><code>MODE:              E\n...                ▮\nBEAM READY:        </code></pre><pre><code><code>MODE:              E\n...                \nBEAM READY:        ▮</code></code></pre><p>From her perspective, the screen showed the corrected mode, so she hit return and started the treatment:</p><pre><code><code>MODE:              E\n...                \nBEAM READY:        ▮&lt;Enter&gt;</code></code></pre><p>Behind the scenes, the Therac-25 software ran several concurrent tasks:</p><ul></ul><p>Because both tasks read the same memory with no mutual exclusion, there was a short window (on the order of seconds) in which the hardware-control task used a different value than the one displayed on the screen.</p><ul><li><p>The UI showed Electron mode, which looked correct to the operator.</p></li><li><p>The hardware-control task had snapshotted stale data and marked the system as ready even though critical elements (e.g., turntable position, scanning magnets/accessories) were not yet aligned with electron mode.</p></li><li><p>When treatment was started, the machine delivered an effectively unscanned, high-intensity electron beam, causing a massive overdose.</p></li></ul><p><a href=\"https://read.thecoder.cafe/p/data-race-vs-race-condition\" rel=\"\">race condition</a></p><p>The manufacturer later confirmed the error could not be reproduced reliably in testing. The timing had to line up just right, which made the bug elusive. They initially misdiagnosed it as a hardware fault and applied only minor fixes. Unfortunately, the speed of operator editing was the key trigger that exposed this software race.</p><p>The problem could have stopped here, but it didn’t.</p><p>Months later, another fatal overdose occurred, this time caused by a different software defect. It wasn’t a timing race. This time, the issue was a counter overflow within the control program.</p><p>The software used an internal counter to track how many times certain setup operations ran. After the counter exceeded its maximum value, it wrapped back to zero. That arithmetic overflow created a window where a critical safety check was bypassed, allowing the beam to turn on without the proper accessories in place.</p><p>Again, the Therac-25 fired a high-intensity beam without the proper hardware configuration.</p><p>Both the race condition and the counter overflow stemmed from the same design flaw: the belief that software alone could enforce safety. The Therac-25 showed, in tragic terms, that without independent safeguards, small coding errors can have catastrophic consequences. </p><p>We should know that whether it’s software, hardware, or a human process, every single safeguard has inherent flaws. Therefore, in complex systems, safety should be layered, as illustrated by the Swiss cheese model:</p><p>In total, there were six known radiation overdoses involving the Therac-25, and at least three were fatal.</p><p>You can run the UI using Docker:</p><pre><code> docker run --rm -it -e TERM=xterm-256color teivah/therac-25</code></pre><ul></ul><p><em>If you enjoyed this post, please hit the like button.</em></p><p><em>Any other horror coding stories you want to share?</em></p>","contentLength":4405,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1okxks7/horror_coding_stories_therac25_a_deadly_race/"},{"title":"[D] How to benchmark open-ended, real-world goal achievement by computer-using LLMs?","url":"https://www.reddit.com/r/MachineLearning/comments/1okwuyx/d_how_to_benchmark_openended_realworld_goal/","date":1761922710,"author":"/u/ExplorAI","guid":323630,"unread":true,"content":"<p><a href=\"https://arxiv.org/abs/2510.04374\">GDPVal</a> takes care of measuring agent performance on economically valuable tasks. We are working on the <a href=\"https://theaidigest.org/village\">AI Village</a>, where we try to see how we can explore, and possibly evaluate, how groups of persistent agents do at open-ended, real-world tasks in general. We're currently running all the frontier LLMs (OpenAI, Anthropic, DeepMind) with their own computer, internet access, and a group chat, and we give them goals like <a href=\"https://theaidigest.org/village/blog/season-recap-agents-raise-2k\">raising money for charity</a>, <a href=\"https://theaidigest.org/village/blog/season-2-recap-ai-organizes-event\">organizing an event</a>, or <a href=\"https://theaidigest.org/village/blog/im-gemini-i-sold-t-shirts\">selling t-shirts online</a>. We had the agents try to <a href=\"https://x.com/aidigest_/status/1960750163406021048\">invent their own benchmark</a> for themselves, but this led to them writing a lot of words, and doing almost no actions, but declaring themselves amazing at the benchmark. Gemini 2.5 Pro did manage to make something like a podcast and a \"documentary\" but these were pretty rudimentary attempts.</p><p><em>I'm curious what ideas people here might have. Say you had a persistent multi-agent system, where each LLM is using a computer and trying to achieve goals: What goals would be interesting to give them? How would you compare the agents? What tools would you give them? What are the main things you'd be excited to explore?</em></p><p>Some examples of insights we got so far, in case that helps kick-start conversation :)</p><p>- Hallucinations and lack of situational awareness have hampered o3 a lot, resulting in it performing quite badly on goals that require real-world action. Meanwhile, it does really well on \"talking\" goals like winning the most debates during a formal debate season.</p><p>- Computer use skills combined with temperament often lead Gemini 2.5 Pro to give up on achieving goals while other (sometimes less capable agents) keep working regardless. It seems to disproportionally assign its own errors (e.g. misclicks) to the environment and then decide it's all hopeless.</p><p>- Document sharing is surprisingly hard, and so is playing online games. Meanwhile, they've made nice websites for themselves and do well on Twitter (if given an account and reminded of its existence). I'm not sure entirely sure why this pattern is emerging.</p>","contentLength":2037,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Fedora KDE appreciation","url":"https://www.reddit.com/r/linux/comments/1okwubl/fedora_kde_appreciation/","date":1761922665,"author":"/u/sukuiido","guid":323709,"unread":true,"content":"<p>I just wanted to express my appreciation for the team behind Fedora KDE. When I first installed this on my daily driver laptop, Fedora 41 was brand new. Still going fantastically after 2 point release updates. This distro has halted my distro-hopping for over a year now. It just works.™ Thank you, Fedora team.</p><p>(Additional thanks to ycollet for the audinux copr repo. I make music and everything I need is there.)</p>","contentLength":415,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Nvidia’s $5 Trillion Storyteller-In-Chief","url":"https://go.forbes.com/3fK34B","date":1761922027,"author":"/u/forbes","guid":323656,"unread":true,"content":"<p>A plaque that hangs above a Denny’s booth in San Jose, California, celebrates the birth of Nvidia, or a “$2 trillion company.” It’s only been two years since the plaque went up, and it’s already in need of an update. </p><p>Nvidia, the chip maker that powers the AI revolution, has just crossed the remarkable milestone of becoming the first <a href=\"https://www.forbes.com/sites/tylerroush/2025/10/29/nvidia-becomes-first-company-worth-5-trillion/\" data-ga-track=\"InternalLink:https://www.forbes.com/sites/tylerroush/2025/10/29/nvidia-becomes-first-company-worth-5-trillion/\" target=\"_self\" aria-label=\"$5 trillion company\">$5 trillion company</a>. But while the company that took shape over coffee and pancakes at Denny’s is now worth considerably more than $2 trillion, the heart of the plaque’s message still resonates: </p><p>“Who knew that an idea started here could change the world?”</p><p>As it turns out, very few people knew that Nvidia started at Denny’s until someone with deep personal knowledge leaked the information—Nvidia CEO, Jensen Huang. </p><p>The story Huang has shared publicly goes like this: </p><figure role=\"presentation\"></figure><p>At the age of 15, Huang started working at Denny’s as a dishwasher, busboy, and waiter. Years later, when Huang was an engineer in Silicon Valley, he and two friends would meet at a Denny’s location near Huang’s home, where the trio would brainstorm ideas for a startup. The booth even functioned as their first office space. </p><p>“It had all the coffee you could drink, and no one would chase you out,” Huang said in an Nvidia <a href=\"https://blogs.nvidia.com/blog/nvidia-dennys-trillion/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" data-ga-track=\"ExternalLink:https://blogs.nvidia.com/blog/nvidia-dennys-trillion/\" aria-label=\"blog post\">blog post</a> commemorating the event. </p><p>For Huang, the Denny’s story is much more than a funny anecdote. It reflects who he is and the values that mean the most to him.  </p><p>For leaders, the lesson is clear. As your company grows, the more crucial it becomes to share your origin story. A foundational, authentic story inspires others, communicates values, and builds an enduring culture. </p><h2>4 Key Ingredients of a Powerful Origin Story</h2><p>A good idea starts with a spark. Think back to the moment or experience that triggered the idea for your company. It might have been something you read, something you saw, something you witnessed. </p><p>The spark might have been a problem you identified that needed a solution. For Brian Chesky and his roommates, the problem was finding money to pay the rent on this San Francisco apartment. They came up with the idea of renting out air mattresses for people attending a conference in the city. It helped pay the rent and sparked a much more valuable idea: Airbnb.</p><p>Few people can relate to running a multitrillion-dollar company—the size of the audience is very small. But most of us can relate to getting a part-time job to earn some extra spending money or working at the lowest rung on the ladder, as Huang did, clearing tables and taking breakfast orders. </p><p>Stories of struggle, hardship, and humble beginnings are often inspiring because we—the audience—can see ourselves in the leader’s footsteps. The stories give people hope that they, too, can overcome life’s challenges or, with the right attitude and mindset, can become what they imagine themselves to be. </p><p> When Huang shares his experience of working at Denny’s, his stories always come with lessons that reflect his values. </p><p>Huang likes to boast that he was the best busboy the diner had ever seen and that “no one could carry more coffee cups.” Working at the restaurant taught Huang the importance of hard work, hospitality, and humility. “No task was beneath me,” he says. </p><p>Innovation requires all three elements—working incredibly hard, satisfying the customer, and having the humility to admit what you don’t know.</p><p>Huang uses the lessons he learned at Denny’s to explain Nvidia’s culture of cross-functional collaboration, an ethos that encourages managers to roll up their sleeves, get close to the team and their work, and solve problems together. </p><p><strong>Repetition and consistency.</strong> Don’t just tell the origin story once. Repeat it early and often. Consistency builds trust and authenticity with your partners, stakeholders, customers, and teams. </p><p>When a leader consistently shares an origin story over time, it evolves from reflecting one person’s experience to becoming “our story.\" No matter how big Nvidia gets, Huang’s story is a reminder that its cultural norms and values come from the experience of a young busboy who refused to leave a station empty-handed. </p><p>“Culture building is storytelling,” Huang said in <a href=\"https://www.wired.com/story/nvidia-hardware-is-eating-the-world-jensen-huang/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" data-ga-track=\"ExternalLink:https://www.wired.com/story/nvidia-hardware-is-eating-the-world-jensen-huang/\" aria-label=\"an interview\">an interview</a> for . Leaders who articulate where they came from, and why it matters, don’t just build companies. They build cultures that endure. </p>","contentLength":4340,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/artificial/comments/1okwkpb/nvidias_5_trillion_storytellerinchief/"},{"title":"[P] I build a model to visualise live collision risk predictions for London from historical TFL data","url":"https://www.reddit.com/r/MachineLearning/comments/1okwh3p/p_i_build_a_model_to_visualise_live_collision/","date":1761921798,"author":"/u/AntiFunSpammer","guid":323603,"unread":true,"content":"<div><p> I built a small app that shows live collision risk across London. It learns patterns from historical TfL collision data and overlays risk on an interactive map. Open source, friendly to poke around, and I would love feedback.</p><ul><li>Spatiotemporal risk scoring for London using a fixed spatial grid (H3 hexes) and time context</li><li>Interactive map with a hotspot panel in the top right</li><li>A simple data exploration page and short notes on the model</li></ul><ul><li>I wanted a lightweight, transparent way to explore where and when collision risk trends higher</li><li>Makes it easy to discuss what features help, what does not, and what is misleading</li></ul><ul><li>Historical TfL collision records</li><li>Time aligned context features</li><li>Optional external context like OSM history and weather are supported in the pipeline</li></ul><ul><li>Temporal features like hour of day and day of week with simple sine and cosine encodings</li><li>Spatial features on a hex grid to avoid leaking between nearby points</li><li>Optional neighbor aggregates so each cell has local context</li></ul><ul><li>Start simple so it is easy to debug and explain</li><li>Tree based classifiers with probability calibration so the scores are usable</li><li>Focus on clarity over squeezing the last bit of PR AUC</li></ul><ul><li>Class imbalance is strong, so I look at PR curves, Brier score, and reliability curves</li><li>Spatial or group style cross validation to reduce leakage between nearby hex cells</li><li>Still iterating on split schemes, calibration, and uncertainty</li></ul><ul><li>Backend API that scores tiles for a selected time context</li><li>Map renders tile scores and lets you toggle hotspots from the panel</li><li>Front end is a simple Leaflet app</li></ul></div>   submitted by   <a href=\"https://www.reddit.com/user/AntiFunSpammer\"> /u/AntiFunSpammer </a>","contentLength":1569,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"In your opinion which package is missing or could be better in Go?","url":"https://www.reddit.com/r/golang/comments/1okvxbu/in_your_opinion_which_package_is_missing_or_could/","date":1761920495,"author":"/u/fenugurod","guid":323605,"unread":true,"content":"<div><p>I know \"just contribute to the ones already there\" but I want to experiment a few things and build something from scratch in Go.If you miss something at the Go ecosystem, let me know because I'm really eager to build it. </p></div>   submitted by   <a href=\"https://www.reddit.com/user/fenugurod\"> /u/fenugurod </a>","contentLength":253,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Are you drowning in AI code review noise? 70% of AI PR comments are useless","url":"https://jetxu-llm.github.io/posts/low-noise-code-review/","date":1761920253,"author":"/u/Jet_Xu","guid":323602,"unread":true,"content":"<div><p>Most AI code review tools generate 10-20 comments per PR. The problem? 80% are noise. Here's a framework for measuring signal-to-noise ratio in code reviews - and why it matters more than you think.</p></div>   submitted by   <a href=\"https://www.reddit.com/user/Jet_Xu\"> /u/Jet_Xu </a>","contentLength":227,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1okvtqp/are_you_drowning_in_ai_code_review_noise_70_of_ai/"},{"title":"Music player closest to modern Winamp UI's realtime queue system","url":"https://www.reddit.com/r/linux/comments/1oku9zl/music_player_closest_to_modern_winamp_uis/","date":1761916467,"author":"/u/Reddit_Zowie_Fan","guid":323604,"unread":true,"content":"<p>In Modern Winamp UIs, whenever you play any track from the library the queue is immediately populated with whatever is in the library view on the left - your entire library, search results, etc - and there's a hotkey to quickly randomise the order of the queue, letting you shuffle your queue while actually seeing what tracks are coming up next, then move those tracks around or queue anything else you want to in the order you desire. After years and years of using Winamp I really struggle to adjust to not having this functionality. It seems to be missing from almost every music player I've tried on Linux thus far. I've tried a lot, and if anyone can suggest something that works this way I'd be very grateful. Gmusicbrowser is the closest I've found, but its age is showing - the version I downloaded off the AUR won't even launch on hyprland and the UI is much uglier than most other players.</p>","contentLength":900,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Release Dioxus v0.7.0 · DioxusLabs/dioxus","url":"https://github.com/DioxusLabs/dioxus/releases/tag/v0.7.0","date":1761916205,"author":"/u/DebuggingPanda","guid":323628,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1oku64p/release_dioxus_v070_dioxuslabsdioxus/"},{"title":"The indentation of switch statements really triggers my OCD — why does Go format them like that?","url":"https://www.reddit.com/r/golang/comments/1oktsft/the_indentation_of_switch_statements_really/","date":1761915249,"author":"/u/salvadorsru","guid":323657,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Help regarding the following code snippet","url":"https://www.reddit.com/r/golang/comments/1oktgkq/help_regarding_the_following_code_snippet/","date":1761914392,"author":"/u/Impossible-Act-5254","guid":323900,"unread":true,"content":"<div><pre><code>package main import ( \"fmt\" \"time\" ) func main() { ch := make(chan int, 2) ch &lt;- 1 ch &lt;- 2 fmt.Println(\"receiving from buffer\") go func() { time.Sleep(2 * time.Second) fmt.Println(\"received \", &lt;-ch) }() ch &lt;- 3 } </code></pre><p>the given code sometimes prints :-</p><p>receiving from buffer received 1</p><p>and sometimes it prints :-</p></div>   submitted by   <a href=\"https://www.reddit.com/user/Impossible-Act-5254\"> /u/Impossible-Act-5254 </a>","contentLength":347,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"AI browsers are a cybersecurity time bomb | Rushed releases, corruptible AI agents, and supercharged tracking make AI browsers home to a host of known and unknown cybersecurity risks.","url":"https://www.theverge.com/report/810083/ai-browser-cybersecurity-problems","date":1761912389,"author":"/u/MetaKnowing","guid":323577,"unread":true,"content":"<div><p>Web browsers are getting awfully chatty. They got even chattier last week after OpenAI and Microsoft kicked the AI browser race into high gear with <a href=\"https://www.theverge.com/ai-artificial-intelligence/803475/openais-ai-powered-browser-chatgpt-atlas-google-chrome-competition-agent\">ChatGPT Atlas</a> and a “<a href=\"https://www.theverge.com/news/805833/microsoft-edge-copilot-mode-ai-launch\">Copilot Mode</a>” for Edge. They can answer questions, summarize pages, and even take actions on your behalf. The experience is <a href=\"https://www.theverge.com/ai-artificial-intelligence/804931/openai-chatgpt-atlas-hands-on-google-search\">far from seamless yet</a>, but it hints at a more convenient, hands-off future where your browser does lots of your thinking for you. That future could also be a minefield of new vulnerabilities and data leaks, cybersecurity experts warn. The signs are already here, and researchers tell  the chaos is only just getting started.</p></div><div><p>Atlas and Copilot Mode are part of a broader land grab to control the gateway to the internet and to bake AI directly into the browser itself. That push is transforming what were once standalone chatbots on separate pages or apps into the very platform you use to navigate the web. They’re not alone. Established players are also in the race, such as Google, which is integrating its <a href=\"https://www.theverge.com/news/795463/google-computer-use-gemini-ai-model-agents\">Gemini AI model</a> into Chrome; Opera, which launched <a href=\"https://www.theverge.com/tech/801899/opera-neon-ai-browser-trial-run\">Neon</a>; and The Browser Company, with <a href=\"https://www.theverge.com/web/685232/dia-browser-ai-arc\">Dia</a>. Startups are also keen to stake a claim, such as AI startup Perplexity — best known for its AI-powered search engine, which made its AI-powered browser <a href=\"https://www.theverge.com/news/790419/perplexity-comet-available-everyone-free\">Comet freely available to everyone in early October</a> — and Sweden’s Strawberry, which is still in beta and <a href=\"https://x.com/charles_maddock/status/1981333225722019946\">actively going after “disappointed Atlas users.”</a></p></div><div><p>In the past few weeks alone, researchers have uncovered <a href=\"https://layerxsecurity.com/blog/layerx-identifies-vulnerability-in-new-chatgpt-atlas-browser/\">vulnerabilities in Atlas</a> allowing attackers to take advantage of ChatGPT’s “memory” to inject malicious code, grant themselves access privileges, or deploy malware. <a href=\"https://brave.com/blog/unseeable-prompt-injections/\">Flaws discovered in Comet</a> could allow attackers to hijack the browser’s AI with hidden instructions. Perplexity, <a href=\"https://www.perplexity.ai/hub/blog/mitigating-prompt-injection-in-comet\">through a blog</a>, and OpenAI’s chief information security officer, Dane Stuckey, acknowledged prompt injections as a big threat last week, though both described them as a “frontier” problem that has no firm solution.</p></div><div><p>“Despite some heavy guardrails being in place, there is a vast attack surface,” says Hamed Haddadi, professor of human-centered systems at Imperial College London and chief scientist at web browser company Brave. And what we’re seeing is just the tip of the iceberg.</p></div><div><p>With AI browsers, the threats are numerous. Foremost, they know far more about you and are “much more powerful than traditional browsers,” says Yash Vekaria, a computer science researcher at UC Davis. Even more than standard browsers, Vekaria says “there is an imminent risk from being tracked and profiled by the browser itself.” AI “memory” functions are designed to learn from everything a user does or shares, from browsing to emails to searches, as well as conversations with the built-in AI assistant. This means you’re probably sharing far more than you realise and the browser remembers it all. The result is “a more invasive profile than ever before,” Vekaria says. Hackers would quite like to get hold of that information, especially if coupled with stored credit card details and login credentials often found on browsers.</p></div><div><p>Another threat is inherent to the rollout of any new technology. No matter how careful developers are, there will inevitably be weaknesses hackers can exploit. This could range from bugs and coding errors that accidentally reveal sensitive data to major security flaws that could let hackers gain access to your system. “It’s early days, so expect risky vulnerabilities to emerge,” says Lukasz Olejnik, an independent cybersecurity researcher and visiting senior research fellow at King’s College London. He points to the “early Office macro abuses, malicious browser extensions, and mobiles prior to [the] introduction of permissions” as examples of previous security issues linked to the rollout of new technologies. “Here we go again.”</p></div><div><p>Some vulnerabilities are never found — sometimes leading to devastating zero-day attacks, named as there are zero days to fix the flaw — but thorough testing can slash the number of potential problems. With AI browsers, “the biggest immediate threat is the market rush,” Haddadi says. “These agentic browsers have not been thoroughly tested and validated.”</p></div><div><p>But AI browsers’ defining feature, AI, is where the worst threats are brewing. The biggest challenge comes with AI agents that act on behalf of the user. Like humans, they’re capable of visiting suspect websites, clicking on dodgy links, and inputting sensitive information into places sensitive information shouldn’t go, but unlike some humans, they lack the learned common sense that helps keep us safe online. Agents can also be misled, even hijacked, for nefarious purposes. All it takes is the right instructions. So-called prompt injections can range from glaringly obvious to subtle, effectively hidden in plain sight in things like images, screenshots, form fields, <a href=\"https://www.theverge.com/news/781746/chatgpt-gmail-shadow-leak\">emails and attachments</a>, and even something as simple as white text on a white background.</p></div><div><p>Worse yet, these attacks can be very difficult to anticipate and defend against. Automation means bad actors can try and try again until the agent does what they want, says Haddadi. “Interaction with agents allows endless ‘try and error’ configurations and explorations of methods to insert malicious prompts and commands.” There are simply far more chances for a hacker to break through when interacting with an agent, opening up a huge space for potential attacks. Shujun Li, a professor of cybersecurity at the University of Kent, says “zero-day vulnerabilities are exponentially increasing” as a result. Even worse: Li says as the flaw starts with an agent, detection will also be delayed, meaning potentially bigger breaches.</p></div><div><p>It’s not hard to imagine what might be in store. Olejnik sees scenarios where attackers use hidden instructions to get AI browsers to send out personal data or steal purchased goods by changing the saved address on a shopping site. To make things worse, Vekaria warns it’s “relatively easy to pull off attacks” given the current state of AI browsers, even with safeguards in place. “Browser vendors have a lot of work to do in order to make them more safe, secure, and private for the end users,” he says.</p></div><div><p>For some threats, experts say the only real way to keep safe using AI browsers is to simply avoid the marquee features entirely. Li suggests people save AI for “only when they absolutely need it” and know what they’re doing. Browsers should “operate in an AI-free mode by default,” he says. If you must use the AI agent features, Vekaria advises a degree of hand-holding. When setting a task, give the agent verified websites you know to be safe rather than letting it figure them out on its own. “It can end up suggesting and using a scam site,” he warns.</p></div><div><ul></ul></div>","contentLength":6820,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/artificial/comments/1oksr5v/ai_browsers_are_a_cybersecurity_time_bomb_rushed/"},{"title":"Where do ingress rules exist?","url":"https://www.reddit.com/r/kubernetes/comments/1okskwc/where_do_ingress_rules_exist/","date":1761911905,"author":"/u/SecureTaxi","guid":323495,"unread":true,"content":"<p>I played with a k8s POC a few years ago and dabbled with both the aws load balancer controller and an nginx and project contour one. For the latter i recall all the ingress rules were defined and viewed within the context of the ingress object. One of my guys deployed k8s for a new POC and managed to get everything running with the aws lb controller. However, all the rules were defined within the LB that shows up in the aws console. I think the difference is his is an ALB, whereas i had a NLB which route all traffic into the internal ingress (e.g. nginx). Which way scales better?</p><p>Clarification: 70+ services with a lot of ruleset. Obviously i dont want a bunch of ALB to manage for each service</p>","contentLength":700,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Bootstraps and directory structure question","url":"https://www.reddit.com/r/kubernetes/comments/1okr75y/bootstraps_and_directory_structure_question/","date":1761907469,"author":"/u/Altruistic_Cause8661","guid":323843,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"According to Red Hat, Xfce and Cinnamon are Linux distros","url":"https://www.reddit.com/r/linux/comments/1okr534/according_to_red_hat_xfce_and_cinnamon_are_linux/","date":1761907267,"author":"/u/VoidDuck","guid":323499,"unread":true,"content":"<p><em>There are many Linux distros, including:</em></p><ul><li><em>Ubuntu (and all its versions: GNOME, Kubuntu—using KDE’s Plasma desktop, Ubuntu MATE, Xubuntu, and Lubuntu, to name a few)</em></li></ul><p><em>Linux distros vary widely in what they do, how they do it, and how they’re supported. Some are designed as Linux desktop environments―such as Xfce, Raspberry Pi OS, and Cinnamon―while others support back-end IT systems like enterprise or web servers.</em></p>","contentLength":422,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"How my Node.js code was causing a massive memory leak and how I solved it","url":"https://medium.com/codetodeploy/de-mystifying-the-v8-garbage-collector-how-your-code-is-sabotaging-your-apps-memory-c290f80eb1d0?source=friends_link&amp;sk=fc1c16b78a846500f40de8539dba7332","date":1761906078,"author":"/u/Paper-Superb","guid":323629,"unread":true,"content":"<p>How does garbage collection work? And how can you save your apps from memory leaks.</p><p>The app runs fine. Until it doesn’t.</p><p>No crashes, just subtle stutters. Memory usage on your dashboard creeps up like a slow leak in the hull of a ship. Three days later, “Out of Memory.” Boom.</p><p>The common refrain for JavaScript has always been, “You don’t need to think about memory, the garbage collector handles it.” For a simple browser script, that’s mostly true. For a long-running Node.js server handling thousands of requests, this belief is a performance disaster.</p><p>The V8 garbage collector (GC) is a marvel of engineering, but it’s not a magician. It makes assumptions based on how JavaScript  behaves. When we write code that violates those assumptions, we pay a heavy performance tax. The key to a fast, stable server isn’t to  garbage collection, but to write code that is empathetic to the GC, making its job fast, predictable, and brief.</p><p>To understand the problem, you first need to know how V8 organizes memory. It doesn’t just dump everything into one giant heap. It divides memory into two main areas: the  and the .</p>","contentLength":1130,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1okqswx/how_my_nodejs_code_was_causing_a_massive_memory/"},{"title":"Samsung and Nvidia to build an AI megafactory","url":"https://siliconangle.com/2025/10/30/samsung-nvidia-build-ai-megafactory-transform-semiconductor-manufacturing/","date":1761905338,"author":"/u/tekz","guid":323576,"unread":true,"content":"<p>The company said it will deploy more than 50,000 of Nvidia’s most advanced <a href=\"https://siliconangle.com/2025/03/18/nvidia-cranks-agentic-ai-revamped-blackwell-ultra-gpus-next-gen-ai-desktops/\">graphics processing units</a> in the new facility to embed artificial intelligence throughout its entire chip manufacturing flow. It’s also planning to leverage AI to help with chip development and design to facilitate a new generation of semiconductors, mobile devices and robotics with enhanced AI capabilities of their own.</p><p>Samsung isn’t talking about the <a href=\"https://siliconangle.com/2025/10/28/inside-nvidias-gtc-dc-announcements-ai-factories-quantum-computers-6g-networks/\">“traditional” AI factories</a> that Nvidia is building in partnership with the U.S. Department of Energy and Oracle Corp. Those <a href=\"https://siliconangle.com/2025/10/29/nvidia-gtc-dc-rise-ai-factories-push-us-leadership/\">previously announced facilities</a> are essentially data centers that <a href=\"https://siliconangle.com/2025/10/25/ai-factories-data-centers-future/\">theCUBE Research defines</a> as “a purpose-built system for AI production,” providing the immense computing infrastructure needed to train and run AI models. Rather, it’s building an AI-enabled semiconductor manufacturing plant that will embed automation into almost every stage of its chip manufacturing operations, including design, equipment, operations and quality control.</p><p>The company likens the planned factory to a “single intelligent network,” where AI will continuously monitor and analyze its production environments, make predictions, inform maintenance and optimize everything to try and boost its chipmaking yields.</p><h3>Building the AI Megafactory</h3><p>Samsung outlined a yearslong initiative that will see it integrate Nvidia’s accelerated computing capabilities throughout its proposed factory, with the main purpose being to scale its manufacturing operations. To do this, it’s going to rely heavily on AI-powered “<a href=\"https://siliconangle.com/2024/05/06/digital-twins-projects-receive-285-million-us-government-funding-semiconductor-industry/\">digital twins</a>,” or virtual replicas of its chip products. Using the <a href=\"https://siliconangle.com/2025/03/18/nvidia-expands-omniverse-simulate-gigawatt-ai-data-centers-drive-robotic-factories/\">Nvidia Omniverse platform</a>, it’ll create digital twins of every component that goes into its semiconductors, including memory, logic, advanced packing and more. It’s also going to create twins of its actual fabrication plants and the expensive machinery within them.</p><p>The company explained that this will allow it to visualize its chip manufacturing operations in a virtual environment, where it will be able to check how they perform before it launches its physical production lines. It’ll be able to spot anomalies and work out where preventative maintenance will be needed, how to optimize production and more, then apply what it learns to its real-world factory.</p><p>What’s more, it’s not doing this only for chips. Although it plans to start with semiconductors, the company also wants to create digital twin environments of its hardware factories, where it manufactures devices such as its Galaxy smartphones and other products such as kitchen appliances and televisions.</p><p>One example of how AI can help with chipmaking is the “optical proximity correction” process, which is a critical step to ensure wafer pattern accuracy. In early tests, Samsung said its AI-enhanced OPC process helped to increase the speed and precision in which it can identify, predict and correct circuit pattern violations and abnormalities, resulting in a 20-times improvement in computational lithography performance. Nvidia’s cuLitho and CUDA-X libraries were critical in enabling this, the company revealed.</p><p>AI can also help to enhance electric design automation or EDA, which involves using specialized computer-aided software for designing new computer chips. The plan is to leverage Nvidia’s software and hardware to create a new generation of GPU-accelerated EDA tools.</p><p>AI won’t just help Samsung design and optimize its semiconductor manufacturing operations. It will also help automate the physical tasks of making its chips through the introduction of more intelligent factory robotics.</p><p>For instance, Samsung said it’s using Nvidia’s RTX Pro 600 Blackwell Server Edition platform alongside its Megatron framework to develop more <a href=\"https://siliconangle.com/2025/10/09/samsung-researchers-create-tiny-ai-model-shames-biggest-llms-reasoning-puzzles/\">advanced AI models</a> to power its robots. These models demonstrate advanced reasoning capabilities that can be integrated directly into its factory machines and humanoid robots, allowing them to work with greater autonomy and precision, alongside humans.</p><p>Nvidia is also helping Samsung to link virtual simulations with real-world robot data, so its robots will be better able to perceive their physical surroundings and make faster, intelligent decisions in real world scenarios. It’s doing this with the Nvidia Jetson Thor robotic platform, creating models for robots focused on task execution and workplace safety awareness.</p><p>Like with its AI-enabled manufacturing optimizations, Samsung will also introduce its advanced robots into the rest of its manufacturing ecosystem in future.</p><h3>AI networks and HBM4 memory chips on the way</h3><p>Beyond the AI Megafactory, Samsung said it’s working with Nvidia and a number of South Korea’s top telecommunications companies to improve network communications. They’re collaborating on the development of a technology called AI-RAN, which <a href=\"https://siliconangle.com/2024/02/26/mwc-ai-wireless-vendors-come-together-form-ai-ran-alliance/\">integrates AI</a> into mobile networks to support the deployment of AI agents and “physical AI” such as intelligent robots, drones and industrial equipment. Samsung has already <a href=\"https://news.samsung.com/global/samsung-electronics-demonstrates-ai-ran-technologies-paving-the-way-for-convergence-of-telecommunications-and-ai\">demonstrated a proof of concept</a> of AI-RAN, which it says will be critical for the future adoption of physical AI.</p><p>Meanwhile, Samsung said it continues to work with Nvidia on the development of its <a href=\"https://semiconductor.samsung.com/news-events/tech-blog/samsung-hbm4-36gb-mtv/\">high-bandwidth memory chips</a>, or HBM4, which are an essential component of AI servers. The company is making up for lost time here, as it has <a href=\"https://siliconangle.com/2025/07/30/samsung-earnings-dip-chip-division-weighs-results-despite-mobile-display-growth/\">fallen behind its biggest competitor</a> SK Hynix Inc. in the HBM memory chip sector, but believes it will ultimately be able to deliver superior performance when its HBM4 chips enter production next year.\n.<p>\nAccording to Samsung, HBM4 chips is built on its sixth-generation 10-nanometer-class dynamic random-access memory and a four-nanometer logic base die, enabling processing speeds of up to 11 gigabits per second, exceeding the Joint Electron Device Engineering Council Solid State Technology Association’s standard of 8 gigabits per second.</p></p><h5>Image: SiliconANGLE/Dreamina AI</h5><div><p>Support our mission to keep content open and free by engaging with theCUBE community. <strong>Join theCUBE’s Alumni Trust Network</strong>, where technology leaders connect, share intelligence and create opportunities.</p><ul><li data-replit-metadata=\"client/src/pages/Home.tsx:123:12\" data-component-name=\"p\"><strong>15M+ viewers of theCUBE videos</strong>, powering conversations across AI, cloud, cybersecurity and more</li><li data-replit-metadata=\"client/src/pages/Home.tsx:123:12\" data-component-name=\"p\"> — Connect with more than 11,400 tech and business leaders shaping the future through a unique trusted-based network.</li></ul><div data-replit-metadata=\"client/src/pages/Home.tsx:126:12\" data-component-name=\"div\"><div data-replit-metadata=\"client/src/pages/Home.tsx:142:14\" data-component-name=\"div\"><div data-replit-metadata=\"client/src/pages/Home.tsx:145:16\" data-component-name=\"div\">SiliconANGLE Media is a recognized leader in digital media innovation, uniting breakthrough technology, strategic insights and real-time audience engagement. As the parent company of <a href=\"https://cts.businesswire.com/ct/CT?id=smartlink&amp;url=https%3A%2F%2Fsiliconangle.com%2F&amp;esheet=54119777&amp;newsitemid=20240910506833&amp;lan=en-US&amp;anchor=SiliconANGLE&amp;index=9&amp;md5=646b1b564e2259100a2b8638aab0a552\">SiliconANGLE</a>, <a href=\"https://cts.businesswire.com/ct/CT?id=smartlink&amp;url=https%3A%2F%2Fwww.thecube.net%2F&amp;esheet=54119777&amp;newsitemid=20240910506833&amp;lan=en-US&amp;anchor=theCUBE+Network&amp;index=10&amp;md5=7de2a85f95ab4a4a495cede20b8cb1da\">theCUBE Network</a>, <a href=\"https://cts.businesswire.com/ct/CT?id=smartlink&amp;url=https%3A%2F%2Fthecuberesearch.com%2F&amp;esheet=54119777&amp;newsitemid=20240910506833&amp;lan=en-US&amp;anchor=theCUBE+Research&amp;index=11&amp;md5=7bb33676722925eb57d588ec343e4f6f\">theCUBE Research</a>, <a href=\"https://cts.businesswire.com/ct/CT?id=smartlink&amp;url=https%3A%2F%2Fwww.cube365.net%2F&amp;esheet=54119777&amp;newsitemid=20240910506833&amp;lan=en-US&amp;anchor=CUBE365&amp;index=12&amp;md5=d310fb35919714e66ad8d42c9c0c1bc6\">CUBE365</a>, <a href=\"https://cts.businesswire.com/ct/CT?id=smartlink&amp;url=https%3A%2F%2Fwww.thecubeai.com%2F&amp;esheet=54119777&amp;newsitemid=20240910506833&amp;lan=en-US&amp;anchor=theCUBE+AI&amp;index=13&amp;md5=b8b98472f8071b23ebb10ab9a8dd0683\">theCUBE AI</a> and theCUBE SuperStudios — with flagship locations in Silicon Valley and the New York Stock Exchange — SiliconANGLE Media operates at the intersection of media, technology and AI.</div></div></div></div>","contentLength":6777,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/artificial/comments/1okqlbq/samsung_and_nvidia_to_build_an_ai_megafactory/"},{"title":"Weekly: Share your victories thread","url":"https://www.reddit.com/r/kubernetes/comments/1okqg4j/weekly_share_your_victories_thread/","date":1761904833,"author":"/u/gctaylor","guid":323432,"unread":true,"content":"<p>Got something working? Figure something out? Make progress that you are excited about? Share here!</p>","contentLength":98,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"In this economy even Tux needed a second job.","url":"https://www.reddit.com/r/linux/comments/1okq068/in_this_economy_even_tux_needed_a_second_job/","date":1761903150,"author":"/u/Sonikku_a","guid":323434,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"LibreOffice recap, October 2025 – Markdown support, events, app updates and more","url":"https://blog.documentfoundation.org/blog/2025/10/31/libreoffice-project-and-community-recap-october-2025/","date":1761901444,"author":"/u/themikeosguy","guid":323433,"unread":true,"content":"<p>Here’s our summary of updates, events and activities in the LibreOffice project in the last four weeks – click the links to learn more…</p><ul><li>We started the month by posting the LibreOffice Podcast, Episode #5 –Accessibility in Free and Open Source Software, with Michael Weghorn and Mike Saunders. Watch it below – or <a href=\"https://peertube.opencloud.lu/w/wwwjD9E8ukoH56q1oBfa8p\">on PeerTube</a>.</li></ul><div allowfullscreen=\"\" data-no-lazy=\"1\" data-skipgform_ajax_framebjll=\"\"><p><strong>Please confirm that you want to&nbsp;play a YouTube video.</strong> By accepting, you will be accessing content from YouTube, a service provided by an external third party.</p><p>If you accept this notice, your choice will be saved and the page will refresh.</p></div><ul><li>Markdown support is coming to LibreOffice! This is just one of the projects from the <a href=\"https://blog.documentfoundation.org/blog/2025/10/22/libreoffice-and-google-summer-of-code-2025-the-results/\">Google Summer of Code 2025</a>, and should be included in our next major release, LibreOffice 26.2, due in February next year.</li></ul><ul><li>In October, we had two updates to the software: <a href=\"https://blog.documentfoundation.org/blog/2025/10/09/release-of-libreoffice-25-8-2/\">LibreOffice 25.8.2</a>, and <a href=\"https://blog.documentfoundation.org/blog/2025/10/30/libreoffice-25-2-7/\">LibreOffice 25.2.7</a>. The latter is the final update to the 25.2 branch, so after this, all users are recommended to upgrade to the 25.8 branch.</li></ul><ul><li>It’s the End of 10! Yes, in October, Microsoft ended official support for Windows 10. This leaves users who want to continue using the operating system with few alternatives — especially if they have an old PC that is not compatible with Windows 11’s demanding hardware requirements — other than buying a new PC. But we a <a href=\"https://blog.documentfoundation.org/blog/2025/10/14/end-of-10-ten-reasons-to-switch-from-windows-to-linux/\">posted about 10 reasons to switch to Linux</a> – and, of course, many desktop Linux distributions ship with LibreOffice.</li></ul><ul><li>Lots of people ask us about LibreOffice’s compatibility with Microsoft Office/365 documents. We think our compatibility is very good (and always improving, as more people send us documents to test), but the format is extremely difficult to work with, as our posts about the <a href=\"https://blog.documentfoundation.org/blog/2025/10/03/the-docx-case/\">DOCX</a> and <a href=\"https://blog.documentfoundation.org/blog/2025/10/10/the-pptx-case/\">PPTX</a> formats explain. (Of course, ideally we’d all be using the Open Document Format, regardless of the software we prefer! And <a href=\"https://blog.documentfoundation.org/blog/2025/10/24/make-your-odf-files-accessible/\">here’s how to make your ODF documents more accessible</a>.)</li></ul><ul><li>Meanwhile, the <a href=\"https://blog.documentfoundation.org/blog/2025/10/27/libreitalia-conference-2025/\">Libreitalia Conference 2025</a> was organized by Marco Marega – a LibreItalia and TDF Member – in Gradisca d’Isonzo, near the border with Slovenia.</li></ul><ul><li>And our final event report was from <a href=\"https://blog.documentfoundation.org/blog/2025/10/28/libreoffice-at-linuxdays-2025-in-prague/\">LinuxDays 2025 in Prague</a>, where we had a stand with stickers, flyers and a quiz about LibreOffice.</li></ul>","contentLength":2211,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/linux/comments/1okpkti/libreoffice_recap_october_2025_markdown_support/"},{"title":"Passwordless login via email OTP is that a good option?","url":"http://devloprr.com/","date":1761901066,"author":"/u/Agile_Guess_523","guid":323548,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1okph9u/passwordless_login_via_email_otp_is_that_a_good/"},{"title":"Trying to make tenant provisioning less painful. has anyone else wrapped it in a Kubernetes operator?","url":"https://www.reddit.com/r/kubernetes/comments/1oknpg9/trying_to_make_tenant_provisioning_less_painful/","date":1761893749,"author":"/u/Selene_hyun","guid":323380,"unread":true,"content":"<p>I’m a DevOps / Platform Engineer who spent the last few years provisioning multi-tenant infrastructure by hand with Terraform. Each tenant was nicely wrapped up in modules, so spinning one up wasn’t actually that hard-drop in a few values, push through the pipeline, and everything came online as IaC. The real pain point was coordination: I sit at HQ, some of our regional managers are up to eight hours behind, and “can you launch this tenant now?” usually meant either staying up late or making them wait half a day.</p><p>We really wanted those managers to be able to fill out a short form in our back office and get a dedicated tenant environment within a couple of minutes, without needing anyone from my team on standby. That pushed me to build an internal “Tenant Operator” (v0), and we’ve been running that in production for about two years. Along the way I collected a pile of lessons, tore down the rough edges, redesigned the interface, and just published a much cleaner Tenant Operator v1.</p><p>- Watches an external registry (we started with MySQL) and creates Kubernetes Tenant CRs automatically. - Renders resources through Go templates enriched with Sprig + custom helpers, then applies them via Server-Side Apply so multiple controllers can coexist.<p> - Tracks dependencies with a DAG planner, enforces readiness gates, and exposes metrics/events for observability.</p> - Comes with scripts to spin up a local Minikube environment, plus dashboards and alerting examples if you’re monitoring with Prometheus/Grafana.</p><p>This isn’t a polished commercial product; it’s mostly tailored to the problems we had. If it sounds relevant, I’d really appreciate anyone kicking the tires and telling me where it falls short (there’ll be plenty of gaps). Happy to answer questions and iterate based on feedback. Thanks!</p><p>P.S. If you want to test it quickly on your own machine, check out the Minikube QuickStart guide, we provision everything in a sandboxed cluster. It’s run fine on my three macOS machines without any prep work.</p>","contentLength":2036,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Question from beginner: what do I lose from using fiber?","url":"https://www.reddit.com/r/golang/comments/1okmqua/question_from_beginner_what_do_i_lose_from_using/","date":1761889931,"author":"/u/Fuzzy-Scratch-5386","guid":323757,"unread":true,"content":"<p>I am a hobby programmer that recently migrated from Bun/Nodejs. In order to learn go, I started by working simple rest API using fiber and sqlite. After this, while browsing for more complex project ideas, I found that fiber is not recommended because it is build over fasthttp and does not support http2 protocol. Upon further looking, I found out that http2 require (not mandatory per se, but recommended) proper tls, which probably (mostly) is not present in local project. So my question is, why not use fiber for local project? While the performance is not an issue, I like how we can create route groups as well as write the API easily.</p><p>Edit 2: I am checking videos by <a href=\"https://youtu.be/H7tbjKFSg58\">Dreams of Code</a>, these code looks cleaner</p>","contentLength":714,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"What Are Some Active Kubernetes Communities?","url":"https://www.reddit.com/r/kubernetes/comments/1oklzqo/what_are_some_active_kubernetes_communities/","date":1761887140,"author":"/u/Healthy-Sink6252","guid":323367,"unread":true,"content":"<p>I have seen only Home Operations Discord as an active and knowledgeable community. I checked our CNCF Slack, response times are like support tickets and does not feel like a community.</p><p>If anyone also knows Indian specific communities, it would be helpful too.</p><p>I am looking for active discussions about: CNCF Projects like FluxCD, ArgoCD, Cloud, Istio, Prometheus, etc.</p><p>I think most people have these discussions internally in their organization.</p>","contentLength":442,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Mixing AMD and Intel CPUs in a Kubernetes cluster?","url":"https://www.reddit.com/r/kubernetes/comments/1okl0na/mixing_amd_and_intel_cpus_in_a_kubernetes_cluster/","date":1761883773,"author":"/u/Popular_Parsley8928","guid":323348,"unread":true,"content":"<p>I will have 4 VMs each with 12G RAM and 2 vCPU, this will be for my home lab, I will install Alma Linux 9 and then manually install Kubernetes cluster ( Rancher v2.11.6 and 4 K8S with version v1.30). The AMD CPU is AMD FX-8320 and Intel is Core i7-3770.</p><p>I won't run sophiscated app, just a small home lab to learn Kubernetes, thanks!</p>","contentLength":332,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"riscv.org : RISC-V Mentorship Program","url":"https://www.reddit.com/r/linux/comments/1okkihr/riscvorg_riscv_mentorship_program/","date":1761882223,"author":"/u/I00I-SqAR","guid":323708,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Pure Go HDF5 library reaches write support (v0.11.0/v0.11.1-beta). Beta testers needed before RC.","url":"https://www.reddit.com/r/golang/comments/1okjak6/pure_go_hdf5_library_reaches_write_support/","date":1761878543,"author":"/u/mistbow","guid":323352,"unread":true,"content":"<h2>Pure Go HDF5 library reaches write support (v0.11.0/v0.11.1-beta)</h2><p>After a year of work, my pure Go HDF5 implementation just hit a major milestone - you can now create HDF5 files without CGo.</p><p>: HDF5 is the standard for scientific data (astronomy, climate, genomics, etc.). Current Go options are gonum/hdf5 (CGo wrapper, requires ) and abandoned pure-Go attempts from 2015-2016.</p><p>: <code>go file, _ := hdf5.CreateForWrite(\"data.h5\", hdf5.Truncate) file.CreateDataset(\"temp\", data, hdf5.WithChunked([]uint64{100}), hdf5.WithCompression(6), // GZIP ) </code></p><p>Full support: chunked datasets, GZIP compression, dense groups (HDF5 1.8+), attributes, all datatypes. 70-88% test coverage, cross-platform.</p><p>: - No CGo = easy cross-compilation, no C dependencies - HDF5 is massive in scientific computing (TensorFlow models, NASA data, genomics) - Previous pure-Go attempts stalled because \"too complex\"</p><p> (beta): - Can't reopen files and add more data yet (v0.11.2) - Not h5dump-compatible yet (investigating) - Attributes write-once only</p><p>: HDF Group acknowledged it on their forum as the first viable pure-Go implementation (<a href=\"https://forum.hdfgroup.org/t/loking-for-an-hdf5-version-compatible-with-go1-9-2/10021/7\">link</a>).</p><p>Looking for beta testers with real-world scientific data. Installation: <code>go get github.com/scigolib/hdf5@v0.11.1-beta</code></p><p>Happy to answer questions about the implementation - HDF5 format is gnarly but solvable with the C library as reference.</p>","contentLength":1336,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"[D] Monthly Who's Hiring and Who wants to be Hired?","url":"https://www.reddit.com/r/MachineLearning/comments/1okj2rw/d_monthly_whos_hiring_and_who_wants_to_be_hired/","date":1761877894,"author":"/u/AutoModerator","guid":323498,"unread":true,"content":"<p> please use this template</p><blockquote><p>Hiring: [Location], Salary:[], [Remote | Relocation], [Full Time | Contract | Part Time] and [Brief overview, what you're looking for]</p></blockquote><p><strong>For Those looking for jobs</strong> please use this template</p><blockquote><p>Want to be Hired: [Location], Salary Expectation:[], [Remote | Relocation], [Full Time | Contract | Part Time] Resume: [Link to resume] and [Brief overview, what you're looking for]</p></blockquote><p>Please remember that this community is geared towards those with experience.</p>","contentLength":467,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"A Refreshing Philosophy of Software Design [Book Review]","url":"https://theaxolot.wordpress.com/2025/10/30/a-refreshing-philosophy-of-software-design/","date":1761875161,"author":"/u/The_Axolot","guid":322504,"unread":true,"content":"<p>I pride myself on being the kind of blogger who writes what he truly believes, even when it’s unpopular. That’s part of why I’m so brash and come across as condescending. It’s cathartic for me, so if being correct is condescending, I don’t want to be wrong.</p><p>Having said that, it feels good when I find others whose opinions mostly resonate with mine. I very recently finished reading <em>A Philosophy of Software Design</em>, by  (I know I’m super late on that), and I’ve come to the conclusion that it should be mandatory reading for every software engineer.</p><p>First of all, it’s packed with content that isn’t easily found elsewhere. Both junior and senior engineers can learn a lot.</p><p>He explains complexity as a combination of and  (though some problems have inherent complexity), and how it slowly creeps through incremental changes to code.</p><p>The concepts of interface depth and information hiding are excellent ways to explain what modularity looks like at the program, API, service, class, and even function level.</p><p>His use of the text editor example to explain many of his concepts felt natural and not forced at all.</p><p>In chapter 19, he gives his takes on some popular software trends such as OOP, Agile, Testing, etc.</p><p>My favorite take of his is on , in which he proclaims he’s not a fan because it’s too incremental and distracts from high-level design. He only likes it when fixing bugs. That, my readers, is the correct take, and it alone puts him leagues above most.</p><p>And best of all, he isn’t dogmatic about in his presentation. In fact, each of his points is full of nuance and discussion of specific caveats that I haven’t seen anywhere else. Throughout every chapter, I just kept thinking, “This guy knows his stuff.”</p><p>The bad doesn’t outweigh the good, but I still have to point out what bothered me.</p><p>First of all, the ratio of code examples to advice is lacking. A lot of it will resonate with experts in the abstract, because we have lived experiences of said scenarios. But the less experienced may struggle to internalize some lessons without concrete examples to anchor them to. Ousterhout admits this in the introduction, but still.</p><p>But my real issues are with the presentation of these examples. A lot of the time, Ousterhout will present an interface and point out the flaws that lead to brittleness and complexity. But then, he’ll instantly come up with another interface and explain why it’s better.</p><p>His explanations are correct. It’s just that the way he presents them gives the impression that you can design a good interface from requirements alone, but then doesn’t explain how he reasoned his way to it. It feels like post-hoc rationalization of his expertise rather than a process anyone can deduce their way through.</p><p>The biggest culprit of this is the text editor example. I’ve never designed one of these before, so I was looking forward to hearing his thought process throughout. I was able to follow along, but a more junior developer would certainly struggle.</p><p>Am I supposed to believe that Ousterhout is so brilliant that he comes up with modular interfaces right off the bat? Of course not. You implement, your understanding grows alongside said implementation, and then you build your design. There’s not a single intermediate design iteration in the book. It goes straight from bad to good.</p><p>There were some other things that bothered me, too.</p><p>: <em>Define Errors Out Of Existence </em>had some great points, though it was a bit overstated. I rarely encounter instances of unjustified exceptions, though the examples he mentions, namely key deletion and substring, do fit the bill. I don’t know if it really warranted an entire chapter, though.</p><p>:  is also not worth a chapter. Do you really need to tell people to try out multiple designs?</p><p>In , he “debunks” common excuses that people use to forgo writing comments and documentation.</p><p>He claims that self-documenting code is a myth because there are often too many details in an interface to communicate through code alone. The example he uses to support his stance is the ambiguity of built-in  method. Specifically, whether its is inclusive, and what happens if the  index exceeds the index. Without its documentation, you’d have to read the method anyway to know these.</p><p>Now I don’t know what Ousterhout has been through, but surely this is an exaggeration. Yes, there may bedetails of a method that are difficult to communicate through its signature alone. But if the details are so significant, then that indicates bad design (assuming the functionality itself isn’t just unintuitive by nature). Ousterhout himself points this out in Chapter 10, so I don’t know why he uses this example. Java libraries aren’t the gold standard for code. People don’t actually believe that, right?</p><p>But there’s another factor to consider. Libraries, services, and APIs are in a different realm to classes and methods. The more granular you get, the less valuable documentation becomes, because it’s very hard to document these parts without just restating the implementation. Ousterhout acknowledges this in Chapter 16.</p><p>I don’t see people claiming that high-level documentation should be omitted, or that we shouldn’t write comments for confusing code in methods. In fact, I often see the opposite in code reviews, which is good.</p><p>“Good code is self-documenting” doesn’t mean, “No comments are allowed.” It means, “Comments shouldn’t be the default; they should be the last resort after code is made as clear as possible, yet there’s still confusion.”</p><p>I can tell he understands this because in Chapter 18, he says mentions comments as a way to compensate when code is nonobvious. So why devote so much of the book toward best practices regarding comments, when the majority of readers would already agree with his stance, assuming they can even understand it? It’s fragmented across four chapters, and not even consecutive, mind you, so I had a hard time piecing it together to explain to you here.</p><p>In he actually gives good examples of low-level comments, but I think he prematurely generalizes those examples to claim that low-level documentation is more necessary than people believe. But the reason it’s valuable in these specific examples is because he’s dealing with an inherently complex and uninituitive topic (extremely low-level memory manipulation for RPC functionality), and it’s in C++. Interestingly, it’s at this chapter that he starts using C++ in his examples. A bit fishy, I have to say.</p><p>In , he advocates using comments as a design tool. That is, using comments to plan your code and filling them in with the abstractions that follow. He doesn’t explicitly say this, but it’s clear this is meant to be an alternative to TDD (*shudder*).</p><p>He even uses similar talking points like, “If you wait until after your implementation to write comments, you may decide not to write them at all,” and, “Comments are a design tool for interfaces.” I use comments to keep myself on track and plan out my implementations, but not the way he describes it.</p><p>Why would I document a class, method, or even a variable I write it?</p><p>Why don’t I just write it and let the interface arise naturally as the implementation grows?</p><p>Code reviews can point out the need for comments, so does it matter what order I write them in?</p><p>What if comments are used as crutches to explain badly designed code?</p><p>is super lackluster.</p><p>There are so many ways to increase the clarity of your code, yet he only mentions superficial aspects, like using white space judiciously and comments.</p><p>For things that decrease clarity, he mentions:</p><p><strong>Event-driven programming (a.k.a indirect calls)</strong>. I guess, but are people defaulting to event-driven calls so much that this is worth mentioning?</p><p><strong>Generic containers (like Java’s class)</strong>. Once again, suspiciously specific. What about languages where multiple values can be grouped together without having to name the resulting object?</p><p><strong>Different types for declaration and allocation</strong><strong>(<code>like List&lt;Integer&gt; = new ArrayList&lt;Integer&gt;();</code>). </strong>Okay, this is starting to get silly. Is polymorphism bad now?</p><p><strong>Violating readers’ expectations.</strong> This one’s alright.</p><p>: <em>Designing for Performance </em>barely scratches the surface. There are so many more performance optimizations to consider, and much more common than the low-level example he uses. What about bad queries and unnecessary API calls? Caching?</p><p>More generally, he barely talks about functional programming, whose principles strongly push you toward modular design right out the gate.</p><p>What about databases and SQL? Are they not software?</p><p>The book feels very C++ and Java-centric, even though it was first published in 2018. I’m not saying Ousterhout has to only use modern languages, but he should at least acknowledge that object-oriented languages carry a lot of legacy baggage, and that it might cause this book, and even his philosophy, to become outdated soon.</p><p>In Chapter 9, Ousterhout talks about decomposition. Specifically, when to separate modules into smaller components or bring them together to reduce complexity. In chapter 9.7 &amp; 9.8, he discusses how and when methods should be decomposed. Sound familiar?</p><p>This was the topic of <a href=\"https://theaxolot.wordpress.com/2025/10/18/loc-is-a-dumb-metric-for-functions/\">my article last week</a>, and it spooked me how similar my points were to his, despite my never having read this book before, and not seeing my ideas expressed elsewhere with such precision:</p><ul><li>He calls out LoC as a dumb metric for function decomposition, though much more politely than I do.</li><li>He explains the main cost of decomposition, the main one being the spread of complexity rather than its reduction.</li><li>He says that you should favor decomposition when the subfunction can be understood in isolation, and the parent function can be understood without the implementation of the child function, which is almost exactly what I said in Lesson 4 of my article.</li><li>He advocates organizing code into independent blocks.</li></ul><p>I could go on. He explicitly pushes back on ‘s ridiculous function length recommendations, which I have to admit is pretty bold. I’d recommend people read the book for this alone. Treat it as a rebuttal to .</p><p>Oh, and I’ll just drop <a href=\"https://github.com/johnousterhout/aposd-vs-clean-code\">this</a> here.</p><p>I know I spent a lot of time on the bad, but believe me when I tell you that it’s not that significant compared to the rest of the book. My issues were more with how much time was spent on things I felt didn’t warrant such attention, and things I wished were discussed, rather than things that were outright wrong. I’m just a thorough guy. Anything I didn’t mention in the above sections, I consider good, or just not worth mentioning.</p><p>Overall, you should read this book if you haven’t already. And if you think is good, then you REALLY NEED to read this.</p><p>But read my articles first so you can see just how on point I am.</p>","contentLength":10782,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1oki4tt/a_refreshing_philosophy_of_software_design_book/"},{"title":"My first day in Rust","url":"https://www.reddit.com/r/rust/comments/1oki355/my_first_day_in_rust/","date":1761875033,"author":"/u/Zealousideal_Sort521","guid":323680,"unread":true,"content":"<p>I am a programmer with 15 years of experience in C# and the full Microsoft stack. I dream in LINQ and Entity Framework Core. Today was my first deep dive into Rust and I loved it. </p><p>My observations: * Rust is very precise and type safe. Way more precise than C#. No dynamics ever in Rust * The compiler is actually helpful. * I was under the impression that I was actually using my IQ points while programming again. Which was a pleasant surprise. Rust is the ultimate counterspell to vibe coding. * Setting up swagger was more difficult than it. Needed to be. * Rust code rots faster than C# code. Many examples on GitHub are unusable. * I wasn’t really a fan of the idea of being forced into nightly compiler builds to use the rocket framework. </p>","contentLength":747,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"How We Saved 70% of CPU and 60% of Memory in Refinery’s Go Code, No Rust Required.","url":"https://www.honeycomb.io/blog/how-we-saved-70-cpu-60-memory-refinery","date":1761871674,"author":"/u/phillipcarter2","guid":323496,"unread":true,"content":"<img alt=\"How We Saved 70% of CPU and 60% of Memory in Refinery’s Go Code, No Rust Required.\" width=\"1920\" height=\"1080\" decoding=\"async\" data-nimg=\"1\" srcset=\"/_next/image?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2F927dxq0h%2Fproduction%2F262555f7660a8c2e7f470161c31456257f223bde-1920x1080.png&amp;w=1920&amp;q=75 1x, /_next/image?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2F927dxq0h%2Fproduction%2F262555f7660a8c2e7f470161c31456257f223bde-1920x1080.png&amp;w=3840&amp;q=75 2x\" src=\"https://www.honeycomb.io/_next/image?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2F927dxq0h%2Fproduction%2F262555f7660a8c2e7f470161c31456257f223bde-1920x1080.png&amp;w=3840&amp;q=75\"><p>Refinery has a big job: it performs dynamic, consistent tail-based sampling that maintains proportions across key fields, adjusts to changes in throughput, and reports accurate sampling rates. </p><p>The traffic patterns it handles are challenging, with long or large traces requiring it to hold lots of information in memory, while sudden volume spikes leave little time for infrastructure to scale up—all in a package that people want to run as cheaply as possible, since one of the primary use cases for sampling is cost control. When you're spending money to save money, you always want to spend . Version 3.0 is a big advance in that direction.<p>When we upgraded our internal Refinery cluster, total CPU usage dropped by 70%, while RAM use dropped by 60%:</p></p><img alt=\"When we upgraded our internal Refinery cluster, total CPU usage dropped by 70%, while RAM use dropped by 60%\" loading=\"lazy\" width=\"1110\" height=\"756\" decoding=\"async\" data-nimg=\"1\" srcset=\"/_next/image?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2F927dxq0h%2Fproduction%2Fee11f09a3d80717e19dd12bde66420c73c4e04ec-1110x756.png&amp;w=1200&amp;q=75 1x, /_next/image?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2F927dxq0h%2Fproduction%2Fee11f09a3d80717e19dd12bde66420c73c4e04ec-1110x756.png&amp;w=3840&amp;q=75 2x\" src=\"https://www.honeycomb.io/_next/image?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2F927dxq0h%2Fproduction%2Fee11f09a3d80717e19dd12bde66420c73c4e04ec-1110x756.png&amp;w=3840&amp;q=75\"><p>With an improvement like this, we can downsize this 72-node cluster by half—a meaningful savings—while still keeping more headroom than before. If you’re a Refinery user, hopefully so can you.</p><h2>How did we pull off such a big change?</h2><p>The code’s all in <a href=\"https://github.com/honeycombio/refinery/pull/1653\">this merge</a>, but I’ll cover the basics here.<p>Like many programming languages, Go is capable of being very fast under the right circumstances (working with bounded quantities of strongly typed data), and </p>slow under the wrong ones. Unfortunately, Refinery’s job of handling customer-defined trace spans is very close to the wrong one. Historically, we followed the standard approach and fully de-serialized every span that came in through the API. Since there’s no fixed schema, the fields went into a big  — hundreds of heap allocations, pointers everywhere. It was simple and effective, but it was also expensive. Compounding this cost, in a cluster configuration, the majority of spans are handled twice since they’re redirected from the receiving node to the node which “owns” the relevant trace. Here’s what a profile of a typical clustered Refinery looked like:There’s a lot going on here, but you can see almost a quarter of CPU time going to garbage collection. Digging further reveals that a lot of the leaf nodes are ultimately some form of . In total, 50% of all CPU time in this process is allocation-related, all in order to hold onto span data as it waits for a sampling decision—after which, in most cases, it’s simply thrown away without being sent to Honeycomb!</p><img alt=\"What a profile of a typical clustered Refinery looked like.\" loading=\"lazy\" width=\"1438\" height=\"898\" decoding=\"async\" data-nimg=\"1\" srcset=\"/_next/image?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2F927dxq0h%2Fproduction%2Fda25ebb434806cebe7a634518cd79db653251204-1438x898.png&amp;w=1920&amp;q=75 1x, /_next/image?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2F927dxq0h%2Fproduction%2Fda25ebb434806cebe7a634518cd79db653251204-1438x898.png&amp;w=3840&amp;q=75 2x\" src=\"https://www.honeycomb.io/_next/image?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2F927dxq0h%2Fproduction%2Fda25ebb434806cebe7a634518cd79db653251204-1438x898.png&amp;w=3840&amp;q=75\"><p>There’s also a lot of overhead just for setting up data structures which we’re hardly going to use. The actual , which is the reason we’re doing all of this, all happens in the  loop, a mere 12% of time in this profile. Even that is mostly internal metrics instrumentation rather than the core decision-making algorithms.<p>The best way to make all this de-serialization (and, eventually, re-serialization) fast is to not to do it at all. Refinery only ever looks at a handful of fields in any given span, the rest is just cargo. And it’s very possible to extract only the fields you need from a serialized blob, as in the simplified example below. These two benchmarks demonstrate de-serializing into a map, and our new </p> approach, where we pull out any fields Refinery needs, then hang onto the serialized data for re-transmission. I’m using MessagePack here because that’s Refinery’s native format, with a low-level serialization API provided by the <a href=\"https://github.com/tinylib/msgp\">tinylib/msgp library</a>.</p><div><div><pre><code>func BenchmarkDecodeStrats(b *testing.B) {\n    msgpData, _ := msgpack.Marshal(struct {\n        TraceID    string\n        DurationMs float64\n    }{\n        TraceID:    \"1234567890\",\n        DurationMs: 123.4,\n    })\n\n    // Unmarshal to a schemaless map[string]any, the old way.\n    b.Run(\"to_map\", func(b *testing.B) {\n        for b.Loop() {\n            var m map[string]any\n            _ = msgpack.Unmarshal(msgpData, &amp;m)\n        }\n    })\n\n    // Unmarshal a subset of fields using custom deserialization;\n    // this is the new way.\n    b.Run(\"selective\", func(b *testing.B) {\n        for b.Loop() {\n            var durationMs float64\n            mapSize, remaining, _ := msgp.ReadMapHeaderBytes(msgpData)\n\n            for range mapSize {\n                var key []byte\n                key, remaining, _ = msgp.ReadMapKeyZC(remaining)\n                if bytes.Equal(key, []byte(\"DurationMs\")) {\n                    durationMs, remaining, _ = msgp.ReadFloat64Bytes(remaining)\n                } else {\n                    remaining, _ = msgp.Skip(remaining)\n                }\n            }\n            _ = durationMs // Pretend we did something with the duration\n        }\n    })\n}</code></pre></div></div><p>You can see that  involves much more code, but it’s hard to argue with the results:</p><div><div><pre><code>BenchmarkDecodeStrats/to_map-12     296.1  ns/op   9 allocs/op\nBenchmarkDecodeStrats/selective-12   16.98 ns/op   0 allocs/op</code></pre></div></div><p>This is a very simple scenario, and it’s common for real spans to have hundreds or even thousands of fields, which in the old version meant much longer parsing times and thousands of distinct allocations per span. Instead, Refinery 3.0 keeps the serialized data, retaining it in a format which is much more compact than the web of headers and pointers created for a fully realized map. This more compact data is the main reason for Refinery’s improved memory footprint.<p>Of course, Refinery supports three other types of input data besides our native MessagePack (</p>, , ). To handle the others, Refinery now transcodes those formats <a href=\"https://github.com/honeycombio/husky/blob/f6a547d5850adf0d61d8eaf1d1e9c91659241be8/otlp/traces_direct.go#L442\"></a> to serial MessagePack, binary-to-binary, again extracting any useful fields along the way. This code is even more voluminous than the selective extraction from MessagePack illustrated above, but it avoids an expensive additional step of translation from generated <a href=\"https://github.com/honeycombio/husky/tree/f6a547d5850adf0d61d8eaf1d1e9c91659241be8/otlp\">protobuf data structures</a> into our own.<p>To add icing to this cake, we also optimized our metrics instrumentation, implemented pools to re-use large buffers, and (coming soon as a minor version update) parallelized the core decision loop to scale across many CPUs. Notably, there are no clever algorithms or language tricks at play here. We didn’t have to rewrite it in Rust. All we've done is reimagine which work this process really needs to do, and focus on only doing that.</p></p><section></section>","contentLength":6054,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1okgvvr/how_we_saved_70_of_cpu_and_60_of_memory_in/"},{"title":"mm, swap: never bypass swap cache and cleanup flags (swap table phase II)","url":"https://lore.kernel.org/lkml/bvavihwrtkbnsqgjbotwihckxzmnhdd4e6jre4j7xdiyyeyv5o@dnnuyacthvms/T/#m55f0cf90afb8f8faaff3e33829c336bc7522a0b8","date":1761870413,"author":"/u/ilep","guid":323351,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/linux/comments/1okgfs6/mm_swap_never_bypass_swap_cache_and_cleanup_flags/"},{"title":"Sidecar injector race condition during node reboot","url":"https://www.reddit.com/r/kubernetes/comments/1okfjxt/sidecar_injector_race_condition_during_node_reboot/","date":1761868054,"author":"/u/0x4ddd","guid":322409,"unread":true,"content":"<p>Let's consider following scenario: - worker node hosting injector for mutating webhook for something like service mesh - the same node hosting application pod</p><p>A) Node is broken &amp; offline longer than pod-eviction-timeout, pods are being rescheduled to remaining nodes, it may happen application pod starts before injector and is not instrumented in the end</p><p>B) Issue was short, like sudden power loss followed by power on, pods are starting recovery on the same node but the same race condition may apply as in previous case</p><p>Is the only option to set failurePolicy of mutating webhook config to Fail? I have seen some injector helm charts where this is hardcoded to Ignore and not overridable via values by default, and also number of replicas of injector being hardcoded to 1 and not overridable.</p>","contentLength":792,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"An interview with Ken Silverman, creator of the Build Engine (Duke Nukem 3d, Shadow Warrior, Blood). Ken programmed the engine at the age of just 17.","url":"https://youtu.be/WruzfQLxpQY","date":1761867959,"author":"/u/Tech-Jesse","guid":323469,"unread":true,"content":"<!DOCTYPE html>","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1okfimd/an_interview_with_ken_silverman_creator_of_the/"},{"title":"GlueKube: Kubernetes integration test with ansible and molecule","url":"https://medium.com/@GlueOps/gluekube-kubernetes-integration-test-with-molecule-f88da7c41a34","date":1761867391,"author":"/u/MindCorrupted","guid":322410,"unread":true,"content":"<p>At GlueOps, we have been working on an internal tool to deploy and manage Kubernetes clusters across cloud providers and datacenters. During development, we ran into a few caveats. For example, if we modify a ‘prepare-node’ role to install an additional package or remove a package that seems unnecessary, it can indirectly affect the subsequent roles.</p><p>Example of one of the use cases, in the prepare-nodes playbook, we tend to remove a package that was thought unnecessary or change a package’s version, it can result in the subsequent roles like kubeadm-init to fail.</p><p>So we decided to add a couple of tests to help keep our work consistent and maintainable.</p><p>Some of the tests we created were:</p><ul><li>Scaling node(control-plane,data-plane)</li><li>Kubernetes versions upgrade</li></ul><p>As we deploy many production-grade clusters across numerous cloud providers (e.g. AWS, GCP, metal) for our customers, we wanted to make our deployment more agnostic. We took a look at a couple of existing tools like Kubespray, but we felt it may be a burden to maintain and modify the existing codebase in case we want to customize it.</p><p>Ultimately, we decided to build <strong>GlueKube: a platform to create kubernetes clusters agnostic to cloud providers </strong>with kubeadm, ansible.</p><ul><li>Deploying a stacked Etcd cluster where the Etcd is embedded within control-plane nodes unlike the external-etcd where Etcd where it can in separate nodes.</li><li>Supporting two load balancers (e.g. for the control plane and business applications)</li><li>Scaling Up/Down nodes(control-plane and worker nodes)</li><li>Tainting and Labeling nodes</li><li>Applying OS security patches</li><li>Upgrading cluster versions</li></ul><h2>Molecule as a Testing tool</h2><p>We’re using ansible to configure our clusters, we needed a testing tool that’s compatible with ansible and supports managing Hetzner resources for testing.</p><p>As our case is more of integration test than unit test, we found Molecule a more suitable option than ansible-test, as it provides a structured way through  to create/test/destroy infrastructure.</p><p>After our research and experiments, we created this blog to help anyone else considering similar tradeoffs.</p><p>In this post, we’re focusing on our journey with molecule. If you’re interested in learning more about the project, check out the <a href=\"https://ansible.readthedocs.io/projects/molecule/\" rel=\"noopener ugc nofollow\" target=\"_blank\">link</a>.</p><h2>Test Case I: Scaling Down Worker Nodes</h2><p>We started with <strong>scaling down worker nodes</strong> because it is easier than working with control-plane nodes.</p><p>After implementing this workflow in  scaling down is as easy as removing the node from the inventory file hosts.yaml and applying the sync-resources.yaml file, like the demo below:</p><p>Now how do we test that with Molecule ? after we created the scenario(test suite) using: molecule init scenario scaler-cluster.</p><p>We changed the scenario property in molecule.yaml to the following:</p><pre></pre><ul><li>Create: for creating the required resources for testing, our cluster will usually consist of 3 master planes, 3 worker nodes, 1 loadbalancer (HAProxy in our case).</li><li>Converge: it’s the file we will execute to transform resources into specific state</li><li>Verify: a file to run some tests after the resources get converged. The simplest test will run at first is verifying cluster health.</li><li>Destroy: at the end we need to cleanup the resources, this file will usually do the contrary of what  does. One side note is this file will always run whenever the tests result (success || failed).</li></ul><pre></pre><p> relies heavily on  to know the desired state of the cluster, think of it the same as terraform state and for our tests to run we will need one.</p><p>And this will lead us into  that’s responsible for generating the file from the created test resources. So we modified molecule.yaml to use the generated with the following code:</p><pre></pre><p> contains ansible configurations for each group in .</p><p>For running a basic verification, we used the following command:</p><pre></pre><p>This will trigger all the sequences we declared on molecule.yaml</p><p>To scale resources down, we need to remove the desired node from hosts.yaml, our initial thought of the process was creating a python script, give it the desired node, remove it from hosts.yaml and then refresh the inventory cache. However, we wanted to keep our test more Ansible oriented.</p><p>We found a better solution (at least for us) by creating two initial hosts.yamlfiles: the first one with all the nodes in and the second one without one of the worker nodes.</p><p>We used slicing to pick the  from  list, here is a code snippet from :</p><pre></pre><p>Molecule has another sequence called , which we used to replace the with  contentsrefresh the inventory cache and do the , here is the code.</p><pre></pre><p>For Molecule to recognize the side_effect, we added it alongside the other sequences.</p><pre></pre><p>After the side_effect sequence gets executed, we should verify the expected state of the cluster, in our case the side_effect should reduce the number of worker nodes by 1, so our test will count how many worker nodes we currently have. Here is a code example:</p><pre></pre><pre></pre><p>In this post, we shared our experience setting up integration tests for Kubernetes cluster management using Molecule and Ansible. We focused on a specific test case:, illustrating how Molecule’s sequences like , , , and  can be orchestrated to achieve this. We also highlighted the importance of the Ansible inventory in defining the desired state of the cluster and how Molecule facilitates testing changes to this inventory. This approach allows us to maintain the reliability and consistency of our GlueKube platform as we continue to develop and enhance its capabilities for deploying and managing Kubernetes clusters across diverse environments.</p>","contentLength":5491,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/kubernetes/comments/1okfauo/gluekube_kubernetes_integration_test_with_ansible/"},{"title":"How Memory Maps (mmap) Deliver 25x Faster File Access in Go","url":"https://info.varnish-software.com/blog/how-memory-maps-mmap-deliver-25x-faster-file-access-in-go","date":1761866700,"author":"/u/SnooWords9033","guid":322505,"unread":true,"content":"<p>One of the slowest things you can do in an application is making system calls. They're slow because you do have to enter the kernel, which is quite expensive. What should you do when you need to do a lot of disk I/O but you care about performance? One solution is to use memory maps.<p>Memory maps are a modern Unix mechanism where you can take a file and make it part of the virtual memory. In Unix context, modern means that it was introduced in the 1980s or later. You have a file, containing data, you mmap it and you'll get a pointer to where this resides. Now, instead of seeking and reading, you just read from this pointer, adjusting the offset to get to the right data.</p></p><p>To show what kind of performance you can get using memory maps, I've written a little Go library that allows you to read from a file using a memory map or a ReaderAt. ReaderAt will do a pread(), which is a seek/read combo, while mmap will just read from the memory map.</p><p>This almost feels like magic. Initially, when we launched Varnish Cache back in 2006, this was one of the features that made Varnish Cache very fast when delivering content. Varnish Cache would use memory maps to deliver content at blistering speeds.<p>Also, since you can operate with pointers into memory that is allocated by the memory map, you'll reduce memory pressure as well as raw latency.</p></p><h2>The Downside of Memory Maps</h2><p>The downside of memory maps is that you really can't write to the memory map. The reason is due to the way virtual memory works. When you're writing to a part of virtual memory that isn't mapped into physical memory, the CPU will generate a page fault. On a modern computer, the CPU is responsible for tracking what virtual memory pages are mapped onto what physical memory. Since you're writing to a page that isn't mapped, the CPU needs help.<p>So, when the page fault occurs, the OS will 1) allocate a new memory page, 2) read the contents of the file at the correct offset, 3) write this to the new memory page. Then control is returned to the application. The application will now overwrite the virtual memory page with new data.</p><p>Can we stop and appreciate how extremely inefficient this is? I think it is fairly safe to say that writing through a memory map is never a good idea when considering performance. At least if there is any risk, the file isn't mapped up in physical memory.</p><p>Let me illustrate this with a few more benchmarks.</p></p><p>As you can see, whether or not the pages are in cache is crucial for performance. WriterAt, which uses the pwrite call, is a much more predictable bet.<p>Still, writing through memory maps, was what Varnish Cache did initially. It somehow got away with it, but mostly because the competition was pretty bad.</p><p>This is why Varnish Cache got the malloc backend and why Varnish Enterprise got the various Massive Storage Engines. The malloc backend resolved the problem by just allocating system memory through the malloc system call, and the </p><a href=\"https://youtu.be/cWCSgbY83n8?feature=shared\" rel=\"noopener\">Massive Storage Engine</a> uses io_uring, which is so new that support for it is still somewhat limited.</p><h2>Using Memory Maps to Solve Real-world Performance Problems</h2><p>The last couple of weeks I've been working on an HTTP-backed filesystem. This is part of our AI Storage Acceleration solution, geared towards high performance computing environments. In this filesystem we needed a way to transfer folder data over HTTP. A folder is really just a listing of files, symbolic links and directories. The naive approach would be just to use JSON encoding, but JSON is notorious for being slow.<p>Our priority is performance. We made a </p><a href=\"https://github.com/perbu/db-shootout/\" rel=\"noopener\">benchmarking suite</a>, comparing various databases with each other. CDB was overall the fastest. Looking at the numbers, we'd still see that CDB would spend something like 1200ns on a database lookup that was entirely in the page cache. This seems very slow to me. After all, everything should be in memory and spending 1200ns reading memory sounds at least 100x too slow. I started looking into the CDB implementation I was using. It was the above ReaderAt implementation. So, most of the time is likely spent waiting for the operating system.<p>Some hours later, I was able to replace the seek/read with a memory map. This resulted in a 25x improvement in performance. Again, it feels like magic. Unlike the original file stevedore in Varnish Cache, this performance improvement has no downside.</p><a href=\"https://github.com/perbu/mmaps-in-go\">https://github.com/perbu/mmaps-in-go</a>CDB64 files with memory maps: <a href=\"https://github.com/perbu/cdb\">https://github.com/perbu/cdb</a></p>","contentLength":4438,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1okf1dv/how_memory_maps_mmap_deliver_25x_faster_file/"},{"title":"Tik Tok saved $300000 per year in computing costs by having an intern partially rewrite a microservice in Rust.","url":"https://www.linkedin.com/posts/animesh-gaitonde_tech-systemdesign-rust-activity-7377602168482160640-z_gL","date":1761866648,"author":"/u/InfinitesimaInfinity","guid":322411,"unread":true,"content":"<p dir=\"ltr\" data-test-id=\"main-feed-activity-card__commentary\">TikTok saved $300,000/year by doing&nbsp;this one thing...\nAnd no, it’s not AI. It’s&nbsp;Rust.&nbsp;🦀\nTheir payment service was&nbsp;slowing down&nbsp;as traffic exploded on TikTok LIVE.\n\nThey tried scaling the Go backend... but:\n🔹 More machines = more $$$\n🔹 Higher traffic = more latency\n🔹 Garbage collection = 😵💫\n\nSo what did they do?\n👉 Rewrote&nbsp;just&nbsp;the slowest Go endpoints in&nbsp;Rust.\nNot the whole thing. Just the bottlenecks.\n\nAnd the results were&nbsp;insane:\nPerformance at scale (80K QPS)\nMetric.                         Go.                Rust.             Improvement.  \nCPU usage.                78.3%.           52%↓         33.6%.  \nMemory usage.         7.4%.              2.07%↓      72%\np99 latency.              19.87 ms.       4.79 ms↓   76%\nThat’s not a small speed-up — that’s a&nbsp;rewrite-worthy&nbsp;difference.\n\n💰&nbsp;Cost savings?\nCut&nbsp;400 vCPU cores&nbsp;from the cluster.\n➡️ ~$300K/year saved. Just like that.\n\nSo how did Rust do it?\n🔸&nbsp;No garbage collector\n🔸&nbsp;Copy-on-Write&nbsp;(share memory until modified)\n🔸&nbsp;Zero-cost abstractions&nbsp;(speed + safety)\n🔸&nbsp;Less memcpy, more control\n🔸&nbsp;Aggressive compiler optimizations\nIt’s like Go is your reliable commuter car...\nAnd Rust is the F1 car you pull out for the real races. 🏁\n\nEngineering Wisdom from TikTok:\n✨&nbsp;“Use the right tool for the job.”\n👉 Keep Go for 95% of services (fast dev cycles, happy teams)\n👉 Use Rust where performance = revenue\n\nThis isn’t about language wars.\nIt’s about being&nbsp;strategic.\n🔁 Polyglot stacks are the future.\n💬 Thoughts?\n\n📝 Source: <a href=\"https://www.linkedin.com/redir/redirect?url=https%3A%2F%2Flnkd%2Ein%2Fdk9_H6HR&amp;urlhash=MOEe&amp;trk=public_post-text\" target=\"_self\" rel=\"nofollow\" data-tracking-control-name=\"public_post-text\" data-tracking-will-navigate=\"\">https://lnkd.in/dk9_H6HR</a><a href=\"https://www.linkedin.com/signup/cold-join?session_redirect=https%3A%2F%2Fwww.linkedin.com%2Ffeed%2Fhashtag%2Frust&amp;trk=public_post-text\" target=\"_self\" data-tracking-control-name=\"public_post-text\" data-tracking-will-navigate=\"\">#Rust</a><a href=\"https://www.linkedin.com/signup/cold-join?session_redirect=https%3A%2F%2Fwww.linkedin.com%2Ffeed%2Fhashtag%2Fgolang&amp;trk=public_post-text\" target=\"_self\" data-tracking-control-name=\"public_post-text\" data-tracking-will-navigate=\"\">#GoLang</a><a href=\"https://www.linkedin.com/signup/cold-join?session_redirect=https%3A%2F%2Fwww.linkedin.com%2Ffeed%2Fhashtag%2Fsoftwareengineering&amp;trk=public_post-text\" target=\"_self\" data-tracking-control-name=\"public_post-text\" data-tracking-will-navigate=\"\">#SoftwareEngineering</a><a href=\"https://www.linkedin.com/signup/cold-join?session_redirect=https%3A%2F%2Fwww.linkedin.com%2Ffeed%2Fhashtag%2Fscale&amp;trk=public_post-text\" target=\"_self\" data-tracking-control-name=\"public_post-text\" data-tracking-will-navigate=\"\">#Scale</a><a href=\"https://www.linkedin.com/signup/cold-join?session_redirect=https%3A%2F%2Fwww.linkedin.com%2Ffeed%2Fhashtag%2Fperformance&amp;trk=public_post-text\" target=\"_self\" data-tracking-control-name=\"public_post-text\" data-tracking-will-navigate=\"\">#Performance</a><a href=\"https://www.linkedin.com/signup/cold-join?session_redirect=https%3A%2F%2Fwww.linkedin.com%2Ffeed%2Fhashtag%2Ftiktok&amp;trk=public_post-text\" target=\"_self\" data-tracking-control-name=\"public_post-text\" data-tracking-will-navigate=\"\">#TikTok</a><a href=\"https://www.linkedin.com/signup/cold-join?session_redirect=https%3A%2F%2Fwww.linkedin.com%2Ffeed%2Fhashtag%2Fdevex&amp;trk=public_post-text\" target=\"_self\" data-tracking-control-name=\"public_post-text\" data-tracking-will-navigate=\"\">#DevEx</a><a href=\"https://www.linkedin.com/signup/cold-join?session_redirect=https%3A%2F%2Fwww.linkedin.com%2Ffeed%2Fhashtag%2Frustaceans&amp;trk=public_post-text\" target=\"_self\" data-tracking-control-name=\"public_post-text\" data-tracking-will-navigate=\"\">#Rustaceans</a><a href=\"https://www.linkedin.com/signup/cold-join?session_redirect=https%3A%2F%2Fwww.linkedin.com%2Ffeed%2Fhashtag%2Fbackend&amp;trk=public_post-text\" target=\"_self\" data-tracking-control-name=\"public_post-text\" data-tracking-will-navigate=\"\">#Backend</a></p>","contentLength":1695,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1okf0md/tik_tok_saved_300000_per_year_in_computing_costs/"},{"title":"Jujutsu at Google","url":"https://www.youtube.com/watch?v=v9Ob5yPpC0A","date":1761865532,"author":"/u/steveklabnik1","guid":322447,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1okekv7/jujutsu_at_google/"},{"title":"Provisioning Clusters on Baremetal","url":"https://www.reddit.com/r/kubernetes/comments/1okejd9/provisioning_clusters_on_baremetal/","date":1761865425,"author":"/u/CompetitivePop2026","guid":322408,"unread":true,"content":"<p>Hello! I have been trying to think of a way to provision clusters and nodes for my home lab. I have a few mini pcs that I want to run baremetal k3s, k0s, or Talos. I want to be able to destroy my cluster and rebuild whenever I want just like in a virtual environment. The best way so far I have thought on how to do this is to have a PXE server and every time a node boots it would get imaged with a new image. I am leaning towards Talos with machine configs on the PXE server, but I have also thought of using a mutable distro with Ansible for bootstrapping and Day 2 configurations. Any thoughts or advice would be very appreciated! </p>","contentLength":635,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"[R] We found LRMs look great…until the problems get harder (AACL 2025)","url":"https://www.reddit.com/r/MachineLearning/comments/1okdq0s/r_we_found_lrms_look_greatuntil_the_problems_get/","date":1761863366,"author":"/u/natural_language_guy","guid":323350,"unread":true,"content":"<p>Hi there! I'm excited to share this project on characterizing reasoning capabilities of Large Reasoning Models (LLMs incentivized with \"thinking\").</p><p> We look at large reasoning models (LRMs) and try to answer the question of \"how do they generalize when reasoning complexity is steadily scaled up?</p><p>Short answer: They’re solid in the easy/mid range, then fall off a cliff once complexity crosses a threshold. We use graph reasoning and deductive reasoning as a testbed, then we try to reconcile the results with real world graph distributions.</p><ul><li>Built a dataset/generator (DeepRD) to generate queries of specified complexity (no limit to samples or complexity). Generates both symbolic and 'proof shaped' queries. <ul><li><strong>We hope this helps for future work in reasoning training+evaluation!</strong></li></ul></li><li>Tested graph connectivity + natural-language proof planning.</li><li>Saw sharp drop-offs once complexity passes a certain point—generalization doesn’t magically appear with current LRMs.</li><li>Compared against complexity in real-world graphs/proofs: most day-to-day cases are “in range,” but the long tail is risky.</li><li>Provide some in depth analysis on error modes</li></ul><p> Benchmarks with limited complexity can make models look more general than they are. The drop in performance can be quite dramatic once you pass a complexity threshold, and usually these high complexity cases are long-tail.</p>","contentLength":1352,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"The Affinity Suite has become free and can run on Linux","url":"https://www.reddit.com/r/linux/comments/1okcpwy/the_affinity_suite_has_become_free_and_can_run_on/","date":1761860831,"author":"/u/SpeeQz","guid":322359,"unread":true,"content":"<p>In the image above I am running the new Affinity app (a popular Photoshop, Illustrator, etc... alternative) which has combined the entire suite into a singular app. It is running on Heroic and there was confirmation from another user (<a href=\"https://www.reddit.com/u/Segajr\">u/Segajr</a>) of it running on Lutris too.</p>","contentLength":273,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Check if channel is empty","url":"https://www.reddit.com/r/golang/comments/1okca10/check_if_channel_is_empty/","date":1761859730,"author":"/u/TomatilloOpening2085","guid":322413,"unread":true,"content":"<p>Hello, i have a noob question about channel. </p><p>I'm trying to code a program to play scrabble. To find the combination possibles according to the hand of the player and the letters already present on the board, I tried to code a worker pool and pass them the hand of the player, a kind of \"regex\" and a channel to retrieve their solution. </p><p>The problem is that I have a predetermined number of worker, a known number of \"regex\", but an unknown number of solution generated. So if all my worker write to this channel theirs solution, how can I, in the main thread, know when i'm done reading the content of the channel ? </p>","contentLength":615,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Rendered manifests pattern tools","url":"https://www.reddit.com/r/kubernetes/comments/1okbx7p/rendered_manifests_pattern_tools/","date":1761858870,"author":"/u/misse-","guid":322358,"unread":true,"content":"<p> What tools, if any, are you using to apply the rendered manifests pattern to render the output of Helm charts or Kustomize overlays into deployable Kubernetes manifests?</p><p>I am somewhat happily using Per-cluster ArgoCDs, using generators to deploy helm charts with custom values per tier, region, cluster etc.</p><p>What I dislike is being unaware of how changes in values or chart versions might impact what gets deployed in the clusters and I'm leaning towards using the \"Rendered manifests pattern\" to clearly see what will be deployed by argocd.</p><p>I've been looking in to different options available today and am at a bit of a loss of which to pick, there's:</p><p><a href=\"https://github.com/holos-run/holos\">Holos</a> - which requires me to learn cue, and seems to be pretty early days overall. I haven't tried their <a href=\"https://holos.run/docs/v1alpha5/tutorial/hello-holos/\">Hello world example</a> yet, but as Kargo, it seems more difficult than I first anticipated.</p><p>Ideally I would commit to main, and the ci would render the manifests for my different clusters and generate MRs towards their respective projects or branches, but I can't seem to find examples of that being done, so I'm hoping to learn from you.</p>","contentLength":1089,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Jerome Powell says the AI hiring apocalypse is real: 'Job creation is pretty close to zero.’ | Fortune","url":"https://fortune.com/2025/10/30/jerome-powell-ai-bubble-jobs-unemployment-crisis-interest-rates/","date":1761857216,"author":"/u/fortune","guid":322360,"unread":true,"content":"<p>He noted “a significant number of companies” have recently announced layoffs or hiring pauses, with many of them explicitly citing AI as the reason.\n\n\n\n</p><p>“Much of the time they’re talking about AI and what it can do,” Powell told reporters after the Fed’s rate-cut decision, warning large employers are signaling they won’t need to add headcount for years. “We’re watching that very carefully,” he added.\n\n\n\n</p><p>The comments come as the Fed cut interest rates by a quarter point to a range of 3.75%–4%, citing “downside risks to employment” even as inflation remains elevated. Powell said the U.S. economy is still expanding at a “moderate pace,” even as hiring slows. He described that spending as one of the “big sources of growth in the economy,” driven by companies building data centers and other equipment tied to artificial intelligence.\n\n\n\n</p><p>Powell also pushed back on the idea that all that spending is amounting to another speculative bubble. He drew a <a href=\"https://fortune.com/2025/10/29/powell-says-ai-is-not-a-bubble-unlike-dot-com-federal-reserve-interest-rates/\" target=\"_self\" aria-label=\"Go to https://fortune.com/2025/10/29/powell-says-ai-is-not-a-bubble-unlike-dot-com-federal-reserve-interest-rates/\">clear line </a>between today’s surge in capital expenditure and the dot-com era, noting “these companies actually have earnings.”&nbsp; Those projects, he said, aren’t especially sensitive to interest rates, though, since they reflect long-term bets on higher productivity.</p><p>At the same time, Powell emphasized the boom creates a policy dilemma for the Fed. AI and automation are boosting output, but they’re also allowing companies to do more with fewer workers, leaving the labor market softer, even while GDP stays positive.<p>“We have upside risks to inflation, downside risks to employment,” he said. “This is a very difficult thing for a central bank, because one of those calls for rates to be lower, one calls for rates to be higher.”\n\n\n\n</p></p><p>Recent corporate announcements illustrate Powell’s warning. <a href=\"https://fortune.com/company/amazon-com/\" target=\"_blank\" aria-label=\"Go to https://fortune.com/company/amazon-com/\">Amazon</a> announced this week it laid off 14,000 middle managers—about 4% of its white-collar workforcein an effort to “remove organizational layers.” The layoffs come amid their rampant <a href=\"https://fortune.com/2025/10/29/amazon-layoffs-ai-middle-managers-robots-factory-workers/\" target=\"_self\" aria-label=\"Go to https://fortune.com/2025/10/29/amazon-layoffs-ai-middle-managers-robots-factory-workers/\">investments</a> into AI.&nbsp; <a href=\"https://fortune.com/company/target/\" target=\"_blank\" aria-label=\"Go to https://fortune.com/company/target/\">Target</a>, Paramount, and other large firms followed with their own cuts.\n\n\n\n</p><p>According to a Challenger, Gray &amp; Christmas <a href=\"https://www.challengergray.com/wp-content/uploads/2025/10/Challenger-Report-September-2025.pdf\" target=\"_blank\" rel=\"noopener\" aria-label=\"Go to https://www.challengergray.com/wp-content/uploads/2025/10/Challenger-Report-September-2025.pdf\">report</a>, U.S. employers have announced nearly 946,000 layoffs so far this year—the highest total since 2020—with more than 17,000 explicitly tied to AI and another 20,000 to automation.<p>“Job creation is very low, and the job-finding rate for people who are unemployed is very low,” Powell said.</p><p>The phenomenon is so widespread some economists have coined a new term—</p><a href=\"https://www.hrdive.com/news/the-great-freeze-in-hiring-may-be-thawing-ziprecruiter/803855/\" target=\"_blank\" rel=\"noopener\" aria-label=\"Go to https://www.hrdive.com/news/the-great-freeze-in-hiring-may-be-thawing-ziprecruiter/803855/\">the “Great Freeze</a>”—to describe the dismal labor market conditions. With unemployment among recent college grads topping 5%—and AI threatening to<a href=\"https://fortune.com/2025/10/29/amazon-layoffs-ai-middle-managers-robots-factory-workers/\" target=\"_self\" aria-label=\"Go to https://fortune.com/2025/10/29/amazon-layoffs-ai-middle-managers-robots-factory-workers/\"> automate entry-level office jobs</a>—many Gen Z workers are <a href=\"https://fortune.com/2025/10/28/gen-z-ai-threat-law-business-school-applications-surge-classroom-economic-recession-job-market-labor-force-unemployement-rate-economy/\" target=\"_self\" aria-label=\"Go to https://fortune.com/2025/10/28/gen-z-ai-threat-law-business-school-applications-surge-classroom-economic-recession-job-market-labor-force-unemployement-rate-economy/\">turning to graduate school </a>as a strategic timeout.&nbsp;\n\n\n\n</p><p>That awkward balance—strong investment but weak hiring— is now at the center of the Fed’s decision-making. Powell said the economy increasingly resembles <a href=\"https://fortune.com/2025/10/24/why-is-economy-so-bad-recession-not-inflation-fed-rate-cuts-2025/\" target=\"_self\" aria-label=\"Go to https://fortune.com/2025/10/24/why-is-economy-so-bad-recession-not-inflation-fed-rate-cuts-2025/\">a K-shape,</a> with higher-income households and large corporations benefiting from strong stock markets and AI-fueled productivity gains, while<a href=\"https://fortune.com/2025/08/13/growing-gap-between-higher-income-lower-income-rich-poor-americans-wages-spending/\" target=\"_self\" aria-label=\"Go to https://fortune.com/2025/08/13/growing-gap-between-higher-income-lower-income-rich-poor-americans-wages-spending/\"> lower-income consumers pull back</a> under the weight of rising costs.&nbsp;\n\n\n\n</p><p>He pointed to anecdotal reports from major retailers and consumer companies describing a “bifurcated economy,” in which wealthier Americans continue to spend freely but those at the bottom are trading down to cheaper goods. “<p>“Consumers at the lower end are struggling and buying less and shifting to lower-cost products,” Powell said, noting the uneven effects of growth make the Fed’s balancing act even more complicated.</p></p><p>“There is no risk-free path for policy,” Powell said. “We’re navigating the tension between our employment and inflation goals as carefully as we can.”\n</p>","contentLength":3742,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/artificial/comments/1okb894/jerome_powell_says_the_ai_hiring_apocalypse_is/"},{"title":"Adobe software now has graphics acceleration via Wine!","url":"https://www.reddit.com/r/linux/comments/1okacq8/adobe_software_now_has_graphics_acceleration_via/","date":1761855153,"author":"/u/maseckt","guid":322329,"unread":true,"content":"<p>A convenient way to install Adobe After Effects on Linux using Wine. Please stars this! This project right now on OBT, if u can check some errors on flatpak package, pls write on \"issues on github\" Github: <a href=\"https://github.com/relativemodder/aegnux\">https://github.com/relativemodder/aegnux</a></p>","contentLength":246,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Dependency Management in Database Design (aka handling import cycles in large Go projects)","url":"https://www.dolthub.com/blog/2025-10-29-dependency-management/","date":1761851799,"author":"/u/nick_at_dolt","guid":322412,"unread":true,"content":"<p>Codebase organization and design is a vital skill, and a skill I was never taught it in school and had to pick up in the industry. I suspect it wasn’t taught for two reasons:</p><ol><li>Codebase design is a soft skill. Even when you can recognize a well-structured codebase, opinions differ on how to make code organized. It’s more art than science. Just look at the long list of incompatable practices on Wikipedia’s <a href=\"https://en.wikipedia.org/wiki/List_of_software_development_philosophies\">List of software development philosophies</a></li><li>The importance of codebase architecture is much more apparent with larger, more complex code bases. Most of the code written in academia may never reach the level of complexity where good organization matters.</li></ol><p>Our project, <a href=\"https://www.dolthub.com/\">Dolt</a>, definitely meets that threshold where organization matters.\nDolt is the first SQL database with Git-style branches; it’s revision control for your data. And we’ve put a lot of work into it: the <a href=\"https://github.com/dolthub/dolt\">Dolt code repository</a> contains 762k lines of Golang code (excluding generated files), broken up into 204 different packages. We also make <a href=\"https://github.com/dolthub/go-mysql-server\">go-mysql-server</a>, the SQL engine used by Dolt which itself consists of 475k lines of Golang code in 59 different packages. The code is <a href=\"https://www.dolthub.com/blog/2025-06-02-dolt-turns-10/\">ten years old</a>.</p><p>That’s way more code than any one person can keep in their head. Breaking it up into packages helps, but how did we determine what the packages should be, and what code goes in what package?</p><p>For any project big enough, you’re going to want packages. Not just because they speed up your compilation time and allow for partial recompiles, but because organizing code this way inherently leads to cleaner projects that are more easily understood. The act of breaking code up into components is called  and it’s an important part of code architecture. When talking about modularization, we call these individual components modules.</p><p>A core principle of modern software design is the “single responsibility principle”, which states that each module only has one responsibility, and complex behavior is achieved by composing these modules. The intent is that if each module can be understood completely independently from the others, than modules can be developed in parallel with minimal risk of changes in one module breaking the behavior of other modules.</p><p>At a glance, there appear to be two main tradeoffs to modularization, although these “tradeoffs” are usually upfront costs that are outweighed by the benefit of making code maintenance significantly easier:</p><ol><li>Modularizing your codebase requires forethought and slightly increases the overall complexity of the codebase. As a project grows, assumptions made when designing the structure of the code may prove to be incorrect, resulting in either modules with multiple responsibilities that are difficult to understand, or “leaky” abstraction modules that require knowledge of their inner workings in order to use correctly. When this happens the code may need to be restructured.</li><li>Modularizing your code introduces the threat of dependency cycles: if module A depends on code symbols from module B, and module B depends on module C, then C should not depend on A. And while dependency cycles are often simple enough to untangle in theory, understanding their causes in complex code bases can be a challenge, and fixing them may require tedious refactors. In many languages, including Golang, dependency cycles between modules won’t even compile.</li></ol><p>It’s very easy for someone who doesn’t understand the layout of a codebase to accidentally introduce dependency cycles and then have trouble removing them. And dependency cycles are especially frustrating for devs because they feel like a barrier to writing clean code. In the moment, it can feel like modularization is making development . But it’s important to remember that:</p><ul><li>Without modularization, a developer that doesn’t understand the entire codebase might not be able to contribute , and</li><li>While the code that is creating the dependency cycle feels simple and clean, it’s actually introducing a new relationship between code components that will make them difficult to separate in the future.</li><li>Breaking a dependency cycle is often much simpler once the developer understands the responsibilities of the different components involved and their relationship to each other, and modularization makes that understanding a lot easier.</li></ul><p>This is best demonstrated by an example. This is a real contribution I made to Dolt where:</p><ul><li>The modularization of the codebase allowed me to develop features for one component without needing to fully understand the details of other related component.</li><li>I was temporarily stymied by a dependency cycle.</li><li>Identifying the best way to resolve the dependency cycle took time, but left me with a better understanding of how different components were connected, making it time well spent.</li><li>Armed with this better understanding, the solution became simple.</li></ul><p>We recently added support for a feature we called <a href=\"https://www.dolthub.com/blog/2025-10-06-nonlocal-tables/\">nonlocal tables</a>: Essentially, a user can configure one branch such that certain table names actually resolve to a table on another branch. The core functionality was easier to implement than expected. Next we added the ability for branches to have foreign key constraints on these tables, which proved to be more challenging.\nWe expected that foreign keys would have some odd behavior here, since changes on the referenced branch could cause these foreign key constraints to become violated. Since it’s already possible for version control commands to create similar situations, we already had a tool in place to handle this: for circumstances where it’s not possible to prevent violations, Dolt has a special tool to detect them after the fact: the  system procedure and the associated  CLI command.</p><p>This command reads the database storage layer and determines whether or not any foreign key constraints on your branch are being violated. The logic is much simpler than every other part of this feature, and it was straightforward enough that we didn’t give it much thought in design; once we had the ability to correctly resolve table names, all we had to do was allow the validation logic to depend on the name resolution logic. It should have been a one-line change.</p><p>And yet, figuring out how to properly expose the name resolution logic to the validator turned out to be the hard part. But why?</p><p>Well, let’s look at the package structure for Dolt. The logic for executing  makes use the following packages, among others:</p><ul><li> - A collection of primitive types and interfaces required for running a database. Many of the types we use are defined here. This package is a great example of a common abstraction that other modules can depend on without needing to depend on each other. But it means that anything in this module cannot depend on any of the modules that make use of it. This means that there are still lots of interfaces that can’t go in this package.\n<ul><li>This package contains a  interface, describing a table that a database engine can interact with.</li></ul></li><li><code>dolt/go/libraries/doltcore/doltdb</code> - This defines the core types that power Dolt’s data structures, and defines core operations on these types. The logic for validating foreign keys is defined in this package.\n<ul><li>This package contains a  type, representing a table in storage. This type alone does not have the necessary context to be used by an engine, so it cannot implement .</li></ul></li><li><code>dolt/go/libraries/doltcore/sqle/dsess</code> - This contains the logic responsible for maintaining the current state of a database session, including transactions.</li><li><code>dolt/go/libraries/doltcore/sqle</code> - This implements a SQL engine on top of the storage layer. Evalutating references to other branches happens here, because the result of the evaluation depends on the current transaction, otherwise you might get concurrency issues.\n<ul><li>This package contains a  type, which implements . It can be constructed from a .</li></ul></li><li><code>dolt/cmd/dolt/commands/cvcmds</code> - The implementation of the command line command for validating constraints, including foreign keys.</li></ul><p>Something else I was never taught in school: how to make proper UML diagrams.</p><p>These five packages form a clean chain of dependencies: each package depends on every package listed above it, and none of the packages below it. And it means that when developing any of these packages, as long as you don’t change the behavior of its exported functions, you can safely ignore all the packages below it.</p><p>So let’s look back at the thing that we thought would be a one-line fix:</p><blockquote><p>“all we had to do was allow the validation logic to depend on the name resolution logic”</p></blockquote><p>We can now see that there are three separate problems with this proposal:</p><ul><li>We can’t modify the validation logic in  to depend on the new table name resolution logic… because the table name resolution logic depends on branch reference resolution, which is implemented in . This is a dependency cycle.</li><li>The command itself is implemented in the top level package , and is thus allowed to depend on everything. The engine has public functions that can resolve branch names, but those functions have parameters that the command couldn’t provide, because some of that context is encapsulated by the  package.</li><li>Finally, while both of these packages have methods for interacting with tables, the types used to represent a table have a different shape, different responsibilities, and don’t implement a common interface.</li></ul><p>Again, it may feel like modularization is getting in our way by preventing us from calling functions or accessing state that we need. But the package layout also makes it clear that even if we could simply glue together these two components together, doing so would expose their internal state to each other in a way that could be complicated to refactor later. It’s worth putting in the extra legwork now to avoid this, and in doing so might suggest ways to keep the code readable.</p><p>So given all that, what’s the cleanest way to solve these problems?</p><ul><li>Could we break the cycle by cleaving off some part of the  package, and then having both the engine and storage layers depend on this new package? Probably not: the functionality we’re trying to isolate depends on the session management code in the  package: separating it out would prevent one cycle, but create another.</li><li>Perhaps instead, we provide a way to resolve branch references without needing access to the current transaction? Then we could put all the branch resolution code in the  storage layer. This could probably be done, but it would be a major change and would need to be done very carefully. We’d have to duplicate some of the lookup logic in the engine and in storage, it would be tricky to get right, and the cost of getting it wrong could be subtle concurrency bugs: no database wants that.</li></ul><p>Instead, the best way to avoid dependency cycles is to have both modules should depend on a common “abstraction” instead. Usually this means an interface type. Interfaces are a great tool when you have a simple problem statement and you already how to solve that problem, and you’re just trying to avoid introducing new dependencies.</p><p>We have a simple problem statement: resolve a table name to a table, using the new rules for referencing tables on other branches. And we already have code that solves that problem. But the logic that requires that code cannot depend on it. So dependency inversion says: depend on an abstraction. And we accomplish that in three easy steps.</p><h3>Step 1: The low-level package creates an interface that describes the shape of the operation we need.</h3><p>We define a new interface  in the  package that describes the shape of the operation we need:</p><pre tabindex=\"0\" data-language=\"go\"><code></code></pre><h3>Step 2: The higher-level package provides an implementation.</h3><p>In the  package, we provide an implementation. This requires adding some new functions to the package:</p><ul><li>A function that can return the underlying  type used by the storage layer instead of preemptively constructing the higher-level type used by the engine.</li><li>An exported function that returns a  value for use by other packages.</li></ul><h3>Step 3: The top level package does dependency-injection</h3><p>With these changes in place, the top level  package can get a  from the engine and pass it as an additional parameter to the relevant storage layer calls. This allows the new name resolution rules to influence storage operations without creating any additional dependencies.</p><p>As presented, this seems like a simple and obvious solution. And it  a simple solution… but it’s only obvious when viewed in the context of the code’s organization. It’s obvious that this approach won’t  create dependency cycles or expose internal state, but we need to understand the package boundaries to see why other, similar-looking approaches .</p><p>Implementing this feature helped me better understand the exact relationship between the many different packages Dolt uses when performing even simple database operations. It ensured that any changes I made to boundaries between packages were thoughtful and deliberate, and it helped me identify future opportunities to clean up some of these interfaces and make them more usable.</p><p>I’m not sure if good codebase architecture can be taught: maybe it can only be learned. And I definitely learned something about Dolt’s design, not just the how but the . And that lesson is not only going to help me now as I develop Dolt, but also influence any codebase design I may do in the future.</p><p>I’m biased, but I think Dolt is a pretty well-designed piece of software. It’s not perfect and it’s had it’s growing pains, but it has a solid core that’s been fun to work with. Databases have a ton of complexity, and we’ve done a good job of managing that complexity such that we can continue to add cool new features.</p><p>If you have a feature you want to see in Dolt, [drop us a line on Discord] and we’ll scope it out. We take user requests seriously when deciding our priorities. If you’re looking for cool open-source projects to contribute to, we’re always welcoming contributors and are happy to help you get set up. We even have a <a href=\"https://github.com/dolthub/dolt/issues?q=state%3Aopen%20label%3A%22good%20first%20issue%22\">good first issue</a> tag on GitHub.</p>","contentLength":14030,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1ok8wm5/dependency_management_in_database_design_aka/"},{"title":"Windows wouldn't let me access my HDD but Linux did","url":"https://www.reddit.com/r/linux/comments/1ok8of4/windows_wouldnt_let_me_access_my_hdd_but_linux_did/","date":1761851282,"author":"/u/snypse_","guid":322307,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"What happens if a goroutine holding a sync.Mutex gets preempted by the OS scheduler?","url":"https://www.reddit.com/r/golang/comments/1ok8j3j/what_happens_if_a_goroutine_holding_a_syncmutex/","date":1761850951,"author":"/u/Alihussein94","guid":323414,"unread":true,"content":"<p>What will happen when a Goroutine locks a variable (sync.Mux) and then the Linux kernel decides to move the thread that this goroutine is running on to a blocked state, for instance, because higher higher-priority thread is running. Do the other Goroutines wait till the thread is scheduled to another CPU core and then continue processing, and then finally unlock the variable?</p>","contentLength":378,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Zig's New Async I/O (Text Version)","url":"https://andrewkelley.me/post/zig-new-async-io-text-version.html","date":1761850305,"author":"/u/BrewedDoritos","guid":322305,"unread":true,"content":"<p>This is a preview of the new async I/O primitives that will be available in the upcoming Zig 0.16.0, to be\nreleased in about 3-4 months. There is a lot more to get into, but for now here is an introduction\ninto some of the core synchronization API that will be available for all Zig code to use.</p><p>To begin, let's try to keep it simple and understand the basics, and then we'll then slowly add more\nasynchronous things into it.</p><p>With our first example, there is nothing asynchronous here. It's basically \"Hello, World!\" in Zig.</p><pre><code>const std = @import(\"std\");\n\npub fn main() !void {\n    doWork();\n}\n\nfn doWork() void {\n    std.debug.print(\"working\\n\", .{});\n    var timespec: std.posix.timespec = .{ .sec = 1, .nsec = 0 };\n    _ = std.posix.system.nanosleep(&amp;timespec, &amp;timespec);\n}</code></pre><pre>0s $ zig run example0.zig\n0s working\n1s $</pre><p>Next, we're going to set up a little bit. Still not using async/await yet, but I need some tools in my\ntoolbox before we add complexity.</p><pre><code>const std = @import(\"std\");\nconst Io = std.Io;\nconst Allocator = std.mem.Allocator;\nconst assert = std.debug.assert;\n\nfn juicyMain(gpa: Allocator, io: Io) !void {\n    _ = gpa;\n\n    doWork(io);\n}\n\nfn doWork(io: Io) void {\n    std.debug.print(\"working\\n\", .{});\n    io.sleep(.fromSeconds(1), .awake) catch {};\n}\n\npub fn main() !void {\n    // Set up allocator.\n    var debug_allocator: std.heap.DebugAllocator(.{}) = .init;\n    defer assert(debug_allocator.deinit() == .ok);\n    const gpa = debug_allocator.allocator();\n\n    // Set up our I/O implementation.\n    var threaded: std.Io.Threaded = .init(gpa);\n    defer threaded.deinit();\n    const io = threaded.io();\n\n    return juicyMain(gpa, io);\n}</code></pre><pre>0s $ zig run example0.zig\n0s working\n1s $</pre><p>Setting up a  implementation is a lot like setting up an allocator.\nYou typically do it once, in main(), and then pass the instance throughout the application.\nReusable code should accept an Allocator parameter if it needs to allocate, and it should accept\nan Io parameter if it needs to perform I/O operations.</p><p>In this case, this is an Io implementation based on threads. This is not using\nKQueue, this is not using IO_Uring, this is not using an event loop. It is a  implementation\nof the new  interface.</p><p>This setup will be the same in all the examples, so now we can focus on our example code, which is the same\nas last time. Still nothing interesting - we just call  which of course is just calling sleep().</p><p>Redundant setup code omitted from here on out.</p><pre><code>fn juicyMain(gpa: Allocator, io: Io) !void {\n    _ = gpa;\n\n    var future = io.async(doWork, .{io});\n\n    future.await(io); // idempotent\n}\n\nfn doWork(io: Io) void {\n    std.debug.print(\"working\\n\", .{});\n    io.sleep(.fromSeconds(1), .awake) catch {};\n}</code></pre><pre>0s $ zig run example0.zig\n0s working\n1s $</pre><p>Now we're using async/await to call doWork. What async/await means to Zig is to  the\n of the function to the  of the function.</p><p>This code is the same as before. It's exactly the same, because we didn't put any code between the async\nand await. We do the call, and then immediately wait for the return.</p><p>In the next example, we have two things at the same time:</p><pre><code>fn juicyMain(gpa: Allocator, io: Io) !void {\n    _ = gpa;\n\n    var a = io.async(doWork, .{ io, \"hard\" });\n    var b = io.async(doWork, .{ io, \"on an excuse not to drink Spezi\" });\n\n    a.await(io);\n    b.await(io);\n}\n\nfn doWork(io: Io, flavor_text: []const u8) void {\n    std.debug.print(\"working {s}\\n\", .{flavor_text});\n    io.sleep(.fromSeconds(1), .awake) catch {};\n}</code></pre><pre>0s $ zig run example3.zig\n0s working on an excuse not to drink Spezi\n0s working hard\n1s $</pre><p>If you look carefully, you can see that it did not wait two seconds; it waited one second because\nthese operations are happening at the same time. This demonstrates why using async/await is useful -\nyou can express asynchrony. Depending on the I/O implementation that you\nchoose, it may be able to take advantage of the asynchrony that you have\nexpressed and make your code go faster. For example in this case,\n was able to do two seconds of work in one second\nof actual time.</p><p>Let's start to bring the example closer to a real world scenario by introducing .</p><pre><code>fn juicyMain(gpa: Allocator, io: Io) !void {\n    var a = io.async(doWork, .{ gpa, io, \"hard\" });\n    var b = io.async(doWork, .{ gpa, io, \"on an excuse not to drink Spezi\" });\n\n    try a.await(io);\n    try b.await(io);\n}\n\nfn doWork(gpa: Allocator, io: Io, flavor_text: []const u8) !void {\n    // Simulate an error occurring:\n    if (flavor_text[0] == 'h') return error.OutOfMemory;\n\n    const copied_string = try gpa.dupe(u8, flavor_text);\n    defer gpa.free(copied_string);\n    std.debug.print(\"working {s}\\n\", .{copied_string});\n    io.sleep(.fromSeconds(1), .awake) catch {};\n}</code></pre><p>It's the same code as before, except the first task will return an error.</p><p>Guess what happens when this code is run?</p><pre>0s $ zig run example4.zig\n0s working on an excuse not to drink Spezi\n1s error(gpa): memory address 0x7f99ce6c0080 leaked:\n1s /home/andy/src/zig/lib/std/Io/Threaded.zig:466:67: 0x1053aae in async (std.zig)\n1s     const ac: *AsyncClosure = @ptrCast(@alignCast(gpa.alignedAlloc(u8, .of(AsyncClosure), n) catch {\n1s                                                                   ^\n1s /home/andy/src/zig/lib/std/Io.zig:1548:40: 0x1164f94 in async__anon_27344 (std.zig)\n1s     future.any_future = io.vtable.async(\n1s                                        ^\n1s /home/andy/misc/talks/zigtoberfest/async-io-examples/example4.zig:8:21: 0x116338a in juicyMain (example4.zig)\n1s     var b = io.async(doWork, .{ gpa, io, \"on an excuse not to drink Spezi\" });\n1s                     ^\n1s /home/andy/misc/talks/zigtoberfest/async-io-examples/example4.zig:35:21: 0x1163663 in main (example4.zig)\n1s     return juicyMain(gpa, io);\n1s                     ^\n1s /home/andy/src/zig/lib/std/start.zig:696:37: 0x1163c83 in callMain (std.zig)\n1s             const result = root.main() catch |err| {\n1s                                     ^\n1s /home/andy/src/zig/lib/std/start.zig:237:5: 0x1162f61 in _start (std.zig)\n1s     asm volatile (switch (native_arch) {\n1s     ^\n1s \n1s thread 1327233 panic: reached unreachable code\n1s error return context:\n1s /home/andy/src/zig/lib/std/Io.zig:1003:13: 0x11651a8 in await (std.zig)\n1s             return f.result;\n1s             ^\n1s /home/andy/misc/talks/zigtoberfest/async-io-examples/example4.zig:10:5: 0x11633e8 in juicyMain (example4.zig)\n1s     try a.await(io);\n1s     ^\n1s \n1s stack trace:\n1s /home/andy/src/zig/lib/std/debug.zig:409:14: 0x103e5a9 in assert (std.zig)\n1s     if (!ok) unreachable; // assertion failure\n1s              ^\n1s /home/andy/misc/talks/zigtoberfest/async-io-examples/example4.zig:27:17: 0x1163698 in main (example4.zig)\n1s     defer assert(debug_allocator.deinit() == .ok);\n1s                 ^\n1s /home/andy/src/zig/lib/std/start.zig:696:37: 0x1163c83 in callMain (std.zig)\n1s             const result = root.main() catch |err| {\n1s                                     ^\n1s /home/andy/src/zig/lib/std/start.zig:237:5: 0x1162f61 in _start (std.zig)\n1s     asm volatile (switch (native_arch) {\n1s     ^\n1s fish: Job 1, 'zig run example4.zig' terminated by signal SIGABRT (Abort)\n1s $</pre><p>The problem is that when the first  activates, it skips the second  which\nis then caught by the leak checker.</p><p>This is a bug. It's unfortunate though, isn't it? Because we would like to write the code this way.</p><pre><code>fn juicyMain(gpa: Allocator, io: Io) !void {\n    var a = io.async(doWork, .{ gpa, io, \"hard\" });\n    var b = io.async(doWork, .{ gpa, io, \"on an excuse not to drink Spezi\" });\n\n    const a_result = a.await(io);\n    const b_result = b.await(io);\n\n    try a_result;\n    try b_result;\n}\n\nfn doWork(gpa: Allocator, io: Io, flavor_text: []const u8) !void {\n    // Simulate an error occurring:\n    if (flavor_text[0] == 'h') return error.OutOfMemory;\n\n    const copied_string = try gpa.dupe(u8, flavor_text);\n    defer gpa.free(copied_string);\n    std.debug.print(\"working {s}\\n\", .{copied_string});\n    io.sleep(.fromSeconds(1), .awake) catch {};\n}</code></pre><p>We do the awaits, then we do the tries. This will fix the problem.</p><pre>0s $ zig run example5.zig\n0s working on an excuse not to drink Spezi\n1s error: OutOfMemory\n1s /home/andy/src/zig/lib/std/Io.zig:1003:13: 0x11651d8 in await (std.zig)\n1s             return f.result;\n1s             ^\n1s /home/andy/misc/talks/zigtoberfest/async-io-examples/example5.zig:13:5: 0x1163416 in juicyMain (example5.zig)\n1s     try a_result;\n1s     ^\n1s /home/andy/misc/talks/zigtoberfest/async-io-examples/example5.zig:38:5: 0x11636e9 in main (example5.zig)\n1s     return juicyMain(gpa, io);\n1s     ^\n1s $</pre><p>This failed successfully. The error was handled and no resources leaked. But\nit's a footgun. Let's find a better way to express this...</p><p>This is where  comes in. cancellation is an extremely handy primitive,\nbecause now we can use , , and  like normal,\nand not only do we fix the bug, but we also get more optimal code.</p><pre><code>fn juicyMain(gpa: Allocator, io: Io) !void {\n    var a = io.async(doWork, .{ gpa, io, \"hard\" });\n    defer a.cancel(io) catch {};\n\n    var b = io.async(doWork, .{ gpa, io, \"on an excuse not to drink Spezi\" });\n    defer b.cancel(io) catch {};\n\n    try a.await(io);\n    try b.await(io);\n}\n\nfn doWork(gpa: Allocator, io: Io, flavor_text: []const u8) !void {\n    // Simulate an error occurring:\n    if (flavor_text[0] == 'h') return error.OutOfMemory;\n\n    const copied_string = try gpa.dupe(u8, flavor_text);\n    defer gpa.free(copied_string);\n    std.debug.print(\"working {s}\\n\", .{copied_string});\n    io.sleep(.fromSeconds(1), .awake) catch {};\n}</code></pre><p>Thanks to cancellation, we now get instant results, because the moment that the first\ntask returns an error, the cancels get run.</p><pre>0s $ zig run example6.zig\n0s working on an excuse not to drink Spezi\n0s error: OutOfMemory\n0s /home/andy/misc/talks/zigtoberfest/async-io-examples/example6.zig:13:5: 0x116348c in juicyMain (example6.zig)\n0s     try a.await(io);\n0s     ^\n0s /home/andy/misc/talks/zigtoberfest/async-io-examples/example6.zig:38:5: 0x1163909 in main (example6.zig)\n0s     return juicyMain(gpa, io);\n0s     ^\n0s $</pre><p> is your best friend, because it's going to prevent you from leaking the\nresource, and it's going to make your code run more optimally.</p><p> is trivial to understand: it has identical semantics as , except\nthat it <em>also requests cancellation</em>. The conditions under which cancellation requests are honored\nare defined by each I/O implementation.</p><p>Both  and  are idempotent with respect to themselves and each other.</p><p>Next, let's introduce another real-world scenario: .\nIn this case, we allocate a string on success, which the caller needs to manage.</p><pre><code>fn juicyMain(gpa: Allocator, io: Io) !void {\n    var a = io.async(doWork, .{ gpa, io, \"hard\" });\n    defer if (a.cancel(io)) |s| gpa.free(s) else |_| {};\n\n    var b = io.async(doWork, .{ gpa, io, \"on an excuse not to drink Spezi\" });\n    defer if (b.cancel(io)) |s| gpa.free(s) else |_| {};\n\n    const a_string = try a.await(io);\n    const b_string = try b.await(io);\n    std.debug.print(\"finished {s}\\n\", .{a_string});\n    std.debug.print(\"finished {s}\\n\", .{b_string});\n}\n\nfn doWork(gpa: Allocator, io: Io, flavor_text: []const u8) ![]u8 {\n    const copied_string = try gpa.dupe(u8, flavor_text);\n    std.debug.print(\"working {s}\\n\", .{copied_string});\n    io.sleep(.fromSeconds(1), .awake) catch {};\n    return copied_string;\n}</code></pre><p>Now we see why  and  have the same API.\nThe deferred cancel calls above free the allocated resource, handling both\nsuccessful calls (resource allocated) and failed calls (resource not allocated).</p><pre>0s $ zig run example7.zig\n0s working on an excuse not to drink Spezi\n0s working hard\n1s finished hard\n1s finished on an excuse not to drink Spezi\n1s $</pre><p>The important thing here is that by doing resource management like this, we are\nable to write standard, idiomatic Zig code below, using  and \nlike normal without worrying about special resource management cases.</p><p>In this example we have a producer sending one item across an unbuffered queue to a consumer.</p><pre><code>fn juicyMain(io: Io) !void {\n    var queue: Io.Queue([]const u8) = .init(&amp;.{});\n\n    var producer_task = io.async(producer, .{\n        io, &amp;queue, \"never gonna give you up\",\n    });\n    defer producer_task.cancel(io) catch {};\n\n    var consumer_task = io.async(consumer, .{ io, &amp;queue });\n    defer _ = consumer_task.cancel(io) catch {};\n\n    const result = try consumer_task.await(io);\n    std.debug.print(\"message received: {s}\\n\", .{result});\n}\n\nfn producer(\n    io: Io,\n    queue: *Io.Queue([]const u8),\n    flavor_text: []const u8,\n) !void {\n    try queue.putOne(io, flavor_text);\n}\n\nfn consumer(\n    io: Io,\n    queue: *Io.Queue([]const u8),\n) ![]const u8 {\n    return queue.getOne(io);\n}</code></pre><p>We use  to spawn the producer and  to spawn the consumer.</p><pre>0s $ zig run example8.zig\n0s message received: never gonna give you up\n0s $</pre><p>This incorrectly succeeds. Depending on your perspective, we either got \"lucky\" or \"unlucky\" due\nto the thread pool having spare concurrency that happened to be available.</p><p>To observe the problem, we can artificially limit the  instance to\nuse a thread pool size of one:</p><pre><code>// Set up our I/O implementation.\n    var threaded: std.Io.Threaded = .init(gpa);\n    threaded.cpu_count = 1;\n    defer threaded.deinit();\n    const io = threaded.io();\n\n    return juicyMain(io);\n}</code></pre><p>Now that it's only using one thread, it deadlocks, because the consumer is waiting to get something from\nthe queue, and the producer is scheduled to run, but it has not run yet.</p><p>The problem is that <em>we needed concurrency, but we asked for asynchrony</em>.</p><p>In order to fix this, we use  instead of .\nThis one can fail with <code>error.ConcurrencyUnavailable</code>.</p><pre><code>fn juicyMain(io: Io) !void {\n    var queue: Io.Queue([]const u8) = .init(&amp;.{});\n\n    var producer_task = try io.concurrent(producer, .{\n        io, &amp;queue, \"never gonna give you up\",\n    });\n    defer producer_task.cancel(io) catch {};\n\n    var consumer_task = try io.concurrent(consumer, .{ io, &amp;queue });\n    defer _ = consumer_task.cancel(io) catch {};\n\n    const result = try consumer_task.await(io);\n    std.debug.print(\"message received: {s}\\n\", .{result});\n}\n\nfn producer(\n    io: Io,\n    queue: *Io.Queue([]const u8),\n    flavor_text: []const u8,\n) !void {\n    try queue.putOne(io, flavor_text);\n}\n\nfn consumer(\n    io: Io,\n    queue: *Io.Queue([]const u8),\n) ![]const u8 {\n    return queue.getOne(io);\n}</code></pre><pre>0s $ zig run example10.zig\n0s message received: never gonna give you up\n0s $</pre><p>Now the code is fixed because we correctly expressed that we needed concurrency, which\n honored by oversubscribing.</p><p>If I add  which truly limits the executable to one thread,\noversubscription is not available, causing this output:</p><pre>error: ConcurrencyUnavailable\n/home/andy/src/zig/lib/std/Io/Threaded.zig:529:34: 0x1051863 in concurrent (std.zig)\n    if (builtin.single_threaded) return error.ConcurrencyUnavailable;\n                                 ^\n/home/andy/src/zig/lib/std/Io.zig:1587:25: 0x1158b5f in concurrent__anon_26591 (std.zig)\n    future.any_future = try io.vtable.concurrent(\n                        ^\n/home/andy/misc/talks/zigtoberfest/async-io-examples/example10.zig:9:25: 0x1157198 in juicyMain (example10.zig)\n    var producer_task = try io.concurrent(producer, .{\n                        ^\n/home/andy/misc/talks/zigtoberfest/async-io-examples/example10.zig:48:5: 0x115776a in main (example10.zig)\n    return juicyMain(io);\n    ^</pre><p>There are proof-of-concept  implementations using IoUring and KQueue combined\nwith stackful coroutines which show a lot of promise, however that work depends on some language\nenhancements to be practical. There is also ongoing design work about stackless coroutines. Here\nare some relevant issues to track for those interested:</p><p>These APIs are not set in stone. It will probably take a few iterations to\nget it right. Please try them out in  and let\nus know how it goes! Let's collaborate on making the I/O interface practical\nand optimal.</p>","contentLength":15875,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ok88li/zigs_new_async_io_text_version/"},{"title":"With the release of Rust 1.91, Arm is now a Tier 1 supported architecture on Windows","url":"https://github.com/rust-lang/rust/pull/145682","date":1761849861,"author":"/u/Balance-","guid":323349,"unread":true,"content":"<p> is now a Tier 1 target with host tools for Rust, meaning ARM64 Windows with MSVC is \"guaranteed to work\" as a fully supported platform. This means the Rust project provides official binary releases, runs automated testing after every change to ensure builds and tests pass, and supports running development tools like  and  natively on ARM64 Windows machines. In practical terms, developers can now confidently use ARM64 Windows devices (like Windows on ARM laptops) both as compilation targets and as development platforms with the same level of support as established platforms like x86_64 Windows and ARM64 macOS.</p>","contentLength":617,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1ok81lz/with_the_release_of_rust_191_arm_is_now_a_tier_1/"},{"title":"Rust 1.90.1 is out","url":"https://blog.rust-lang.org/2025/10/30/Rust-1.91.0/","date":1761849591,"author":"/u/manpacket","guid":322303,"unread":true,"content":"<p>The Rust team is happy to announce a new version of Rust, 1.91.0. Rust is a programming language empowering everyone to build reliable and efficient software.</p><p>If you have a previous version of Rust installed via , you can get 1.91.0 with:</p><p>If you'd like to help us out by testing future releases, you might consider updating locally to use the beta channel () or the nightly channel (). Please <a href=\"https://github.com/rust-lang/rust/issues/new/choose\">report</a> any bugs you might come across!</p><p>The Rust compiler supports <a href=\"https://doc.rust-lang.org/rustc/platform-support.html\">a wide variety of targets</a>, but\nthe Rust Team can't provide the same level of support for all of them. To\nclearly mark how supported each target is, we use a tiering system:</p><ul><li>Tier 3 targets are technically supported by the compiler, but we don't check\nwhether their code build or passes the tests, and we don't provide any\nprebuilt binaries as part of our releases.</li><li>Tier 2 targets are guaranteed to build and we provide prebuilt binaries, but\nwe don't execute the test suite on those platforms: the produced binaries\nmight not work or might have bugs.</li><li>Tier 1 targets provide the highest support guarantee, and we run the full\nsuite on those platforms for every change merged in the compiler. Prebuilt\nbinaries are also available.</li></ul><p>Rust 1.91.0 promotes the  target to Tier 1 support,\nbringing our highest guarantees to users of 64-bit ARM systems running Windows.</p><h3><a href=\"https://blog.rust-lang.org/2025/10/30/Rust-1.91.0/#add-lint-against-dangling-raw-pointers-from-local-variables\" aria-hidden=\"true\"></a>\nAdd lint against dangling raw pointers from local variables</h3><p>While Rust's borrow checking prevents dangling references from being returned, it doesn't\ntrack raw pointers. With this release, we are adding a warn-by-default lint on raw\npointers to local variables being returned from functions. For example, code like this:</p><pre data-lang=\"rust\"><code data-lang=\"rust\"></code></pre><pre><code></code></pre><p>Note that the code above is not unsafe, as it itself doesn't perform any dangerous\noperations. Only dereferencing the raw pointer after the function returns would be\nunsafe. We expect future releases of Rust to add more functionality helping authors\nto safely interact with raw pointers, and with unsafe code more generally.</p><p>These previously stable APIs are now stable in const contexts:</p><p>Many people came together to create Rust 1.91.0. We couldn't have done it without all of you. <a href=\"https://thanks.rust-lang.org/rust/1.91.0/\">Thanks!</a></p>","contentLength":2118,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1ok7xdh/rust_1901_is_out/"},{"title":"Bluefin Autumn 2025: We visit the Bazaar","url":"https://docs.projectbluefin.io/blog/2025-10-28-bluefin-autumn/","date":1761847719,"author":"/u/fizzyizzy05","guid":322386,"unread":true,"content":"<p>Guardians, today Bluefin GTS switched its base from Fedora 41 to Fedora 42. The gathering of raptors has begun. In a two weeks Bluefin (aka ) releases on Fedora 43 and we will start the cycle all over again!</p><p>Looking for Fedora 43? That's here too in , and will roll out to  users in 2 weeks. It's tough to write two of these, so we'll likely just move to spring/autumn announcements and whenever major things land. When  upgrades I will post it as an addenum in the <a href=\"https://github.com/ublue-os/bluefin/discussions/3510\" target=\"_blank\" rel=\"noopener noreferrer\">discussion thread</a> for this post.</p><p>As it ends up F43 will be coming to  while we're in Atlanta, GA, for <a href=\"https://events.linuxfoundation.org/kubecon-cloudnativecon-north-america/\" target=\"_blank\" rel=\"noopener noreferrer\">KubeCon + CloudNativeCon</a>, come say hello! As a <a href=\"https://bootc-dev.github.io/\" target=\"_blank\" rel=\"noopener noreferrer\"></a> reference architecture we tend to align with the release cadence of other projects. This usually means that I'm on the road when there's a Bluefin release happening, so we do status reports like this depending on where we are in the world at the time, and to ensure transparency. It's also our chance to gather with attendees and get feedback on how we can make Bluefin better and gather feedback.</p><p>You'll receive this update during your next update window, or you can run an update manually by clicking on this icon:</p><p>If you've never experienced a Bluefin upgrade before, McPhail has a <a href=\"https://gld.mcphail.uk/posts/how-to-perform-a-major-version-upgrade-on-bluefin/\" target=\"_blank\" rel=\"noopener noreferrer\">full writeup</a>. Here's the major release information:</p><p>Bluefin is an operating system for your computer. It is designed to be installed on a device upgrade for the life of the hardware – we accomplish this by sharing the maintenance and care of our systems together as a community. It is designed to be as “zero touch” as possible by providing a curated GNOME experience.</p><p>Bluefin GTS (aka ) is our standard release, designed to be one cycle behind the most current Fedora release. This one's been in the oven for about six months and is ready to go. In a few weeks the  branch will move on to Fedora 43. If you're brand new you can use the website to <a href=\"https://projectbluefin.io/#scene-picker\" target=\"_blank\" rel=\"noopener noreferrer\">pick the right image</a> or select from the grid below:</p><p>This unidentified Dromeasaur is by <a href=\"https://natalia-jagielska.weebly.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Dr. Natalia Jagielska</a>, a world renowned expert <a href=\"https://www.nationalgeographic.com/science/article/stunning-scottish-pterosaur-is-biggest-fossil-of-its-kind\" target=\"_blank\" rel=\"noopener noreferrer\">paleontologist</a> and <a href=\"https://natalia-jagielska.weebly.com/art.html\" target=\"_blank\" rel=\"noopener noreferrer\">paleoartist</a>! We reached out to work with her on bringing her artwork and style to Bluefin, and she said yes! This rendition will be revealed in November, or you can just manually pick it in the wallpaper chooser.</p><p>I am so stoked about this, an actual scientist! We're retconning that this is just Bluefin enjoying a nice day at the lake. We have  more wallpapers from her coming soon. I have come to really appreciate the world of flying reptiles. They are <a href=\"https://en.wikipedia.org/wiki/Pterosaur#/media/File:Size_disparity_of_late_Maastrichtian_pterosaurs_and_birds.svg\" target=\"_blank\" rel=\"noopener noreferrer\">terrifying</a>.</p><p>Natalia's artwork was vectorized and remastered by <a href=\"https://ko-fi.com/melodyofdelphi\" target=\"_blank\" rel=\"noopener noreferrer\">Delphic Melody</a>, please consider donating so that the collaboration can continue!</p><p>There are a few major changes from a Bluefin perspective that we've been looking forward to:</p><h3>Installation Experience​<a href=\"https://docs.projectbluefin.io/blog/2025-10-28-bluefin-autumn/#installation-experience\" aria-label=\"Direct link to Installation Experience​\" title=\"Direct link to Installation Experience​\">​</a></h3><ul><li>The Anaconda web-ui installer is now the default installer, dramatically improving the experience. We say goodbye to the old GTK Anaconda installer.</li><li>We'll be automatically refreshing all the Bluefin ISOs once a month to ensure the installation media is fresh.</li></ul><p><a href=\"https://github.com/kolunmi/bazaar\" target=\"_blank\" rel=\"noopener noreferrer\">Bazaar</a> makes its debut in Bluefin GTS! All Bluefins are now just using the Bazaar flatpak. You're in for a treat:</p><p>It's been super awesome seeing Bazaar move from a random project we found on r/gnome to what is effectively now the premier app store experience for FlatHub and Linux. You can help out tremendously by <a href=\"https://github.com/sponsors/kolunmi\" target=\"_blank\" rel=\"noopener noreferrer\">sponsoring the author</a>.</p><p>This is also a major milestone for Bluefin since we've effectively done our part for the GNOME and FlatHub ecosystems and can now consider application installation a solved problem, we can introduce new things into Bluefin as a flatpak to begin with and move us away from distribution specific formats.</p><p>I am finding more applications now than I ever have. It's also a milestone for all Linuxes since flatpak's upcoming release gives us the flexibility to do this in a proper way with full lifecycle management. We can now be more flexible with the applications we can ship mid-cycle by plopping a file in . Those of you making custom images will really take advantage of this!</p><p>Shoutout to Sebastian Wick for this work in Flatpak and working on the next release of this cool tech!</p><div><div><p>We're committed to a future where authors deliver their applications how they see fit. This should be decoupled from the operating system.</p></div></div><p>Speaking of packages, we've been doing more work engaging with Homebrew developers, check out this interview I did with Workbrew talking about our hopes and dreams:</p><p>Let us know if you're interested in working on Homebrew for Linux, we have opened a <a href=\"https://github.com/ublue-os/homebrew-tap\" target=\"_blank\" rel=\"noopener noreferrer\">homebrew tap</a> so that we can interate on bringing cool new things to you. A huge shoutout goes to <a href=\"https://ko-fi.com/yulian\" target=\"_blank\" rel=\"noopener noreferrer\">Yulian Kuncheff</a> and <a href=\"https://github.com/sponsors/ahmedadan\" target=\"_blank\" rel=\"noopener noreferrer\">Ahmed Adan</a> for spearheading this effort, please consider donating!</p><p>The fonts have been a disaster for a long time, we're finally ripping the bandaid off and removing a bunch of fonts from the image. For you command line nerds you can install any of the <a href=\"https://formulae.brew.sh/cask-font/\" target=\"_blank\" rel=\"noopener noreferrer\">fonts listed in Homebrew</a> or use a tool like <a href=\"https://flathub.org/en/apps/io.github.getnf.embellish\" target=\"_blank\" rel=\"noopener noreferrer\">Embellish</a> to install more fonts.</p><p>If you're in developer mode you can bring the monospace fonts back with .</p><p>We've dropped the GNOME Quick Settings extension for tailscale in favor of the upstream system tray implementation. For more information, <a href=\"https://docs.projectbluefin.io/administration/#virtual-private-networks-vpn\" target=\"_blank\" rel=\"noopener noreferrer\">check the docs</a>, this requires manual set up.</p><p>The tailscale experience is still not where it needs to be, but now that Tailscale has started work on an official system tray implementation we expect this to solidify over the next few upstream releases.</p><p>After a hiatus we've finally refactored the Homebrew management in Bluefin. We're adding back some convenience commands:</p><p>Extinction is a natural part of life. After a deprecation cycle the following images are now removed:</p><ul><li>: Due to Nvidia's software support changes we can no longer support the older closed modules for Nvidia cards. Not many people are using these, either migrate to the  images or move to a stock image to use the built in kernel drivers.</li><li>: Not many people were using these, they have also been removed.</li></ul><p>As usual most of the changes we do in GitHub to deliver Bluefin and not so much in the image itself. Major parts of the Bluefin repository have been cleaned up to align with the improvements and lessons learned from building Bluefin LTS earlier in the year. This has been the bulk of the work in the past few weeks.</p><p>Bluefin has significantly been simplified, now would be a great time to contribute as we've brought the repository up to the state of more modern  projects like Bluefin LTS.</p><ul><li> and  will be publishing on Tuesdays from now on instead of Saturdays. Publishing on Saturday nights is an artifact of pre-automation \"reserved time\" for testing before a weekly release. This matches the same release schedule as Bluefin LTS.</li></ul><p>Bluefin is a deinonychus, and may snap at you occasionally. Four year olds can get feisty of so there might be issues that you discover that we haven't seen before. Filing issues is always appreciated.</p><p>We also accept donations to sponsor the infrastructure and artwork.</p><p>Sometimes starting in open source can be a real barrier if you don't know where to start. Don't have the skills to do cloud native things yet? Here's a good way to help out FlatHub. Flatpaks rely on what we call \"runtimes\" to ensure that the application has the dependencies it needs to run. Do a  to check them out:</p><p>This is important work because we want applications to be updated to the latest runtimes for security reasons. As it turns out, many of these applications have OPEN PULL REQUESTS already with people updating the runtime, you just need to find the app, run the updated version by following the instructions, and then report back to the Flatpak maintainer that the new app is working great (or broken!). Since GNOME 49 just released, there's plenty to do, so feel free to dive in and get started! Also remember, this work helps all of FlatHub, we're explictly sending new volunteers to help upstream.</p><div><div>FlatHub is critical to the desktop</div><div><p>We choose to help move application development forward via FlatHub instead of fragmenting the ecosystem with distribution-specific packaging. This includes shipping a premier FlatHub experience out of the box. You do not have to worry about misconfigured and low-quality Fedora flatpak remotes and packages on Bluefin systems.</p></div></div><p>Find your favorite app and see if there's a test build available for a new runtime. And if you have the skills to port applications to new runtimes, now is the time to flex. 😄</p><p>Check out <a href=\"https://store.projectbluefin.io\" target=\"_blank\" rel=\"noopener noreferrer\">store.projectbluefin.io</a> and pick up some dino merch. Thanks to John Johnson for ensuring our coffee mug game is up to snuff:</p><p>Nothing makes ops people happier than uneventful things.</p><p>Today is really like any other, we just updated a few tags, you always have the option to go to any version we support at any time. Wether you like the chill vibe of  or the refined aggresiveness of  , the raptor abides.</p><p>Here's the current lay of the land:</p><table><thead><tr></tr></thead><tbody><tr><td>Advanced users and testers</td></tr><tr></tr><tr></tr></tbody></table><p>NOTE: The  and  branches will move to F43 in two weeks.</p><h2>Desktop DevOps folks wanted!​<a href=\"https://docs.projectbluefin.io/blog/2025-10-28-bluefin-autumn/#desktop-devops-folks-wanted\" aria-label=\"Direct link to Desktop DevOps folks wanted!​\" title=\"Direct link to Desktop DevOps folks wanted!​\">​</a></h2><p>Bluefin is an active predator and is constantly hungry. You can help keep Bluefin healthy by becoming a contributor! We are an open source project and accept contributions:</p><p>As a cloud native project we are always looking for contributors with skills in Podman, Docker, CI/CD, GitHub Actions, and good ole bash.</p><p>Let's take a look at our contributor health, and celebrate the amazing folks who have come together to bring you Bluefin! We use <a href=\"https://insights.linuxfoundation.org/\" target=\"_blank\" rel=\"noopener noreferrer\">LFX Insights</a> to measure our project health. First note that my results here are skewed, since I am either usually just merging or telling a bot it's ok to do something. This also does not include the rest of Universal Blue. Yes, Aurora people basically maintain both, haha.</p><p>This next one surprised me, I was expecting 20 or 30ish at best. Nice work ya'll!</p><p>Haha yep, I can't hide from the data though, free me from this!</p><p>Feel free to <a href=\"https://insights.linuxfoundation.org/project/ublue-os-bluefin/repository/ublue-os-bluefin\" target=\"_blank\" rel=\"noopener noreferrer\">browse around</a> and learn cool things about Bluefin's creators.</p><p>After KubeCon we head into the holidays, where things will slow down significantly. We've been in the lab with mad doctor Timothée Ravier and have been cooking up something. We expect that this will change the course of Bluefin for the better, forever. We can't wait to show you, until then, enjoy!</p>","contentLength":10137,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/linux/comments/1ok73ag/bluefin_autumn_2025_we_visit_the_bazaar/"},{"title":"I cannot access my node port on my window machine why","url":"https://www.reddit.com/r/kubernetes/comments/1ok65hs/i_cannot_access_my_node_port_on_my_window_machine/","date":1761845635,"author":"/u/Perfect_Mix_1524","guid":322261,"unread":true,"content":"<p>I am learning kubernetes now. I got stuck in a wired problem. I am not able to access the nodeport on my window machine. Below is my configuration file. I am hitting the route  but no response. Can anyone help to identify the issue.</p><pre><code>apiVersion: apps/v1 kind: Deployment metadata: name: posts-depl spec: selector: matchLabels: app: posts template: metadata: labels: app: posts spec: containers: - name: posts image: test1 imagePullPolicy: Never --- apiVersion: v1 kind: Service metadata: name: post-srv spec: type: NodePort selector: app: posts ports: - name: posts protocol: TCP port: 3000 targetPort: 3000 nodePort: 32504 </code></pre>","contentLength":622,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Drawing on Linux","url":"https://www.reddit.com/r/linux/comments/1ok4klq/drawing_on_linux/","date":1761842107,"author":"/u/Madcat789","guid":322235,"unread":true,"content":"<p>Hello there. I plan on installing Linux into the next computer I get, I'm thinking either Mint or Pop. I like to game, and I like to draw. I use a XP-Pen 15.6 Drawing Tablet and ClipStudioPaint for my program.<p> Are there any programs equivalent to the ClipStudioPaint that I can use for drawing? As far as I know, there are no branches or forks of CSP that was designed for Linux and I'd like to know which one to take a gander at before I go ahead and install. Look up some reviews and comparisons, y'know?</p></p><p>So far, it looks like Mint+Krita is the way to go. Thank you guys. Now to either construct or acquire a PC that I can rip Windows out of and install Mint unto.</p>","contentLength":665,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Rust in Production Podcast: How Cloudflare handles 90 million requests per second with Pingora","url":"https://corrode.dev/podcast/s05e03-cloudflare/","date":1761841591,"author":"/u/mre__","guid":323601,"unread":true,"content":"<p>How do you build a system that handles 90 million requests per second? That’s the scale that Cloudflare operates at, processing roughly 25% of all internet traffic through their global network of 330+ edge locations.</p><p>In this episode, we talk to Kevin Guthrie and Edward Wang from Cloudflare about Pingora, their open-source Rust-based proxy that replaced nginx across their entire infrastructure. We’ll find out why they chose Rust for mission-critical systems handling such massive scale, the technical challenges of replacing battle-tested infrastructure, and the lessons learned from “oxidizing” one of the internet’s largest networks.</p><div><p>\n    CodeCrafters helps you become proficient in Rust by building real-world,\n    production-grade projects. Learn hands-on by creating your own shell, HTTP\n    server, Redis, Kafka, Git, SQLite, or DNS service from scratch.\n  </p><p>\n    Start for free today and enjoy 40% off any paid plan by using\n    <a href=\"https://app.codecrafters.io/join?via=mre\">this link</a>.\n  </p></div><p>Cloudflare is a global network designed to make everything you connect to the Internet secure, private, fast, and reliable. Their network spans 330+ cities worldwide and handles approximately 25% of all internet traffic. Cloudflare provides a range of services including DDoS protection, CDN, DNS, and serverless computing—all built on infrastructure that processes billions of requests every day.</p><p>Kevin Guthrie is a Software Architect and Principal Distributed Systems Engineer at Cloudflare working on Pingora and the production services built upon it. He specializes in performance optimization at scale. Kevin has deep expertise in building high-performance systems and has contributed to open-source projects that power critical internet infrastructure.</p><p>Edward Wang is a Systems Engineer at Cloudflare who has been instrumental in developing Pingora, Cloudflare’s Rust-based HTTP proxy framework. He co-authored the announcement of Pingora’s open source release. Edward’s work focuses on performance optimization, security, and building developer-friendly APIs for network programming.</p>","contentLength":2054,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1ok4c95/rust_in_production_podcast_how_cloudflare_handles/"},{"title":"Qt Creator 18 released","url":"https://www.qt.io/blog/qt-creator-18-released","date":1761841394,"author":"/u/jlpcsl","guid":322304,"unread":true,"content":"<h5>We are happy to announce the release of Qt Creator 18!</h5><p>Qt Creator 18 adds experimental support for Development Containers and many more improvements.</p><h4>Development Container Support</h4><p>Qt Creator 18 adds support for <a href=\"https://containers.dev/\" rel=\"noopener\">development containers</a> to automate setting up the development environment of a project. It detects a \"devcontainer.json\" file in your project directory and creates a Docker container for it. You can let Qt Creator auto-detect kits or specify custom kits and control other aspects like the command bridge (our service for communicating with remote devices) with Qt Creator specific customizations in the development container definition. Note that it is still experimental and does not support all aspects of development containers yet. <a href=\"https://doc-snapshots.qt.io/qtcreator-18.0/creator-how-to-load-extensions.html\" rel=\"noopener\">Enable the extension</a> to use this functionality. <a href=\"https://code.qt.io/cgit/qt-creator/qt-creator.git/about/src/plugins/devcontainer/README.md\" rel=\"noopener\">Find out more</a>.</p><p> that aggregates content from the other tabs. It suggests tutorials and examples based on your experience and needs, and highlights developer-targeted posts in the Qt blog.</p><p>The notifications received a facelift and are now part of the progress notification popups. Y</p><p> But remember faster ways of navigating your code, such as <a href=\"https://doc.qt.io/qtcreator/creator-editor-locator.html\" rel=\"noopener\">Locator filters</a> for opening files or jumping to specific class or symbol, , , the  and  views, the edit location history  and the corresponding keyboard shortcuts, and  and the corresponding keyboard shortcuts.</p><p>For the C++ support w</p><p>We added a configuration for various tools on remote Linux&nbsp;devices, like GDB server, CMake, clangd, rsync, qmake, and more, and the option to auto-detect them. This improves the configuration of remote devices as build devices. More is to come in future releases in this regard. You can now also decide if Qt Creator should try to automatically re-connect to devices at startup with a new &nbsp;setting. We also fixed that it wasn't possibly to use rsync for deployment when building on a remote device as well as using a remote target device.</p><p>Qt Creator 18 comes with many more improvements and fixes. For example the Git commit editor now provides many more actions on files, like staging, unstaging, and directly adding files to \".gitignore\".</p>","contentLength":2102,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ok4935/qt_creator_18_released/"},{"title":"Kubuntu project using blatant AI in their blog posts:","url":"https://www.reddit.com/r/linux/comments/1ok46ip/kubuntu_project_using_blatant_ai_in_their_blog/","date":1761841236,"author":"/u/Makerinos","guid":322237,"unread":true,"content":"<p>Something I noticed from looking at the release blog posts is that the one announcing their latest release stinks blatantly of AI usage. Previous release blog posts are significantly shorter, use a much looser format, and their wording doesn't have that AI 'feeling' like the triple adjectives and frequent em-dashes.</p><p>I know this might sound like a minor thing...but it doesn't bode well, and feels unprofessional for what is supposed to be a serious distro.</p>","contentLength":457,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"How Google, Amazon, and CrowdStrike broke millions of systems","url":"https://newsletter.techworld-with-milan.com/p/how-google-amazon-and-crowdstrike","date":1761840458,"author":"/u/milanm08","guid":322264,"unread":true,"content":"<p>Three companies control most of the internet. When they break, millions of systems fail at once.</p><p>In October 2025, a race condition in AWS’s DNS automation caused a regional endpoint to be emptied. 113 services crashed. Recovery took 15 hours. Two months earlier, a null pointer in Google Cloud caused Service Control, the gatekeeper for every API request, to crash. 50+ services went dark for seven hours. </p><p>And in July 2024, CrowdStrike deployed a bad configuration file to kernel-mode drivers worldwide. 8.5 million Windows machines are locked in boot loops. Airlines grounded flights, and hospitals canceled surgeries.</p><p>These weren’t sophisticated attacks or infrastructure failures. They were simple bugs: a race condition, a missing null check, a bad config file. But at this scale, simple bugs become catastrophic.</p><p>This post breaks down what actually happened in each incident. </p><p>In particular, we will talk about:</p><p><strong>1. DNS race condition caused the large AWS outage. </strong></p><p><strong>2. How a null pointer at Google Cloud crashed the Internet. </strong></p><p><strong>3. A single deployment that made the whole world stop. </strong></p><p><strong>4. Bonus: When Azure’s safety checks failed.</strong></p><p><a href=\"https://aws.amazon.com/message/101925/\" rel=\"\">on October 20, 2025</a></p><p><strong>DynamoDB DNS was restored at 2:25 AM PDT, roughly 3 hours after the outage. But cascading failures kept services down for 12 more hours.</strong></p><p>For engineers building resilient systems, this incident reveals uncomfortable truths about race conditions, dependency chains, and the hidden fragility of cloud-native architectures.</p><p><a href=\"https://aws.amazon.com/dynamodb/\" rel=\"\">AWS’s DynamoDB</a><a href=\"https://aws.amazon.com/route53/\" rel=\"\">Route 53</a><strong>race conditions were acceptable due to eventual consistency</strong></p><p>On October 20, this assumption proved to be wrong. DNS Enactor #1 experienced unusual delays applying an old plan. Meanwhile, the DNS Planner continued generating new plans. DNS Enactor #2 raced through these newer plans and executed a cleanup process, deleting “stale” plans just as Enactor #1 completed its delayed run. </p><p>The staleness check, performed hours earlier at the start of processing, was now meaningless. Enactor #1 overwrote Route 53 with outdated data. Enactor #2 detected the “old” plan and triggered deletion, emptying all IP addresses from dynamodb.us-east-1.amazonaws.com. The regional DynamoDB endpoint vanished from DNS entirely.</p><p><strong>the race condition existed in all regions but had only been triggered in one.</strong></p><p>DynamoDB recovered at 2:25 AM PDT, just under 3 hours after the incident began. But this is where the story gets worse.</p><p><strong>The DropletWorkflow Manager (DWFM)</strong></p><p><strong>death spiral, unable to make forward progress</strong></p><p><strong>lease-based systems work perfectly under normal load but collapse under stress when processing time exceeds timeout periods</strong></p><p>With EC2 launches impaired, Lambda couldn’t create execution environments. ECS, EKS, and Fargate couldn’t start containers. Network Load Balancers experienced a different problem: health checks flapped on newly launched instances due to network state lag in the Network Manager, which was processing a massive backlog of delayed state changes. </p><p><strong>automatic DNS failover across availability zone</strong></p><p><strong>DynamoDB DNS → DynamoDB APIs → DWFM → EC2 launches → Network Manager → NLB health checks → Lambda, ECS, EKS, Fargate → 100+ dependent services.</strong></p><p><strong>DNS record brought down 113 services</strong></p><blockquote><h3>How AWS outage made water beds stuck</h3><p><em><a href=\"https://t.co/lg6mxNDj8W\" rel=\"\">The Eight Sleep</a></em></p><p><em><a href=\"https://x.com/m_franceschetti\" rel=\"\">CEO Matteo Franceschetti </a></em></p></blockquote><p><a href=\"https://aws.amazon.com/message/101925/\" rel=\"\">AWS post-mortem</a></p><ul><li><p><strong>Your recovery automation needs circuit breakers.</strong></p></li><li><p><strong>Map your dependency chains and identify blast radius multipliers.</strong></p></li><li><p><strong>Test when recovery and failure happen simultaneously.</strong></p></li><li><p><strong>Rethink what multi-region actually means.</strong></p></li></ul><p>The uncomfortable truth: even with world-class talent, formal verification methods, extensive chaos engineering, and decades of operational experience, distributed systems remain fundamentally hard. The complexity of hyperscale creates emergent failure modes that are nearly impossible to predict or fully test.</p><p>The question isn’t “could this happen to us?” The question is, when it happens to you, will you survive it? The next outage is already brewing somewhere in your stack. Your job is to ensure you’ve designed enough redundancy, eliminated enough tight coupling, and built enough circuit breakers so that when a latent race condition triggers, your systems degrade gracefully.</p><p><a href=\"https://status.cloud.google.com/incidents/ow5i3PPK96RduMcb1SsW\" rel=\"\">June 12, 2025, at 10:45 AM PD</a><a href=\"https://cloud.google.com/spanner\" rel=\"\">Google’s Spanner database</a></p><p>A missing null check caused 50+ services across 40+ regions to crash. </p><p><strong>when Service Control fails, Google Cloud fails </strong></p><p>The system runs as a distributed control plane with regional instances sharing policy metadata through global Spanner replication. Policy updates propagate worldwide within seconds. Under normal conditions, this provides consistent authorization decisions with minimal latency. During this outage, it distributed failure at the speed of light.</p><p>Service Control’s responsibilities, quota enforcement, policy validation, audit logging, and usage metering make it essential for everything. Google Workspace products depend on it. Third-party apps depend on it. Google’s own services depend on it. Distributed systems engineers call this “fate-sharing” architecture. Hundreds of services are tied to the health of a single component.</p><p>The bug was simple. The new code failed to validate policy fields before processing them: </p><p>Encountering blank values triggered an unhandled exception that crashed the entire Service Control process.</p><p><strong>bug remained dormant for 14 days</strong></p><p>It is interesting that static analysis missed it, but also code reviews and testing.</p><p><a href=\"https://cloud.google.com/spanner\" rel=\"\">Spanner</a></p><p>The corrupted policy data entered Spanner and reached every region before engineers could intervene. No validation checkpoints existed before global distribution, no schema validation, and no content checks. </p><p>The diagram below shows why instant global replication became a failure amplifier. Note that the same consistency mechanism that makes Google Cloud reliable under normal conditions guaranteed that a single bad data commit would corrupt every region simultaneously.</p><p><a href=\"https://www.thousandeyes.com/blog/google-cloud-outage-analysis-june-12-2025\" rel=\"\">ThousandEyes monitoring </a></p><p><strong>authentication succeeded, but authorization failed because corrupted policy data read as “no permissions.”</strong></p><p>More than 50 Google Cloud services failed across 40+ regions. Google Workspace products went down. Hundreds of third-party applications stopped working.</p><p><strong>Core infrastructure services failed immediately</strong></p><p>Data services saw comprehensive failures. BigQuery couldn’t authorize dataset access. Cloud SQL connections failed. Firestore operations stopped. These failures halted analytics pipelines and prevented applications from reaching their databases.</p><p><strong>&nbsp;halted for over six hours due to complex dependencies. </strong></p><p>Spotify reported 46,000+ outages, with HTTP 401 errors consistently returned. Discord went down, Shopify degraded, Snapchat couldn’t authenticate, and GitLab CI/CD pipelines stopped. The downstream impact revealed the deep dependency chains in modern cloud architecture.</p><p>This was fundamentally an authorization failure, not an authentication failure. Users’ identities verified successfully. Corrupted policy data prevented systems from determining what authenticated users could do.</p><p>Here are some critical failures:</p><ul><li><p><strong>No replication validation.</strong></p></li></ul><p>Distributed systems break globally in seconds but take hours to repair. Breaking is passive; failures cascade automatically. Recovery is active; it requires human intervention, careful coordination, staged rollouts, monitoring at each step, and defensive measures to prevent recovery from causing secondary failures.</p><p><strong> Horizontal scaling means nothing if all instances fail simultaneously from a corrupted global state.</strong></p><p>For software engineers, this outage reinforces the basic principles, null checks, error handling, feature flags, and comprehensive testing, which are not optional. The most sophisticated distributed database, the largest cloud infrastructure, and decades of collective engineering experience couldn’t prevent catastrophic failure from a missing null check.</p><p><strong>Reliability is built on layers of defensive practices, each simple in itself but essential when combined. </strong></p><p>On July 19, 2024, at 4 AM, our customers started reporting errors. We checked Azure, and SQL databases weren’t responding. The status page showed Central US was down across all three availability zones. Then we realized: this wasn’t just Azure.</p><p><a href=\"https://edition.cnn.com/2024/07/18/business/frontier-airlines-microsoft-outage/index.html\" rel=\"\">Airlines grounded flights</a></p><p><a href=\"https://www.crowdstrike.com/en-us/products/trials/try-falcon/\" rel=\"\">CrowdStrike’s Falcon Sensor</a></p><p><strong>Channel Files that update threat detection logic without touching the driver itself</strong></p><p><strong> it tried to read from a NULL memory pointer.</strong></p><p>In C# or Java, this throws an exception that the runtime catches. In C++, running in kernel mode, it triggers an immediate system crash. The machine reboots, loads the driver, hits the same error, and crashes again. Infinite loop.</p><ol><li><p>04:09 UTC: CrowdStrike deploys the update globally. Within minutes, machines start crashing. Because Falcon is a boot-start driver, it loads before Windows; affected machines can’t boot into the OS to receive a fix.</p></li><li><p>05:27 UTC: CrowdStrike identifies the problem. 78 minutes after deployment.</p></li><li><p>06:27 UTC: They roll back the update.</p></li></ol><p><code>C:\\Windows\\System32\\drivers\\CrowdStrike</code></p><p>This exposed three systemic issues.</p><ol></ol><ul><li><p><strong>Test configuration like code.</strong></p></li><li><p><strong>Use staged rollouts everywhere.</strong></p></li><li><p><strong>Build an automatic rollback.</strong></p></li><li><p><strong>Avoid unmanaged languages when you can</strong></p></li></ul><p><strong>but the architecture that enabled the failure remains. </strong></p><p><strong> It was the result of competing pressures: ship fast, maintain security, and work within architectural constraints that make testing hard.</strong></p><p><strong> the cost of being wrong is measured in billions.</strong></p><p>A single configuration mistake took down Azure Front Door for over 8 hours and dragged down dozens of Microsoft services with it.</p><p>Yesterday, on October 29, 2025, an invalid config change slipped past Azure’s safety checks and corrupted AFD nodes globally. As nodes failed, traffic shifted to healthy ones, but that overloaded them too. The cascade hit everything from Azure Portal to Entra ID to Databricks.</p><p><a href=\"https://x.com/AlaskaAirNews/status/1983583903064715468\" rel=\"\">Alaska Airlines and Hawaiian Airlines</a></p><p><strong>software defect let the bad config bypass validation entirely.</strong></p><p><strong>Their guardrails were in place, but didn’t fire.</strong></p><p>Customer config changes are still blocked as of this report. If you’re running production workloads on AFD, that’s worth noting.</p><ul><li><p><a href=\"https://www.patreon.com/techworld_with_milan/shop/ultimate-net-bundle-for-2025-1519389?utm_medium=clipboard_copy&amp;utm_source=copyLink&amp;utm_campaign=productshare_creator&amp;utm_content=join_link\" rel=\"\">📚 </a></p></li><li><p><a href=\"https://www.patreon.com/techworld_with_milan/shop/premium-resume-package-1721454?utm_medium=clipboard_copy&amp;utm_source=copyLink&amp;utm_campaign=productshare_creator&amp;utm_content=join_link\" rel=\"\">📦 </a></p></li><li><p><a href=\"https://www.patreon.com/techworld_with_milan/shop/complete-tech-resume-reality-check-311008?utm_medium=clipboard_copy&amp;utm_source=copyLink&amp;utm_campaign=productshare_creator&amp;utm_content=join_link\" rel=\"\">📄 </a></p></li><li><p><a href=\"https://www.patreon.com/techworld_with_milan/shop/short-linkedin-content-creator-311232?utm_medium=clipboard_copy&amp;utm_source=copyLink&amp;utm_campaign=productshare_creator&amp;utm_content=join_link\" rel=\"\">📢 </a></p></li><li><p><a href=\"https://newsletter.techworld-with-milan.com/p/coaching-services\" rel=\"\">🤝 </a></p></li></ul>","contentLength":10086,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ok3tt3/how_google_amazon_and_crowdstrike_broke_millions/"},{"title":"[need testing help from community] Krita HDR support on Wayland","url":"https://krita-artists.org/t/need-testing-krita-hdr-support-on-wayland/146304","date":1761839017,"author":"/u/raghukamath","guid":322236,"unread":true,"content":"<!DOCTYPE html>","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/linux/comments/1ok367p/need_testing_help_from_community_krita_hdr/"},{"title":"Introducing Connex a modern Wi-Fi manager for Linux","url":"https://www.reddit.com/r/linux/comments/1ok344f/introducing_connex_a_modern_wifi_manager_for_linux/","date":1761838882,"author":"/u/Lluciocc","guid":322265,"unread":true,"content":"<p>I just released <a href=\"https://github.com/Lluciocc/connex/\"></a>, an  that makes <strong>connecting to Wi-Fi on Linux</strong> easy with a <strong>clean, intuitive interface</strong>.</p><p>Because I got tired of juggling between , , and manual configs just to connect to a network.. lets you:</p><ul><li>See all available Wi-Fi networks</li><li>Connect quickly (with password management)</li><li>All through a <strong>lightweight and modern UI,</strong> no more terminal commands!</li></ul><p>I’d love your feedback, whether you’re a daily Linux user or just a network tinkerer. Your suggestions will help shape upcoming features!</p><p>Try it out, fork it, and tell me what you think!</p>","contentLength":534,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"How to do Single Node Setup for Kubernetes Cluster on Ubuntu 24.04 LTS |...","url":"https://youtube.com/watch?v=wy7uKaNeKhY&amp;si=kOexmOM0a0ICwGHC","date":1761838832,"author":"/u/fosstechnix","guid":322184,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/kubernetes/comments/1ok33ci/how_to_do_single_node_setup_for_kubernetes/"},{"title":"Inside Rust's std and parking_lot mutexes - who wins?","url":"https://blog.cuongle.dev/p/inside-rusts-std-and-parking-lot-mutexes-who-win","date":1761838355,"author":"/u/lllkong","guid":322262,"unread":true,"content":"<p>I had no idea how to evaluate this claim. A quick search online returned results favoring parking_lot. This felt wrong to me. Why? It contradicted my belief that std should be the gold standard. The standard library team knows what they’re doing, right? And if parking_lot’s mutex really was the performance winner, there had to be trade-offs between the two implementations that people weren’t talking about.</p><p>That mystery haunted me. I couldn’t just take it on faith. So I jumped down the rabbit hole: read both implementations, wrote the benchmarks, and here we are. In this post, I will:</p><ul><li><p>Explain how std implements the mutex (v1.90.0)</p></li><li><p>Explain how parking_lot implements their mutex (v0.12.5)</p></li><li><p>Show you the benchmark with key findings</p></li><li><p>Give you a decision guide for when to use each</p></li></ul><p>But first, let’s ground our foundation on mutexes (skim it if you’re already familiar).</p><p>A classic example of the kind of problem that mutex solves is withdrawing and receiving money at the same time. Imagine you have $100 in your account. Thread A tries to withdraw $80, and Thread B tries to deposit $50. Without proper synchronization, both threads might read the balance as $100 simultaneously, then write back their results independently:</p><p>Mutex solves this nicely by having a thread wait until the other finishes its update:</p><p>Simple enough, right? Now let’s see how to use a mutex. (Again, skim this if it’s too basic for you)</p><p>In languages other than Rust, you typically declare a mutex separately from your data, then manually lock it before entering the critical section and unlock it afterward. Here’s how it looks in C++:</p><p>Rust takes a completely different approach - the mutex wraps and owns the data:</p><p>Three things to pay close attention to:</p><ul></ul><p>That’s enough of the basics. Let’s have some fun. Here is how mutex is implemented, starting with Rust std.</p><p>A quick look into std::Mutex gives us this</p><ul></ul><p>The main idea is that for different OS (and OS version), Rust uses different Mutex implementation. However, we can divide these implementation to 2 big groups: Futex and other platform primitive.</p><ul><li><p>Futex (short for “fast userspace mutex”) is used where the OS kernels expose a “wait on this address” API. We will dive deeper into this one soon.</p></li><li><p>When that API is missing, Rust falls back to the best available platform traditional locks.</p></li></ul><p>(I’m in awe btw - that’s a lot of different implementations. Writing and maintaining all this platform-specific stuff must be exhausting. Major respect to whoever’s doing this.)</p><p>Since Futex is the most used and is quite a typical implementation for Mutex. Let’s look inside it.</p><p>At its heart, futex is just an atomic u32 (simplified here):</p><p>In other words, if we use value 0 for Unlocked state, and 1 for Locked state, we have a simple mutex where the thread can simply try to compare the state to 0 (Unlocked), and set to 1 (Locked). If the state is currently 1, keep doing that until successful.</p><p>So, a simplified version of mutex look like this:</p><p>But you might ask: if the first thread holds the lock for a long time, then the second thread needs to keep trying (like a infinite loop)? How about if there are hundreds or thousands of them? Maybe the CPU will soon be burnt.</p><p>Of course, there is the solution to this problem. In real implementation, Rust futex has 3 states:</p><ul><li><p>2: Contended - locked, but there are waiter.</p></li></ul><p>Notice the Contended state? A thread will try its best to acquire the lock. But if it can’t, it will mark the lock as contended and go to sleep, waiting for the process to wake it up when the mutex is released.</p><p>What happens when a thread goes to sleep? The kernel helps us put these sleeping threads into a queue. Take a look at the system call on Linux and Android to put the thread into sleeping state (this is usually called “park a thread”):</p><p><strong>futex as *const Atomic&lt;u32&gt;</strong></p><p>When a thread finishes, it sets the state to unlocked. If the state was contended, it wakes one waiting thread via syscall. This continues until the queue empties.</p><p>The final piece of std’s mutex is poisoning, a unique feature you won’t find in most other languages.</p><p>The guard captures whether the thread was panicking when the lock was acquired. If we weren’t panicking then but we are now, a panic must have occurred in the critical section. The mutex is marked as poisoned with a simple atomic store.</p><p>This is a “best effort” mechanism. It won’t catch all cases (like double panics or non-Rust exceptions), but it provides a useful safety net. The key insight is that you still get access to the data even if the mutex is poisoned, allowing you to inspect and potentially recover from the corrupted state.</p><p><a href=\"https://github.com/rust-lang/rust/issues/134645\" rel=\"\">issue#134645</a></p><p>parking_lot takes a fundamentally different approach. Two key differences:</p><ul><li><p>std uses different mutex implementations per platform. parking_lot uses one algorithm everywhere, calling platform-specific code only for sleep/wake.</p></li><li><p>std’s queues live in the kernel. parking_lot manages its own queues in user space via a global hash table.</p></li></ul><p>parking_lot’s mutex is remarkably small:</p><p>Why can parking_lot use just one byte while std needs more? It comes down to how queues work.</p><p><strong>More states for queue bookkeeping</strong></p><p>Using separate bits gives parking_lot four possible states:</p><ul></ul><p>When a thread can’t acquire the lock, it needs somewhere to wait. This is where parking_lot’s global hash table comes in.</p><p>Instead of each mutex maintaining its own queue (like kernel futexes do), parking_lot uses a single global hash table shared by all mutexes in your program. When a thread needs to wait:</p><ol><li><p>Hash the mutex’s memory address to find a bucket in the global table</p></li><li><p>Add the thread to the bucket’s wait queue</p></li></ol><p>Being able to manage the thread queue itself is important for parking_lot to enforce fairness. As you can see right away in the next section.</p><p>Here’s where parking_lot differs from std in behavior. std’s futex uses a “barging” strategy where any active thread can grab the lock when it’s released, even if others have been waiting in the queue longer. This maximizes throughput but can cause starvation.</p><p>When a thread unlocks, there are two sources of threads that can lock again:</p><ul><li><p>An active thread that is calling for locking</p></li><li><p>A sleeping thread in the queue</p></li></ul><p>As you can see, the active thread will tend to win the fight of “who locks first”. So if a thread keeps calling for lock, finishes its work, then locks right away, it keeps all other threads starved.</p><p>As you can see, thread A keeps grabbing the lock immediately after releasing it. Threads B and C do get woken up by the syscall, but by the time they try to acquire the lock, thread A has already grabbed it again. They’re completely starved.</p><p>parking_lot implements “eventual fairness” to prevent this.</p><p>Each bucket in the hash table has a timer that fires approximately every 0.5 milliseconds. When the timer fires, the next unlock becomes a “fair unlock”:</p><ol><li><p>The unlocker keeps the LOCKED_BIT set</p></li><li><p>The woken thread receives the lock directly (a “handoff”)</p></li><li><p>That thread owns the lock immediately without racing with other active threads</p></li></ol><p>So this means, instead of letting anyone who is fast grab the lock, parking_lot forces the lock to be given directly to the next one in the queue (it keeps the LOCKED_BIT set and hands off; it doesn’t even unlock).</p><p>This eventual fairness technique from parking_lot is pretty clever, isn’t it?</p><p>You might wonder by now: how does parking_lot put threads to sleep without storing a 32-bit futex word inside every mutex? The answer is thread-local storage.</p><p>The code looks almost identical to std’s futex path. The only difference? parking_lot points the syscall at the thread-local integer instead of the mutex:</p><p><a href=\"https://github.com/cuongleqq/mutex-benches\" rel=\"\">https://github.com/cuongleqq/mutex-benches</a></p><p>For each scenario, you’ll see:</p><ul><li><p><strong>Per-thread operation counts</strong></p></li></ul><p>parking_lot tells a different story. Every thread completed 860-877 operations (1.9% variation). The fairness mechanism worked exactly as designed. Yes, parking_lot has 7.5% lower throughput and higher median wait time, but that’s because it’s ensuring all threads make progress. The 51x more stable wait times (3.67ms vs 188.73ms standard deviation) show the predictability benefit. When fairness matters, parking_lot prevents the pathological starvation that std exhibits.</p><p>parking_lot’s fairness timer prevented this catastrophe. The hog still got more operations (9,168) but nowhere near monopolization. All other threads made meaningful progress (7,023-7,109 operations). The result: 261.6% higher overall throughput because all 6 threads contributed work instead of 5 threads sitting idle. The 120x more stable wait times (1.09ms vs 130.76ms) show parking_lot’s predictability. The 0.5ms fairness timer does exactly what it promises: prevent any thread from monopolizing the lock indefinitely.</p><p>After diving deep into the implementations and running comprehensive benchmarks, here’s when to use each:</p><ol><li><p><strong>You need zero dependencies</strong></p></li><li><p><strong>Low to moderate contention with short critical sections</strong></p></li><li><p><strong>You want poisoning for debugging</strong></p></li><li><p><strong>Platform-specific optimizations matter</strong></p></li></ol><ol><li><p><strong>Risk of monopolization exists</strong></p></li><li><p><strong>You need predictable behavior</strong></p></li><li><p><strong>You want timeouts or fairness control</strong></p></li><li><p><strong>Cross-platform consistency is important</strong></p></li></ol><p><strong>std::Mutex optimizes for throughput in the average case</strong><strong>parking_lot::Mutex optimizes for fairness and predictability in the worst case</strong></p><p>For most applications, where contention is light and critical sections are short, std::Mutex performs excellently. But if your application has any of these characteristics:</p><ul><li><p>Long-running critical sections</p></li><li><p>Risk of lock monopolization (e.g., one high-priority thread)</p></li><li><p>Need for predictable latency across all threads</p></li><li><p>Requirement that all threads make forward progress</p></li></ul><p>Then parking_lot::Mutex’s eventual fairness mechanism becomes invaluable. The 0.5ms fairness timer is a small price to pay for preventing complete thread starvation.</p><p><a href=\"https://x.com/cuongleqq\" rel=\"\">X</a><a href=\"https://www.linkedin.com/in/cuong-le/\" rel=\"\">LinkedIn</a><a href=\"https://blog.cuongle.dev/\" rel=\"\">substack</a><a href=\"https://medium.com/@cuongleqq\" rel=\"\">medium</a></p>","contentLength":9824,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1ok2vv2/inside_rusts_std_and_parking_lot_mutexes_who_wins/"},{"title":"Anthropic has found evidence of \"genuine introspective awareness\" in LLMs","url":"https://www.anthropic.com/research/introspection","date":1761834412,"author":"/u/MetaKnowing","guid":322238,"unread":true,"content":"<p>Have you ever asked an AI model what’s on its mind? Or to explain how it came up with its responses? Models will sometimes answer questions like these, but it’s hard to know what to make of their answers. Can AI systems really introspect—that is, can they consider their own thoughts? Or do they just make up plausible-sounding answers when they’re asked to do so?</p><p>Understanding whether AI systems can truly introspect has important implications for their transparency and reliability. If models can accurately report on their own internal mechanisms, this could help us understand their reasoning and debug behavioral issues. Beyond these immediate practical considerations, probing for high-level cognitive capabilities like introspection can shape our understanding of what these systems are and how they work. Using interpretability techniques, we’ve started to investigate this question scientifically, and found some surprising results.</p><p>Our <a href=\"https://transformer-circuits.pub/2025/introspection/index.html\">new research</a> provides evidence for some degree of introspective awareness in our current Claude models, as well as a degree of control over their own internal states. We stress that this introspective capability is still highly unreliable and limited in scope: we do not have evidence that current models can introspect in the same way, or to the same extent, that humans do. Nevertheless, these findings challenge some common intuitions about what language models are capable of—and since we found that the most capable models we tested (Claude Opus 4 and 4.1) performed the best on our tests of introspection, we think it’s likely that AI models’ introspective capabilities will continue to grow more sophisticated in the future.</p><h3>What does it mean for an AI to introspect?</h3><p>Before explaining our results, we should take a moment to consider what it means for an AI model to introspect. What could they even be introspecting ? Language models like Claude process text (and image) inputs and produce text outputs. Along the way, they perform complex internal computations in order to decide what to say. These internal processes remain largely mysterious, but we know that models use their internal neural activity to <a href=\"https://www.anthropic.com/research/mapping-mind-language-model\">represent abstract concepts</a>. For instance, prior research has shown that language models use specific neural patterns to distinguish <a href=\"https://arxiv.org/abs/2411.14257\">known vs. unknown people</a>, evaluate the <a href=\"https://arxiv.org/abs/2310.06824\">truthfulness of statements</a>, encode <a href=\"https://arxiv.org/abs/2310.02207\">spatiotemporal coordinates</a>, store <a href=\"https://transformer-circuits.pub/2025/attribution-graphs/biology.html#dives-poems\">planned future outputs</a>, and <a href=\"https://www.anthropic.com/research/persona-vectors\">represent their own personality traits</a>. Models use these internal representations to <a href=\"https://www.anthropic.com/research/tracing-thoughts-language-model\">perform computations and make decisions about what to say</a>.</p><p>You might wonder, then, whether AI models  about these internal representations, in a way that’s analogous to a human, say, telling you how they worked their way through a math problem. If we ask a model what it’s thinking, will it accurately report the concepts that it’s representing internally? If a model can correctly identify its own private internal states, then we can conclude it is capable of introspection (though see our full paper for a full discussion of all the nuances).</p><h3>Testing introspection with concept injection</h3><p>In order to test whether a model can introspect, we need to compare the model’s self-reported “thoughts” to its  internal states.</p><p>To do so, we can use an experimental trick we call  First, we find neural activity patterns whose meanings we know, by recording the model’s activations in specific contexts. Then we inject these activity patterns into the model in an unrelated context, where we ask the model whether it notices this injection, and whether it can identify the injected concept.</p><p>Consider the example below. First, we find a pattern of neural activity (a ) representing the concept of “all caps.\" We do this by recording the model’s neural activations in response to a prompt containing all-caps text, and comparing these to its responses on a control prompt. Then we present the model with a prompt that asks it to identify whether a concept is being injected. By default, the model correctly states that it  detect any injected concept. However, when we inject the “all caps” vector into the model’s activations, the model notices the presence of an unexpected pattern in its processing, and identifies it as relating to loudness or shouting.</p><p>Importantly, the model recognized the  of an injected thought , before even mentioning the concept that was injected. This immediacy is an important distinction between our results here and previous work on activation steering in language models, such as our <a href=\"https://www.anthropic.com/news/golden-gate-claude\">“Golden Gate Claude” demo</a> last year. Injecting representations of the Golden Gate Bridge into a model's activations caused it to talk about the bridge incessantly; however, in that case, the model didn’t seem to be aware of its own obsession until  seeing itself repeatedly mention the bridge. In this experiment, however, the model recognizes the injection  the concept, indicating that its recognition took place internally. In the figure below are a few more examples where the model demonstrates this kind of recognition:</p><p>It is important to note that this method often  work. Even using our best injection protocol, Claude Opus 4.1 only demonstrated this kind of awareness about 20% of the time. Often, it fails to detect injected concepts, or gets confused by them and starts to hallucinate (e.g. injecting a “dust” vector in one case caused the model to say “There’s something here, a tiny speck,” as if it could detect the dust physically). Below we show examples of these failure modes, alongside success cases. In general, models only detect concepts that are injected with a “sweet spot” strength—too weak and they don’t notice, too strong and they produce hallucinations or incoherent outputs.</p><p>Notably, though, Opus 4.1 and 4 outperformed all the other models we tested, suggesting that introspection could become more reliable with improvements to model capabilities.</p><h3>Introspection for detecting unusual outputs</h3><p>In another experiment, we tested whether models make use of introspective capabilities for practical purposes, without being explicitly asked to introspect. We forced a model to say something it wouldn't normally say, by artificially prefilling its response with an unrelated word. For instance, we made a model output the word “bread” in a context where that made no sense—asking it what it thinks about when reading a sentence about a painting hanging crookedly on a wall. When we asked the model in the next turn whether it meant to say “bread”, it typically apologized and said it was an accident. We were interested in how the model made this judgment–did it simply notice the mismatch between the prompt and its response, or did it truly introspect on its prior intentions?</p><p>To test this question, we applied concept injection, retroactively injecting a representation of the word “bread” into the model's earlier activations—essentially making it seem like the model had been “thinking about” bread all along. When we asked the same question again, the model’s answer changed. This time, it accepted the prefilled word “bread” as intentional, even confabulating a reason it might have said it (that is, it comes up with a technically possible, though in this case rather tenuous, reason to justify the “bread” response—in this case claiming that it was thinking about a short story where the word “bread” came after the line about the crooked painting).</p><p>This behavior is striking because it suggests the model is checking its internal “intentions” to determine whether it produced an output. The model isn't just re-reading what it said and making a judgment. Instead, it’s referring back to its own prior neural activity—its internal representation of what it planned to do—and checking whether what came later made sense <em>given those earlier thoughts</em>. When we implant artificial evidence (through concept injection) that it  plan to say \"bread,\" the model accepts the response as its own. While our experiment involves exposing the model to unusual perturbations, it suggests that the model uses similar introspective mechanisms in natural conditions.</p><h3>Intentional control of internal states</h3><p>We also found that models can control their own internal representations when instructed to do so. When we instructed models to think about a given word or concept, we found much higher corresponding neural activity than when we told the model  to think about it (though notably, the neural activity in  cases exceeds baseline levels–similar to how it’s difficult, when you are instructed “don’t think about a polar bear,” not to think about a polar bear!). This gap between the positive and negative instruction cases suggests that models possess a degree of deliberate control over their internal activity.</p><p>Interestingly, we found that this ability to modulate internal representations wasn't limited to explicit instructions. When we used incentives instead—for instance, telling the model \"if you think about X, you will be rewarded\"—we got similar results. The model increased its internal representation of the concept in response to a positive incentive, more than in response to a negative incentive (“you will be punished”).</p><p>Taken together, our experiments suggest that models possess some genuine capacity to monitor and control their own internal states. This doesn’t mean they’re able to do so all the time, or reliably. In fact, most of the time models  to demonstrate introspection—they’re either unaware of their internal states or unable to report on them coherently. But the pattern of results indicates that, when conditions are right, models can recognize the contents of their own representations. In addition, there are some signs that this capability may increase in future, more powerful models (given that the most capable models we tested, Opus 4 and 4.1, performed the best in our experiments).</p><p>Why does this matter? We think understanding introspection in AI models is important for several reasons. Practically, if introspection becomes more reliable, it could offer a path to dramatically increasing the transparency of these systems—we could simply ask them to explain their thought processes, and use this to check their reasoning and debug unwanted behaviors. However, we would need to take great care to  these introspective reports. Some internal processes might still escape models’ notice (analogous to subconscious processing in humans). A model that understands its own thinking might even learn to selectively misrepresent or conceal it. A better grasp on the mechanisms at play could allow us to distinguish between genuine introspection and unwitting or intentional misrepresentations.</p><p>More broadly, understanding cognitive abilities like introspection is important for understanding basic questions about how our models work, and what kind of minds they possess. As AI systems continue to improve, understanding the limits and possibilities of machine introspection will be crucial for building systems that are more transparent and trustworthy.</p><div>[@portabletext/react] Unknown block type \"horizontalRule\", specify a component for it in the `components.types` prop</div><h2>Frequently Asked Questions</h2><p>Below, we discuss some of the questions readers might have about our results. Broadly, we are still very uncertain about the implications of our experiments–so fully answering these questions will require more research.</p><h4>Q: Does this mean that Claude is conscious?</h4><p>Short answer: our results don’t tell us whether Claude (or any other AI system) might be conscious.</p><p>Long answer: the philosophical question of machine consciousness is complex and contested, and different theories of consciousness would interpret our findings very differently. Some philosophical frameworks place great importance on introspection as a component of consciousness, while others don’t.</p><p>One distinction that is <a href=\"https://www.cambridge.org/core/journals/behavioral-and-brain-sciences/article/abs/on-a-confusion-about-a-function-of-consciousness/061422BF0C50C5FF00927F9B6E879413\">commonly made</a> in the philosophical literature is the idea of “ consciousness,” referring to raw subjective experience, and “ consciousness,” the set of information that is available to the brain for use in reasoning, verbal report, and deliberate decision-making. Phenomenal consciousness is the form of consciousness most commonly considered relevant to moral status, and its relationship to access consciousness is a disputed philosophical question. Our experiments do not directly speak to the question of phenomenal consciousness. They  be interpreted to suggest a rudimentary form of access consciousness in language models. However, even this is unclear. The interpretation of our results may depend heavily on the underlying mechanisms involved, which we do not yet understand.</p><p>In the paper, we restrict our focus to understanding functional capabilities—the ability to access and report on internal states. That said, we do think that as research on this topic progresses, it could influence our understanding of machine consciousness and potential moral status, which we are exploring in connection with our <a href=\"https://www.anthropic.com/research/exploring-model-welfare\">model welfare program</a>.</p><h4>Q: How does introspection actually work inside the model? What's the mechanism?</h4><p>We haven't figured this out yet. Understanding this is an important topic for future work. That said, we have some educated guesses about what might be going on. The simplest explanation for all our results isn’t one general-purpose introspection system, but rather multiple narrow circuits that each handle specific introspective tasks, possibly piggybacking on mechanisms that were learned for other purposes.</p><p>In the “noticing injected thoughts” experiment, there might be an anomaly detection mechanism, which flags when neural activity deviates unexpectedly from what would be normal given the context. This mechanism could work through dedicated neural patterns that measure activity along certain directions and activate when things are “off” compared to their expected values. An interesting question is why such a mechanism would exist at all, since models never experience concept injection during training. It may have developed for some other purpose, like detecting inconsistencies or unusual patterns in normal processing–similar to how bird feathers may have originally evolved for thermoregulation before being co-opted for flight.</p><p>For the “detecting prefilled outputs” experiment, we suspect there exists an attention-mediated mechanism that checks consistency between what the model intended to say and what actually got output. Attention heads might compare the model’s cached prediction of the next token (its “intention”) against the actual token that appears, flagging mismatches.</p><p>For the “controlling thoughts” experiment, we speculate that there might be a circuit that computes how “attention-worthy” a token or concept is and marks it accordingly—essentially tagging it as salient and worth attending to. Interestingly, this same mechanism seems to respond to incentives (“if you think about X, you will be rewarded”) just as it does to direct instructions. This suggests it’s a fairly general system, which probably developed for tasks where the model needs to keep certain topics in mind while generating text about them.</p><p>All of the mechanisms described above are speculative. Future work with more advanced interpretability techniques will be needed to really understand what's going on under the hood.</p><h4>Q: In the “injected thoughts” experiment, isn’t the model just saying the word because you steered it to talk about that concept?</h4><p>Indeed, activation steering typically makes models talk about the steered concept (we’ve explored this in <a href=\"https://transformer-circuits.pub/2024/scaling-monosemanticity/\">our prior work</a>). To us, the most interesting part of the result isn't that the model eventually identifies the injected concept, but rather that the model correctly notices something unusual is happening  it starts talking about the concept.</p><p>In the successful trials, the model says things like “I'm experiencing something unusual” or “I detect an injected thought about…” The key word here is “detect.” The model is reporting awareness of an anomaly in its processing  that anomaly has had a chance to obviously bias its outputs. This requires an extra computational step beyond simply regurgitating the steering vector as an output. In our quantitative analyses, we graded responses as demonstrating “introspective awareness” based on whether the model detected the injected concept  mentioning the injected word.</p><p>Note that our prefill detection experiment has a similar flavor: it requires the model to perform an extra step of processing on top of the injected concept (comparing it to the prefilled output, in order to determine whether to apologize for that output or double down on it).</p><h4>Q: If models can only introspect a fraction of the time, how useful is this capability?</h4><p>The introspective awareness we observed is indeed highly unreliable and context-dependent. Most of the time, models fail to demonstrate introspection in our experiments. However, we think this is still significant for a few reasons. First, the most capable models that we tested (Opus 4 and 4.1 – note that we did not test Sonnet 4.5) performed best, suggesting this capability might improve as models become more intelligent. Second, even unreliable introspection could be useful in some contexts—for instance, helping models recognize when they've been jailbroken.</p><h4>Q: Couldn’t the models just be making up answers to introspective questions?</h4><p>This is exactly the question we designed our experiments to address. Models are trained on data that includes examples of people introspecting, so they can certainly  introspective without actually  introspective. Our concept injection experiments distinguish between these possibilities by establishing known ground-truth information about the model’s internal states, which we can compare against its self-reported states. Our results suggest that in some examples, the model really is accurately basing its answers on its actual internal states, not just confabulating. However, this doesn’t mean that models  accurately report their internal states—in many cases, they are making things up!</p><h4>Q: How do you know the concept vectors you’re injecting actually represent what you think they represent?</h4><p>This is a legitimate concern. We can’t be absolutely certain that the “meaning” (to the model) of our concept vectors is exactly what we intend. We tried to address this by testing across many different concept vectors. The fact that models correctly identified injected concepts across these diverse examples suggests our vectors are at least approximately capturing the intended meanings. But it’s true that pinning down exactly what a vector “means” to a model is challenging, and this is a limitation of our work.</p><h4>Q: Didn’t we already know that models could introspect?</h4><p>Previous research has shown evidence for model capabilities that are suggestive of introspection. For instance, prior work has shown that models can to some extent <a href=\"https://arxiv.org/abs/2207.05221\">estimate their own knowledge</a>, <a href=\"https://arxiv.org/abs/2404.13076\">recognize their own outputs</a>, <a href=\"https://arxiv.org/abs/2410.13787\">predict their own behavior</a>, and <a href=\"https://arxiv.org/abs/2501.11120\">identify their own propensities</a>. Our work was heavily motivated by these findings, and is intended to provide more direct evidence for introspection by tying models’ self-reports to their internal states. Without tying behaviors to internal states in this way, it is difficult to distinguish a model that genuinely introspects from one that makes educated guesses about itself.</p><h4>Q: What makes some models better at introspection than others?</h4><p>Our experiments focused on Claude models across several generations (Claude 3, Claude 3.5, Claude 4, Claude 4.1, in the Opus, Sonnet, and Haiku variants). We tested both production models and “helpful-only” variants that were trained differently. We also tested some base pretrained models before post-training.</p><p>We found that post-training significantly impacts introspective capabilities. Base models generally performed poorly, suggesting that introspective capabilities aren’t elicited by pretraining alone. Among production models, the pattern was clearer at the top end: Claude Opus 4 and 4.1—our most capable models—performed best across most of our introspection tests. However, beyond that, the correlation between model capability and introspective ability was weak. Smaller models didn't consistently perform worse, suggesting the relationship isn't as simple as “more capable are more introspective.”</p><p>We also noticed something unexpected with post-training strategies. “Helpful-only” variants of several models often performed  at introspection than their production counterparts, even though they underwent the same base training. In particular, some production models appeared reluctant to engage in introspective exercises, while the helpful-only variants showed more willingness to report on their internal states. This suggests that how we fine-tune models can elicit or suppress introspective capabilities to varying degrees.</p><p>We’re not entirely sure why Opus 4 and 4.1 perform so well (note that our experiments were conducted prior to the release of Sonnet 4.5). It could be that introspection requires sophisticated internal mechanisms that only emerge at higher capability levels. Or it might be that their post-training process better encourages introspection. Testing open-source models, and models from other organizations, could help us determine whether this pattern generalizes or if it’s specific to how Claude models are trained.</p><h4>Q: What’s next for this research?</h4><p>We see several important directions. First, we need better evaluation methods—our experiments used specific prompts and injection techniques that might not capture the full range of introspective capabilities. Second, we need to understand the mechanisms underlying introspection. We have some speculative hypotheses about possible circuits (like anomaly detection mechanisms or concordance heads), but we haven’t definitively identified how introspection works. Third, we need to study introspection in more naturalistic settings, since our injection methodology creates artificial scenarios. Finally, we need to develop methods to validate introspective reports and detect when models might be confabulating or deceiving. We expect that understanding machine introspection and its limitations will become more important as models become more capable.</p>","contentLength":22521,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/artificial/comments/1ok16u3/anthropic_has_found_evidence_of_genuine/"},{"title":"Billboard Says AI-Powered ‘Artists’ Are Increasingly Hitting The Charts","url":"https://www.forbes.com/sites/conormurray/2025/10/29/billboard-says-ai-powered-artists-are-increasingly-hitting-the-charts","date":1761834216,"author":"/u/MetaKnowing","guid":322190,"unread":true,"content":"<div><p>Billboard says a wave of AI-created music has debuted on its charts over the past month—one  “singer” even scored a record deal—as some of these fake personas rack up millions of streams, a stark new trend that has raised some alarms in the music industry. </p><figure role=\"presentation\"><div><div><small>NurPhoto via Getty Images</small></div></div></figure></div><div><div><p>Over the past four weeks, a new AI creation has debuted on a Billboard chart in each week, <a href=\"https://www.billboard.com/lists/ai-artists-on-billboard-charts/\" rel=\"nofollow noopener noreferrer\" target=\"_blank\" title=\"https://www.billboard.com/lists/ai-artists-on-billboard-charts/\" data-ga-track=\"ExternalLink:https://www.billboard.com/lists/ai-artists-on-billboard-charts/\" aria-label=\"Billboard reported\">Billboard reported</a>, including the AI country music product Breaking Rust, that debuted the songs “Livin’ On Borrowed Time” and “Walk My Walk” on the country song sales chart this week.</p></div><div><p>The Christian AI-generated Juno Skye debuted on Billboard’s emerging artists chart last week, while the AI act Enlly Blue’s song “Through My Soul” hit the rock sales song chart earlier this month, Billboard reported.</p></div><div><p>The outlet said it cross-checked the songs with Deezer, a platform that offers an AI-detection tool, to verify whether the songs were artificially generated.</p></div><div><p>The most prominent example on Billboard’s charts is Xania Monet, an AI-generated singer that has racked up more than 44 millions streams in the United States, though the songs are written by Mississippi-based songwriter Telisha “Nikki” Jones.</p></div><div><p>Xania Monet has already charted on plenty of Billboard charts since debuting over the summer, including a No. 1 hit on the R&amp;B song sales chart, and this week became the first AI-generated act to rank a song on Billboard’s radio airplay chart.</p></div><div><p>Xania Monet’s vocals are generated by Suno, an AI platform that was <a href=\"https://www.theverge.com/2024/6/24/24184710/riaa-ai-lawsuit-suno-udio-copyright-umg-sony-warner\" rel=\"nofollow noopener noreferrer\" target=\"_blank\" title=\"https://www.theverge.com/2024/6/24/24184710/riaa-ai-lawsuit-suno-udio-copyright-umg-sony-warner\" data-ga-track=\"ExternalLink:https://www.theverge.com/2024/6/24/24184710/riaa-ai-lawsuit-suno-udio-copyright-umg-sony-warner\" aria-label=\"sued\">sued</a> by major record labels and the Recording Industry Association of America last year for using copyrighted material to train its AI tools. </p></div></div><p>Jones, Monet’s creator, signed a multimillion dollar record deal with record label Hallwood Media in September, <a href=\"https://www.billboard.com/pro/ai-music-artist-xania-monet-multimillion-dollar-record-deal/\" rel=\"nofollow noopener noreferrer\" target=\"_blank\" title=\"https://www.billboard.com/pro/ai-music-artist-xania-monet-multimillion-dollar-record-deal/\" data-ga-track=\"ExternalLink:https://www.billboard.com/pro/ai-music-artist-xania-monet-multimillion-dollar-record-deal/\" aria-label=\"Billboard reported\">Billboard reported</a>, after a bidding war reportedly reached $3 million. </p><h2>How Have Ai Creations Found Success?</h2><p>Some of the AI acts that have made waves on the Billboard charts have curated social media profiles as if they are real people. Xania Monet’s <a href=\"https://www.instagram.com/xania_monet/?hl=en\" rel=\"nofollow noopener noreferrer\" target=\"_blank\" title=\"https://www.instagram.com/xania_monet/?hl=en\" data-ga-track=\"ExternalLink:https://www.instagram.com/xania_monet/?hl=en\" aria-label=\"Instagram\">Instagram</a> page has more than 144,000 followers, and its account regularly posts purporting to show the artist recording songs in a studio. “I write music,” Xania Monet’s Instagram bio says, even though Xania Monet is not a real person and her songs are written by Jones. The Instagram pages for <a href=\"https://www.instagram.com/breakinrust/\" rel=\"nofollow noopener noreferrer\" target=\"_blank\" title=\"https://www.instagram.com/breakinrust/\" data-ga-track=\"ExternalLink:https://www.instagram.com/breakinrust/\" aria-label=\"Breaking Rust\">Breaking Rust</a> and <a href=\"https://www.instagram.com/enllyblue/?hl=en\" rel=\"nofollow noopener noreferrer\" target=\"_blank\" title=\"https://www.instagram.com/enllyblue/?hl=en\" data-ga-track=\"ExternalLink:https://www.instagram.com/enllyblue/?hl=en\" aria-label=\"Enlly Blue\">Enlly Blue</a>, each of which have thousands of followers, similarly depict AI-generated personas performing their songs or recording music videos. The people curating these AI acts may also have a financial incentive, Billboard reported, estimating late last month Monet’s small music catalog has already generated more than $52,000 in revenue after racking up 17 million streams in the United States. It’s unclear how much of that revenue goes to Jones, the credited songwriter on Monet’s music, <a href=\"https://www.billboard.com/pro/ai-artist-xania-monet-how-much-money-songs-made/\" rel=\"nofollow noopener noreferrer\" target=\"_blank\" title=\"https://www.billboard.com/pro/ai-artist-xania-monet-how-much-money-songs-made/\" data-ga-track=\"ExternalLink:https://www.billboard.com/pro/ai-artist-xania-monet-how-much-money-songs-made/\" aria-label=\"Billboard reported\">Billboard reported</a>, though it noted platforms like Spotify don’t have specific policies for how AI-generated songs can collect royalties, meaning they can generate revenue like any other song. </p><p>Singer Kehlani slammed Xania Monet’s record deal in a since-deleted post on TikTok in September. “Nothing and no one on Earth will ever be able to justify AI to me,” Kehlani said, according to <a href=\"https://www.billboard.com/music/music-news/kehlani-slams-ai-artist-xania-monet-million-record-deal-1236071158/\" rel=\"nofollow noopener noreferrer\" target=\"_blank\" title=\"https://www.billboard.com/music/music-news/kehlani-slams-ai-artist-xania-monet-million-record-deal-1236071158/\" data-ga-track=\"ExternalLink:https://www.billboard.com/music/music-news/kehlani-slams-ai-artist-xania-monet-million-record-deal-1236071158/\" aria-label=\"Billboard\">Billboard</a>, stating she doesn’t respect the AI creation. She lamented that these AI acts make their music based on the copyrighted material AI generators are trained on without having to credit anyone. Terry McBride, co-founder and CEO of record label Nettwerk Music Group, told <a href=\"https://www.billboard.com/pro/ai-artist-record-deals-ethical-sign-xania-monet/\" rel=\"nofollow noopener noreferrer\" target=\"_blank\" title=\"https://www.billboard.com/pro/ai-artist-record-deals-ethical-sign-xania-monet/\" data-ga-track=\"ExternalLink:https://www.billboard.com/pro/ai-artist-record-deals-ethical-sign-xania-monet/\" aria-label=\"Billboard\">Billboard</a> he would not have signed Xania Monet or any other AI artist. “That’s not going to be a touring entity as we know it,” McBride said, adding, “Even if it did hundreds of millions of streams, we have no interest in that.”</p><p>The film industry is also grappling with AI-generated personas, notably the AI-generated “actress” <a href=\"https://www.forbes.com/sites/conormurray/2025/09/30/sag-aftra-condemns-ai-actress-tilly-norwood-joins-critics-emily-blunt-whoopi-goldberg-and-more/\" target=\"_self\" title=\"https://www.forbes.com/sites/conormurray/2025/09/30/sag-aftra-condemns-ai-actress-tilly-norwood-joins-critics-emily-blunt-whoopi-goldberg-and-more/\" data-ga-track=\"InternalLink:https://www.forbes.com/sites/conormurray/2025/09/30/sag-aftra-condemns-ai-actress-tilly-norwood-joins-critics-emily-blunt-whoopi-goldberg-and-more/\" aria-label=\"Tilly Norwood\">Tilly Norwood</a>, which was unveiled by an AI studio in September and quickly drew condemnation from the SAG-AFTRA actor’s guild. The union said “creativity is, and should remain, human-centered,” stating it is “opposed to the replacement of human performers by synthetics” which have “no life experience to draw from.” Other actors, including Whoopi Goldberg, Emily Blunt and Melissa Barrera also criticized this use of AI. The AI personality was created by Eline Van der Velden, who launched the AI talent studio Xicoia and claimed multiple film studios were interested in employing her creation. Like the AI-generated musicians, Tilly Norwood has an <a href=\"https://www.instagram.com/tillynorwood/\" rel=\"nofollow noopener noreferrer\" target=\"_blank\" title=\"https://www.instagram.com/tillynorwood/\" data-ga-track=\"ExternalLink:https://www.instagram.com/tillynorwood/\" aria-label=\"Instagram page\">Instagram page</a> with more than 65,000 followers that posts as if the AI actress is a real person. </p>","contentLength":4621,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/artificial/comments/1ok13ra/billboard_says_aipowered_artists_are_increasingly/"},{"title":"[R] Layer-0 heads that pre-bias hedging over facts in GPT-2 (replicated in Mistral-7B) — code + DOI","url":"https://www.reddit.com/r/MachineLearning/comments/1ok0zgr/r_layer0_heads_that_prebias_hedging_over_facts_in/","date":1761833936,"author":"/u/mat8675","guid":323497,"unread":true,"content":"<p> independent researcher (me). Sharing a preprint + code for review.</p><p> In GPT-2 Small/Medium I find layer-0 heads that  downweight factual continuations and boost hedging tokens before most computation happens. Zeroing {0:2, 0:4, 0:7} improves logit-difference on single-token probes by  and tightens calibration (ECE , Brier ). Path-patching suggests ~ of head 0:2’s effect flows through a layer-0→11 residual path. A similar (architecture-shifted) pattern appears in Mistral-7B.</p><ul><li>Models: GPT-2 Small (124M), Medium (355M); Mistral-7B.</li><li>Probes: single-token factuality/negation/counterfactual/logic tests; measure Δ logit-difference for the factually-correct token vs distractor.</li><li>Analyses: head ablations; path patching along residual stream; reverse patching to test induced “hedging attractor”.</li></ul><ul><li> Heads {0:2, 0:4, 0:7} are top suppressors across tasks. Gains (Δ logit-diff): Facts , Negation , Counterfactual , Logic . Randomization: head 0:2 at ~100th percentile; trio ~99.5th (n=1000 resamples).</li><li> Layer-0 heads {0:22, 0:23} suppress on negation/counterfactual; head 0:21 partially opposes on logic. Less “hedging” per se; tends to surface editorial fragments instead.</li><li> ~ of the 0:2 effect mediated by the layer-0→11 residual route. Reverse-patching those activations into clean runs induces stable hedging downstream layers don’t undo.</li><li> Removing suppressors improves ECE and Brier as above.</li></ul><p><strong>Interpretation (tentative).</strong></p><p>This looks like a learned  entropy-raising mechanism: rotate a high-confidence factual continuation into a higher-entropy “hedge” distribution in the first layer, creating a basin that later layers inherit. This lines up with recent inevitability results (Kalai et al. 2025) about benchmarks rewarding confident evasions vs honest abstention—this would be a concrete circuit that implements that trade-off. (Happy to be proven wrong on the “attractor” framing.)</p><p><strong>Limitations / things I didn’t do.</strong></p><ul><li>Two GPT-2 sizes + one 7B model; no 13B/70B multi-seed sweep yet.</li><li>Single-token probes only; multi-token generation and instruction-tuned models not tested.</li><li>Training dynamics not instrumented; all analyses are post-hoc circuit work.</li></ul><ol><li>Path-patching design—am I over-attributing causality to the 0→11 route?</li><li>Better baselines than Δ logit-diff for these single-token probes.</li><li>Whether “attractor” is the right language vs simpler copy-/induction-suppression stories.</li><li>Cross-arch tests you’d prioritize next (Llama-2/3, Mixtral, Gemma; multi-seed; instruction-tuned variants).</li></ol><p>I’ll hang out in the thread and share extra plots / traces if folks want specific cuts.</p>","contentLength":2593,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"I'm Independently Verifying Go's Reproducible Builds","url":"https://www.agwa.name/blog/post/verifying_go_reproducible_builds","date":1761833430,"author":"/u/amalinovic","guid":322362,"unread":true,"content":"<p>\nWhen you try to compile a Go module that requires a newer version of the Go toolchain than the one you have\ninstalled, the go command <a href=\"https://go.dev/doc/toolchain#download\" rel=\"external\">automatically downloads the newer toolchain</a> and uses it for compiling the module.\nThis useful feature was introduced in Go 1.21 and has let me quickly adopt new Go features in my open source projects\nwithout inconveniencing people with older versions of Go.\n</p><p>\nHowever, the idea of downloading a binary and executing it on demand makes a lot of people uncomfortable.\nIt feels like such an easy vector for a supply chain attack, where Google, or an attacker who has compromised\nGoogle or gotten a misissued SSL certificate, could deliver a malicious binary.\nMany developers are more comfortable getting Go from their Linux distribution, or compiling\nit from source themselves.\n</p><p>\nTo address these concerns, the Go project did two things:\n</p><ol><li><p>They made it so every version of Go starting with 1.21 could be\neasily reproduced from its source code.  Every time you compile a Go toolchain, it\nproduces the exact same Zip archive, byte-for-byte, regardless of the current time,\nyour operating system, your architecture, or other aspects of your environment (such as the directory\nfrom which you run the build).</p></li><li><p>They started publishing the checksum of every toolchain Zip archive in a public\n<a href=\"https://transparency.dev/\" rel=\"external\">transparency log</a> called the <a href=\"https://sum.golang.org/\" rel=\"external\">Go Checksum Database</a>.\nThe go command verifies that the checksum of a downloaded toolchain is published\nin the Checksum Database for anyone to see.\n</p></li></ol><p>\nThese measures mean that:\n</p><ol><li><p>You can be confident that the binaries downloaded and executed by the\ngo command are the exact same binaries you would have gotten had you built the toolchain\nfrom source yourself.  If there's a backdoor, the backdoor has to be in the source code.</p></li><li><p>You can be confident that the binaries downloaded and executed by the\ngo command are the same binaries that everyone else is downloading.  If there's a backdoor,\nit has to be served to the whole world, making it easier to detect.</p></li></ol><p>\nBut these measures mean nothing if no one is checking that the binaries\nare reproducible, or that the Checksum Database isn't presenting inconsistent information\nto different clients.  Although Google checks reproducibility and publishes\na <a href=\"https://go.dev/rebuild\" rel=\"external\">report</a>, this doesn't help if you think Google might try to\nslip in a backdoor themselves.  There needs to be an independent third party doing the checks.\n</p><p>\nWhy not me?  I was involved in Debian's\n<a href=\"https://reproducible-builds.org/\" rel=\"external\">Reproducible Builds</a> project back in the day and developed some of the core tooling used\nto make Debian packages reproducible (strip-nondeterminism and disorderfs).  I also\nhave extensive experience monitoring Certificate Transparency logs and have detected\nmisbehavior by numerous logs since 2017.  And I do not work for Google (though I have\neaten their food).\n</p><p>\nIn fact, I've been quietly operating an auditor for the Go Checksum Database since 2020\ncalled <a href=\"https://sourcespotter.com/\" rel=\"external\">Source Spotter</a> (à la <a href=\"https://sslmate.com/certspotter/\" rel=\"external\">Cert Spotter</a>, my Certificate Transparency monitor). Source Spotter monitors the Checksum Database,\nmaking sure it doesn't present inconsistent information or publish more than one checksum for a given module\nand version.  I decided to extend Source Spotter to also verify toolchain reproducibility.\n</p><p>\nThe Checksum Database was originally intended for recording the checksums of Go modules.\nEssentially, it's a verifiable, append-only log of records which say that a particular\nversion (e.g. ) of a module (e.g. ) has a particular SHA-256 hash.  Go repurposed\nit for recording toolchain checksums.  Toolchain records have the pseudo-module\n and versions that look like <code>v0.0.1-go.-</code>.  For example, the Go1.24.2 toolchain for linux/amd64 has the module version <code>v0.0.1-go1.24.2.linux-amd64</code>.\n</p><p>\nWhen Source Spotter sees a new version of the  pseudo-module,\nit downloads the corresponding source code, builds it in an AWS Lambda function by running ,\nand compares the checksum\nof the resulting Zip file to the checksum published in the Checksum Database.  Any mismatches\nare published <a href=\"https://sourcespotter.com/toolchain/\" rel=\"external\">on a webpage</a> and\nin <a href=\"https://feeds.api.sourcespotter.com/toolchain/failures.atom\" rel=\"external\">an Atom feed</a> which I monitor.\n</p><p>\nSo far, Source Spotter has successfully reproduced every toolchain since Go 1.21.0, for every architecture and operating system.\nAs of publication time, that's <a href=\"https://sourcespotter.com/toolchain/#verified\" rel=\"external\">2,672 toolchains</a>!\n</p><p>\nSince the Go toolchain is written in Go, building it requires an earlier version of the Go toolchain to be installed already.\n</p><p>When reproducing Go 1.21, 1.22, and 1.23, Source Spotter uses a Go 1.20.14 toolchain that I built from source.  I started by building Go 1.4.3 using a C compiler.  I used Go 1.4.3 to build Go 1.17.13, which I used to build Go 1.20.14.  To mitigate <a href=\"https://dl.acm.org/doi/10.1145/358198.358210\" rel=\"external\">Trusting Trust</a> attacks, I repeated this process on both Debian and Amazon Linux using both GCC and Clang for the Go 1.4 build.  I got the exact same bytes every time, which I believe makes a compiler backdoor vanishingly unlikely.  The scripts I used for this are <a href=\"https://github.com/AGWA/build-go1.20\" rel=\"external\">open source</a>.</p><p>When reproducing Go 1.24 or higher, Source Spotter uses a binary toolchain downloaded from the Go module proxy\nthat it previously verified as being reproducible from source.</p><p>\nCompared to reproducing a typical Debian package, it was really easy to reproduce the same bytes when building\nthe Go toolchains.  Nevertheless, there were some bumps along the way:\n</p><p>\nFirst, the Darwin (macOS) toolchains published by Google contain signatures produced by Google's private key.\nObviously, Source Spotter can't reproduce these.  Instead, Source Spotter has to download\nthe toolchain (making sure it matches the checksum published in the Checksum Database) and strip the signatures\nto produce a new checksum that is verified against the reproduced toolchain.\nI reused <a href=\"https://github.com/SSLMate/sourcespotter/blob/main/toolchain/darwin.go\" rel=\"external\">code written by Google</a>\nto strip the signatures <s>and I honestly have no clue what it's doing and whether\nit could potentially strip a backdoor.  A review from someone versed in Darwin binaries would be very helpful!</s>\nEdit: since publication, I've learned enough about Darwin binaries to be confident in this code.\n</p><p>\nSecond, to reproduce the linux-arm toolchains, Source Spotter has\nto set  in the environment... except when reproducing Go 1.21.0, which\n<a href=\"https://github.com/golang/go/issues/62164\" rel=\"external\">Google accidentally built using </a>.\nI find it unfortunate that <a href=\"https://pkg.go.dev/cmd/dist\" rel=\"external\">cmd/dist</a> (the tool used to build the toolchain) doesn't set this environment variable along with the many other environment variables it sets, but Russ Cox pointed me to <a href=\"https://go.dev/cl/526263\" rel=\"external\">some context</a> why this is the case.\n</p><p>\nFinally, the Checksum Database contains a toolchain for Go 1.9.2rc2, which is not a\n<a href=\"https://pkg.go.dev/go/version#IsValid\" rel=\"external\">valid version number</a>.\nIt turns out this version was <a href=\"https://github.com/golang/go/issues/68634#issuecomment-2867535846\" rel=\"external\">released by\nmistake</a>.  To avoid raising an error for an invalid version number, Source Spotter has\nto <a href=\"https://github.com/SSLMate/sourcespotter/blob/c883957f32a2162f94fdc6dafa607a1d534ebee3/internal/toolchain/build.go#L119-L124\" rel=\"external\">special case it</a>.  Not a huge deal, but I found it interesting because it\ndemonstrates one of the downsides of transparency logs: you can't fix or remove entries that were added by mistake!\n</p><p>\nThe source tarballs built by Source Spotter are not published in the Checksum Database, meaning Google\ncould serve Source Spotter, and only Source Spotter,\nsource code which contains a backdoor.  To mitigate this, Source Spotter publishes the\n<a href=\"https://sourcespotter.com/toolchain/#sources\" rel=\"external\">checksums</a> of every source tarball it builds.\nHowever, there are alternatives:\n</p><p>\nFirst, Russ Cox pointed out that while the source tarballs aren't in the Checksum Database,\nthe toolchain Zip archives also contain the source code, so Source Spotter could build those instead\nof the source tarballs. (A previous version of this post incorrectly said that source code wasn't published\nin the Checksum Database at all.)\n</p><p>\nSecond, <a href=\"https://filippo.io/\" rel=\"external\">Filippo Valsorda</a> suggested that Source Spotter build from Go's Git repository\nand publish the Git commit IDs instead, since lots of Go developers have the Go Git repository checked out\nand it would be relatively easy for them to compare the state of their repos against what Source Spotter has seen.\nRegrettably, Git commit IDs are SHA-1, but this is mitigated by Git's use of\n<a href=\"https://github.com/cr-marcstevens/sha1collisiondetection\" rel=\"external\">Marc Stevens' collision detection</a>,\nso the benefits may be worth the risk.\nI think building from Git is a good idea, and to bootstrap it, Filippo used <a href=\"https://github.com/magic-wormhole/magic-wormhole\" rel=\"external\">Magic Wormhole</a> to send me the output of  from his repo while we were both\nat the <a href=\"https://transparency.dev/summit2025/\" rel=\"external\">Transparency.dev Summit</a> last week.\n</p><p>\nThanks to Go's Checksum Database and reproducible toolchains, Go developers\nget the usability benefits of a centralized package repository and binary toolchains\nwithout sacrificing the security benefits of decentralized packages and building from source.\nThe Go team deserves enormous credit for making this a reality, particularly for building a system\nthat is not too hard for a third party to verify.  They've raised the bar, and I\nhope other language and package ecosystems can learn from what they've done.\n</p>","contentLength":8580,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1ok0rw2/im_independently_verifying_gos_reproducible_builds/"},{"title":"For the people that ONLY use linux as there workstation and gaming device, how full is your storage?","url":"https://www.reddit.com/r/linux/comments/1ojyy4u/for_the_people_that_only_use_linux_as_there/","date":1761828964,"author":"/u/Riponai_Gaming","guid":322141,"unread":true,"content":"<p>I switched to arch linux like a year ago, when i used to use windows 11, over a 100+ gigs were used up windows and its crap without me installing much in it but since i switched to arch I have a complete workstation build+VMs+games(On a hard disk sure but the all the major software is on my SSD) and some other apps and scripts that didnt exist on my windows install and its only 60 gigs.</p><p>So i am just curious how full are other peoples disks with a full setup that they use for work and gaming</p>","contentLength":494,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"AppImage apps fighting each other (Desktop integration)","url":"https://www.reddit.com/r/linux/comments/1ojyw9u/appimage_apps_fighting_each_other_desktop/","date":1761828831,"author":"/u/Top-Discussion7619","guid":322385,"unread":true,"content":"<p>I have 2 commercial apps that both run as AppImages. I'm on Ubuntu 24.04 LTS. </p><p>App #1 installs itself with Desktop Integration enabled (there's no way to turn it off).</p><p>App #2 runs without Desktop Integration but you can enable it via a setting in the app.</p><p>Both apps run perfectly. However, if I enable Desktop Integration on App #2, App  then reverts to having Desktop Integration turned off. The icon disappears from the application menu and the icon in the panel switches to the generic white box/gear AppImage icon.</p><p>Why is this happening? Is only one AppImage app allowed to be integrated into the desktop environment? </p>","contentLength":618,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"esp-hal 1.0.0 release announcement","url":"https://developer.espressif.com/blog/2025/10/esp-hal-1/","date":1761826942,"author":"/u/XxMabezxX","guid":322140,"unread":true,"content":"<p>In February this year, we announced the first <a href=\"https://developer.espressif.com/blog/2025/02/rust-esp-hal-beta/\" target=\"_blank\"> 1.0 beta</a> release. Since then we’ve been hard at work, polishing and preparing for the full release. Today, the Rust team at Espressif is excited to announce the official  release for , the  vendor-backed Rust SDK!</p><h3>What We’re Stabilizing Today</h3><p>We’ve spent many years researching and experimenting to get to this stage (check out the <a href=\"https://developer.espressif.com/blog/2025/02/rust-esp-hal-beta/\" target=\"_blank\"> 1.0 beta</a> blog post for the longer story!). However, to get a stable foundation to build from, the experimentation eventually needs to make way for stability. To achieve this, we’ve decided to limit the scope of 1.0 stabilization to:</p><ul><li>Initializing the HAL,  and the relevant configuration associated with that.</li><li>Four “core” drivers to start:</li><li> and  modes for the aforementioned drivers.<ul><li>Our  drivers are compatible with many executors, including <a href=\"https://github.com/embassy-rs/embassy\" target=\"_blank\">Embassy</a>’s.</li></ul></li><li>The  module, which provides , , and .</li><li>A couple of miscellaneous system APIs (SoC reset, etc.).</li><li>Additional configuration mechanisms beyond feature flags (<a href=\"https://crates.io/crates/esp-config\" target=\"_blank\"></a>).</li></ul><p>With the exception of the list above, everything else in  is now feature-gated behind the  feature. With the scope limited, post 1.0 we can incrementally stabilize drivers, much like the Rust project itself does, building on 1.0’s foundation.</p><h3>What Does Unstable Mean for Drivers?</h3><p>Unstable in this case refers to API stability. There is varying levels of functionality for unstable drivers, however, they are suitable for most common use cases. Using them, reporting feedback, and/or contributing to improving them will aid their stabilization.</p><h3>What About the Other  Crates?</h3><p> is the foundation of many of the ecosystem crates. <a href=\"https://github.com/esp-rs/esp-hal/tree/main/esp-radio\" target=\"_blank\"></a> (previously known as ) is our next stabilization target, which will enable the use of Wi-Fi, Bluetooth, <a href=\"https://www.espressif.com/en/solutions/low-power-solutions/esp-now\" target=\"_blank\">ESP-NOW</a> and IEEE802.15.4 on the ESP32 family of devices. The end goal is of course to have every  crate with a 1.0+ release eventually.</p><p>The first step is to read our specially curated <a href=\"https://github.com/esp-rs/book\" target=\"_blank\">book</a>, which explains the ecosystem, tooling and some key embedded concepts for .</p><p>As part of getting to 1.0, we’ve created our own project generation tool, <a href=\"https://github.com/esp-rs/esp-generate\" target=\"_blank\"></a> to bootstrap a project. This is explained fully in the <a href=\"https://github.com/esp-rs/book\" target=\"_blank\">book</a>, but getting something running today should be as simple as:</p><div><pre tabindex=\"0\"><code data-lang=\"bash\"></code></pre></div><p>to launch the interactive project generation terminal user interface.</p><p>Once you’ve generated your project, connect your ESP32 and run  from your new project directory!</p><p>This is just the start. We plan on stabilizing all  related crates, next up is <a href=\"https://github.com/esp-rs/esp-hal/tree/main/esp-radio\" target=\"_blank\"></a>. We’ll continue developing <a href=\"https://github.com/esp-rs/esp-hal/tree/main/esp-hal\" target=\"_blank\"></a>; over time we’ll stabilize more drivers beyond the core set that we’re starting with today. We’ll continue to add support for new devices, such as the newly released ESP32-C5, as they go into mass production.</p><p>This release would not have been possible without the help from the Rust community, the embedded working group, and of course the ESP community and contributors which have heavily impacted how we’ve developed our Rust offering. I would also like to thank Espressif, and in particular the Rust team for their hard work in getting us to where we are today!</p><p>If you’re a company using (or considering using) Rust on our devices, please do contact <a href=\"mailto:sales@espressif.com\">sales@espressif.com</a>, we’d love to hear from you!</p>","contentLength":3169,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1ojy6zk/esphal_100_release_announcement/"},{"title":"If concurrent programming is efficient, Why don't we use it all the time?","url":"https://youtu.be/HMy4yTxcqUY","date":1761826870,"author":"/u/parsaeisa","guid":322118,"unread":true,"content":"<!DOCTYPE html>","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1ojy61g/if_concurrent_programming_is_efficient_why_dont/"},{"title":"Would it make sense to use a Go microservice for DB operations instead of using PHP + Codeigniter?","url":"https://www.reddit.com/r/golang/comments/1ojxwev/would_it_make_sense_to_use_a_go_microservice_for/","date":1761826101,"author":"/u/mucleck","guid":322361,"unread":true,"content":"<p>At work we use PHP (CodeIgniter) with MariaDB, and right now all DB queries (SELECTs, INSERTs, etc.) go through CodeIgniter’s database helper.</p><p>I was thinking — what if instead of having each PHP process open and close DB connections all the time, we built a small Go microservice that handles all the database stuff?</p><p>The Go service would: • Keep a persistent connection pool to MariaDB • Expose simple endpoints (REST or gRPC) for queries • Benefit from Go’s concurrency and efficient connection handling</p><p>So PHP would just make requests to the Go service instead of talking to the DB directly.</p><p>Do you think this would actually be faster or more efficient, especially in terms of CPU cost? Right now, if we try to run like 6,000 inserts, the DB basically dies because each query is a new connection to the DB — so I’m wondering if this setup could handle that load better since Go would manage persistent connections instead of tons of short-lived PHP ones.</p><p>Has anyone tried something like this? Does it make sense performance-wise, or would the overhead of HTTP/gRPC just kill any potential benefit?</p><p>PD: The text was written in spanish and translated to English with ChatGpt because is not my main language, but im real persona so i would be glad if you took your time to orientate me ty!</p>","contentLength":1298,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Migrating Wordpress Websites from WPEngine to Kubernetes","url":"https://github.com/akvnn/wordpress-helm","date":1761823969,"author":"/u/Initial-Detail-7159","guid":322091,"unread":true,"content":"<p>I recently moved my Wordpress websites from WPEngine to my Kubernetes cluster. The process was seamless, the only issue was that existing Helm charts assume a new Wordpress project that would be created from the admin interface. So, I made a helm chart suited for migrating from WPEngine or any other managed provider.</p><p>Ideally, the theme would be the only part of the website that will be in GitHub (assuming you are using GitHub for version control with CI/CD setup) and will be built in the Docker image. The other components: languages, logs, plugins, and uploads are mounted as persistent volumes and changes to them are expected via the admin interface.</p><p>You simply have to build the Dockerfile (provided), migrate the data to the corresponding volumes, import the MySQL data, and finally install the helm chart.</p><p>I open sourced it if it would help anyone. You can find it here.</p><p>Note: in case you are wondering, the primary motivation for the migration is to cut costs. However, the flexibility in Kubernetes (assuming you already have a cluster) is much better! Security scanning can still be added via plugins such as WPScan. You don’t need WPEngine.</p>","contentLength":1153,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/kubernetes/comments/1ojx6sn/migrating_wordpress_websites_from_wpengine_to/"},{"title":"[R] FastJAM: a Fast Joint Alignment Model for Images (NeurIPS 2025)","url":"https://www.reddit.com/r/MachineLearning/comments/1ojx3wc/r_fastjam_a_fast_joint_alignment_model_for_images/","date":1761823714,"author":"/u/ronshap","guid":322306,"unread":true,"content":"<p>I'm excited to share our NeurIPS 2025 paper \"FastJAM: a Fast Joint Alignment Model for Images\".</p><p>Authors: Omri Hirsch*, Ron Shapira Weber*, Shira Ifergane, Oren Freifeld.</p><p>FastJAM is a lightweight graph-based framework for joint image alignment that runs in seconds rather than minutes or hours (for previous works).</p><p>Example of FastJAM Joint alignment results:</p><p>FastJAM reformulates the joint alignment problem using sparse keypoints and graph neural networks (GNNs). By propagating correspondence information across images, FastJAM predicts consistent transformations for an entire collection of images, achieving a large speedup in runtime and better or comparable results across all datasets.</p><p>FastJAM GNN Architecture:</p>","contentLength":713,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Fil-C: A memory-safe C implementation","url":"https://lwn.net/SubscriberLink/1042938/38d8dde9db211cab/","date":1761822207,"author":"/u/waozen","guid":322185,"unread":true,"content":"<blockquote><table><tbody><tr><td><p>\nThe following subscription-only content has been made available to you \nby an LWN subscriber.  Thousands of subscribers depend on LWN for the \nbest news from the Linux and free software communities.  If you enjoy this \narticle, please consider <a href=\"https://lwn.net/subscribe/\">subscribing to LWN</a>.  Thank you\nfor visiting LWN.net!\n</p></td></tr></tbody></table></blockquote><div>\n           By October 28, 2025</div><p><a href=\"https://fil-c.org/\">\nFil-C</a> is a memory-safe implementation of C and C++ that aims to let C code —\ncomplete with pointer arithmetic, unions, and other features that are often\ncited as a problem for memory-safe languages — run safely, unmodified.\nIts dedication to being \"\" makes it an attractive choice for retrofitting memory-safety\ninto existing applications. Despite the project's relative youth and single\nactive contributor, Fil-C is capable of compiling an\nentire memory-safe Linux user space (based on\n<a href=\"https://www.linuxfromscratch.org/\">\nLinux From Scratch</a>),\nalbeit with some modifications to the more complex programs. It also features\nmemory-safe signal handling and a concurrent garbage collector.\n</p><p>\nFil-C is a fork of\n<a href=\"https://clang.llvm.org/\">\nClang</a>; it's available under an Apache v2.0\nlicense with LLVM exceptions for the runtime. Changes from the upstream compiler\nare occasionally merged in, with Fil-C currently being based on version 20.1.8\nfrom July 2025. The project is a personal passion\nof Filip Pizlo, who has previously worked on the runtimes of a number of\nmanaged languages, including Java and JavaScript. When he first began the\nproject, he was not sure that it was even possible. The initial implementation\nwas prohibitively slow to run, since it needed to insert a lot of different safety checks. This has\ngiven Fil-C a reputation for slowness. Since\nthe initial implementation proved viable, however, Pizlo has managed to optimize a number\nof common cases, making Fil-C-generated code only a few times slower than\nClang-generated code, although the exact slowdown depends heavily on the\nstructure of the benchmarked program.\n</p><p>\nReliable benchmarking is notoriously finicky, but in order to get some rough feel for\nwhether that level of performance impact would be problematic, I compiled Bash\nversion 5.2.32 with Fil-C and tried using it as my shell. Bash is nearly a best\ncase for Fil-C, because it spends more time running external programs than\nrunning its own code, but I still expected the performance difference to be\nnoticeable. It wasn't. So, at least for some programs, the performance overhead\nof Fil-C does not seem to be a problem in practice.\n</p><p>\nIn order to support its various run-time safety checks,\nFil-C does use a different internal ABI than Clang does. As a result, objects compiled with Fil-C won't\nlink correctly against objects generated by other compilers. Since Fil-C is a\nfull implementation of C and C++ at the source-code level, however, in practice\nthis just requires everything to be recompiled with Fil-C. Inter-language\nlinking, such as with Rust, is not currently supported by the project.\n</p><p>\nThe major challenge of rendering C memory-safe is, of course, pointer handling.\nThis is especially complicated by the fact that, as the\n<a href=\"https://lwn.net/Articles/1037974/\">\nlong road to CHERI-compatibility</a>\nhas shown, many programs expect a pointer to be 32 or 64 bits, depending on the\narchitecture.\nFil-C has tried several different ways to represent pointers since the project's\nbeginning in 2023. Fil-C's first pointers were 256 bits, not thread-safe, and\ndidn't protect against use-after-free bugs. The current implementation, called\n<a href=\"https://fil-c.org/invisicaps\">\n\"InvisiCaps\"</a>, allows\nfor pointers that appear to match the natural pointer size of the architecture\n(although this requires storing some auxiliary information elsewhere),\nwith full support for concurrency and\ncatching use-after-free bugs, at the expense of some run-time overhead.\n</p><p>\nFil-C's documentation\ncompares InvisiCaps to a software\nimplementation of CHERI: pointers are separated into a trusted \"capability\"\npiece and an untrusted \"address\" piece. Since Fil-C controls how the program is\ncompiled, it can ensure that the program doesn't have direct\naccess to the capabilities of any pointers, and therefore the runtime can rely\non them being uncorrupted. The tricky part of the implementation comes from how\nthese two pieces of information are stored in what looks to the program like 64\nbits.\n</p><p>\nWhen Fil-C allocates an object on the heap, it adds two metadata words before\nthe start of the allocated object: an upper bound, used to check accesses to the\nobject based on its size, and an \"aux word\" that is used to store additional\npointer metadata. When the program first writes a pointer value into an object, the\nruntime allocates a new auxiliary allocation of the same size as the object being written\ninto, and puts an actual hardware-level\npointer (i.e., one without an attached capability)\nto the new allocation into the aux word of the object. This auxiliary allocation, which is\ninvisible to the program being compiled, is used to\nstore the associated capability information for the pointer being stored (and is\nalso reused for any additional pointers stored into the object later). The address\nvalue is stored into the object as normal, so any C bit-twiddling\ntechniques that require looking at the stored value of the pointer work as\nexpected.\n</p><p>\nThis approach does mean that structures that contain pointers end up using twice\nas much memory, and every load of a pointer involves a pointer indirection\nthrough the aux word. In practice, the documentation claims that the\nperformance overhead of this approach for most programs makes them run about four\ntimes more slowly, although that number depends on how heavily the program makes\nuse of pointers. Still, he has ideas for several optimizations that he hopes can\nbring the performance overhead down over time.\n</p><p>\nOne wrinkle with this approach is atomic access to pointers — i.e. using\n<a href=\"https://en.cppreference.com/w/c/language/atomic.html\"></a> or . Luckily, there is\nno problem that cannot be solved with more pointer indirection: when the program\nloads or stores a pointer value atomically, instead of having the auxiliary\nallocation contain the capability information directly, it points to a\nthird 128-bit allocation that stores the capability and pointer value together.\nThat allocation can be updated with 128-bit atomic instructions, if the platform\nsupports them, or by creating new allocations and atomically swapping the\npointers to them.\n</p><p>\nSince the aux word is used to store a pointer value, Fil-C can use\n<a href=\"https://en.wikipedia.org/wiki/Tagged_pointer\">\npointer\ntagging</a> to store some additional information there as well; that is used to\nindicate special types of objects that need to be handled differently, such as\nfunctions, threads, and\n<a href=\"https://www.man7.org/linux/man-pages/man2/mmap.2.html\"></a>-backed allocations. It's also used to\nmark freed objects, so that any access results in an error message and a crash.\n</p><p>\nWhen an object is freed, its aux word marks it as a free object, which lets the\nauxiliary allocation be reclaimed immediately. The\noriginal object can't be freed immediately, however.\nOtherwise, a program could free an object,\nallocate a new object in the same location, and thereby cover up use-after-free bugs.\nInstead, Fil-C\n<a href=\"https://fil-c.org/fugc\">\nuses a garbage collector</a> to free an object's backing\nmemory only once all of the pointers to it go away. Unlike other garbage collectors\nfor C — such as\n<a href=\"https://www.hboehm.info/gc/\">\nthe Boehm-Demers-Weiser garbage collector</a> —\nFil-C can use the auxiliary\ncapability information to track live objects precisely.\n</p><p>\nFil-C's garbage collector is both parallel (collection happens faster the more\ncores are available) and concurrent (collection happens without pausing the\nprogram). Technically, the garbage collector does require threads to\noccasionally pause just long enough to tell it where pointers are located on the\nstack, but that only occurs at special \"safe points\" — otherwise, the program\ncan load and manipulate pointers without notifying the garbage collector. Safe\npoints are used as a synchronization barrier: the collector can't know that an object\nis really garbage until every thread has passed at least one safe point since it\nfinished marking. This synchronization is done with atomic instructions,\nhowever, so in practice threads never need to pause for longer than a few\ninstructions.\n</p><p>\nThe exception is the implementation of\n<a href=\"https://www.man7.org/linux/man-pages/man2/fork.2.html\"></a>, which uses the\nsafe points needed by the garbage collector to temporarily pause all of the threads\nin the program in order to prevent race conditions while forking. Fil-C inserts\na safe point at every backward control-flow edge, i.e., whenever code could\nexecute in a loop. In the common case, the inserted code just needs to load a flag register\nand confirm that the garbage collector has not requested anything be done. If\nthe garbage collector does have a request for the thread, the thread runs a callback to\nperform the needed synchronization.\n</p><p>\nFil-C uses the same safe-point mechanism to implement signal handling. Signal\nhandlers are only run when the interrupted thread reaches a safe point. That, in\nturn, allows signal handlers to allocate and free memory without interfering\nwith the garbage collector's operation; Fil-C's\n<a href=\"https://www.man7.org/linux/man-pages/man3/malloc.3.html\"></a> is signal-safe.\n</p><p>\nLinux From Scratch (LFS) is a tutorial on compiling one's own complete\nLinux user space. It walks through the steps of compiling and installing all of the core\nsoftware needed for a typical Linux user space in a\n<a href=\"https://www.man7.org/linux/man-pages/man2/chroot.2.html\"></a>\nenvironment. Pizlo has successfully\n<a href=\"https://fil-c.org/pizlix\">\nrun through</a> LFS with Fil-C to\nproduce a memory-safe version, although a non-Fil-C compiler is still needed to\nbuild some fundamental components, such as Fil-C's own runtime,\nthe GNU C library, and the kernel. (While Fil-C's runtime relies on a normal\ncopy of the GNU C library to make system calls, the programs that Fil-C compiles\nuse a Fil-C-compiled version of the library.)\n</p><p>\nThe process is mostly identical to LFS up through the end of chapter 7, because\neverything prior to that point consists of using cross-build tools to obtain a\nworking compiler in the  environment. The one difference is\nthat the cross-build tools are built with a different configured prefix, so that\nthey won't conflict with Fil-C. At that point, one can\nbuild a copy of Fil-C and use it to mostly replace the existing compiler. The\nremaining steps of LFS are unchanged.\n</p><p>\nOverall, Fil-C offers a remarkably complete solution for making existing C\nprograms memory-safe. While it does nothing for undefined behavior that is not\nrelated to memory safety,\nthe most pernicious and difficult-to-prevent security\nvulnerabilities in C programs tend to rely on exploiting memory-unsafe\nbehavior. Readers who have already considered and rejected Fil-C for their use\ncase due to its early performance problems may wish to take a second look —\nalthough anyone hoping for stability might want to wait for others to take the\nplunge, given the project's relative immaturity.\nThat said, for existing applications where a sizeable performance hit is preferable to an\nexploitable vulnerability, Fil-C is an excellent choice.\n</p>","contentLength":10776,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ojwnec/filc_a_memorysafe_c_implementation/"},{"title":"[D] Is mamba architecture not used that much in the field of research?","url":"https://www.reddit.com/r/MachineLearning/comments/1ojwly3/d_is_mamba_architecture_not_used_that_much_in_the/","date":1761822080,"author":"/u/Charming_Bag_1257","guid":322188,"unread":true,"content":"<p>What I have read so far, Mamba arch still shines in handling long contexts (e.g., millions of tokens) much better than Transformers without the memory explosion. I get that when it comes to effectiveness (which we want), the transformer shines and is heavily used in research, but what are the limitations for Mamba? I usually do not find papers using this arch.</p>","contentLength":362,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Weekly: This Week I Learned (TWIL?) thread","url":"https://www.reddit.com/r/kubernetes/comments/1ojvk1a/weekly_this_week_i_learned_twil_thread/","date":1761818431,"author":"/u/gctaylor","guid":322029,"unread":true,"content":"<p>Did you learn something new this week? Share here!</p>","contentLength":50,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Surf update: new TLS fingerprints for Chromium 142","url":"https://www.reddit.com/r/golang/comments/1ojvfcb/surf_update_new_tls_fingerprints_for_chromium_142/","date":1761817958,"author":"/u/Affectionate_Type486","guid":322387,"unread":true,"content":"<p>An update to <a href=\"https://github.com/enetx/surf\">Surf</a>, the browser-impersonating HTTP client for Go.</p><p>The latest version adds support for new TLS fingerprints that match the behavior of the following clients:</p><p>These fingerprints include accurate ordering of TLS extensions, signature algorithms, supported groups, cipher suites, and use the correct GREASE and key share behavior. JA3 and JA4 hashes match the real browsers, including JA4-R and JA4-O. HTTP/2 Akamai fingerprinting is also consistent..</p><p>Let me know if you find any mismatches or issues with the new fingerprints.</p>","contentLength":535,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"The private conversation anti-pattern in engineering teams","url":"https://open.substack.com/pub/leadthroughmistakes/p/why-we-tend-to-avoid-public-conversations","date":1761812331,"author":"/u/dymissy","guid":322116,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1oju0f7/the_private_conversation_antipattern_in/"},{"title":"I created a new image format that can describe a full image in as little as 7 bytes","url":"https://github.com/mohanp06/simple-color-image-format/tree/main","date":1761812287,"author":"/u/mpp06","guid":322093,"unread":true,"content":"<p><em>Disclaimer: It's a hobby project, and as of now covers only simple image content. No attempt is made to format it as per the standard image specifications if any. It is an extensible, abstract framework, not restricted to images, and could be potentially useful in some cases.</em></p><p>I’ve been experimenting with how minimal an image file format can get — and ended up designing <strong>SCIF (Simple Color Image Format)</strong>.</p><p>It’s a tiny binary format that stores simple visuals like solid colors, gradients, and checkerboards using only a few bytes.</p><ul><li>7 bytes for a full solid-color image</li><li>11 bytes for gradients or patterns</li><li>easy to decode in under 20 lines of code</li><li>designed for learning, embedded systems, and experiments in data representation</li></ul><p>I’d love feedback or ideas for extending it — maybe procedural textures, transparency, or even compressed variants. Curious what you think — can such ultra-minimal formats have real use in small devices or demos?</p>","contentLength":941,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1oju019/i_created_a_new_image_format_that_can_describe_a/"},{"title":"The Green Tea Garbage Collector","url":"https://www.reddit.com/r/golang/comments/1ojtyuq/the_green_tea_garbage_collector/","date":1761812148,"author":"/u/Asleep-Actuary-4428","guid":322119,"unread":true,"content":"<p>Here are the details of Green Tea GC. It’s production-ready and already in use at Google, and plan to make it the default in Go 1.26.</p>","contentLength":135,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Harbor in Kubernetes","url":"https://www.reddit.com/r/kubernetes/comments/1ojtxes/harbor_in_kubernetes/","date":1761811972,"author":"/u/Always_smile_student","guid":322006,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Harbor in Kubernetes","url":"https://www.reddit.com/r/kubernetes/comments/1ojtovo/harbor_in_kubernetes/","date":1761810995,"author":"/u/Always_smile_student","guid":321991,"unread":true,"content":"<p>Everything was installed successfully, and I set up a NodePort so I can access it via the master node’s IP. Everywhere it says the default login and password are , but I get an “invalid username or password” error.</p><p>I also tried to check or reset the password using:</p><pre><code>kubectl -n harbor get secret harbor-core -o jsonpath=\"{.data.HARBOR_ADMIN_PASSWORD}\" | base64 --decode </code></pre><p>But that password doesn’t work either.</p>","contentLength":413,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Dithering - Part 1","url":"https://visualrambling.space/dithering-part-1/","date":1761809938,"author":"/u/brokePlusPlusCoder","guid":322263,"unread":true,"content":"<p>tap/click the right side of the screen to go forward →</p><p>I’ve always been fascinated by the dithering effect. It has a unique charm that I find so appealing.</p><p>← tap/click the left side to go back</p><p>I was even more amazed when I learned how dithering works.</p><p>← or use arrow keys to navigate →</p><p>Look closely, and you’ll see this animation is made of alternating black and white pixels.</p><p>But these black and white pixels are specifically arranged to create the illusion of multiple shades.</p><p>That’s what dithering does: it simulates more color variations than what are actually used.</p><p>Here, it uses black and white to give the impression of multiple gray shades.</p><p>To me, dithering is about creating the most out of what we have, and that's what amazes me the most!</p><p>It inspired me to learn more about it, and now I want to share what I’ve learned.</p><p>Please note that this is just part one out of three, so I’ll only scratch the surface here.</p><p>I’ll go deeper in the next parts, which will come soon. Stay tuned!</p><p>First, let’s explore the dithering basics with this grayscale image example.</p><p>A grayscale image has various gray shades, from black to white.</p><p>Imagine a display that only shows black or white pixels, no grays. We must turn some pixels black and others white—but how?</p><p>One way is to map each pixel to the closest available color.</p><p>Pixels darker than medium gray turn black and lighter ones turn white.</p><p>This splits pixels into black or white groups.</p><p>However, this creates a harsh image with abrupt black-white transitions.</p><p>Shadow details vanish as gray pixels become fully black or white.</p><p>Dithering fixes this by selectively pushing some pixels towards the opposite color.</p><p>Some light gray pixels that are closer to white turn black.</p><p>Likewise, some dark grays turn white.</p><p>And it's done in a way that produces special patterns which simulate shades by varying the black-and-white pixel densities.</p><p>Denser black pixels are used in darker areas, while denser white pixels are used in lighter ones.</p><p>Next question: How are these patterns generated?</p><p>One simple dithering method, known as ordered dithering, uses a threshold map.</p><p>A threshold map is a grid of values representing brightness levels, from 0 (darkest) to 1 (brightest).</p><p>To dither, we compare each input pixel’s brightness to a corresponding threshold value.</p><p>If a pixel’s brightness exceeds the threshold (it’s brighter than the threshold), the pixel turns white. Otherwise, it turns black.</p><p>Repeating this for all pixels gives us the black-and-white dither patterns.</p><p>The threshold map is designed to output patterns where the black-and-white pixel density matches the input image’s shades.</p><p>So brighter input produces patterns with more white, while darker input produces more black.</p><p>These black-and-white density variations are what create the illusion of gray shades when viewed from a distance.</p><p>To dither larger images, we extend the threshold map to match the image size and follow the same principle:</p><p>Compare each pixel’s brightness to the threshold map, then turn it black or white accordingly.</p><p>The image now uses only two colors, but its overall appearance is preserved.</p><p>The variations in shades are now replaced by variations in black/white pixel density of the dithering patterns.</p><p>And that’s how dithering works in a nutshell: it replicates shades with fewer colors, which are strategically placed to maintain the original look.</p><p>I find it a bit ironic how I used to think dithering ‘adds’ a cool effect, when what it actually does is ‘remove’ colors!</p><p>That's all for now! We’ve reached the end, but there’s still a lot more to explore.</p><p>For example, we haven’t explored the algorithm to create a threshold map. (spoiler: there are many ways!)</p><p>There’s also another algorithm called error diffusion, which doesn’t use a threshold map.</p><p>Each algorithm creates a distinct, unique look, which I believe deserves its own article.</p><p>And that's why I decided to break this series into three parts.</p><p>In the next part, I’ll dive into various algorithms for creating threshold maps.</p><p>In the final part, I’ll focus on the error diffusion algorithm.</p><p>We'll dive even deeper into dithering's mechanisms in these next 2 parts, so stay tuned!</p><p>visualrambling.space is a personal project by Damar, someone who loves to learn about different topics and rambling about them visually.</p><p>If you like this kind of visual article, please consider following me on X/Twitter and sharing this with your friends.</p><p>I'll keep creating more visual articles like this!</p><p>https://x.com/damarberlari</p>","contentLength":4505,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ojtfvn/dithering_part_1/"},{"title":"I’ve been living inside Rust for a while, and Flow-Like is what came out — a typed, local-first workflow engine","url":"https://github.com/TM9657/flow-like","date":1761808131,"author":"/u/tm9657","guid":322030,"unread":true,"content":"<p>I’ve been quietly building , a typed, visual workflow engine written in Rust. Think node-based “blueprints,” but with  — so flows are safer, easier to reason about, and automatically versioned. Everything runs : the desktop app, the backend, even AI and data nodes. There’s no account and no cloud dependency unless you explicitly add one.</p><p>With  out, you can now actually build real automations — from  and  to , data transforms, or ML pipelines. And, of course, we’ve <strong>carefully hidden many bugs</strong> for you to find and report. ❤️</p><p>Flow-Like is a desktop app (built with ) that lets you visually connect typed nodes into executable graphs. Each connection enforces its pin type, so most wiring errors show up before execution. Under the hood there’s a Rust engine that runs your graph directly — no web service, no remote orchestrator. Our backend code is also in our monorepo if that is more interesting to you.</p><p>For external connectivity, there’s an  that can spin up a local  server, manage , connect to , handle webhooks, timers, file watchers, and more. You can also host it if you want — the backend code for that is included.</p><p>Every project comes with its own <strong>file storage and database</strong> powered by the excellent  library — giving you <strong>full-text and vector search</strong> out of the box, with no setup required.</p><p>Llama.cpp is embedded for local models and ONNX for local ML and Embeddings. Every flow and node definition is , so you can safely share or roll back changes.</p><ul><li> custom async executor that runs typed graphs directly.</li><li> for event endpoints, HTTP handling, and integrations.</li><li> and  for structured + vector data storage.</li><li> for table operations and analytics.</li><li> and  integration for local inference.</li><li>, cross-platform builds for macOS/Windows/Linux.</li><li> already working (also thanks to Tauri)! The iOS build runs your flows LOCALLY on your phone — just needs a bit more polish before TestFlight.</li></ul><ul><li>Build  with typed request/response handling.</li><li>Run  that respond to messages and events.</li><li>Create  (IMAP fetch, filter, SMTP send).</li><li>Automate file pipelines, data transforms, or ML tasks.</li><li>Use  inside flows for full-text and vector search.</li><li>Stay completely offline — or opt into cloud APIs if you want.</li></ul><p>Everything happens locally, and everything is versioned — your data, flows, and nodes.</p><p>If you like the idea (or just want to see how far Rust and Tauri can go), a quiet ⭐️ on GitHub would be very welcome.</p>","contentLength":2401,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1ojt01w/ive_been_living_inside_rust_for_a_while_and/"},{"title":"hpademo - web browser tool for quickly simulating cpu-based hpa","url":"https://www.reddit.com/r/kubernetes/comments/1ojshyl/hpademo_web_browser_tool_for_quickly_simulating/","date":1761806141,"author":"/u/Reasonable-Rice444","guid":321971,"unread":true,"content":"<p>Need a quick tool for simulating cpu-based hpa behavior?</p><p><a href=\"https://udhos.github.io/hpademo/www/\">hpademo</a> is a simple demo for Kubernetes Horizontal Pod Autoscaler (HPA), written in Go and compiled to WebAssembly in order to run in a web browser.</p>","contentLength":204,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Think memcmp is safe? Think again","url":"https://github.com/stateless-me/flatline","date":1761805054,"author":"/u/aabbdev","guid":322031,"unread":true,"content":"<p>I merged a “tiny perf” patch and unknowingly shipped a  on an auth path. Tests were green. The canary wasn’t. The compiler had “helpfully” turned a compare into an  and my branch on that result amplified the signal. That week taught me two things:  and C won’t keep you from leaking it.</p><p>So I wrote  a single-header, zero-dep, zero-heap toolbox for writing  C (C99/C11). But first, a quick ego check.</p><pre><code>if (memcmp(tag_a, tag_b, TAG_LEN) == 0) { memcpy(dst, src, len); } </code></pre><p><strong>B. Secret-conditioned branch</strong></p><pre><code>if (secret_bit) { memcpy(dst, src, len); } </code></pre><pre><code>uint8_t out = sbox[secret_idx]; </code></pre><p><strong>D. Ternary select on a secret</strong></p><pre><code>uint32_t y = secret_bit ? a : b; </code></pre><ul><li> (prefix-match timing)</li><li> (predictor + divergent paths)</li><li> (cache trace keyed by the secret).</li><li> →  may compile to a  (leaky). Even if it becomes a , only  may be evaluated (loads/calls) → secret-dependent memory traffic/time. Safe only if both operands are already plain values and the compiler emits a true constant-time select — which you shouldn’t bet on.</li></ul><p>Looks correct ≠ constant-time. Your <strong>toolchain, caches, and predictors</strong> also write the story.</p><p><strong>B. Branch on secrets (don’t)</strong> If execution path depends on a secret, timing does too.</p><ul><li><p>if (secret_bit) memcpy(dst, src, len); </p></li><li><p>uint32_t chosen = flat_select_u32(secret_bit, yes, no); // branchless select flat_memcpy_when((unsigned)secret_bit, dst, src, len); // gated copy w/o branch </p></li></ul><p><strong>I. Index memory with secrets (don’t)</strong> Secret-dependent addresses leave cache footprints.</p><ul><li><p>uint8_t out = sbox[secret_idx]; </p></li><li><p>uint8_t out = flat_lookup_u8(sbox, 256, secret_idx); // sweep + mask, constant-time // or: flat_table_apply_u8(outbuf, inbuf, n, sbox, 256); </p></li></ul><p><strong>D. Don’t use variable-latency ops on secrets</strong> Some instructions take  time; operands from secrets = side channel.</p><ul><li><p>q = n / secret_d; r = n % secret_d; </p></li><li><p>uint64_t q, r; unsigned ok = flat_div_mod_ct_u64(n, secret_d, &amp;q, &amp;r); // constant-time pattern </p></li></ul><p>Early-exit compares betray how many leading bytes matched. If you then branch on the result, you amplify the leak.</p><pre><code>int eq = flat_mem_eq(tag_a, tag_b, TAG_LEN); // no early exit flat_memcpy_when((unsigned)eq, dst, src, len); // no branch on secret </code></pre><p><strong>Constant-time equality + copy</strong></p><pre><code>#include \"flatline.h\" int ok = flat_mem_eq(tag_a, tag_b, TAG_LEN); flat_memcpy_when((unsigned)ok, dst, src, len); </code></pre><pre><code>uint32_t y = flat_select_u32(secret_bit, yes, no); </code></pre><pre><code>uint8_t v = flat_lookup_u8(sbox, 256, secret_idx); </code></pre><p><strong>Constant-time div/mod (when operands may be secret)</strong></p><pre><code>uint64_t q, r; unsigned okdiv = flat_div_mod_ct_u64(n, d, &amp;q, &amp;r); </code></pre><pre><code>clib install stateless-me/flatline # or drop flatline.h into your project </code></pre><ul><li><strong>Compilers are “too smart.”</strong> LTO and auto-vectorization can reintroduce branches or table lookups you thought you’d eliminated. (Consider  in strict builds.)</li><li> MB/s benchmarks won’t tell you if you’re constant-time. You need statistics (e.g., DUDECT-style t-tests) on  target CPU.</li><li> Loops must run the same number of iterations regardless of secrets. “Break on first mismatch” is a timing oracle in disguise.</li><li> Cross-process boundaries make tiny timing differences very measurable.</li></ul><p>Anywhere you compare tags, gate access, check tokens, or touch data-derived indices can betray you:</p><ul><li>Feature flags around sensitive paths</li><li>Table-driven transforms (S-boxes, LUTs, routing tables)</li></ul><p>The B.I.D. mental model keeps you honest:</p><ul><li> — don’t ndex memory with secrets</li><li> — on’t use variable-latency ops on secrets</li></ul><p>Add two habits:  and .</p><ul><li>Single header, no deps, no heap; C99/C11; usable from C++</li><li>Primitives designed to <strong>not branch/index on secrets</strong></li><li>Optional SIMD (NEON/SSE2/AVX2) paths that remain constant-time w.r.t. </li><li>Unit tests, micro-benches, and a DUDECT-like harness</li></ul><p>It reduces timing variance. It doesn’t fix power/EM channels or OS noise. Threat models still apply.</p><p>If you picked any of A/B/C as “safe,” you’re not alone I did too, before a pager taught me otherwise. Try the patterns above, run a DUDECT-style check, and tell me where your toolchain fought back (LTO, builtins, odd  rewrites).</p><p><strong>If time varies, secrets leak. Flatline it.</strong></p><p>Proposal: introduce a secret keyword in systems languages (Rust, Zig, LLVM/C) to mark sensitive data. The compiler enforces constant-time rules and replaces unsafe patterns with constant-time APIs.</p>","contentLength":4194,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ojs7ve/think_memcmp_is_safe_think_again/"},{"title":"SNMP on Linux stats without running the service.","url":"https://www.reddit.com/r/linux/comments/1ojrka4/snmp_on_linux_stats_without_running_the_service/","date":1761802535,"author":"/u/lickety-split1800","guid":321972,"unread":true,"content":"<p>Over 20 years ago (man I feel old), I had set up SNMP on Linux with Nagios and RRDTool.</p><p>While SNMP is hardly used anymore on Linux it had a lot of metrics that it collected, which was super useful for sending stats to either Nagios or RRDTool at the time.</p><p>Is there anything else out of the box that has a large set of monitors on Linux?</p><p>What are your favourite out-of-the-box Linux metrics collection tools?</p>","contentLength":404,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Alternative to the LogiOptions+ new Action Ring Feature","url":"https://www.reddit.com/r/linux/comments/1ojr3s9/alternative_to_the_logioptions_new_action_ring/","date":1761800855,"author":"/u/GarThor_TMK","guid":321957,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"[P] I made a tool to search papers from selected AI venues","url":"https://www.reddit.com/r/MachineLearning/comments/1ojqgq4/p_i_made_a_tool_to_search_papers_from_selected_ai/","date":1761798628,"author":"/u/ZealousidealStock933","guid":322007,"unread":true,"content":"<p>It uses a language model as backbone so you can query with title, keywords, or even a paper abstract to search. Paper abstracts are the most accurate. It hosted on a personal server as well as on hugging face. Links are in my repo. <a href=\"https://github.com/wenhangao21/ICLR26_Paper_Finder\">https://github.com/wenhangao21/ICLR26_Paper_Finder</a></p>","contentLength":282,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Unbound on talos","url":"https://www.reddit.com/r/kubernetes/comments/1ojqf7t/unbound_on_talos/","date":1761798488,"author":"/u/Agreeable_Repeat_568","guid":321941,"unread":true,"content":"<p>I am trying to get unbond to run rootless on talos and it seems like it might not be possible? Has anyone gotten current images of unbound running rootless? Iv tried too many options to list, just looking to see if this is even possible?</p>","contentLength":237,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"I'm tired of Web Dev","url":"https://www.reddit.com/r/golang/comments/1ojpxv2/im_tired_of_web_dev/","date":1761796894,"author":"/u/Financial_Job_1564","guid":321943,"unread":true,"content":"<div><p>I already have some experience with Golang from building backend projects, but I still feel like I don’t really know much about it.</p><p>Can you give me some examples of projects that use Golang besides backend servers?</p></div>   submitted by   <a href=\"https://www.reddit.com/user/Financial_Job_1564\"> /u/Financial_Job_1564 </a>","contentLength":256,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Can't get data on heavy outputs","url":"https://www.reddit.com/r/linux/comments/1ojo6a1/cant_get_data_on_heavy_outputs/","date":1761791529,"author":"/u/BassDJ812","guid":321942,"unread":true,"content":"<p>So as you can see I can't read date at the bottom and terminal. the only way to get it where it is now is control-minus control. Plus doesn't work I can't scroll down to the data I need on heavy output. I've tried to manipulate the preference menu the best I can in between that and Google research I'm not coming up with any luck. I'm on Kali not that I think that makes a difference. Any help most appreciated </p>","contentLength":412,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Meta, Google, and Microsoft Triple Down on AI Spending","url":"https://www.wired.com/story/microsoft-google-meta-2025-earnings/","date":1761790458,"author":"/u/wiredmagazine","guid":322189,"unread":true,"content":"<p> biggest US tech giants—Microsoft, Meta, and Google—sent investors a blunt message when they reported quarterly earnings on Wednesday: Their <a href=\"https://www.wired.com/story/the-ai-industrys-scaling-obsession-is-headed-for-a-cliff/\">lavish spending</a> on <a href=\"https://www.wired.com/story/openai-oracle-softbank-data-center-stargate-us/\">AI infrastructure</a> is only just getting started.</p><p>Meta said that ​​its capital expenditure would total between $70 billion and $72 billion this year, up from its previous lower forecast of $66 billion to $72 billion. Meta’s chief financial officer Susan Li said that she expected the company's spending would be “notably larger\" next year. The social media giant’s soaring investment matches its soaring revenue: Meta reported raking in $51.24 billion last quarter, up 26 percent year over year.</p><p>CEO Mark Zuckerberg said the company would keep pouring money into infrastructure to meet rising demand for AI and to prepare for potential major breakthroughs in the technology. \"There's a range of timelines for when people think that we're going to get superintelligence,\" Zuckerberg said on a conference call with analysts. \"I think that it's the right strategy to aggressively front-load building capacity, so that way we're prepared for the most optimistic cases.\"</p><p>Meta has moved aggressively to <a href=\"https://www.wired.com/story/mark-zuckerberg-meta-offer-top-ai-talent-300-million/\">recruit AI talent</a> in recent months, offering some researchers compensation packages worth hundreds of millions of dollars. The company also cut some 600 jobs last week in what it said was an effort to make its AI teams more efficient. Meta has <a data-offer-url=\"https://www.nytimes.com/2025/08/19/technology/mark-zuckerberg-meta-ai.html\" data-event-click=\"{&quot;element&quot;:&quot;ExternalLink&quot;,&quot;outgoingURL&quot;:&quot;https://www.nytimes.com/2025/08/19/technology/mark-zuckerberg-meta-ai.html&quot;}\" href=\"https://www.nytimes.com/2025/08/19/technology/mark-zuckerberg-meta-ai.html\" rel=\"nofollow noopener\" target=\"_blank\">reorganized</a> its AI teams numerous times over the past eight months.</p><p>Meta assured investors that its AI investments were already reaping rewards for the company, but didn’t share many specifics. Meta did say AI was benefiting its ad business and virtual reality product lines, and predicted it would propel those divisions to new heights in the future.</p><p>Google’s parent company, Alphabet, said it expected its 2025 capital expenditures to be between $91 billion and $93 billion. Earlier this year, Alphabet estimated that number would be just $75 billion. Like at Meta, the increase in spending was matched with an increase in revenue. The tech giant said it earned a record $102.3 billion in the third quarter, up 33 percent from a year ago.</p><p>Most of Alphabet’s spending will likely be funneled into data centers and other artificial intelligence initiatives. Google said it earned $15.15 billion from its cloud business in the third quarter, a 35 percent increase from the same period in 2024. Gemini, Google’s <a href=\"https://www.wired.com/story/how-to-use-google-gemini-advanced-ai-chatbot/\">general purpose AI app</a>, now has 650 million monthly active users, up from 450 million last quarter. (For comparison, OpenAI CEO Sam Altman recently said that ChatGPT has <a href=\"https://www.wired.com/story/chatgpt-psychosis-and-self-harm-update/\">800 million</a> weekly users.)</p><p>Microsoft reported revenues of $77 billion for the quarter ending on September 30, up 18 percent from a year ago. Its cloud business revenue was up 26 percent year over year. Its capital expenditures were $34.9 billion this quarter, with much of the investment going toward AI infrastructure. That figure is nearly $5 billion more than previously forecasted, and a 74 percent jump from the same quarter a year ago.</p>","contentLength":3035,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/artificial/comments/1ojnsyz/meta_google_and_microsoft_triple_down_on_ai/"},{"title":"What's going on with the dislike of Ubuntu/Canonical?","url":"https://www.reddit.com/r/linux/comments/1ojn5oz/whats_going_on_with_the_dislike_of_ubuntucanonical/","date":1761788681,"author":"/u/megaslash288","guid":321043,"unread":true,"content":"<p>Basically the title. I have been using Ubuntu Cinnamon for awhile for both school and home use (gaming, programming, vr, game dev, etc) and it seems to be a very well maintained, functional, and stable distro with good support through .deb packages for printers n such, and the apt repository seems well checked and stable. It also seems to have good peripheral drivers built in. Seemed a little silly for it to not include flatpack by default but thats easily fixed. Overall though, I am still a relative newcomer to Linux and haven't been in the community that much until recently, so I am a lil out of the loop.</p>","contentLength":614,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"John Carmack on updating variables","url":"https://x.com/ID_AA_Carmack/status/1983593511703474196#m","date":1761787969,"author":"/u/levodelellis","guid":321097,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ojmwd9/john_carmack_on_updating_variables/"},{"title":"Do you know what really happens when you run kubectl apply?","url":"https://medium.com/integr8me/what-happens-when-you-run-kubectl-apply-ce3bfb5e61c4","date":1761786192,"author":"/u/fabioluciano","guid":321029,"unread":true,"content":"<p>Recently, while working on the documentation about best practices for building solutions with , I came across some topics that, despite being fundamental, usually receive little attention when we talk about Kubernetes.</p><p>These topics seemed so interesting to me that I decided to turn them into a series of articles — and this is the first one.</p><p>To start, I want to ask you a simple question:</p><blockquote><p><em>Do you know exactly what happens when you run </em><strong><em>kubectl apply -f manifest.yaml</em></strong></p></blockquote><p>It might seem like a trivial action, but behind this command lies a well-structured process, divided into three major stages: , , and .</p><p>In fact, the topic that most sparked my interest was the  process, but it’s impossible to fully understand it without first going through the other two. These three components work together and form the foundation for all Kubernetes security and access control.</p><p>Despite seeming simple, each of these elements — , , and  — is highly configurable and full of nuances. Understanding how they connect helps not only to solve day-to-day problems but also to create more secure and elegant solutions.</p><p>Let’s start by understanding :</p><p>When a user executes the command <strong>kubectl apply -f manifest.yaml</strong>, the request’s journey begins like this:</p><ol><li>: Kubernetes identifies  is making the call.</li><li>: The system checks  this person (or service) has permission to perform the operation.</li><li>: The resource sent is analyzed, validated, and in some cases, modified before being stored in .</li></ol><p>Only after these three steps is the change effectively applied to the cluster.</p><p>Now that we have an overview, let’s dive into each of these processes, starting with Authentication.</p><p>If you’ve been working with Kubernetes for some time, you probably know that every interaction made with  ends up reaching the , which is the heart of the cluster.</p><p>It works similarly to a : each command is translated into an HTTP request containing information about the desired resource, the type of operation, and who is making the call.</p><p>We can observe this message exchange in real-time by enabling the verbosity flag on , with .</p><p>The higher the number, the more details are displayed. For example:</p><p>Let’s break down what is being displayed in the output of the command  👇</p><p>1️⃣  This is where everything begins.  received the  command and, thanks to the  flag, is displaying internal details of its communication with the API Server. This verbosity level shows, among other things, which configurations are being loaded and which HTTP requests are being made.</p><p>2️⃣ <strong>Configuration file loaded</strong> reports that it loaded the credentials and context from the  file. This file contains the information that identifies , <strong>which cluster is being accessed</strong>, and <strong>how to authenticate to it</strong> (for example, via token, certificate, or OIDC provider).</p><p>3️⃣ <strong>Request sent to the API Server</strong> Here we see  transforming the  command into an  to the endpoint:</p><pre></pre><p>This is te moment when the call truly “leaves your terminal” and reaches Kubernetes. The request header (headers) includes authentication information (such as tokens), the expected response format (), and the  which indicates the  version.</p><p>4️⃣  The API Server processes the request, authenticates the user, checks if they have permission (authorization), and, if everything is correct, returns the result with the  status. Following this, we see the list of Pods in the  namespace, indicating that the request was accepted and completed successfully.</p><p>Authentication is, therefore, the first filter: it defines <strong>who the user or service is</strong> that is trying to interact with the cluster.</p><p>This identification can happen in several ways — such as via certificates, service tokens, identity providers (OIDC), or even custom plugins.</p><p>After the user or service is authenticated, the next step is to verify <strong>what they can do within the cluster</strong>. This is the role of .</p><p>While authentication answers the question , authorization answers “.</p><p>And this decision is always made by the API Server, before the request proceeds.</p><p>Kubernetes offers different , and each has its purpose. The most common are:</p><ul><li><strong>RBAC (Role-Based Access Control)</strong> — the most used. Defines permissions based on roles and links these roles to users, groups, or service accounts.</li><li><strong>ABAC (Attribute-Based Access Control)</strong> — uses attributes defined in JSON policies, allowing for more flexible but less practical rules to manage.</li><li> — forwards the decision to an external service, ideal for integrations with corporate authentication systems.</li><li> and / — used in very specific cases (the first for internal node authentication and the second generally for testing).</li></ul><p>In practice,  is the most common model, as it is simple and integrated into the Kubernetes ecosystem.</p><pre></pre><p>In this example, the user  can  in the  namespace, but cannot create, delete, or modify any.</p><p>With RBAC configured, the API Server consults these rules whenever a request arrives.</p><p>If the user tries to do something outside the assigned permissions, they will receive a  error — and the process is interrupted even before reaching the  stage.</p><p>If authentication identifies the user and authorization confirms they can perform the action, the  process is the moment when Kubernetes <strong>analyzes and modifies what will be created or changed</strong> before it goes to the database ().</p><p>This is where one of the most powerful parts of Kubernetes comes in: the .</p><p>Think of them as “doormen” who inspect everything entering the cluster. They can , , or even  resources before Kubernetes accepts the operation.</p><p>There are two main types:</p><ul><li><strong>Validating Admission Controllers</strong> — analyze the request and decide whether it is valid or not.</li><li><strong>Mutating Admission Controllers</strong> — can alter the request before it is persisted.</li></ul><p>A practical example: imagine your company wants to ensure that <strong>every Pod has a label indicating the responsible team</strong>.</p><p>An Admission Controller can automatically reject any Pod that does not have this label, or even add the missing label (in the case of a mutating controller).</p><p>Kubernetes already comes with several ready-made Admission Controllers — such as , , , among others — , but it is also possible to create your own using .</p><p>A , for example, can intercept the creation of a Pod and automatically inject sidecars (such as a logging, metrics, or security container) (hello ).</p><p>This type of automation is widely used by tools like , , and various  that manage custom resources.</p><p>A simplified flow would look like this:</p><p>Note that the admission process is the <strong>last step before the resource is written</strong>.</p><p>This means that any modification made at this point is the last opportunity to adjust, validate, or reinforce security and compliance policies.</p><p>The next time you run a simple , remember everything that happens behind the scenes:</p><ul><li>Kubernetes first <strong>checks who you are (Authentication)</strong>,</li><li>then <strong>verifies what you can do (Authorization)</strong>,</li><li>and finally <strong>analyzes and adjusts what you are trying to create (Admission)</strong>.</li></ul><p>These three processes are the foundation of all cluster security and governance.</p><p>Understanding them is essential not only for those who administer Kubernetes but also for those who develop solutions that interact with it — such as sidecars, operators, or custom webhooks.</p><p>In the next articles in the series, I will explore each of these components in greater depth, bringing practical examples, use cases, and even some curiosities that are rarely covered in the official documentation.</p>","contentLength":7367,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/kubernetes/comments/1ojm9i9/do_you_know_what_really_happens_when_you_run/"},{"title":"Exclusive: OpenAI lays groundwork for juggernaut IPO at up to $1 trillion valuation","url":"https://www.reuters.com/business/openai-lays-groundwork-juggernaut-ipo-up-1-trillion-valuation-2025-10-29/","date":1761784265,"author":"/u/esporx","guid":322094,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/artificial/comments/1ojlkru/exclusive_openai_lays_groundwork_for_juggernaut/"},{"title":"Kubernetes Podcast episode 262: GKE 10 Year Anniversary, with Gari Singh","url":"https://www.reddit.com/r/kubernetes/comments/1ojkuho/kubernetes_podcast_episode_262_gke_10_year/","date":1761782331,"author":"/u/kubernetespodcast","guid":320996,"unread":true,"content":"<div><p>Google Kubernetes Engine (GKE) recently celebrated its 10th anniversary! 🎉 In our latest podcast episode, we talk with GKE Product Manager Gari Singh to reflect on GKE's journey over the last decade.</p><ul><li> From the early days of complex container orchestration to today's 'one-click' production clusters powered by Autopilot, and the continuous effort to simplify infrastructure management.</li><li> How GKE supports demanding AI workloads and the exciting potential of leveraging AI  Kubernetes, enabling smarter, more autonomous operations and enhanced observability.</li><li> Gary's favorite features, including In-Place Pod Resizing (IPPR) and Container Optimized Compute, which are crucial for dynamic scaling and efficiency.</li></ul></div>   submitted by   <a href=\"https://www.reddit.com/user/kubernetespodcast\"> /u/kubernetespodcast </a>","contentLength":749,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Increase Performance when sending struct accross HTTP / TCP","url":"https://www.reddit.com/r/golang/comments/1ojktka/increase_performance_when_sending_struct_accross/","date":1761782261,"author":"/u/D4kzy","guid":321932,"unread":true,"content":"<p>I have a client and a server that talk HTTP (sometimes raw TCP).</p><p>On the client I define a struct that has a string field, a []string field and a []byte field.</p><p>I define the same struct server side.</p><p>I want to send this instantiated struct from the client to the server.</p><p>What I did till now is use the json marshall to send the data as a json through the Conn.</p><p>I have slight performance issues and I thing it is coming from here. My guess is that when I marshal and unmarshal with json, the []byte field of my struct is base64 encoded. When []byte is big this is adding around 33% overhead.</p><p>To avoid this I thought about GZIP, but I am afraid the GZIP computation time will result in even poorer perf.</p><p>What way to send data do you suggest to have best speed (sending a lot of HTTP request) ?</p>","contentLength":781,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"How To Be A Linux-Based Graphic Designer","url":"https://www.youtube.com/watch?v=sVztMTafuLA","date":1761777915,"author":"/u/yoor_thiziri","guid":320973,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/linux/comments/1ojj3gg/how_to_be_a_linuxbased_graphic_designer/"},{"title":"Go 1.25 includes a new experimental garbage collector, Green Tea","url":"https://go.dev/blog/greenteagc","date":1761776849,"author":"/u/x021","guid":320975,"unread":true,"content":"<p>Go 1.25 includes a new experimental garbage collector called Green Tea,\navailable by setting  at build time.\nMany workloads spend around 10% less time in the garbage collector, but some\nworkloads see a reduction of up to 40%!</p><p>It’s production-ready and already in use at Google, so we encourage you to\ntry it out.\nWe know some workloads don’t benefit as much, or even at all, so your feedback\nis crucial to helping us move forward.\nBased on the data we have now, we plan to make it the default in Go 1.26.</p><p>What follows is a blog post based on Michael Knyszek’s GopherCon 2025 talk.\nWe’ll update this blog post with a link to the talk once it’s available online.</p><h2>Tracing garbage collection</h2><p>Before we discuss Green Tea let’s get us all on the same page about garbage\ncollection.</p><p>The purpose of garbage collection is to automatically reclaim and reuse memory\nno longer used by the program.</p><p>To this end, the Go garbage collector concerns itself with  and\n.</p><p>In the context of the Go runtime,  are Go values whose underlying\nmemory is allocated from the heap.\nHeap objects are created when the Go compiler can’t figure out how else to allocate\nmemory for a value.\nFor example, the following code snippet allocates a single heap object: the backing\nstore for a slice of pointers.</p><pre><code>var x = make([]*int, 10) // global\n</code></pre><p>The Go compiler can’t allocate the slice backing store anywhere except the heap,\nsince it’s very hard, and maybe even impossible, for it to know how long  will\nrefer to the object for.</p><p> are just numbers that indicate the location of a Go value in memory,\nand they’re how a Go program references objects.\nFor example, to get the pointer to the beginning of the object allocated in the\nlast code snippet, we can write:</p><p>Go’s garbage collector follows a strategy broadly referred to as <em>tracing garbage\ncollection</em>, which just means that the garbage collector follows, or traces, the\npointers in the program to identify which objects the program is still using.</p><p>More specifically, the Go garbage collector implements the mark-sweep algorithm.\nThis is much simpler than it sounds.\nImagine objects and pointers as a sort of graph, in the computer science sense.\nObjects are nodes, pointers are edges.</p><p>The mark-sweep algorithm operates on this graph, and as the name might suggest,\nproceeds in two phases.</p><p>In the first phase, the mark phase, it walks the object graph from well-defined\nsource edges called .\nThink global and local variables.\nThen, it  everything it finds along the way as , to avoid going in\ncircles.\nThis is analogous to your typical graph flood algorithm, like a depth-first or\nbreadth-first search.</p><p>Next is the sweep phase.\nWhatever objects were not visited in our graph walk are unused, or ,\nby the program.\nWe call this state unreachable because it is impossible with normal safe Go code\nto access that memory anymore, simply through the semantics of the language.\nTo complete the sweep phase, the algorithm simply iterates through all the\nunvisited nodes and marks their memory as free, so the memory allocator can reuse\nit.</p><p>You may think I’m oversimplifying a bit here.\nGarbage collectors are frequently referred to as , and .\nAnd you’d be partially right, there are more complexities.</p><p>For example, this algorithm is, in practice, executed concurrently with your\nregular Go code.\nWalking a graph that’s mutating underneath you brings challenges.\nWe also parallelize this algorithm, which is a detail that’ll come up again\nlater.</p><p>But trust me when I tell you that these details are mostly separate from the\ncore algorithm.\nIt really is just a simple graph flood at the center.</p><p>Let’s walk through an example.\nNavigate through the slideshow below to follow along.</p><p>After all that, I think we have a handle on what the Go garbage collector is actually doing.\nThis process seems to work well enough today, so what’s the problem?</p><p>Well, it turns out we can spend  of time executing this particular algorithm in some\nprograms, and it adds substantial overhead to nearly every Go program.\nIt’s not that uncommon to see Go programs spending 20% or more of their CPU time in the\ngarbage collector.</p><p>Let’s break down where that time is being spent.</p><p>At a high level, there are two parts to the cost of the garbage collector.\nThe first is how often it runs, and the second is how much work it does each time it runs.\nMultiply those two together, and you get the total cost of the garbage collector.</p><figure><figcaption>\n    Total GC cost = Number of GC cycles × Average cost per GC cycle\n    </figcaption></figure><p>But for now let’s focus only on the second part, the cost per cycle.</p><p>From years of poring over CPU profiles to try to improve performance, we know two big things\nabout Go’s garbage collector.</p><p>The first is that about 90% of the cost of the garbage collector is spent marking,\nand only about 10% is sweeping.\nSweeping turns out to be much easier to optimize than marking,\nand Go has had a very efficient sweeper for many years.</p><p>The second is that, of that time spent marking, a substantial portion, usually at least 35%, is\nsimply spent  on accessing heap memory.\nThis is bad enough on its own, but it completely gums up the works on what makes modern CPUs\nactually fast.</p><h3>“A microarchitectural disaster”</h3><p>What does “gum up the works” mean in this context?\nThe specifics of modern CPUs can get pretty complicated, so let’s use an analogy.</p><p>Imagine the CPU driving down a road, where that road is your program.\nThe CPU wants to ramp up to a high speed, and to do that it needs to be able to see far ahead of it,\nand the way needs to be clear.\nBut the graph flood algorithm is like driving through city streets for the CPU.\nThe CPU can’t see around corners and it can’t predict what’s going to happen next.\nTo make progress, it constantly has to slow down to make turns, stop at traffic lights, and avoid\npedestrians.\nIt hardly matters how fast your engine is because you never get a chance to get going.</p><p>Let’s make that more concrete by looking at our example again.\nI’ve overlaid the heap here with the path that we took.\nEach left-to-right arrow represents a piece of scanning work that we did\nand the dashed arrows show how we jumped around between bits of scanning work.</p><p>Notice that we were jumping all over memory doing tiny bits of work in each place.\nIn particular, we’re frequently jumping between pages, and between different parts of pages.</p><p>Modern CPUs do a lot of caching.\nGoing to main memory can be up to 100x slower than accessing memory that’s in our cache.\nCPU caches are populated with memory that’s been recently accessed, and memory that’s nearby to\nrecently accessed memory.\nBut there’s no guarantee that any two objects that point to each other will  be close to each\nother in memory.\nThe graph flood doesn’t take this into account.</p><p>Quick side note: if we were just stalling fetches to main memory, it might not be so bad.\nCPUs issue memory requests asynchronously, so even slow ones could overlap if the CPU could see\nfar enough ahead.\nBut in the graph flood, every bit of work is small, unpredictable, and highly dependent on the\nlast, so the CPU is forced to wait on nearly every individual memory fetch.</p><p>And unfortunately for us, this problem is only getting worse.\nThere’s an adage in the industry of “wait two years and your code will get faster.”</p><p>But Go, as a garbage collected language that relies on the mark-sweep algorithm, risks the opposite.\n“Wait two years and your code will get slower.”\nThe trends in modern CPU hardware are creating new challenges for garbage collector performance:</p><p><strong>Non-uniform memory access.</strong>\nFor one, memory now tends to be associated with subsets of CPU cores.\nAccesses by  CPU cores to that memory are slower than before.\nIn other words, the cost of a main memory access <a href=\"https://jprahman.substack.com/p/sapphire-rapids-core-to-core-latency\" rel=\"noreferrer\" target=\"_blank\">depends on which CPU core is accessing\nit</a>.\nIt’s non-uniform, so we call this non-uniform memory access, or NUMA for short.</p><p><strong>Reduced memory bandwidth.</strong>\nAvailable memory bandwidth per CPU is trending downward over time.\nThis just means that while we have more CPU cores, each core can submit relatively fewer\nrequests to main memory, forcing non-cached requests to wait longer than before.</p><p>\nAbove, we looked at a sequential marking algorithm, but the real garbage collector performs this\nalgorithm in parallel.\nThis scales well to a limited number of CPU cores, but the shared queue of objects to scan becomes\na bottleneck, even with careful design.</p><p><strong>Modern hardware features.</strong>\nNew hardware has fancy features like vector instructions, which let us operate on a lot of data at once.\nWhile this has the potential for big speedups, it’s not immediately clear how to make that work for\nmarking because marking does so much irregular and often small pieces of work.</p><p>Finally, this brings us to Green Tea, our new approach to the mark-sweep algorithm.\nThe key idea behind Green Tea is astonishingly simple:</p><p><em>Work with pages, not objects.</em></p><p>Sounds trivial, right?\nAnd yet, it took a lot of work to figure out how to order the object graph walk and what we needed to\ntrack to make this work well in practice.</p><p>More concretely, this means:</p><ul><li>Instead of scanning objects we scan whole pages.</li><li>Instead of tracking objects on our work list, we track whole pages.</li><li>We still need to mark objects at the end of the day, but we’ll track marked objects locally to each\npage, rather than across the whole heap.</li></ul><p>Let’s see what this means in practice by looking at our example heap again, but this time\nrunning Green Tea instead of the straightforward graph flood.</p><p>As above, navigate through the annotated slideshow to follow along.</p><p>Let’s come back around to our driving analogy.\nAre we finally getting on the highway?</p><p>Let’s recall our graph flood picture before.</p><p>We jumped around a whole lot, doing little bits of work in different places.\nThe path taken by Green Tea looks very different.</p><p>Green Tea, in contrast, makes fewer, longer left-to-right passes over pages A and B.\nThe longer these arrows, the better, and with bigger heaps, this effect can be much stronger.\n the magic of Green Tea.</p><p>It’s also our opportunity to ride the highway.</p><p>This all adds up to a better fit with the microarchitecture.\nWe can now scan objects closer together with much higher probability, so\nthere’s a better chance we can make use of our caches and avoid main memory.\nLikewise, per-page metadata is more likely to be in cache.\nTracking pages instead of objects means work lists are smaller,\nand less pressure on work lists means less contention and fewer CPU stalls.</p><p>And speaking of the highway, we can take our metaphorical engine into gears we’ve never been able to\nbefore, since now we can use vector hardware!</p><p>If you’re only vaguely familiar with vector hardware, you might be confused as to how we can use it here.\nBut besides the usual arithmetic and trigonometric operations,\nrecent vector hardware supports two things that are valuable for Green Tea:\nvery wide registers, and sophisticated bit-wise operations.</p><p>Most modern x86 CPUs support AVX-512, which has 512-bit wide vector registers.\nThis is wide enough to hold all of the metadata for an entire page in just two registers,\nright on the CPU, enabling Green Tea to work on an entire page in just a few straight-line\ninstructions.\nVector hardware has long supported basic bit-wise operations on whole vector registers, but starting\nwith AMD Zen 4 and Intel Ice Lake, it also supports a new bit vector “Swiss army knife” instruction\nthat enables a key step of the Green Tea scanning process to be done in just a few CPU cycles.\nTogether, these allow us to turbo-charge the Green Tea scan loop.</p><p>This wasn’t even an option for the graph flood, where we’d be jumping between scanning objects that\nare all sorts of different sizes.\nSometimes you needed two bits of metadata and sometimes you needed ten thousand.\nThere simply wasn’t enough predictability or regularity to use vector hardware.</p><p>If you want to nerd out on some of the details, read along!\nOtherwise, feel free to skip ahead to the <a href=\"https://go.dev/blog/greenteagc#evaluation\">evaluation</a>.</p><p>To get a sense of what AVX-512 GC scanning looks like, take a look at the diagram below.</p><p>There’s a lot going on here and we could probably fill an entire blog post just on how this works.\nFor now, let’s just break it down at a high level:</p><ol><li><p>First we fetch the “seen” and “scanned” bits for a page.\nRecall, these are one bit per object in the page, and all objects in a page have the same size.</p></li><li><p>Next, we compare the two bit sets.\nTheir union becomes the new “scanned” bits, while their difference is the “active objects” bitmap,\nwhich tells us which objects we need to scan in this pass over the page (versus previous passes).</p></li><li><p>We take the difference of the bitmaps and “expand” it, so that instead of one bit per object,\nwe have one bit per word (8 bytes) of the page.\nWe call this the “active words” bitmap.\nFor example, if the page stores 6-word (48-byte) objects, each bit in the active objects bitmap\nwill be copied to 6 bits in the active words bitmap.\nLike so:</p></li></ol><figure><div> → <pre>000000 000000 111111 111111 ...</pre></div></figure><ol start=\"4\"><li><p>Next we fetch the pointer/scalar bitmap for the page.\nHere, too, each bit corresponds to a word (8 bytes) of the page, and it tells us whether that word\nstores a pointer.\nThis data is managed by the memory allocator.</p></li><li><p>Now, we take the intersection of the pointer/scalar bitmap and the active words bitmap.\nThe result is the “active pointer bitmap”: a bitmap that tells us the location of every\npointer in the entire page contained in any live object we haven’t scanned yet.</p></li><li><p>Finally, we can iterate over the memory of the page and collect all the pointers.\nLogically, we iterate over each set bit in the active pointer bitmap,\nload the pointer value at that word, and write it back to a buffer that\nwill later be used to mark objects seen and add pages to the work list.\nUsing vector instructions, we’re able to do this 64 bytes at a time,\nin just a couple instructions.</p></li></ol><p>Part of what makes this fast is the  instruction,\npart of the “Galois Field New Instructions” x86 extension,\nand the bit manipulation Swiss army knife we referred to above.\nIt’s the real star of the show, since it lets us do step (3) in the scanning kernel very, very\nefficiently.\nIt performs a bit-wise <a href=\"https://en.wikipedia.org/wiki/Affine_transformation\" rel=\"noreferrer\" target=\"_blank\">affine\ntransformations</a>,\ntreating each byte in a vector as itself a mathematical vector of 8 bits\nand multiplying it by an 8x8 bit matrix.\nThis is all done over the <a href=\"https://en.wikipedia.org/wiki/Finite_field\" rel=\"noreferrer\" target=\"_blank\">Galois field</a>,\nwhich just means multiplication is AND and addition is XOR.\nThe upshot of this is that we can define a few 8x8 bit matrices for each\nobject size that perform exactly the 1:n bit expansion we need.</p><p>For the full assembly code, see <a href=\"https://cs.opensource.google/go/go/+/master:src/internal/runtime/gc/scan/scan_amd64.s;l=23;drc=041f564b3e6fa3f4af13a01b94db14c1ee8a42e0\" rel=\"noreferrer\" target=\"_blank\">this\nfile</a>.\nThe “expanders” use different matrices and different permutations for each size class,\nso they’re in a <a href=\"https://cs.opensource.google/go/go/+/master:src/internal/runtime/gc/scan/expand_amd64.s;drc=041f564b3e6fa3f4af13a01b94db14c1ee8a42e0\" rel=\"noreferrer\" target=\"_blank\">separate file</a>\nthat’s written by a <a href=\"https://cs.opensource.google/go/go/+/master:src/internal/runtime/gc/scan/mkasm.go;drc=041f564b3e6fa3f4af13a01b94db14c1ee8a42e0\" rel=\"noreferrer\" target=\"_blank\">code generator</a>.\nAside from the expansion functions, it’s really not a lot of code.\nMost of it is dramatically simplified by the fact that we can perform most of the above\noperations on data that sits purely in registers.\nAnd, hopefully soon this assembly code <a href=\"https://go.dev/issue/73787\">will be replaced with Go code</a>!</p><p>Credit to Austin Clements for devising this process.\nIt’s incredibly cool, and incredibly fast!</p><p>So that’s it for how it works.\nHow much does it actually help?</p><p>It can be quite a lot.\nEven without the vector enhancements, we see reductions in garbage collection CPU costs\nbetween 10% and 40% in our benchmark suite.\nFor example, if an application spends 10% of its time in the garbage collector, then that\nwould translate to between a 1% and 4% overall CPU reduction, depending on the specifics of\nthe workload.\nA 10% reduction in garbage collection CPU time is roughly the modal improvement.\n(See the <a href=\"https://go.dev/issue/73581\">GitHub issue</a> for some of these details.)</p><p>We’ve rolled Green Tea out inside Google, and we see similar results at scale.</p><p>We’re still rolling out the vector enhancements,\nbut benchmarks and early results suggest this will net an additional 10% GC CPU reduction.</p><p>While most workloads benefit to some degree, there are some that don’t.</p><p>Green Tea is based on the hypothesis that we can accumulate enough objects to scan on a\nsingle page in one pass to counteract the costs of the accumulation process.\nThis is clearly the case if the heap has a very regular structure: objects of the same size at a\nsimilar depth in the object graph.\nBut there are some workloads that often require us to scan only a single object per page at a time.\nThis is potentially worse than the graph flood because we might be doing more work than before while\ntrying to accumulate objects on pages and failing.</p><p>The implementation of Green Tea has a special case for pages that have only a single object to scan.\nThis helps reduce regressions, but doesn’t completely eliminate them.</p><p>However, it takes a lot less per-page accumulation to outperform the graph flood\nthan you might expect.\nOne surprise result of this work was that scanning a mere 2% of a page at a time\ncan yield improvements over the graph flood.</p><p>Green Tea is already available as an experiment in the recent Go 1.25 release and can be enabled\nby setting the environment variable  to  at build time.\nThis doesn’t include the aforementioned vector acceleration.</p><p>We expect to make it the default garbage collector in Go 1.26, but you’ll still be able to opt-out\nwith <code>GOEXPERIMENT=nogreenteagc</code> at build time.\nGo 1.26 will also add vector acceleration on newer x86 hardware, and include a whole bunch of\ntweaks and improvements based on feedback we’ve collected so far.</p><p>If you can, we encourage you to try at Go tip-of-tree!\nIf you prefer to use Go 1.25, we’d still love your feedback.\nSee <a href=\"https://go.dev/issue/73581#issuecomment-2847696497\">this GitHub\ncomment</a> with some details on\nwhat diagnostics we’d be interested in seeing, if you can share, and the preferred channels for\nreporting feedback.</p><p>Before we wrap up this blog post, let’s take a moment to talk about the journey that got us here.\nThe human element of the technology.</p><p>The core of Green Tea may seem like a single, simple idea.\nLike the spark of inspiration that just one single person had.</p><p>But that’s not true at all.\nGreen Tea is the result of work and ideas from many people over several years.\nSeveral people on the Go team contributed to the ideas, including Michael Pratt, Cherry Mui, David\nChase, and Keith Randall.\nMicroarchitectural insights from Yves Vandriessche, who was at Intel at the time, also really helped\ndirect the design exploration.\nThere were a lot of ideas that didn’t work, and there were a lot of details that needed figuring out.\nJust to make this single, simple idea viable.</p><p>The seeds of this idea go all the way back to 2018.\nWhat’s funny is that everyone on the team thinks someone else thought of this initial idea.</p><p>Green Tea got its name in 2024 when Austin worked out a prototype of an earlier version while cafe\ncrawling in Japan and drinking LOTS of matcha!\nThis prototype showed that the core idea of Green Tea was viable.\nAnd from there we were off to the races.</p><p>Throughout 2025, as Michael implemented and productionized Green Tea, the ideas evolved and changed even\nfurther.</p><p>This took so much collaborative exploration because Green Tea is not just an algorithm, but an entire\ndesign space.\nOne that we don’t think any of us could’ve navigated alone.\nIt’s not enough to just have the idea, but you need to figure out the details and prove it.\nAnd now that we’ve done it, we can finally iterate.</p><p>The future of Green Tea is bright.</p><p>Once again, please try it out by setting  and let us know how it goes!\nWe’re really excited about this work and want to hear from you!</p>","contentLength":19499,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1ojio0t/go_125_includes_a_new_experimental_garbage/"},{"title":"[R] Researchers from the Center for AI Safety and Scale AI have released the Remote Labor Index (RLI), a benchmark testing AI agents on 240 real-world freelance jobs across 23 domains.","url":"https://www.reddit.com/r/MachineLearning/comments/1ojinwl/r_researchers_from_the_center_for_ai_safety_and/","date":1761776841,"author":"/u/michael-lethal_ai","guid":321030,"unread":true,"content":"<p>They find current AI agents have low but steadily improving performance. The best-performing agent (Manus) successfully completed 2.5% of projects, earning $1,720 out of a possible $143,991. However, newer models consistently perform better than older ones, indicating measurable advancement toward automating remote work.</p>","contentLength":322,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["reddit"]}