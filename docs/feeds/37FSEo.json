{"id":"37FSEo","title":"Rust","displayTitle":"Rust","url":"","feedLink":"","isQuery":true,"isEmpty":false,"isHidden":false,"itemCount":29,"items":[{"title":"Optimizing Rust Compilation: Smaller, Faster, or Both?","url":"https://dev.to/leapcell/optimizing-rust-compilation-smaller-faster-or-both-16pe","date":1740298736,"author":"Leapcell","guid":9510,"unread":true,"content":"<p>You have completed writing a Rust project and are now working on compilation. How can you make the compiled file as small as possible? How can you make it run as fast as possible? Or how can you achieve both small size and high speed?</p><p>You may have these considerations:</p><ul><li>: Suitable for embedded development, where the project is small and not complex, and execution speed is already fast. The main goal is to reduce the file size as much as possible.</li><li><strong>Maximizing execution speed</strong>: Suitable for network services where file size is not a concern, but maximizing concurrency is the top priority.</li><li><strong>Balancing both size and speed</strong>: A middle ground that is suitable for various types of projects.</li></ul><p>You only need to add the following configuration to your  file and run:</p><h3>\n  \n  \n  Generate a Smaller Executable\n</h3><div><pre><code></code></pre></div><h3>\n  \n  \n  Generate a Faster Executable\n</h3><div><pre><code></code></pre></div><h3>\n  \n  \n  Balance Between Size and Speed\n</h3><div><pre><code></code></pre></div><h2>\n  \n  \n  Explanation of Configurations\n</h2><p>: Specifies the level of compiler optimizations.</p><ul><li>: No optimization, fastest compilation time.</li><li>: Optimize for faster compilation.</li><li>: Balance between compilation speed and runtime performance (default).</li><li>: Optimize for maximum runtime performance.</li><li>: Optimize for smaller code size.</li><li>: Further optimize for code size, more aggressively than .</li></ul><p>: Use  to generate the smallest executable; use  to generate the fastest executable.</p><p>: Enables Link Time Optimization (LTO).</p><ul><li>: Disable LTO (default).</li><li>: Enable the most aggressive LTO.</li></ul><p>: Enabling LTO reduces binary size and improves runtime performance.  is a moderate choice, while  provides the best optimization but increases compilation time.</p><p>: Controls the number of code generation units.</p><p>: Usually . Setting it to  enables the highest level of optimization.</p><p>: Reducing the number of code generation units gives the compiler more information for global optimizations, resulting in a smaller and faster executable. Setting it to  maximizes optimization but increases compilation time.</p><p>: Controls panic behavior.</p><ul><li>: Unwind the stack (default).</li><li>: Directly abort the process.</li></ul><p>: Using  reduces the executable size and improves performance in some cases since it eliminates the need for stack unwinding information.</p><p>: Controls which debug and symbol information is removed.</p><ul><li>: Keep all information (default).</li><li>: Remove debug information.</li><li>: Remove symbol tables but retain necessary debug information.</li><li>: Remove all optional information, including debug and symbol data.</li></ul><p>: Removing unnecessary debug and symbol information significantly reduces executable size.</p><p>These are the optimization techniques for compiling a Rust project. Have you mastered them?</p><p><a href=\"https://leapcell.io/?lc_t=d_rustbuildoptim\" rel=\"noopener noreferrer\">Leapcell</a> is the Next-Gen Serverless Platform for Web Hosting, Async Tasks, and Redis:</p><ul><li>Develop with Node.js, Python, Go, or Rust.</li></ul><p><strong>Deploy unlimited projects for free</strong></p><ul><li>pay only for usage — no requests, no charges.</li></ul><p><strong>Unbeatable Cost Efficiency</strong></p><ul><li>Pay-as-you-go with no idle charges.</li><li>Example: $25 supports 6.94M requests at a 60ms average response time.</li></ul><p><strong>Streamlined Developer Experience</strong></p><ul><li>Intuitive UI for effortless setup.</li><li>Fully automated CI/CD pipelines and GitOps integration.</li><li>Real-time metrics and logging for actionable insights.</li></ul><p><strong>Effortless Scalability and High Performance</strong></p><ul><li>Auto-scaling to handle high concurrency with ease.</li><li>Zero operational overhead — just focus on building.</li></ul>","contentLength":3225,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Rust, ROS, and dynamic typing https://open.substack.com/pub/intrepidai/p/rust-ros-and-dynamic-typing?r=7n2a9&utm_campaign=post&utm_medium=web&showWelcomeOnShare=false","url":"https://dev.to/fgadaleta/rust-ros-and-dynamic-typing-42n9","date":1740296161,"author":"frag","guid":9489,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Streaming SQL in Stateful DataFlows","url":"https://dev.to/debadyuti/streaming-sql-in-stateful-dataflows-3jng","date":1740263855,"author":"Deb","guid":9372,"unread":true,"content":"<h2>\n  \n  \n  Streaming SQL Functionality\n</h2><p>SQL Streaming Queries and Stream Processing Operations is released in Stateful DataFlow Beta 7 running on Fluvio 0.15.2</p><p><strong>With SQL Streaming on Stateful DataFlow you can:</strong></p><ul><li>Run ad-hoc queries on saved state objects and materialized views based live event streams.</li><li>Use SQL queries to run stream processing operations in data flows.</li></ul><p>For those who are not aware of Fluvio or Stateful DataFlow yet:</p><p>Stateful DataFlow - Stream processing layer built on Fluvio built using the wasm component model.</p><h2>\n  \n  \n  SQL: From Static Tables to Streaming Data\n</h2><p>Remember when SQL was the only way to talk to your data? It wasn't just a query language - it was  query language. But its story goes deeper than syntax.</p><h3>\n  \n  \n  The Universal Language of Data\n</h3><p>Just as merchants in medieval Mediterranean ports needed a shared language to trade (that's where \"lingua franca\" came from), the tech world needed SQL to make data accessible across different systems and teams.</p><p>If you're in a room with a DBA, a data analyst, and a business analyst. What's the one language they all speak? Likely SQL.</p><div><pre><code></code></pre></div><p>Look familiar? Whether you're running Oracle, Postgres, or MySQL, this just works. Well sort of!</p><p>Three key factors made SQL a long-term utility that stood the test of time:</p><ol><li><p>\nInstead of telling machines HOW to get data, you just say WHAT you want. <code>SELECT * FROM users WHERE status = 'active'</code> reads almost like English.</p></li><li><p>\nFrom startups to Fortune 500s, SQL skills travel. Write once, run anywhere - from healthcare to fintech.</p></li><li><p>\nNeed to analyze sales data? Track user behavior? SQL's got you covered, backed by decades of tooling and optimization.</p></li></ol><p>In a world of Artificial Intelligence, Web3, and global markets, event streaming is no longer a luxury - it's a basic need. Ask yourself:</p><ul><li>Is your application combining data from multiple sources in real-time?</li><li>Are your customers happy with stale insights?</li><li>Do you need fresh data on demand?</li></ul><h3>\n  \n  \n  Bridging Static and Streaming\n</h3><p>What if you could use familiar SQL syntax for real-time data processing? What if your team could leverage their existing SQL skills for stream processing?</p><p>We've been exploring these questions and implementing solutions that bring SQL's simplicity to streaming data. Want to see how? Check out the full article where we dive into:</p><ul><li>Practical examples using NY Transit data</li><li>Real-world streaming SQL queries in action</li><li>How to implement stream processing without learning a new language</li></ul>","contentLength":2437,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"HN: cypher queries tips (Graph dbms)","url":"https://dev.to/falkordb/hn-cypher-queries-tips-graph-dbms-hck","date":1740062774,"author":"Dan Shalev","guid":7239,"unread":true,"content":"<p>Writing performant Cypher queries isn’t just about syntax—it’s about understanding graph structures, optimizing query paths, and leveraging advanced features. At FalkorDB, we’ve seen how poorly optimized queries can bottleneck even the most robust systems.</p><p>Most devs don’t realize inefficient Cypher queries often stem from broad MATCH patterns and missing indexes. </p>","contentLength":375,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Deep Dive into Rust Structs: A Comprehensive Guide","url":"https://dev.to/sajiram_a4704bc095/deep-dive-into-rust-structs-a-comprehensive-guide-956","date":1740052988,"author":"Sajiron","guid":7174,"unread":true,"content":"<p>Structs in Rust are essential for organizing and managing complex data structures efficiently. This guide covers regular, tuple, and unit-like structs, along with advanced features such as generics, associated functions, lifetimes, and struct update syntax. Learn how to create structured, readable, and reusable Rust code with practical examples and best practices.</p>","contentLength":366,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Announcing Rust 1.85.0 and Rust 2024","url":"https://blog.rust-lang.org/2025/02/20/Rust-1.85.0.html","date":1740009600,"author":"The Rust Release Team","guid":7312,"unread":true,"content":"<p>The Rust team is happy to announce a new version of Rust, 1.85.0. This stabilizes the 2024 edition as well.\nRust is a programming language empowering everyone to build reliable and efficient software.</p><p>If you have a previous version of Rust installed via , you can get 1.85.0 with:</p><p>If you'd like to help us out by testing future releases, you might consider updating locally to use the beta channel () or the nightly channel (). Please <a href=\"https://github.com/rust-lang/rust/issues/new/choose\">report</a> any bugs you might come across!</p><p>We are excited to announce that the Rust 2024 Edition is now stable!\nEditions are a mechanism for opt-in changes that may otherwise pose a backwards compatibility risk. See <a href=\"https://doc.rust-lang.org/edition-guide/editions/index.html\">the edition guide</a> for details on how this is achieved, and detailed instructions on how to migrate.</p><p>This is the largest edition we have released. The <a href=\"https://doc.rust-lang.org/edition-guide/rust-2024/index.html\">edition guide</a> contains detailed information about each change, but as a summary, here are all the changes:</p><p>The guide includes migration instructions for all new features, and in general\n<a href=\"https://doc.rust-lang.org/edition-guide/editions/transitioning-an-existing-project-to-a-new-edition.html\">transitioning an existing project to a new edition</a>.\nIn many cases  can automate the necessary changes. You may even find that no changes in your code are needed at all for 2024!</p><p>Note that automatic fixes via  are very conservative to avoid ever changing the semantics of your code. In many cases you may wish to keep your code the same and use the new semantics of Rust 2024; for instance, continuing to use the  macro matcher, and ignoring the conversions of conditionals because you want the new 2024 drop order semantics. The result of  should not be considered a recommendation, just a conservative conversion that preserves behavior.</p><p> people came together to create this edition. We'd like to thank them all for their hard work!</p><p>Rust now supports asynchronous closures like  which return futures when called. This works like an  which can also capture values from the local environment, just like the difference between regular closures and functions. This also comes with 3 analogous traits in the standard library prelude: , , and .</p><p>In some cases, you could already approximate this with a regular closure and an asynchronous block, like . However, the future returned by such an inner block is not able to borrow from the closure captures, but this does work with  closures:</p><pre><code>let mut vec: Vec&lt;String&gt; = vec![];\n\nlet closure = async || {\n    vec.push(ready(String::from(\"\")).await);\n};\n</code></pre><p>It also has not been possible to properly express higher-ranked function signatures with the  traits returning a , but you can write this with the  traits:</p><pre><code>use core::future::Future;\nasync fn f&lt;Fut&gt;(_: impl for&lt;'a&gt; Fn(&amp;'a u8) -&gt; Fut)\nwhere\n    Fut: Future&lt;Output = ()&gt;,\n{ todo!() }\n\nasync fn f2(_: impl for&lt;'a&gt; AsyncFn(&amp;'a u8))\n{ todo!() }\n\nasync fn main() {\n    async fn g(_: &amp;u8) { todo!() }\n    f(g).await;\n    //~^ ERROR mismatched types\n    //~| ERROR one type is more general than the other\n\n    f2(g).await; // ok!\n}\n</code></pre><h3><a href=\"https://blog.rust-lang.org/2025/02/20/Rust-1.85.0.html#hiding-trait-implementations-from-diagnostics\" aria-hidden=\"true\"></a>Hiding trait implementations from diagnostics</h3><p>The new <code>#[diagnostic::do_not_recommend]</code> attribute is a hint to the compiler to not show the annotated trait implementation as part of a diagnostic message. For library authors, this is a way to keep the compiler from making suggestions that may be unhelpful or misleading. For example:</p><pre><code>pub trait Foo {}\npub trait Bar {}\n\nimpl&lt;T: Foo&gt; Bar for T {}\n\nstruct MyType;\n\nfn main() {\n    let _object: &amp;dyn Bar = &amp;MyType;\n}\n</code></pre><pre><code>error[E0277]: the trait bound `MyType: Bar` is not satisfied\n --&gt; src/main.rs:9:29\n  |\n9 |     let _object: &amp;dyn Bar = &amp;MyType;\n  |                             ^^^^ the trait `Foo` is not implemented for `MyType`\n  |\nnote: required for `MyType` to implement `Bar`\n --&gt; src/main.rs:4:14\n  |\n4 | impl&lt;T: Foo&gt; Bar for T {}\n  |         ---  ^^^     ^\n  |         |\n  |         unsatisfied trait bound introduced here\n  = note: required for the cast from `&amp;MyType` to `&amp;dyn Bar`\n</code></pre><p>For some APIs, it might make good sense for you to implement , and get  indirectly by that blanket implementation. For others, it might be expected that most users should implement  directly, so that  suggestion is a red herring. In that case, adding the diagnostic hint will change the error message like so:</p><pre><code>#[diagnostic::do_not_recommend]\nimpl&lt;T: Foo&gt; Bar for T {}\n</code></pre><pre><code>error[E0277]: the trait bound `MyType: Bar` is not satisfied\n  --&gt; src/main.rs:10:29\n   |\n10 |     let _object: &amp;dyn Bar = &amp;MyType;\n   |                             ^^^^ the trait `Bar` is not implemented for `MyType`\n   |\n   = note: required for the cast from `&amp;MyType` to `&amp;dyn Bar`\n</code></pre><h3><a href=\"https://blog.rust-lang.org/2025/02/20/Rust-1.85.0.html#fromiterator-and-extend-for-tuples\" aria-hidden=\"true\"></a> and  for tuples</h3><p>Earlier versions of Rust implemented convenience traits for iterators of  tuple pairs to behave like , with  in 1.56 and  in 1.79. These have now been  to more tuple lengths, from singleton  through to 12 items long, . For example, you can now use  to fanout into multiple collections at once:</p><pre><code>use std::collections::{LinkedList, VecDeque};\nfn main() {\n    let (squares, cubes, tesseracts): (Vec&lt;_&gt;, VecDeque&lt;_&gt;, LinkedList&lt;_&gt;) =\n        (0i32..10).map(|i| (i * i, i.pow(3), i.pow(4))).collect();\n    println!(\"{squares:?}\");\n    println!(\"{cubes:?}\");\n    println!(\"{tesseracts:?}\");\n}\n</code></pre><pre><code>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n[0, 1, 8, 27, 64, 125, 216, 343, 512, 729]\n[0, 1, 16, 81, 256, 625, 1296, 2401, 4096, 6561]\n</code></pre><h3><a href=\"https://blog.rust-lang.org/2025/02/20/Rust-1.85.0.html#updates-to-stdenvhome_dir\" aria-hidden=\"true\"></a>Updates to </h3><p> has been deprecated for years, because it can give surprising results in some Windows configurations if the  environment variable is set (which is not the normal configuration on Windows). We had previously avoided changing its behavior, out of concern for compatibility with code depending on this non-standard configuration. Given how long this function has been deprecated, we're now updating its behavior as a bug fix, and a subsequent release will remove the deprecation for this function.</p><p>These APIs are now stable in const contexts</p><p>Many people came together to create Rust 1.85.0. We couldn't have done it without all of you. <a href=\"https://thanks.rust-lang.org/rust/1.85.0/\">Thanks!</a></p>","contentLength":5852,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Languages in the Linux kernel","url":"https://dev.to/cies/languages-in-the-linux-kernel-43bf","date":1740002782,"author":"Cies Breijs","guid":6085,"unread":true,"content":"<p>The Linux kernel it written in many languages, but at the time of writing (2025) the main language of the project is C, clocking in at 98% (from <a href=\"https://github.com/torvalds/linux\" rel=\"noopener noreferrer\">github.com/torvalds/linux</a> on 2025-02-19):</p><p>I believe the only language —or more correct \"language family\"— in the Linux kernel that will always be there is Assembly. At some point you need to write code, without any abstraction, directly for the hardware. Assembly is just that.</p><h2>\n  \n  \n  Allowing C++ in the kernel\n</h2><p>I believe Linus was right to reject C++ for the following reaons:</p><ol><li>C++ is a gigantic language, allowing it would create an endless discussion on which of its features would be allowed/forbidden,</li><li>being a loose superset of C it has the same archaic syntax, thus little improvement to the developer experience, and</li><li>no matter how many features would be allowed C++ does not improve enough on C to offset the cost of porting it.</li></ol><p>In recent year one thing became clear: C is no longer the best tool for the job. It's still the best understood tool, especially by the current team. It's what 98% of the Linux kernel is written in today. But the \"unchallenged best\" status it used to have for so many years in pragmatic kernel development is shaky.</p><p>Better languages have come up, specifically <a href=\"https://en.wikipedia.org/wiki/Zig_(programming_language)\" rel=\"noopener noreferrer\">Zig</a> and <a href=\"https://en.wikipedia.org/wiki/Rust_(programming_language)\" rel=\"noopener noreferrer\">Rust</a>.</p><p>There has been a lot of discussion on allowing Rust in the kernel. But since the main honchos, Linus and Greg Kroah-Hartman, have put their weight behind it, it is clear that Rust will find it's way into the project. We still have to wait and see how much of the project will be written in Rust.</p><p>Unlike C++, Rust has lots of features that are very useful in kernel development, and very few features that would need to be forbidden. Especially features related to memory safety, which constitute a <a href=\"https://lore.kernel.org/rust-for-linux/2025021954-flaccid-pucker-f7d9@gregkh\" rel=\"noopener noreferrer\">large part of the bugs in Linux</a>. Compared to C, Rust provides much a improved developer experience, which is not weird considering Rust is 40 younger.</p><p>Rust's main downside is: slower compile times. Compile times matter very much, but so does safety. While this is a hard trade-off, the decision seems to be final: Rust is to stay in the Linux kernel.</p><p>I expect Zig will come from another angle. The Zig compiler compiles C as well as Zig code. It's just a matter of time before the Zig compiler will be able to compile the Linux kernel. Once this is achieved, C-files can be ported to Zig one-by-one. I expect LLMs will help a great deal with the initial port of the Linux kernel's C code to Zig. Once in Zig, the code can be optimized by humans.</p><p>Zig is very similar to C. This makes the initial port rather straight forward. LLMs will perform much better on C-to-Zig than on C-to-Rust. </p><p>Compared to C, Zig brings serious improvements in the developer experience at similar-to-C compile times. Features like  are really cool and may allow the kernel project to do away with lots of crufty old C preprocessor macros on the one side, while allowing for interesting optimizations on the other.</p><p>I expect we will have a Linux kernel in Zig, Rust and Assembly in 10 years. It may be a fork. It may be the Linux mainline: it all depends on the open-mindedness of the main devs.</p><p>So far they seem up for it!</p>","contentLength":3140,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"How I Built a Local LLM-Powered File Reorganizer in Rust","url":"https://dev.to/__87e2e207/how-i-built-a-local-llm-powered-file-reorganizer-in-rust-1bip","date":1739978429,"author":"Евгений Перминов","guid":5881,"unread":true,"content":"<p>Some time ago, I decided to dive into Rust —this must be my  attempt. I’d tried learning it before, but each time I either got swamped by the borrow checker or got sidetracked by other projects. This time, I wanted a small,  project to force myself to stick with Rust. The result is <a href=\"https://github.com/PerminovEugene/messy-folder-reorganizer-ai/tree/main\" rel=\"noopener noreferrer\">messy-folder-reorganizer-ai</a>, a command-line tool for file organization powered by a local LLM.</p><h2>\n  \n  \n  The Inspiration: A Bloated Downloads Folder\n</h2><p>The main motivation was my messy  folder, which often ballooned to hundreds of files—images, documents, installers—essentially chaos. Instead of manually sorting through them, I thought, “Why not let an AI propose a structure?”</p><p>While brainstorming, I stumbled upon the possibility of running LLMs , like Ollama or other self-hosted frameworks. I loved the idea of  my data to some cloud service. So I decided to build a Rust-based CLI that  a local LLM server for suggestions on how to reorganize my folders.</p><h2>\n  \n  \n  Challenges: LLM &amp; Large Folders\n</h2><ul><li> I started using , but the responses didn’t follow prompt instructions well, so I switched to , which performed much better.\n</li><li> When testing on folders with many files, the model began forgetting the beginning of the prompt and stopped following instructions properly. Increasing  (which defines the model’s context size) helped partially, but the model still struggles with .\n</li><li><ul><li> Split the file list into smaller chunks and send multiple prompts.\n</li><li> If you’re an LLM expert—especially with local models like Ollama—I’d love advice on how to handle larger sets without hitting memory or context limits.</li></ul></li></ul><ul><li> Specify the local LLM endpoint, model name, or other model options.\n</li><li> Tweak the AI prompt to fine-tune how the model interprets your folder’s contents.\n</li><li> The tool shows you the proposed structure and asks for confirmation before reorganizing any files.</li></ul><ul><li> I’d love code feedback — best practices, performance tips, or suggestions on how to structure the CLI.\n</li><li> Any advice on optimizing local model inference for large file sets or advanced chunking strategies would be invaluable.</li></ul><p>This project has been a great way to re-learn some Rust features and experiment with local AI solutions. While it works decently for medium-sized folders, there’s plenty of room to grow. If this concept resonates with you—maybe your Downloads folder is as messy as mine—give it a try, open an issue, or contribute a pull request.</p><p><p>\nFeel free to reach out on the </p><a href=\"https://github.com/PerminovEugene/messy-folder-reorganizer-ai/issues\" rel=\"noopener noreferrer\">GitHub issues page</a>, or drop me a note if you have any thoughts, suggestions, or just want to talk about Rust and AI!</p>","contentLength":2560,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"How I Built a Local LLM-Powered File Reorganizer with Rust","url":"https://dev.to/evgeniiperminov/how-i-built-a-local-llm-powered-file-reorganizer-in-rust-1bip","date":1739978429,"author":"Evgenii Perminov","guid":5914,"unread":true,"content":"<p>Some time ago, I decided to dive into Rust —this must be my  attempt. I’d tried learning it before, but each time I either got swamped by the borrow checker or got sidetracked by other projects. This time, I wanted a small,  project to force myself to stick with Rust. The result is <a href=\"https://github.com/PerminovEugene/messy-folder-reorganizer-ai/tree/main\" rel=\"noopener noreferrer\">messy-folder-reorganizer-ai</a>, a command-line tool for file organization powered by a local LLM.</p><h2>\n  \n  \n  The Inspiration: A Bloated Downloads Folder\n</h2><p>The main motivation was my messy  folder, which often ballooned to hundreds of files—images, documents, installers—essentially chaos. Instead of manually sorting through them, I thought, “Why not let an AI propose a structure?”</p><p>While brainstorming, I stumbled upon the possibility of running LLMs , like Ollama or other self-hosted frameworks. I loved the idea of  my data to some cloud service. So I decided to build a Rust-based CLI that  a local LLM server for suggestions on how to reorganize my folders.</p><h2>\n  \n  \n  Challenges: LLM &amp; Large Folders\n</h2><ul><li> I started using , but the responses didn’t follow prompt instructions well, so I switched to , which performed much better.\n</li><li> When testing on folders with many files, the model began forgetting the beginning of the prompt and stopped following instructions properly. Increasing  (which defines the model’s context size) helped partially, but the model still struggles with .\n</li><li><ul><li> Split the file list into smaller chunks and send multiple prompts.\n</li><li> If you’re an LLM expert—especially with local models like Ollama—I’d love advice on how to handle larger sets without hitting memory or context limits.</li></ul></li></ul><ul><li> Specify the local LLM endpoint, model name, or other model options.\n</li><li> Tweak the AI prompt to fine-tune how the model interprets your folder’s contents.\n</li><li> The tool shows you the proposed structure and asks for confirmation before reorganizing any files.</li></ul><ul><li> I’d love code feedback — best practices, performance tips, or suggestions on how to structure the CLI.\n</li><li> Any advice on optimizing local model inference for large file sets or advanced chunking strategies would be invaluable.</li></ul><p>This project has been a great way to re-learn some Rust features and experiment with local AI solutions. While it works decently for medium-sized folders, there’s plenty of room to grow. If this concept resonates with you—maybe your Downloads folder is as messy as mine—give it a try, open an issue, or contribute a pull request.</p><p><p>\nFeel free to reach out on the </p><a href=\"https://github.com/PerminovEugene/messy-folder-reorganizer-ai/issues\" rel=\"noopener noreferrer\">GitHub issues page</a>, or drop me a note if you have any thoughts, suggestions, or just want to talk about Rust and AI!</p>","contentLength":2560,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Building CSV RAG with Rig and Rust 🔥🔥🔥","url":"https://dev.to/josh_mo_91f294fcef0333006/building-csv-rag-with-rig-and-rust-2bpi","date":1739974434,"author":"Josh Mo","guid":5853,"unread":true,"content":"<p>In this article, we're going to look at how you can use the <a href=\"https://github.com/0xplaygrounds/rig\" rel=\"noopener noreferrer\"></a> Rust AI framework to create an application that is able to load a CSV file, embed it into a vector store and have an LLM answer questions based on provided context from our vector store. We'll serve the application in the form of a command-line tool.</p><p>Retrieval-Augmented Generation (RAG) is a technique that combines the power of information retrieval with the generative capabilities of large language models (LLMs). The process typically involves two main components: retrieving relevant knowledge from a pre-existing database or knowledge base and generating contextually accurate answers based on that information. When a question or query is posed, the model first retrieves relevant snippets or pieces of information from the knowledge base. It then augments its generative model with this newly acquired knowledge, enabling it to provide a more accurate, informed response.</p><p>In contrast to traditional LLMs that rely purely on their trained parameters, RAG systems dynamically incorporate external data, ensuring that responses are grounded in factual and up-to-date knowledge. When a question is asked, the relevant knowledge from a pre-existing dataset is retrieved and fed into the model. The LLM then generates an answer that combines the retrieved information and its generative abilities, aiming to offer a detailed and accurate response. This hybrid approach allows RAG models to provide answers that are not only linguistically fluent but also well-supported by factual data.</p><p>Next, you'll need to create a new project using :</p><div><pre><code></code></pre></div><p>Before we start, let's add the relevant dependencies which we need:</p><div><pre><code>cargo add serde rig-core tokio csv \nserde/derive,tokio/macros,tokio/rt-multi-thread\n</code></pre></div><p>This adds the following dependencies:</p><ul><li> - The rig library.</li><li> - an asynchronous Rust runtime. We additionally add the  and  feature as we want to use the macro.</li><li> - The Rust crate for using CSVs.</li></ul><p>Before we do anything else, we'll need to declare our struct type as well as derive the correct macros for it. Note that the embedding trait for Rig also depends on  (which also depends on ), hence the derivation.</p><div><pre><code></code></pre></div><p>Next to be able to use Rig's embeddings API, we need to implement the  trait. This trait simply defines a method for what to embed. Because we don't have a singular field we want to embed and will need the whole record, we can simply just implement  for the struct then format the whole struct into a string (which we can then embed).</p><div><pre><code></code></pre></div><p>Thankfully, embedding our CSV is actually quite easy now that we've done the hard part. We can create an OpenAI client and get the embedding model, then iterate through each record and build an embedding from it and store it in Rig's in-memory vector store.</p><p>You can see below the code to generate an OpenAI client is fairly simple:</p><div><pre><code></code></pre></div><p>We'll also keep the code for loading the CSV in as a separate function as it's relatively long.</p><div><pre><code></code></pre></div><p>The next step will be to actually take input from the user and prompt the LLM using not only the prompt, but additional (relevant!) snippets from the vector store. </p><p>We'll start by taking some input from standard input (i.e., you load up the application in the terminal, then you type in something and press Enter). We then check if the prompt is equal to  - if it is then immediately break the loop and close the application, if not, carry on and retrieve a response from the LLM.</p><div><pre><code></code></pre></div><p>In terms of storing your conversation history, it is actually quite simple to do so. All you need to do is to create a  and then feed it into the agent, using the  function instead of . You then add a user message and assistant message (in that order) at the end of the loop iteration. This allows you to build up a conversation with the LLM.</p><p>Additionally, we'll also add a  command which allows the entire conversation to be wiped should the user want to ask the LLM about something else.</p><div><pre><code></code></pre></div><p>Now that we've set up a base for your command-line tool, here are a few ways you can extend this demo to do much more than just simple ragging:</p><ul><li>What about semantic routing to make sure your LLM stays on track?</li><li>Try incorporating CSV RAG into a new, bigger pipeline!</li></ul><p>Thanks for reading! Hopefully you will have a good example of how to improve how you work with data by creating a RAG pipeline from your CSV.</p>","contentLength":4278,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Master Rust’s Ownership & Borrowing System 🚀","url":"https://dev.to/sajiram_a4704bc095/master-rusts-ownership-borrowing-system-cp2","date":1739967118,"author":"Sajiron","guid":5782,"unread":true,"content":"<p>Rust’s Ownership &amp; Borrowing system is one of its most powerful features, ensuring memory safety without a garbage collector. In this guide, we break down:</p><p>✅ How ownership works and why it matters\n✅ The difference between mutable &amp; immutable references<p>\n✅ How lifetimes prevent dangling references</p></p>","contentLength":303,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"This Week in Rust 587","url":"https://this-week-in-rust.org/blog/2025/02/19/this-week-in-rust-587/","date":1739941200,"author":"TWiR Contributors","guid":6156,"unread":true,"content":"<p>This week's crate is <a href=\"https://crates.io/crates/httpmock\">httpmock</a>, which is quite unsurprisingly a HTTP mocking library for Rust.</p><p>An important step for RFC implementation is for people to experiment with the\nimplementation and give feedback, especially before stabilization.  The following\nRFCs would benefit from user testing before moving forward:</p><ul><li><em>No calls for testing were issued this week.</em></li></ul><ul><li><em>No calls for testing were issued this week.</em></li></ul><ul><li><em>No calls for testing were issued this week.</em></li></ul><p>If you are a feature implementer and would like your RFC to appear on the above list, add the new \nlabel to your RFC along with a comment providing testing instructions and/or guidance on which aspect(s) of the feature\nneed testing.</p><p>Always wanted to contribute to open-source projects but did not know where to start?\nEvery week we highlight some tasks from the Rust community for you to pick and get started!</p><p>Some of these tasks may also have mentors available, visit the task page for more information.</p><p>Are you a new or experienced speaker looking for a place to share something cool? This section highlights events that are being planned and are accepting submissions to join their event as a speaker.</p><p>This week's results were dominated by the update to LLVM 20 (<a href=\"https://github.com/rust-lang/rust/pull/135763\">#135763</a>),\nwhich brought a large number of performance improvements, as usually. There were also two other\nsignificant improvements, caused by improving the representation of  values (<a href=\"https://github.com/rust-lang/rust/pull/136593\">#136593</a>) and doing less work when formatting in  (<a href=\"https://github.com/rust-lang/rust/pull/136828\">#136828</a>).</p><table><thead><tr></tr></thead><tbody><tr></tr><tr></tr><tr></tr><tr><td align=\"center\">Improvements ✅  (secondary)</td></tr><tr></tr></tbody></table><p>3 Regressions, 2 Improvements, 4 Mixed; 4 of them in rollups\n50 artifact comparisons made in total</p><p>Every week, <a href=\"https://www.rust-lang.org/team.html\">the team</a> announces the 'final comment period' for RFCs and key PRs\nwhich are reaching a decision. Express your opinions now.</p><ul><li><em>No RFCs entered Final Comment Period this week.</em></li></ul><ul><li><em>No Cargo Tracking Issues or PRs entered Final Comment Period this week.</em></li></ul><ul><li><em>No Language Team Proposals entered Final Comment Period this week.</em></li></ul><ul><li><em>No Language Reference RFCs entered Final Comment Period this week.</em></li></ul><ul><li><em>No Unsafe Code Guideline Tracking Issues or PRs entered Final Comment Period this week.</em></li></ul><p>Rusty Events between 2025-02-19 - 2025-03-19 🦀</p><p>If you are running a Rust event please add it to the <a href=\"https://www.google.com/calendar/embed?src=apd9vmbc22egenmtu5l6c5jbfc%40group.calendar.google.com\">calendar</a> to get\nit mentioned here. Please remember to add a link to the event too.\nEmail the <a href=\"mailto:community-team@rust-lang.org\">Rust Community Team</a> for access.</p><blockquote><p>I have found that many automated code review tools, including LLMs, catch 10 out of 3 bugs.</p></blockquote><p>Despite a lamentable lack of suggestions, llogiq is properly pleased with his choice.</p>","contentLength":2447,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"I created a CLI-Music Player in Rust!","url":"https://dev.to/paradoxy/i-created-a-cli-music-player-in-rust-5a3f","date":1739919121,"author":"Ojalla","guid":4455,"unread":true,"content":"<p>I built a  that allows users to play, pause, stop, and manage their music files directly from the terminal. It supports basic playback controls, volume adjustment, and song listing.</p><p>This walkthrough will cover:</p><ul><li>How the music player was implemented</li><li>How to run the application</li><li>A guide on available commands</li></ul><p>I used the following Rust crates:</p><ol><li> – For command-line argument parsing.</li><li> – For colored terminal output.</li><li> – For audio playback.</li><li> – To handle  for graceful exit.</li></ol><div><pre><code>cargo add clap colored rodio ctrlc\n</code></pre></div><h2><strong>How the CLI Music Player Works</strong></h2><p>The music player follows a command-line workflow where users can:</p><ul><li>Load songs from a specified directory.</li><li>Play, pause, resume, stop playback.</li></ul><h3><strong>1. Command-Line Interface (CLI) Configuration</strong></h3><p>The application uses  to handle command-line arguments. Users must specify a music directory:</p><div><pre><code></code></pre></div><p>This ensures that users provide a valid music directory or request help using .</p><p>The player reads user commands in a loop:</p><div><pre><code></code></pre></div><p>This function displays a colored prompt and waits for user input.</p><h3><strong>3. Implementing the Music Player</strong></h3><p>I created a  struct to store the player’s state:</p><div><pre><code></code></pre></div><ul><li>The audio sink and output stream ().</li><li>The directory containing music files.</li><li>The current playing song and status.</li></ul><h3><strong>4. Loading Songs from a Directory</strong></h3><p>When the application starts, it loads music files from the given directory:</p><div><pre><code></code></pre></div><p>This function reads all files in the specified directory and maps them to numbers for easy selection.</p><p>To play a song, the application reads the file, decodes it, and plays it using :</p><div><pre><code></code></pre></div><ul><li>Stops any currently playing track.</li><li>Loads and decodes the selected song.</li></ul><h3><strong>6. Implementing Playback Controls</strong></h3><p>The player handles commands like play, pause, resume, stop, and volume adjustment:</p><div><pre><code></code></pre></div><p>These functions control playback using  methods like , , , and .</p><h3><strong>7. Displaying Available Songs</strong></h3><p>Users can list all available songs:</p><div><pre><code></code></pre></div><div><pre><code>git clone https://github.com/Parado-xy/rust-cli-music-player\nrust-cli-music-player\n</code></pre></div><ol><li>Run the application with a music directory:\n</li></ol><div><pre><code>cargo run  /path/to/music\n</code></pre></div><ol><li>Use the available commands:\n</li></ol><div><pre><code>play &lt;number&gt;    \npause            \nresume           \nstop             \nvolume &lt;0.0-1.0&gt; \nlist             \nstatus           </code></pre></div><p>This Rust CLI Music Player is a simple but powerful terminal-based music player. It utilizes  for audio playback,  for argument parsing, and  for improved UI. Future improvements could include playlist support and file format filtering.</p>","contentLength":2324,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Automating Data Classification with Stof","url":"https://dev.to/amelia_wampler_e7aa93dab9/automating-data-classification-with-stof-afo","date":1739909058,"author":"Amelia Wampler","guid":4414,"unread":true,"content":"<p>Data classification is a crucial step in organizing and utilizing information effectively, especially in AI-driven applications. With Stof, developers can seamlessly classify and structure incoming data using built-in schema functions. In this example, we’ll walk through how Stof can automatically assign color classifications to t-shirt records based on hex values or color names.</p><h2>\n  \n  \n  The Problem: Identifying T-Shirt Colors\n</h2><p>Imagine you're processing product data, and a t-shirt record comes in with only a single color field. This value could be a color name or a hex code, but to make it useful for AI models or analytics, you need a standardized classification.</p><h2>\n  \n  \n  The Stof Solution: Schema-Based Classification\n</h2><p>Using Stof’s schema and schemify functions, we can dynamically classify colors as data flows in. Here’s how it works:</p><ul><li><strong>Preloading a Color Dataset</strong> – A comprehensive list of color names and their corresponding hex values is stored efficiently in a compiled binary format.</li><li> – A function converts hex codes into RGB values to find the closest matching color in our dataset.</li><li><strong>Applying Meta-Code for Classification</strong> – As each t-shirt record is processed, Stof automatically assigns a standardized color name based on the closest RGB match. If a name is provided instead of a hex value, it appends the corresponding hex code instead.</li></ul><p>Running this through Stof’s CLI (or embedding it in an application) demonstrates its efficiency. Given a hex code, Stof finds the closest color match and updates the record. For example:</p><ul><li> Hex Code for Light Blue → Output: \"Aquamarine\"</li><li> \"Lime\" → Output: Hex Code for Lime Green</li></ul><p>This logic runs efficiently via WebAssembly, making it highly performant across different environments.</p><p>With Stof, data classification happens in real-time, reducing the need for extra processing logic in applications. This approach enhances AI readiness, improves data consistency, and simplifies the developer experience—all while ensuring data remains structured and searchable.</p><p>This is just one example of how Stof can automate data structuring and classification. Whether you’re handling product data, AI training sets, or dynamic records, Stof streamlines data governance and accessibility. Read more in our Docs and visit our Github to start contributing. </p>","contentLength":2303,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Online events: Rust in English (Feb 18-Feb 28)","url":"https://dev.to/szabgab/online-events-rust-in-english-feb-18-feb-28-454i","date":1739902721,"author":"Gabor Szabo","guid":4346,"unread":true,"content":"<p>I found the following Rust in English-related online events for the next 10 days.</p><p>Online events remove the physical limitation of who can participate. What remain are the time-zone differences and the language barrier. In order to make it easier for you to find events that match those constraints I started to collect the <a href=\"https://events.code-maven.com/\" rel=\"noopener noreferrer\">online events</a> where you can filter by topic and time. Above I took the events and included the starting time in a few selected time-zones. I hope it makes it easier to find an event that is relevant to you. The data and the code generating the pages are all on <a href=\"https://github.com/szabgab/events/\" rel=\"noopener noreferrer\">GitHub</a>. Share your ideas on how to improve the listings to help you more.</p>","contentLength":656,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"My first Aya program","url":"https://dev.to/littlejo/my-first-aya-program-2j0p","date":1739870243,"author":"Joseph Ligier","guid":4056,"unread":true,"content":"<p>I'm getting started with eBPF programming with Aya. The idea behind this series of articles is to get you started too.</p><p>In this section, we'll create our first Aya program. We'll also see that there are different types of eBPF programs.</p><h2>\n  \n  \n  Example of Hello world Program\n</h2><p>I assume you have an operating environment as defined in <a href=\"https://dev.to/littlejo/lets-introduce-ebpf-and-aya-40ji\">Part 1</a>. You can also follow this step-by-step lab on creating an Aya program:</p><p>To generate an Aya program, we'll use cargo generate :</p><div><pre><code>cargo generate https://github.com/aya-rs/aya-template\n</code></pre></div><p>We're going to answer a few questions:</p><ul><li>: the name of the project (I put )</li><li>The second question is more interesting:</li></ul><p>In fact, there are different types of eBPF programs. As we saw in <a href=\"https://dev.to/littlejo/lets-introduce-ebpf-and-aya-40ji\">Part 1</a>, I wrote that there are 3 types of eBPF software:</p><ul><li>Observability and Tracing</li></ul><p>The choices presented to generate the eBPF program are, in fact, parts of the Linux kernel that can be modified or supervised by eBPF. So you need to think carefully about this before jumping headlong into programming.</p><p>As I wrote in Part 1, Aya is not yet fully mature compared with other solutions. Here's one reason why: although it may seem as if there are already a lot of program types available, there are still quite a few missing:</p><p>What's more, as the Linux kernel continues to evolve, there will certainly be other types of eBPF programs available in the near future.</p><p>I tested a few types of eBPF program with Aya before writing this article. To study each type, you can quickly spend days: \"I don't understand, it doesn't work\" is certainly the phrase I'm uttering the most at the moment. There aren't many similarities between eBPF program types. If you've already played with  programs, you'll have other problems with  programs, for example. For this article, we'll be looking at  eBPF programs.</p><p>Tracepoints are, as the name suggests, places in the Linux code that have been marked (see <a href=\"https://docs.kernel.org/trace/tracepoints.html\" rel=\"noopener noreferrer\">recommendations</a>). They are mainly used for tracing and debugging the Linux kernel.</p><p>All these points are accessible in the <code>/sys/kernel/debug/tracing/available_events</code> file:</p><p>Just in time, this is the supplementary question we ask:</p><p>We're going to choose  because everyone knows what a syscall is. Does everyone?</p><p>When a program is run, it asks the kernel to perform primary functions called syscalls (system calls).</p><p>To view the syscalls performed when a command is run, you can use the strace program. For example, you can use:</p><p>To find available tracepoint names, simply issue this command:</p><div><pre><code>grep syscalls: /sys/kernel/debug/tracing/available_events\n</code></pre></div><p>We can see that they are of the : <code>sys_(enter|exit)_$name_of_syscall</code></p><ul><li>&nbsp;: starting of syscall</li></ul><p>We'll arbitrarily choose , which is the syscall that executes a program and the one that starts the . So we have .</p><p>Now we're going to test the generated program directly:</p><div><pre><code>cd test-aya\nRUST_LOG=info cargo run\n</code></pre></div><p>This will take a little while: the time it takes to download and compile all the dependencies. Now you can go and have <a href=\"https://a-cup-of.coffee/\" rel=\"noopener noreferrer\">a cup of coffee</a>!</p><p>Once your program has been demarched, run commands on another terminal, e.g.: \nOn the  terminal, you'll see the following message every time you type a command:</p><div><pre><code>[INFO test_aya] tracepoint sys_enter_execve called\n</code></pre></div><p>So every time the syscall  is called, this message will be displayed. We've just created the \"Hello World\" of the Tracepoint eBPF program (). So, for an eBPF program to start up, it needs an event () that tells it to run: this is what we call a .</p><h2>\n  \n  \n  Anatomy of a Hello world Aya program\n</h2><p>Let's take a look at what the  command has generated. As we saw in part 1, there are two parts to an eBPF program: kernel space and user space.</p><p>The eBPF program source code can be found here: <code>test-aya-ebpf/src/main.rs</code>. It is compiled first.\nHere are its contents:</p><div><pre><code></code></pre></div><p>If you've been following part 1, there's one thing that should already shock you about Rust code: there is no  function. This is a prerequisite for writing an eBPF program. To overcome this problem, we use the notation: </p><p>Another more disturbing prerequisite is that the standard library (std) is forbidden. Only the core library and all libraries that use it are allowed. This means you can't use the  macro. To tell Rust not to use the standard: </p><p>But then how are we going to display anything if  isn't possible? That's where Aya comes to the rescue: \nThis library can be used to display messages if the  environment variable is set. It also includes , ,  and  (see <a href=\"https://docs.rs/aya-log/latest/aya_log/\" rel=\"noopener noreferrer\">documentation</a>).\nThanks to this library, you can display :<code>info!(&amp;ctx, \"tracepoint sys_enter_execve called\");</code></p><p>We're going to discard this part of the program:</p><div><pre><code></code></pre></div><p>Don't panic! We'll never change it. It's the code that makes the program work.\nAll that's left is to explain :</p><div><pre><code></code></pre></div><p>Two  libraries are used, including one for the tracepoint macro:</p><div><pre><code></code></pre></div><p>In other words, we're going to create an eBPF tracepoint program with the function .</p><p>The  keyword is to say that the function is public; it's not really “important”, it's just to make the Aya framework work. If we remove these unwanted elements:</p><div><pre><code></code></pre></div><p>We're back to a few things we've already seen in part 1.\nThings to remember:</p><ul><li>the  function is attached to the  program.</li><li>All the work will be done in the  function.</li><li>: this is the context variable that will enable us to go beyond a  program.</li></ul><p>As you can see, there's no mention of  for the moment. I want this Tracepoint program to be attached to an  syscall. Good timing: let's take a look at the user-space code now.</p><p>In this article, we won't be modifying the user space code. It can be found in this file: .\nI'll simplify its code for a better understanding:</p><div><pre><code></code></pre></div><p>This Rust code is a little more traditional: you can use the standard library, as evidenced by the  and the  function.\nI've commented out the important parts of the code with numbers:</p><ul><li>1: We'll load the previously compiled eBPF code into an ebpf variable</li><li>2: We'll start displaying the eBPF logs (for example, the  from the previous code) in the user space</li><li>3: Convert the main function of the eBPF code into  code</li><li>4: Load the main program function (the  function)</li><li>5: Attach it to the tracepoint <em>syscalls:sys_enter_execve</em></li></ul><p>The rest of the code is for program operation, such as not quitting the program before the logs start.</p><p>If you're new to Rust, there are certainly some parts of the code that may seem obscure to you. That's a good thing! The next section is dedicated to Rust.</p><h2>\n  \n  \n  Rust, it's getting complicated!\n</h2><p>Before modifying the code, I think it's worth reviewing the Rust language a little more theoretically. I didn't want to scare you too much in part 1 😃</p><p>In Part 1, we looked at variable declaration and modification. But we didn't talk much about types. This is important because, for example, all functions must be filled in with the various types.\nThere are two types:</p><ul></ul><p>Let's take a look at scalar types: for integers, for example, we can define very precisely how many bits they are encoded in:</p><p>It's often optional to declare the variable with its type, but to remove any ambiguity, we do it this way:</p><p>With , you can display the contents in a different way, for example, you can convert to hexadecimal:</p><div><pre><code></code></pre></div><p>That's the magic of the macro! There's also this kind of possibility with  in Aya. For example, you can convert a number into an  or  address: very useful for eBPF networking.</p><p>Let's finish with scalar types and talk about , i.e. modifying the type. Let's take a look at this example:</p><div><pre><code></code></pre></div><p>This program won't work because the arguments require u32 and not u16. It is of course possible to change the function directly, but you don't always have access to the function as you would in a library. How do I change the code? Use the keyword :</p><div><pre><code></code></pre></div><p>Now let's talk about compound types, for example how to represent integer arrays:</p><div><pre><code></code></pre></div><p>An array has a fixed number of entries: you can't add a number after the fact. There are also dynamic arrays in Rust, such as . However, eBPF programs (on the kernel side) cannot use them: they require arrays with a number of entries already defined before compilation. The strategy is therefore to evaluate the maximum number an array can have by filling it with 0.</p><div><pre><code></code></pre></div><p>The default string in Rust is an array (a slice, to be precise - I'll get a slap on the wrist if I don't) with a fixed number of  entries (and therefore ). It is not, as in other programming languages, an array of characters (). The notation is .</p><p>Thus, it's not possible to concatenate in this way:</p><div><pre><code></code></pre></div><p>However, if we convert  to , it works:</p><div><pre><code></code></pre></div><p> is the equivalent of . This makes it possible to have arrays of  dynamically.</p><p> are a mixture of different types. The keyword is . For example, to create a simple role-playing game :</p><div><pre><code></code></pre></div><p>If you find initialization a little complicated, you can create methods with the  keyword:</p><div><pre><code></code></pre></div><p>As you can see, thanks to the structures, the programming language reads almost naturally. In a way, it's like an object language.\nTo give you a more realistic example, take a look at the code generated in the user area above:</p><div><pre><code></code></pre></div><p>What can be deduced from the doc, the approximate code:</p><div><pre><code></code></pre></div><p>Previously, we had to cast to have the same type:</p><div><pre><code></code></pre></div><p>Using generic function, we don't need to cast:</p><div><pre><code></code></pre></div><p>This way, you won't have to think about which type you need to use the addition function.\nThe function is inevitably a little more complicated to write. We won't be writing any in this section. But for use via a library, it's pure bliss (I'm exaggerating a little bit).</p><p>Soon, we'll see a generic function:<a href=\"https://media2.dev.to/dynamic/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fjj7ml0k9y5nzzr8kj23v.png\"><img src=\"https://media2.dev.to/dynamic/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fjj7ml0k9y5nzzr8kj23v.png\" alt=\"Example of generic function\" width=\"800\" height=\"288\"></a></p><p>We've been seeing  a lot since part 1. Let's talk about it in a little more detail. is an . We haven't seen what it is, but to put it simply:  lets you create functions that can result in a success or an error. This is elegant when used with  or  as we saw in Part 1.</p><p>As with ,  and  can be of any type (within certain constraints).\nAs a reminder, here's a simple example of a function that returns  :</p><div><pre><code></code></pre></div><p>In this example, only integers greater than 10 are displayed.</p><p> is another  quite similar to Result: the function returns either  or . It's an  value.</p><p>To retrieve the  value, there's no equivalent to the question mark with . However, a trick is to convert the Option type with  to  and then add the .\nHere's an equivalent of the previous code with a function that returns  :</p><div><pre><code></code></pre></div><p>Another solution to retrieve this value is to use  method:</p><div><pre><code></code></pre></div><p>But there's a big : it's not possible to use  in kernel space code. Why not? To cut a long story short:  can panic, and an eBPF program can't afford that:</p><p>The piece of code that we discarded in the kernel space above :</p><div><pre><code></code></pre></div><p>It can be used to manage the case of , for example.</p><p>When a variable is created in a program, the compiler must take care of finding where in RAM to add the variable, as well as deleting it to avoid so-called memory leaks. For fixed variables such as integers or non-dynamic arrays, variables are stored in , so there are no problems with releasing them. Thus, because of the restrictions in kernel space programs, there are no clean-up problems in eBPF. Dynamic variables, on the other hand, are stored in , and that's where the problems come in.</p><p>In , we let the developer do this with  and . If he forgets to free memory, it often goes unnoticed, but is a potential source of bugs.</p><p>In other languages (such as  or ), the garbage collector takes care of cleaning up automatically, without developer intervention. However, this is done at the expense of performance.</p><p>In Rust, we use the notion of ownership to solve the problem.</p><div><pre><code></code></pre></div><ul><li> has the  type, which is dynamic</li></ul><p>This program cannot compile. Why?</p><ul><li> will reserve memory space in the heap:<code>let s1 = String::from(\"Hello\");</code></li><li> will retrieve the ownership of this memory space: \nThus  has lost ownership of this memory space:</li></ul><p>This means that no two (or more) variables can have the same memory space. Rust will automatically release a variable once it has left the scope.</p><p>The most elegant solution is to use a  (Keyword: ). These references are also known as safe pointers:</p><div><pre><code></code></pre></div><p>This will display  twice.\nWe say that 's value, but  retains its property.\nLet's take one last example to show you that this isn't always obvious:</p><div><pre><code></code></pre></div><p>This code doesn't compile either. Why? will reserve a memory space in the heap:<code>let s = String::from(\"Hello\");</code>\nThe  function will take the property of this memory space:\nAt the end of this processing, Rust will delete this memory space:</p><div><pre><code></code></pre></div><p>So the display of  crashes.</p><p>To solve this problem simply use this borrowing system:</p><div><pre><code></code></pre></div><p>When you're not used to it, you often make the mistake. But the error messages are self-explanatory and therefore easy to correct.</p><p>The  keyword is very useful when working at low level. It's the sysadmin equivalent of . By default, Rust has protections, notably for reading memory. The unsafe keyword lets you tell Rust: \"Don't worry, I know what I'm doing! If you set  anywhere, Rust will remind you with a warning, or if you don't set unsafe anywhere, Rust will tell you to set it if that's what you really want to do.</p><p>Let's finish this busy section with raw pointers. The notion is similar to the C pointer. It lets you know the address of the variable. There are two types of raw pointers:</p><ul><li>If data of type  cannot change : </li><li>If data of type  can change: </li></ul><p>To convert to a raw pointer, use the  function:</p><div><pre><code></code></pre></div><p>That's all for this Rust part. I hope it wasn't too complicated and dense to understand. If it was, don't worry: let us guide you through the rest, and we'll review each point for a concrete case.</p><p>We've already created a program that every time a binary is executed, it displays a few things in the logs. It would be nice to be able to see which binary is being executed. So we're going to create a little program that will log all the binaries that are executed on the machine. It might be handy to see this for security reasons.</p><p>To do this, you'll need to modify the aya code in kernel space <code>test-aya-ebpf/src/main.rs</code>\nThis is the main part you'll need to modify:</p><div><pre><code></code></pre></div><p>This is based on the  variable, which is a  structure.\nTo do this, we'll take a look at <a href=\"https://docs.rs/aya-ebpf/latest/aya_ebpf/\" rel=\"noopener noreferrer\">the documentation</a>:</p><p>The library is located at the program level:<code>use aya_ebpf::programs::TracePointContext;</code>\nThis shows all the documentation for each type of eBPF program:</p><p>This shows the functions that can be used with :</p><p>We're not interested in the first function, which is used to create a . It's probably used in the macro. That leaves us with the second function: . This function reads the tracepoint at a certain offset. How do we find this offset?</p><p>You need to look in the syscall tracepoint file. To find it, go to: <code>/sys/kernel/debug/tracing/events/[category]/[name]</code>. And the file name is .\nSo the file is here: <code>/sys/kernel/debug/tracing/events/syscalls/sys_enter_execve/format</code>.</p><p>We'll try to retrieve the filename with offset :</p><div><pre><code></code></pre></div><p>I wasn't sure what to put in place of , so I arbitrarily set the type to .\nIf you try to compile :</p><p>It works better now with :</p><div><pre><code></code></pre></div><p>Now let's try using this variable. The result of the read_at function is . The aim is to retrieve . Just use the question mark ().\nSo we'll get :</p><div><pre><code></code></pre></div><p>Nevertheless, compilation won't work because if it makes an error, the  function returns an  and my final function returns a .</p><div><pre><code></code></pre></div><p>Similarly, the  function must always return a . We must therefore cast the type to  :</p><div><pre><code></code></pre></div><p>With these type-matching modifications, it should compile. Let's have a look at the contents of filename. Here's the whole file now if you're lost :</p><div><pre><code></code></pre></div><p>If we run a cargo run again, here's what we see:</p><div><pre><code>[INFO  test_aya] tracepoint sys_enter_execve called 94803283704040\n[INFO  test_aya] tracepoint sys_enter_execve called 94803283704112\n[INFO  test_aya] tracepoint sys_enter_execve called 94173001563176\n[INFO  test_aya] tracepoint sys_enter_execve called 824637710416\n[INFO  test_aya] tracepoint sys_enter_execve called 94865232898256\n[INFO  test_aya] tracepoint sys_enter_execve called 824638316624\n[INFO  test_aya] tracepoint sys_enter_execve called 94865232898256\n</code></pre></div><p>These numbers are not file names. This was to be expected, given that the type is . What I notice is that when I run a command: I'm always number  if it's the server it's the other numbers, if I change user I get a different number.\nWell... that's not much help. Shall we give up? The documentation isn't complete, it doesn't say what it's really for.<p>\nI look at the source code of the </p> function:</p><div><pre><code></code></pre></div><p>And what does  do?</p><p>In this way, an address in memory is accessed. Now we need to think about how to successfully read this address.\nI'll take a look at the helper functions:</p><p>I have the feeling that this is this function that i need:</p><p>Let's add these lines and see what happens:</p><div><pre><code></code></pre></div><p>So all we have to do is change the  type to  (a raw pointer) and we'll change the variable names to be consistent with the documentation:</p><div><pre><code></code></pre></div><p>The compilation works! Now we have a byte-coded file name. Now we need to figure out how to convert it to .</p><p>That's what I want, but as I said earlier, eBPF doesn't accept the standard library ().\nMiracle! It also exists in the  library :</p><p>So we add:<code>let _filename = core::str::from_utf8(_filename_bytes);</code>\nLet's see if it compiles:</p><p>So it compiled fine. But the eBPF verifier is not happy at all. The verifier is a kernel protection system that prevents an eBPF program from being launched if it considers it dangerous for the kernel. What we see in the screenshot is JIT code (Just In Time code).</p><p>The explanation is at the end:<a href=\"https://media2.dev.to/dynamic/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F418g93byz58zwp9yw592.png\"><img src=\"https://media2.dev.to/dynamic/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F418g93byz58zwp9yw592.png\" alt=\"Permission denied\" width=\"787\" height=\"149\"></a></p><p>In the documentation, there's another function that might suit us. Perhaps  makes too many checks that are not compatible with the eBPF verifier?</p><p>Let's add  and :</p><div><pre><code></code></pre></div><p>It compiles!\nBy modifying the log line:</p><div><pre><code></code></pre></div><p>I connect with  on the server where the program is installed, I see all the binaries that are executed :</p><p>The code works, and if you clean it up afterwards, you'll get a code similar to this one</p><p>You can find the program in <a href=\"https://github.com/littlejo/aya-examples/blob/main/tracepoint-binary/tracepoint-binary-ebpf/src/main.rs\" rel=\"noopener noreferrer\">GitHub</a>.</p><p>That's all for this part. I hope you enjoyed it. It was much more technical than the first part. In the next part, we'll be looking at a few things we've already mentioned: the eBPF map. This will, for example, solve the problem we have with the program: file names are truncated. With an eBPF map, we can solve the problem!</p>","contentLength":17774,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Rust Control Flow & Functions: A Beginner’s Guide 🚀","url":"https://dev.to/sajiram_a4704bc095/rust-control-flow-functions-a-beginners-guide-fp5","date":1739868439,"author":"Sajiron","guid":4026,"unread":true,"content":"<p>Control flow is the backbone of programming, dictating how code executes based on conditions and loops. In Rust, we have if statements, match expressions, and loop constructs like for, while, and loop. But that’s not all—Rust’s functions play a crucial role in keeping our code modular and reusable.</p><p>In this guide, you’ll learn:\n✅ How to use if and match for decision-making<p>\n✅ When to use for, while, and loop in Rust</p>\n✅ How to define and call functions with parameters and return values<p>\n✅ The power of generics, closures, and associated functions</p></p><p>Mastering these concepts will give you a solid foundation for writing efficient and idiomatic Rust code.</p>","contentLength":665,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Experience WebForms Core Technology in Rust; File Deletion Example","url":"https://dev.to/elanatframework/experience-webforms-core-technology-in-rust-file-deletion-example-14an","date":1739833819,"author":"Elanat Framework","guid":2092,"unread":true,"content":"<p>For Rust developers, we have good news: From now on, you can also experience <a href=\"https://elanat.net/page_content/web_forms_core\" rel=\"noopener noreferrer\">WebForms Core</a> technology in Rust. At <a href=\"https://elanat.net\" rel=\"noopener noreferrer\">Elanat</a>, we have updated the <a href=\"https://github.com/elanatframework/Web_forms_classes\" rel=\"noopener noreferrer\">WebForms class</a> of the Rust programming language to the latest version of the <a href=\"https://github.com/elanatframework/Web_forms\" rel=\"noopener noreferrer\">WebFormsJS</a> library, version 1.6.</p><p>WebForms Core is an automated and advanced technology for simple management of HTML tags on the server. In this technology, data is sent to the server completely faithfully to HTML (and is done via WebFormsJS), but the state of the page remains static. The server also sends INI data via the WebForms class to the WebFormsJS library on the client. WebForms Core technology allows you to manipulate tags offline in serverless scenarios. To use this technology, you need to add the WebFormsJS library and the WebForms class associated with your desired programming language to your system.</p><p>You can download the WebForms class for the Rust programming language from the link below.</p><p>To download the latest version of WebFormsJS, visit the following link.</p><h2>\n  \n  \n  Example: Using WebForms Core in Actix Web\n</h2><p>The code below the page is the view and the lower code you see is the server code related to the Rust programming language created under the  framework. This is an example to display a list of image files and the ability to delete them via a web page. In this example, the user views the images on the web page and has the ability to delete them. In this example, when the user clicks on the red button, the image file is deleted from the server and subsequently, on the web page, the tag containing the image, the image name, and the delete button are deleted and a deletion message is shown to the user for 3 seconds.</p><p>This file is an HTML template that displays a list of files and a form to delete them. It uses Tera templating engine for rendering dynamic content.</p><div><pre><code>{{ title }}WebForms Core Technology in Rust\n            {% for file in files %}\n            {{ file }}\n            {% endfor %}\n        </code></pre></div><p>In the code below, the \"main\" method is for setting the initial configuration. The \"index\" method is also created to call the \"index.html\" page and create a list of image files.\nThe \"handle_post\" method has been added to delete the image file and use WebForms Core technology.</p><div><pre><code></code></pre></div><p>The GIF image below shows how the above code works.</p><div><pre><code></code></pre></div><p>Since we want to use the WebForms core technology in the Rust programming language, we need to call this class as follows.</p><p>If you look at the view page, you will notice that the data is sent via the POST method. The \"handle_post\" method is also called to respond to the data sent via the POST method.\nIn the \"handle_post\" method, the data value of the input tag, which is of the submit type, is first read. Here, there are two data values, one is the index and the other is the file name. These values ​​are separated and placed in an array called \"parts\".<p>\nNote: Sending multiple values ​​via HTML is a common practice. The submit tag is initialized as follows after rendering:</p></p><div><pre><code></code></pre></div><p>Following the codes of the \"handle_post\" method, the file is physically deleted. A new instance of the WebForms class is created and using the WebForms class, an h3 tag is added to the beginning of the single form and its color is changed to orange. Then the text \"File removed successfully.\" is placed inside the h3 tag and then the command to remove the h3 tag after 3 seconds is added. Finally, the command to remove the parent tag for the img tag is added via its id value.</p><div><pre><code></code></pre></div><p>At the end of the method, the response is sent via the  method.</p><p><strong>What is sent from the client to the server?</strong></p><p>As we mentioned earlier, in WebForms Core technology, data is sent as if it were an HTML page form submission.</p><p><strong>What does the server respond to the client?</strong></p><p>The server response is also based on the INI pattern.</p><div><pre><code>[web-forms]\nut&lt;form&gt;=h3\nbc&lt;h3&gt;=orange\nst&lt;h3&gt;=File removed successfully.\n:3)de&lt;h3&gt;=1\nde/file_1=1\n</code></pre></div><p>WebForms Core Technology in Rust opens up exciting possibilities for Rust developers by integrating an automated and advanced way to manage HTML tags on the server. Leveraging the latest version of the WebFormsJS library, version 1.6, WebForms Core offers a seamless and efficient way to manipulate tags offline in serverless scenarios.</p><p>The provided example demonstrates a practical implementation using Actix Web to display and delete image files via a web page. The user-friendly interface, combined with the robust capabilities of WebForms Core, showcases the power and flexibility of this technology.</p><p>By incorporating WebForms Core into your Rust projects, you can enhance your web development experience with automated tag management, making it easier to build dynamic and interactive web applications. Download the WebForms class for Rust and the WebFormsJS library to get started and explore the full potential of this innovative technology.</p>","contentLength":4795,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Understanding Data Interfaces: Simplifying Data Exchange with Stof","url":"https://dev.to/amelia_wampler_e7aa93dab9/understanding-data-interfaces-simplifying-data-exchange-with-stof-8hm","date":1739833049,"author":"Amelia Wampler","guid":2091,"unread":true,"content":"<p>In today's complex digital landscape, seamless data exchange between systems is critical. Data interfaces serve as the backbone of this exchange, enabling applications, services, and devices to communicate effectively. In this post, we'll explore what a data interface is, why it’s important, how it ties into the innovative approach of Stof, and why you should join our community.</p><h2>\n  \n  \n  What Is a Data Interface?\n</h2><p>A data interface acts as a conduit for information between different systems, applications, or devices. Think of it as a communication layer that translates data formats and protocols so that each system can understand and use the information correctly. Traditionally, setting up these interfaces required custom APIs, SDKs, and parsers—each designed to handle the intricacies of data parsing, structuring, and transformation. This complexity often leads to increased development time and potential integration challenges.</p><h2>\n  \n  \n  Why Is a Data Interface Important?\n</h2><p>Data interfaces are crucial for several reasons:\nStreamlined Communication: They ensure that disparate systems can exchange information smoothly without getting bogged down by incompatible data formats.</p><ul><li><p> By managing the translation of data formats centrally, data interfaces reduce the need for extensive, application-specific code.</p></li><li><p><strong>Enhanced Maintainability:</strong> A unified approach to data exchange leads to systems that are easier to scale, update, and maintain over time.</p></li><li><p> Centralizing the logic in the data layer helps avoid common pitfalls associated with manual data handling, thus reducing errors.</p></li></ul><p>In essence, a robust data interface simplifies the architectural framework, enabling developers to focus on building innovative solutions rather than wrestling with data compatibility issues.</p><h2>\n  \n  \n  How Does Stof Transform Data Interfaces?\n</h2><p>Stof reimagines the concept of a data interface by consolidating its elements into a single, cohesive format. Here’s how Stof makes a difference:</p><ul><li><p> Stof allows developers to embed additional types, functions, and schemas directly within a single document. This enriched interface means that multiple applications can leverage the same structured data without needing extra layers of custom code.</p></li><li><p> By shifting the heavy lifting into the data layer, Stof reduces the need for external parsers and APIs. This approach not only simplifies implementation but also enhances portability across different systems.</p></li><li><p> With a unified format, Stof minimizes the challenges associated with traditional data interface integration. Developers can achieve more robust and scalable applications with fewer hurdles to overcome.</p></li></ul><p>By addressing the common challenges of traditional data interfaces, Stof paves the way for more efficient, maintainable, and innovative system architectures.</p><p>Are you ready to revolutionize the way your applications handle data exchange? We invite you to join the Stof community and be a part of this exciting journey to enhance the way we work with data. Connect with us on <a href=\"https://github.com/dev-formata-io/stof\" rel=\"noopener noreferrer\">GitHub</a> to explore the code, contribute to discussions, and stay updated on the latest developments. Also, follow us on <a href=\"https://www.linkedin.com/company/formataio\" rel=\"noopener noreferrer\">Linkedin</a> and join our <a href=\"https://discord.gg/Up5kxdeXZt\" rel=\"noopener noreferrer\">Discord</a> to engage with a community that’s passionate about shaping the future of data interfaces.</p><p>Embrace the power of simplified data exchange with <a href=\"https://www.stof.dev/\" rel=\"noopener noreferrer\">Stof</a>, and transform the way your systems communicate. Join us today and help drive innovation for our community!</p>","contentLength":3405,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Finally, a guide to Atomic::Ordering that won’t make my brain segfault. If you’ve ever stared at Rust’s memory model like it personally wronged you, this one's for you","url":"https://dev.to/aryan_getsrusty/finally-a-guide-to-atomicordering-that-wont-make-my-brain-segfault-if-youve-ever-stared-at-4ojd","date":1739819373,"author":"Aryan Anand","guid":1999,"unread":true,"content":"<h2>The Missing Guide to Rust's Atomic::Ordering</h2>","contentLength":44,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"The Missing Guide to Rust's Atomic::Ordering","url":"https://dev.to/aryan_getsrusty/the-missing-guide-to-rusts-atomicordering-1g9p","date":1739819283,"author":"Aryan Anand","guid":1998,"unread":true,"content":"<p>When working with concurrent programming in Rust, atomic operations provide a powerful way to manage shared state safely. However, one aspect that often confuses developers—especially those new to low-level concurrency—is . The  variants in Rust's  module control how operations on atomics are perceived across threads, ensuring correctness while balancing performance.</p><p>In this article, we'll break down <strong>what  really means, why it matters, and how to choose the right ordering for your use case</strong>. We'll be implementing a Mutex from scratch and build up to different  (, , , , and ) orderings, examine their trade-offs, and use practical examples with real world analogies to understand the concept </p><p>The word atomic comes from the Greek word , meaning indivisible, something that cannot be cut into smaller pieces. In computer science, it is used to describe an operation that is indivisible: it is either fully completed, or it didn’t happen yet.</p><p> in Rust are used to perform small operations (add, substract, compare, etc) on a shared memory. Unlike a normal  statement which has to go through the <strong>Fetch, Decode, Execute, WriteBack</strong> cycle, atomics on the other hand gets executed in a single  CPU Cycle. Hence preventing a  condition among threads. This makes it perfect for implementing </p><div><pre><code></code></pre></div><p>For simplicity's sake, just ignore the  and let's use  cause we're all  in general. </p><p>CPU and Modern Compilers often re-order the instructions to improve performance and CPU utilisation, However, this is'nt very useful when multiple independent entities  .This could cause  and , stalling the threads for a long time.</p><p>Now our poorly implemented Mutex falls prey to this, the instructions could get shuffled and all our  implementation goes to waste. Since it could reorder into something like:</p><div><pre><code></code></pre></div><p>Which would interefere with another thread who currently has the lock.  something like</p><div><pre><code></code></pre></div><p>This could lead to the mutex locking its own access to the data and being in the state of Deadlock forever, leading to freezing the program.</p><h2>\n  \n  \n  How does  save us from this ?\n</h2><p>It gives special instructions to the compiler, i.e when should it reorder and when it should'nt.</p><h2><code>Ordering::Acquire/Release</code>(together) – Ensures Seeing Previous Writes and Future Reads\n</h2><ul><li>Ensures that <strong>all writes done before another thread released the data are visible</strong>. </li><li>Prevents <strong>previous reads/writes from moving after the acquire operation</strong>. </li></ul><h3>: Imagine  is preparing a , and  is the delivery person.\n</h3><div><pre><code></code></pre></div><p>Now as compiler gets the instructions:- </p><ul><li><strong>T1 (cook) sets  and then flips  to true.</strong></li><li><strong>T2 (delivery) waits until  and only then picks up .</strong></li><li><strong>No chance of reading old data!</strong></li></ul><h3>\n  \n  \n  Example 2 : Think of  as a warehouse preparing a package, and  as a delivery worker picking it up.\n</h3><div><pre><code></code></pre></div><ul><li><strong>T1 (warehouse) packs the order (), then sets  to true.</strong></li><li><strong>T2 (delivery) will NOT pick up  until  is fully written.</strong></li><li><strong>T2 always gets the correct value.</strong></li></ul><p>Key Point:  ensures that all previous writes (like )  are visible before setting .</p><h2> - Ensures previous writes are seen\n</h2><h3>\n  \n  \n  Example : Imagine  is the Chef cooking and  is the Waiter\n</h3><ul><li>The waiter () checks if the dish is  ().</li><li>Once the ticket (flag) is marked \"Ready,\" the waiter  the dish is complete.</li><li>But , they might do unrelated tasks in any order.\n</li></ul><div><pre><code></code></pre></div><ul><li> ensures that once the waiter sees , they will also see the completed dish () and pick it up.</li><li>However,  tasks(like setting up plates) i.e previous instructions might have happened before checking.</li></ul><p>Using  ordering for a store ensures all prior changes are visible after the store. A  will see the stored value and enforce order for subsequent operations. However, in load-store operations, the store part becomes \"Relaxed,\" losing strong ordering guarantees.</p><p><strong>ENSURES WE SEE ALL MEMORY CHANGES MADE BY THE PREVIOUS LOCK OWNERS</strong></p><h2> – Ensures future accesses see the change made\n</h2><h3>\n  \n  \n  Example : Imagine  is the Chef cooking and  is the Waiter\n</h3><p><em>Before the waiter picks the dish...</em></p><ul><li>The chef ()  finish preparing the dish  marking the order as ready ().</li><li>Or else, customers could receive a half-cooked meal.</li></ul><div><pre><code></code></pre></div><ul><li> makes sure <strong>everything before it happens first</strong> (the dish is ready before the flag is flipped).</li></ul><p>An Acquire load ensures all operations before a prior store are visible, preventing outdated or inconsistent data. It acts as a barrier, enforcing memory consistency across threads.</p><p><strong>ENSURES THAT FUTURE READS WILL SEE THIS UPDATED VALUE</strong></p><h3><strong> – Ensures a globally consistent order of operations</strong></h3><h3>\n  \n  \n  Example: Imagine  is the Customer A and  is the Customer B\n</h3><p><em>Before transferring money...</em></p><ul><li>Customer A () must  from their account  depositing it into Customer B's account.</li><li>Customer B () will  once Customer A's withdrawal is complete.</li><li>Both actions must happen in a globally consistent order, ensuring that no thread (i.e., no customer) will observe the operations out of order, even if both threads are executed on different processors.</li></ul><div><pre><code></code></pre></div><ul><li> ensures that all threads observe the operations in a globally consistent order. This means  is seen . No other thread will see the operations in a different order, thus preventing race conditions and ensuring the bank's accounting is correct.</li></ul><h2> – Atomic Counters (No Synchronization Guaranteed)\n</h2><ul><li>Make modification to the shared variable without reading it.</li></ul><div><pre><code></code></pre></div><ul><li>We  care when a thread sees the updated count.</li><li>As long as the , we’re good.</li></ul><ul><li>Each update would enforce , slowing down performance.\n## Using everything we know now to fix our Mutex implementation</li></ul><p><strong>When unlocking and locking a mutex</strong>: When a mutex is unlocked, a happens-before relationship is created between the unlock operation and the next lock operation on the same mutex. This ensures that:</p><p><strong>The next thread that locks the mutex will see all of the changes that were made by the thread that unlocked the mutex.</strong></p><div><pre><code></code></pre></div><div><table><thead><tr></tr></thead><tbody><tr><td>Ensures this read sees  before a  store. store is done, then it may/may not see based on where the CPU has re-ordered the instruction</td></tr><tr><td>Ensures <strong>all previous  writes</strong> are visible before unlocking. for the same reason that it may be reordered ahead of the write.</td></tr></tbody></table></div>","contentLength":5936,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Latency based container scaling with Orbit","url":"https://dev.to/airpipe/latency-based-container-scaling-with-orbit-1c3i","date":1739804513,"author":"Kav Pather","guid":4005,"unread":true,"content":"<p>In our previous article, we introduced Orbit, our lightweight container orchestrator built in Rust. Since then, we've made significant improvements driven by both community feedback and production requirements. Let's dive into the technical evolution that's making Orbit even more powerful and efficient.</p><h2>\n  \n  \n  Community-Driven Development\n</h2><p>One of the most exciting aspects of Orbit's development has been the community engagement. A perfect example is our implementation of <a href=\"https://en.wikipedia.org/wiki/CoDel\" rel=\"noopener noreferrer\">CoDel (Controlled Delay)</a> for scaling decisions, which came directly from a community member's suggestion on Medium. We're also grateful to community members like <a href=\"https://github.com/josselinchevalay\" rel=\"noopener noreferrer\">Josselin Chevalay</a> who contributed the  feature in our latest release, allowing control over container image pulling behavior. This collaborative approach will continue to help shape Orbit's feature set and technical direction.</p><h2>\n  \n  \n  Technical Evolution: Key Improvements\n</h2><h3>\n  \n  \n  1. CoDel (Controlled Delay) - Inspired Scaling: Latency-Driven Container Orchestration\n</h3><p>Unlike traditional orchestrators that rely solely on CPU and memory metrics, we've implemented <a href=\"https://en.wikipedia.org/wiki/CoDel\" rel=\"noopener noreferrer\">CoDel-based/inspired scaling</a> - a feature not natively available in Kubernetes or other major orchestrators. Here's how it works:</p><div><pre><code></code></pre></div><div><pre><code></code></pre></div><p>The CoDel inspired implementation monitors request latency and makes intelligent scaling decisions based on both immediate and historical performance data. Benefits include:</p><ul><li><p>More responsive scaling based on actual service performance</p></li><li><p>Better handling of latency spikes</p></li><li><p>Prevention of unnecessary scale-ups during temporary load increases</p></li></ul><p> that this is just our initial implementation, and we will continue to improve where possible and perhaps rename when appropriate.</p><p>Key Differences from Traditional CoDel:</p><ul><li><p><strong>Service-Level Application</strong> :</p><ul><li>Our implementation applies CoDel principles at the service level rather than packet level</li><li>Uses request latency instead of packet sojourn time</li><li>Focuses on scaling rather than packet dropping</li></ul></li><li><ul><li>This is simpler than traditional CoDel's state machine.\n</li></ul></li></ul><div><pre><code></code></pre></div><p>We've added the usual health monitoring with TCP health checks:</p><div><pre><code></code></pre></div><ul><li><p>Configurable health check parameters</p></li><li><p>TCP-level connectivity verification</p></li><li><p>Granular control over failure thresholds</p></li><li><p>Separate startup and liveness checks</p></li></ul><h3>\n  \n  \n  3. Performance Optimizations\n</h3><p>We've made several low-level optimizations to improve performance:</p><h4>\n  \n  \n  Switching to FxHashMap/FxHashSet\n</h4><div><pre><code></code></pre></div><p>By replacing standard HashMap with FxHashMap:</p><ul><li><p>Better performance for string keys</p></li><li><p>Lower collision rates in our specific use cases</p></li></ul><h3>\n  \n  \n  4. Improved Resource Management\n</h3><p>We've implemented a more sophisticated resource management system:</p><div><pre><code></code></pre></div><ul><li><p>Fine-grained control over resource utilization</p></li><li><p>Better handling of CPU quota management</p></li><li><p>More accurate memory tracking</p></li><li><p>Customizable metrics aggregation strategies</p></li></ul><p>These improvements have had significant real-world impact:</p><ul><li><p>30% reduction in unnecessary scaling operations</p></li><li><p>More stable performance under varying load conditions</p></li><li><p>Reduced resource usage in the orchestrator itself</p></li><li><p>Better handling of microservices with varying performance characteristics</p></li><li><p>Still managed to retain a &lt;5MB binary size footprint</p></li></ul><h2>\n  \n  \n  What's Next: Decentralized Clustering!?\n</h2><p>We're excited to explore our next major development focus: a decentralized clustering solution. This will allow Orbit to:</p><ul><li><p>Operate without a central control plane</p></li><li><p>Provide better resilience in edge deployments</p></li><li><p>Enable peer-to-peer node coordination</p></li><li><p>Support dynamic cluster topology changes</p></li></ul><p>We have some initial ideas on how to design the solution, so please follow for our next update to see how we hope to make this happen!</p><h2>\n  \n  \n  Building at Scale with Air Pipe\n</h2><p>While Orbit handles container orchestration, it's just one piece of the puzzle. At <a href=\"https://airpipe.io\" rel=\"noopener noreferrer\">Air Pipe</a>, we're building a comprehensive platform for creating scalable, resilient APIs, integrations, and workflows. Our platform enables you to:</p><ul><li><p>Build and deploy scalable APIs with minimal boilerplate</p></li><li><p>Create robust integration workflows</p></li><li><p>Implement resilient data processing pipelines</p></li><li><p>Leverage edge computing capabilities</p></li></ul><p>If you're building distributed systems or scalable applications, visit <a href=\"https://airpipe.io\" rel=\"noopener noreferrer\">airpipe.io</a> to learn how our platform can accelerate your development.</p><p>We're building Orbit in the open and value community input. Whether you're interested in the technical details or want to contribute to our upcoming clustering features:</p><p>Stay tuned for our next technical deep-dive where we'll explore the architecture of our decentralized clustering approach!</p>","contentLength":4415,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"notl.ink - open source blazingly fast url shortener ever. Live on ProductHunt.","url":"https://dev.to/abdibrokhim/notlink-open-source-blazingly-fast-url-shortener-ever-live-on-producthunt-41mk","date":1739798316,"author":"Ibrohim Abdivokhidov","guid":1836,"unread":true,"content":"<p>Launching on ProductHunt February 18th, 2025 12:01 AM PST.&nbsp;</p>","contentLength":60,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Build a software career with meaning: a playbook","url":"https://dev.to/jonesbeach/build-a-software-career-with-meaning-a-playbook-d3b","date":1739795400,"author":"Jones Beach","guid":1811,"unread":true,"content":"<p>Even with 20 fingers and toes, I barely have enough digits to count how many times during my 9-5 career I thought, “Wow, I feel frustrated/stuck/alone/hungry, maybe I should look for a new job.” A new job holds the allure of allowing you to let go of all your negative emotions (especially hunger) and start over.</p><p>There are plenty of reasons to switch jobs, particularly when advocating for fairer compensation or a less-toxic environment. But if you're like me and looking to build a meaningful software career, where you can use your brain to its fullest and maybe do a bit of good, job hopping is more like a salve on a wound than a complete fix.</p><p>With this in mind, I’m excited to announce my new email course: <a href=\"https://fromscratchcode.com/courses/meaningful-career/\" rel=\"noopener noreferrer\">Build a Software Career with Meaning</a>. While under development, I called this “How I went from ‘Hello World!’ to ‘How can I help?’ in just 19 years,” which is clearly a cheeky title but captures the work-in-progress feel of my career.</p><p>Did I mention it’s free? Over the course of 5 (business) days, you’ll receive a brief email with a piece of wisdom, along with an actionable thought experiment you can test on your career.</p><p>I also want to be transparent: in email marketing speak, this is called a “lead magnet.” I learned this term from reading (does YouTube still exist?), so I can only assume this is referring to the element from the periodic table with the symbol  (you know, the one pronounced ‘led’). And here I thought lead wasn't magnetic!</p><p>I'm offering the course for free because I want to share how I think about things. At the end of 5 (business) days, perhaps you’ll feel like you know a bit more about my values and want to work with me. If you don’t, that’s more than okay! You are welcome to stay on the list indefinitely, and the option to unsubscribe will always be at the bottom. There are no tricks here, just a marketing playbook I’ve been learning in between <a href=\"https://fromscratchcode.com/blog/building-a-markdown-blog-with-links-optimized-for-gatsby/\" rel=\"noopener noreferrer\">implementing my Markdown blog</a> and <a href=\"https://fromscratchcode.com/blog/how-i-added-support-for-nested-functions-in-python-bytecode/\" rel=\"noopener noreferrer\">nested functions in Python bytecode</a>.</p><p>If you’ve ever felt stuck or disillusioned in your software career, I hope this course gives you a new perspective. If nothing else, it’ll be five (business) days of me popping into your email client with career advice just a tad more nuanced than “Quit your job!”</p><p>P.S. If you’re interested in reading the story about how my 9-5 career crashed-and-burned—and how I built something better from the wreckage—I have the complete account over on <a href=\"https://fromscratchdotorg.substack.com/p/why-i-left-my-9-5-for-good\" rel=\"noopener noreferrer\">From Scratch dot org</a>. I’d love to hear if any of my experiences and catatonic thought loops (the kind where you forget to eat) mirror your own!</p><p>I mentor software engineers to navigate technical challenges and career growth in a supportive, sometimes silly environment. If you’re interested, you can <a href=\"https://fromscratchcode.com/mentorship/\" rel=\"noopener noreferrer\">explore my mentorship programs</a>.</p><p>In addition to mentoring, I also write about neurodivergence and self-employment. Less code and the same number of jokes.</p>","contentLength":2906,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Rust Basics: Syntax, Data Types, and Naming Conventions","url":"https://dev.to/sajiram_a4704bc095/rust-basics-syntax-data-types-and-naming-conventions-4kpm","date":1739790461,"author":"Sajiron","guid":1778,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Rust Atomic Operations Guide: High-Performance Lock-Free Programming Techniques [Tutorial]","url":"https://dev.to/aaravjoshi/rust-atomic-operations-guide-high-performance-lock-free-programming-techniques-tutorial-2nf2","date":1739783680,"author":"Aarav Joshi","guid":1714,"unread":true,"content":"<blockquote><p>As a best-selling author, I invite you to explore my books on <a href=\"https://www.amazon.com/stores/Aarav-Joshi/author/B0DQYNVXZ7?ref=ap_rdr&amp;isDramIntegrated=true&amp;shoppingPortalEnabled=true&amp;ccs_id=738636bd-0ca1-4d7b-8efa-481bfc222571\" rel=\"noopener noreferrer\">Amazon</a>. Don't forget to follow me on <a href=\"https://medium.com/@aarav-joshi\" rel=\"noopener noreferrer\">Medium</a> and show your support. Thank you! Your support means the world! </p></blockquote><p>Atomic operations and lock-free programming in Rust represent a sophisticated approach to concurrent programming. These concepts form essential building blocks for developing high-performance concurrent systems that minimize synchronization overhead.</p><p>The foundation of atomic operations in Rust centers on the std::sync::atomic module. This module provides atomic versions of primitive types that guarantee thread-safe operations without traditional locks. Let's explore the core atomic types:</p><div><pre><code></code></pre></div><p>Memory ordering plays a crucial role in atomic operations. Rust provides several ordering levels that determine the synchronization guarantees between threads:</p><div><pre><code></code></pre></div><p>I've implemented numerous lock-free data structures using atomics. A simple atomic counter demonstrates the basic principles:</p><div><pre><code></code></pre></div><p>Compare-and-swap (CAS) operations form the foundation of many lock-free algorithms. Here's an implementation of a lock-free stack:</p><div><pre><code></code></pre></div><p>Memory fences provide explicit synchronization points when needed. They ensure visibility of changes across threads:</p><div><pre><code></code></pre></div><p>Atomic operations excel in scenarios requiring high performance and minimal contention. I've successfully used them in system-level programming, game engines, and high-frequency trading systems.</p><p>A practical example of atomics in action is a multi-producer, single-consumer channel:</p><div><pre><code></code></pre></div><p>Performance considerations play a vital role when working with atomics. While they avoid the overhead of traditional locks, incorrect usage can lead to contention and reduced performance. I recommend careful benchmarking and profiling to ensure optimal results.</p><p>The ABA problem represents a common challenge in lock-free programming. It occurs when a value changes from A to B and back to A, potentially causing incorrect behavior. Here's a solution using generation counters:</p><div><pre><code></code></pre></div><p>Testing atomic code requires specific strategies. I've developed techniques to verify correctness under concurrent access:</p><div><pre><code></code></pre></div><p>The future of atomic operations in Rust continues to evolve. The language team actively works on improving the atomic API and adding new features. These improvements will further enhance Rust's position as a leading language for systems programming and concurrent applications.</p><p>Remember that atomic operations provide powerful tools for concurrent programming, but they require careful consideration of memory ordering and synchronization requirements. Start with simpler synchronization mechanisms unless performance requirements specifically demand atomic operations.</p><p> is an AI-driven publishing company co-founded by author . By leveraging advanced AI technology, we keep our publishing costs incredibly low—some books are priced as low as —making quality knowledge accessible to everyone.</p><p>Stay tuned for updates and exciting news. When shopping for books, search for  to find more of our titles. Use the provided link to enjoy !</p><p>Be sure to check out our creations:</p>","contentLength":3037,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"The open source fastest URL shortener ever.","url":"https://dev.to/abdibrokhim/the-open-source-fastest-url-shortener-ever-5af3","date":1739746041,"author":"Ibrohim Abdivokhidov","guid":798,"unread":true,"content":"<p>The open source fastest URL shortener ever.</p><p>Built with awesome open source tools x.com/rustlang x.com/shuttle_dev x.com/neondatabase x.com/actix_rs</p><p>x.com/ThePracticalDev x.com/aimlapi x.com/vercel</p>","contentLength":194,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"RustyNum Follow-Up: Fresh Insights and Ongoing Development","url":"https://dev.to/igorsusmelj/rustynum-follow-up-fresh-insights-and-ongoing-development-18f9","date":1739738297,"author":"IgorSusmelj","guid":766,"unread":true,"content":"<p>As a follow-up to my previous introduction to <a href=\"https://github.com/IgorSusmelj/rustynum\" rel=\"noopener noreferrer\">RustyNum</a>, I want to share a developer-focused update about what I’ve been working on these last few weeks. RustyNum, as you might recall, is my lightweight, Rust-powered alternative to NumPy published on GitHub under MIT license. It uses Rust’s portable SIMD features for faster numerical computations, while staying small (around ~300kB for the Python wheel). In this post, I’ll explore a few insights gained during development, point out where it really helps, and highlight recent additions to the documentation and tutorials.</p><p>If you missed the initial announcement, RustyNum focuses on:</p><ul><li>High performance using Rust’s SIMD</li><li>Memory safety in Rust, without GC overhead</li><li>Small distribution size (much smaller than NumPy wheels)</li><li>NumPy-like interface to reduce friction for Python users</li></ul><h2>\n  \n  \n  Developer’s Perspective: What’s New?\n</h2><p><strong>1. Working with Matrix Operations</strong></p><p>I’ve spent a good chunk of time ensuring matrix operations feel familiar. Being able to do something like matrix-vector or matrix-matrix multiplication with minimal code changes from NumPy was a primary goal. A highlight is the  function and the  operator, which both support these operations.</p><div><pre><code></code></pre></div><p>It’s neat to see how close this is to NumPy’s workflow. Benchmarks suggest RustyNum can often handle these tasks at speeds comparable to, and sometimes faster than, NumPy on smaller or medium-sized datasets. For very large matrices, I’m still optimizing the approach.</p><p><strong>2. Speeding Up Common Analytics Tasks</strong></p><div><pre><code></code></pre></div><p>The Python overhead can sometimes offset the raw Rust speed, but in many cases, RustyNum still shows advantages.</p><h2>\n  \n  \n  New Tutorials: Real-World Examples\n</h2><p>One of the best ways to see RustyNum in action is through practical examples. I’ve added several new tutorials with real-world coding scenarios:</p><ol><li> – Focus on dot products, matrix-vector, and matrix-matrix tasks.</li><li><strong>Replacing Core NumPy Calls</strong> – Demonstrates how to switch from NumPy’s mean, min, dot to RustyNum.</li><li><strong>Streamlining ML Preprocessing</strong> – Explores scaling, normalization, and feature engineering for machine learning.</li></ol><p>Check out a snippet of scaling code from that guide:</p><div><pre><code></code></pre></div><p>It’s a small snippet, but it shows how RustyNum can do row/column manipulations quite effectively. After scaling, you can still feed the data into your favorite machine learning frameworks. The overhead of converting RustyNum arrays back into NumPy or direct arrays is minimal compared to the cost of big model training steps.</p><p><strong>1. Large Matrix Optimizations</strong></p><p>I’ve noticed that for very large matrices (like 10k×10k), RustyNum’s current code paths aren’t yet fully optimized compared to NumPy. This area remains an active project. RustyNum is still young, and I’m hoping to introduce further parallelization or block-based multiplication techniques for better large-scale performance.</p><p>RustyNum supports float32 and float64 well, plus some integer types. I’m considering adding stronger integer support for data science tasks like certain indexing or small transformations. Meanwhile, advanced data types (e.g., complex numbers) might appear further down the line if the community needs them.</p><p><strong>3. Documentation and API Enhancements</strong></p><p>The docs site at <a href=\"https://rustynum.com/\" rel=\"noopener noreferrer\">rustynum.com</a> has an API reference and a roadmap. I’m continuously adding to it. If you spot anything missing or if you have a specific use case in mind, feel free to open a GitHub issue or submit a pull request.</p><p><strong>4. The big goal of Rustynum</strong></p><p>RustyNum is simply a learning exercise for me to combine Rust and Python. Since I spend every day around machine learning I would love to have RustyNum replace part of my daily Numpy routines. And we're slowly getting there. I started adding more and more methods around the topic of how to integrate RustyNum in ML pipelines.</p><h2>\n  \n  \n  Quick Code Example: ML Integration\n</h2><p>To demonstrate how RustyNum fits into a data pipeline, here’s a condensed example:</p><div><pre><code></code></pre></div><p>This script highlights that RustyNum can handle data transformations with a Pythonic feel, after which you can pass the arrays into other libraries.</p><p>It’s been fun to expand RustyNum’s features and see how well Rust can integrate with Python for high-performance tasks. The recent tutorials are a window into how RustyNum might replace parts of NumPy in data science or ML tasks, especially when smaller array sizes or mid-range tasks are involved.</p><ul><li>Check out the tutorials at rustynum.com</li><li>Contribute or report issues on GitHub</li><li>Share feedback if there’s a feature you’d love to see</li></ul><p>Thanks for tuning in to this developer-focused update, and I look forward to hearing how RustyNum helps you in your own projects!</p>","contentLength":4610,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Pulumi Gestalt devlog #8","url":"https://dev.to/andrzejressel/pulumi-gestalt-devlog-8-1d1m","date":1739734216,"author":"​Andrzej Ressel","guid":753,"unread":true,"content":"<p>Welcome to the eighth devlog for . This week, the focus was on preparing native Rust support and moving toward an initial release.</p><p>Previously, Rust support in Pulumi Gestalt was essentially Wasm/Rust support, which required a complex setup and runtime environment. This week, I implemented proper native Rust support, which simplifies the process significantly. Now you can get started without external runners - only  and <a href=\"https://github.com/casey/just\" rel=\"noopener noreferrer\"></a> required.</p><p>After several weeks of development and refinement, I believe Pulumi Gestalt has reached a state where it’s ready for an initial release. Over the next few days, I’ll be focusing on finalizing documentation and ensuring consistent naming conventions across the SDKs to provide a smoother experience for users.</p><p>That’s all for this week’s updates! As always, I welcome your feedback. If you have any thoughts, suggestions, or run into issues, feel free to share them on either the <a href=\"https://github.com/andrzejressel/pulumi-gestalt\" rel=\"noopener noreferrer\">main repository</a> or the <a href=\"https://github.com/andrzejressel/pulumi-gestalt-example\" rel=\"noopener noreferrer\">example repository</a>.</p>","contentLength":959,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["rust"]}