{"id":"2Qhhdda6Qnbf8RCfUPd4nB9sSt2WDQfEpF7H3gCnZZ4AsfbGMy3RmrCa6gigGY6TkbrrJn4wmHXXNYcVj1bK","title":"top scoring links : rust","displayTitle":"Reddit - Rust","url":"https://www.reddit.com/r/rust/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/rust/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"My experience so far with Rust as a complete Rust newbie","url":"https://www.reddit.com/r/rust/comments/1ikn7g5/my_experience_so_far_with_rust_as_a_complete_rust/","date":1739021147,"author":"/u/IFreakingLoveOranges","guid":598,"unread":true,"content":"<p>I’ve been a systems programmer for about 6 years, mostly using C/C++ and Java. I always wanted to try something new but kept putting it off. Finally I decided to give Rust a shot to see what all the hype was about.</p><p>I’m still learning, and there’s definitely a lot more to explore, but after using Rust (casually) for about a month, I wanted to share my thoughts so far. And hopefully maybe get some feedback from more experienced Rust users.</p><p>Coming from C/C++, having a package manager that \"just works\" feels amazing. Honestly, this might be my favorite thing about Rust.</p><p>The first week was rough, I almost gave up. But once things clicked, I started feeling way more confident. And what I mean by \"productive\" is that feeling when you can just sit down and get shit done.</p><p>Having a solid C background and a CS degree definitely helped, but I actually didn't struggle much with ownership/borrowing. It’s nice not having to worry about leaks every time I’m working with memory.</p><p>Rust’s documentation is amazing. Not many languages have this level of high quality learning material. The Rust Book had everything I needed to get started.</p><p><em>Things I Don’t Like About Rust</em></p><p>Okay, maybe this is just me being stuck in my OOP habits (aka skill issues), but Rust feels a little weird in this area. I get that Rust isn’t really an OOP language, but it’s also not fully functional either (at least from my understanding). Since it already has the  keyword, it feels like there was some effort to include OOP features. A lot of modern languages mix OOP and functional programming, and honestly I think having full-fledged classes and inheritance would make Rust more accessible for people like me.</p><p>I haven’t looked into the details of how the Rust compiler works under the hood, but wow! some of these compile times are super painful, especially for bigger projects. Compared to C, it’s way slower. Would love to know why.</p><p>All in all, my experience has been positive with Rust for the most parts, and I’m definitely looking forward to getting better at it.</p>","contentLength":2056,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"fasterthanlime: The case for sans-io","url":"https://www.youtube.com/watch?v=RYHYiXMJdZI","date":1739007878,"author":"/u/Orange_Tux","guid":602,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1ikjtgc/fasterthanlime_the_case_for_sansio/"},{"title":"AnyOf<L, R> : Neither | Either<L, R> | Both<L, R>","url":"https://www.reddit.com/r/rust/comments/1ikdp13/anyofl_r_neither_eitherl_r_bothl_r/","date":1738984664,"author":"/u/OkResponsibility9677","guid":601,"unread":true,"content":"<p>My first crate mature enough to talk about:.</p><p>ℹ️ This library allows you to use the  type, which is a sum type of a product type of two types.</p><p>ℹ️ It enables you to represent anything in a type-safe manner. It is an algebraic data type (<a href=\"https://en.wikipedia.org/wiki/Algebraic_data_type\">on Wikipedia</a>).</p><p>✏️ Formally, it can be written as:<code>AnyOf&lt;L, R&gt; = Neither | Either&lt;L, R&gt; | Both&lt;L, R&gt;</code></p><p>✏️ The  and  types allow different combinations of types:<code>Either&lt;L, R&gt; = Left(L) | Right(R)</code></p><p>✏️ The traits , , , and  provide extensibility to the library.</p>","contentLength":502,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"[media] cargo run rust projects with vscode's debugger attached using cargo-debugger!","url":"https://www.reddit.com/r/rust/comments/1ik5gf6/media_cargo_run_rust_projects_with_vscodes/","date":1738961737,"author":"/u/jkelleyrtp","guid":603,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"[Media] Cosmic Yudh: a shooting game for the ESP32 with an OLED display","url":"https://www.reddit.com/r/rust/comments/1ik2b1d/media_cosmic_yudh_a_shooting_game_for_the_esp32/","date":1738953783,"author":"/u/AstraKernel","guid":600,"unread":true,"content":"   submitted by   <a href=\"https://www.reddit.com/user/AstraKernel\"> /u/AstraKernel </a>","contentLength":34,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Best way to work with large strings?","url":"https://www.reddit.com/r/rust/comments/1ijxwdg/best_way_to_work_with_large_strings/","date":1738942977,"author":"/u/exater","guid":599,"unread":true,"content":"<p>I have a long running web server (axum) that pulls large string feeds from another server. Is there a way to reuse some sort of buffer to avoid reallocating on the heap every time it makes an HTTP call? According to the process memory, it makes pretty significant spike when a burst of HTTP calls are made. I'm concerned that this is causing some kind of memory fragmenting? I recently swapped the memory allocator to jemalloc instead of the default. However, after monitoring for a few days, the memory still seems to be slowly creeping up. I've done extensive memory profiling and cannot really isolate a \"leak\". However, according to my metrics, when bursts in HTTP calls are made, the memory similarly spikes up and never really seems to recover fully. For example, if the process was sitting at 100mb, bursts up to 150mb, it may go back down to 110mb but not 100mb. And after long periods of time I'm observing a steady increase. Am I sweating over nothing? Is this just standard allocator behavior, holding on to pages of memory to reuse later? The docker containers limit is 512mb, the server started up at around 150mb, and after running for 2 days continuously it is sitting at 220mb. Under the default allocator, this behavior was observed all the way until it reached 512mb and OOMd (took a few weeks). Is jemalloc smarter? Will jemalloc eventually stable out somewhere and not go all the way to 512mb and kill itself?</p>","contentLength":1429,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev","reddit","rust"]}