{"id":"Lx2uDWR7f1yr334","title":"Programming","displayTitle":"Programming","url":"","feedLink":"","isQuery":true,"isEmpty":false,"isHidden":false,"itemCount":75,"items":[{"title":"Don't \"optimize\" conditional moves in shaders with mix()+step()","url":"https://iquilezles.org/articles/gpuconditionals/","date":1739631147,"author":"/u/namanyayg","guid":638,"unread":true,"content":"\nIn this article I want to correct a popular misconception that's been making the rounds in computer graphics aficionado circles for a long time now. It has to do with conditionals when selecting between two results in the GPUs. Unfortunately there are a couple of educational websites out there that are spreading some misinformation, and it would be nice correcting that. I tried contacting the authors without success, so without further ado, here goes my attempt to fix things up a little:\nSo, say I have this code, which I actually published the other day:<div> snap45(  v )\n{\n     s = (v);\n     x = (v.x);\n     x&gt;?(s.x,):\n           x&gt;?s*():\n                      (,s.y);\n}</div>\nThe exact details of what it does don't matter for this discussion. All we care about is the two ternary operations deciding what's the final value this function should return. Indeed, depending on the value of the variable , the function will return one of three results, which are simple to compute. I could also have implemented this function with regular  statements, and all that I'm going to say in this article stays true.<p>\nNow, here's the problem - when seeing code like this, somebody somewhere will step up and invariably propose the following \"optimization\", which replaces what they believe (erroneously) are \"conditional branches\" in the code, by arithmetic operations. They will suggest something like this:</p><div> snap45(  v )\n{\n     s = (v);\n     x = (v.x);\n\n     w0 = (,x);\n     w1 = (,x)*(-w0);\n     w2 = -w0-w1;\n\n     res0 = (s.x,);\n     res1 = (s.x,s.y)*();\n     res2 = (,s.y);\n\n     w0*res0 + w1*res1 + w2*res2;\n}</div>\nThere are two things wrong with this practice. The first one shows an incorrect understanding of how the GPU works. In particular, the original shader code had no conditional branching in it. Selecting between a few registers with a ternary operator or with a plain  statement does not lead to conditional branching; all it involves is a conditional move (a.k.a. \"select\"), which is a simple instruction to route the correct bits to the destination register. You can think of it as a bitwise AND+NAND+OR on the source registers, which is a simple combinational circuit. I'll repeat it again - there is no branching, the instruction pointer isn't manipulated, there's no prediction involved, no pipe to flush, no instruction cache to invalidation, no nothing.<p>\nFor the record, of course GPUs can do real branching, and those are fine and fast and totally worth it when big chunks of code and computation are to be skipped given a condition. As with all things computing, always check the generated machine code to know what is happening exactly and when. But one thing you can safely assume without having to check any generated code - when moving simple values or computations like in my original example, you are guaranteed to not branch. This has been true for decades at this point, with GPUs. And while I'm not an expert in CPUs, I am pretty sure this is true for them as well.</p><p>\nThe second wrong thing with the supposedly optimized version is that it actually runs much slower than the original version. You can measure it in a variety of hardware. I can only assume that's because the </p> function is probably implemented with some sort of conditional move or subtract + bit propagation + AND.<div> step(  x,  y )\n{\n     x &lt; y ?  : ;\n}</div>\nEither way, using the step() \"optimization\" are either using the ternary operation anyways, which produces the  or  which they will use to mask in and out the different potential outputs with a series of arithmetic multiplications and additions. Which is wasteful, the values could have been conditionally moved directly, which is what the original shader code did.<p>\nBut don't take my word for it, let's look at the generated machine code for the original code I published:</p><div><div>\nGLSL<div> x&gt;?(s.x,):\n       x&gt;?s*():\n                  (,s.y);</div></div><div>\nAMD Compiler<div>     s0,      v3, , v1\n     v4, , v0\n     s1,   vcc, (v2), s0\n v3, 0, v3, vcc\n v0, v0, v4, vcc\n vcc, (v2), s1\n v1, v1, v3, vcc\n v0, 0, v0, vcc</div></div><div>\nMicrosoft Compiler<div>   r0.xy, l(, ), v0.xy\n   r0.zw, v0.xy, l(, )\n r0.xy, -r0.xyxx, r0.zwzz\n r0.xy, r0.xyxx\n  r1.xyzw, r0.xyxy, l4()\n   r2.xy, l(,), v0.xx  r0.z, l()\n r1.xyzw, r2.yyyy, r1.xyzw, r0.zyzy\n o0.xyzw, r2.xxxx, r0.xzxz, r1.xyzw</div></div></div>\nHere we can confirm that the GPU is not branching, as I explained. Instead, according to the AMD compiler, it's performing the required comparisons ( and  - cmp=compare, gt=greater than, ngt=not greated than), and then using the result to mask the results with the bitwise operations mentioned earlier ( - cnd=conditional).<p>\nThe Microsoft compiler has expressed the same idea/implementation in a different format, but you can still see the comparison (</p> - \"lt\"=less than) and the masking or conditional move ( - mov=move, c=conditionally).<p>\nThere are no jump/branch instructions in these listings.</p><p>\nSomething not related to the discussion but interesting, is that some of the </p> GLSL calls I had in my shader before the ternary operator we are discussing, didn't become GPU instructions but rather instruction modifiers, which is the reason you see them in the listing. This means you can think of abs() calls as being free.\nSo, if you ever see somebody proposing this<div> a = ( b, c, ( y, x ) );</div>\nas an optimization to\nthen please correct them for me.","contentLength":5296,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1iq2z4j/dont_optimize_conditional_moves_in_shaders_with/"},{"title":"What is Event Sourcing?","url":"https://newsletter.scalablethread.com/p/what-is-event-sourcing","date":1739628306,"author":"/u/scalablethread","guid":639,"unread":true,"content":"<p>Traditional data storage typically focuses on the current state of an entity. For example, in an e-commerce system, you might store the current state of a customer's order: items, quantities, shipping address, etc. Event sourcing takes a different approach. Instead of storing the current state directly, it stores the events that led to that state. Each event represents a fact that happened in the past. Think of it as a detailed log of transactions on your bank statement. These events are immutable and stored in an append-only event store. The core idea is that an application's state can be derived by replaying events in the order they occurred, just like you can get your current bank balance by replaying all the transactions from the beginning. This makes Event Sourcing particularly useful for applications that require a high degree of audibility and traceability.</p><p>Every change to the application state is captured as an event object in an Event Sourcing system. These events are then stored in an event store, a database optimized for handling event data. Here's a step-by-step breakdown of how Event Sourcing works:</p><ol></ol><p>Reconstructing the state from events involves reading all the events related to an entity from the event store and applying them in sequence to reconstruct the current state. It's like simulating all the changes that have occurred to construct the current state. For example, consider an e-commerce application where an order goes through various states like \"Created,\" \"Paid,\" and \"Shipped.\" To determine the current state of an order, you would:</p><ol><li><p>Retrieve all events related to the order from the event store.</p></li><li><p>Initialize an empty order object.</p></li><li><p>Apply each event to the order object in the order in which they were stored.</p></li></ol><p>By the end of this process, the order object will reflect the current state of the order.</p><p>As the number of events grows, replaying the entire event stream to reconstruct the state can become slow and inefficient. This is where snapshots come in. A snapshot is a saved state of an entity at a specific point in time. Instead of replaying all events from the beginning, the application can load the latest snapshot and then replay only the events that occurred after the snapshot was taken. </p><ul></ul><ul></ul><p><em>If you enjoyed this article, please hit the ‚ù§Ô∏è like button.</em></p><p><em>If you think someone else will benefit from this, then please üîÅ share this post.</em></p>","contentLength":2380,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1iq20v8/what_is_event_sourcing/"},{"title":"Chinese Vice Minister says China and the US must work together to control rogue AI: \"If not... I am afraid that the probability of the machine winning will be high.\"","url":"https://www.scmp.com/news/china/diplomacy/article/3298267/china-and-us-should-team-rein-risks-runaway-ai-former-diplomat-says","date":1739622429,"author":"/u/MetaKnowing","guid":632,"unread":true,"content":"<div datatype=\"p\" data-qa=\"Component-Component\">A former senior Chinese diplomat has called for China and the US to work together to head off the risks of rapid advances in <a target=\"_self\" href=\"https://www.scmp.com/topics/artificial-intelligence?module=inline&amp;pgtype=article\" data-qa=\"BaseLink-renderAnchor-StyledAnchor\"></a> (AI).</div><p datatype=\"p\" data-qa=\"Component-Component\">But the prospect of cooperation was bleak as geopolitical tensions rippled out through the technological landscape, former Chinese foreign vice-minister Fu Ying told a closed-door AI governing panel in Paris on Monday.</p><p datatype=\"p\" data-qa=\"Component-Component\">‚ÄúRealistically, many are not optimistic about US-China AI collaboration, and the tech world is increasingly subject to geopolitical distractions,‚Äù Fu said.</p><p datatype=\"p\" data-qa=\"Component-Component\">‚ÄúAs long as China and the US can cooperate and work together, they can always find a way to control the machine. [Nevertheless], if the countries are incompatible with each other ... I am afraid that the probability of the machine winning will be high.‚Äù</p><div datatype=\"p\" data-qa=\"Component-Component\">The panel discussion is part of a two-day global <a target=\"_self\" href=\"https://www.scmp.com/news/world/europe/article/3297992/trumps-ai-ambition-and-chinas-deepseek-overshadow-major-ai-summit-paris?module=Europe&amp;pgtype=section?module=inline&amp;pgtype=article\" data-qa=\"BaseLink-renderAnchor-StyledAnchor\"></a> that started in Paris on Monday.</div><p datatype=\"p\" data-qa=\"Component-Component\">Other panel members included Yoshua Bengio, the Canadian computer scientist recognised as a pioneer in the field, and Alondra Nelson, a central AI policy adviser to former US president Joe Biden‚Äôs administration and the United Nations.</p>","contentLength":1084,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/artificial/comments/1iq0b4t/chinese_vice_minister_says_china_and_the_us_must/"},{"title":"[P] Daily ArXiv filtering powered by LLM judge","url":"https://www.reddit.com/r/MachineLearning/comments/1ipz934/p_daily_arxiv_filtering_powered_by_llm_judge/","date":1739618056,"author":"/u/MadEyeXZ","guid":634,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Go Nullable with Generics v2.0.0 - now supports omitzero","url":"https://github.com/LukaGiorgadze/gonull","date":1739617221,"author":"/u/Money-Relative-1184","guid":613,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1ipz22f/go_nullable_with_generics_v200_now_supports/"},{"title":"what do you use golang for?","url":"https://www.reddit.com/r/golang/comments/1ipykyd/what_do_you_use_golang_for/","date":1739615068,"author":"/u/Notalabel_4566","guid":617,"unread":true,"content":"<p>Is there any other major use than web development?</p>","contentLength":50,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Show HN: Kreuzberg ‚Äì Modern async Python library for document text extraction","url":"https://github.com/Goldziher/kreuzberg","date":1739614043,"author":"nhirschfeld","guid":325,"unread":true,"content":"<p>I'm excited to showcase Kreuzberg!</p><p>Kreuzberg is a modern Python library built from the ground up with async/await, type hints, and optimized I/O handling.</p><p>It provides a unified interface for extracting text from documents (PDFs, images, office files) without external API dependencies.</p><p>Key technical features:\n- Built with modern Python best practices (async/await, type hints, functional-first)\n- Optimized async I/O with anyio for multi-loop compatibility\n- Smart worker process pool for CPU-bound tasks (OCR, doc conversion)\n- Efficient batch processing with concurrent extractions\n- Clean error handling with context-rich exceptions</p><p>I built this after struggling with existing solutions that were either synchronous-only, required complex deployments, or had poor async support. The goal was to create something that works well in modern async Python applications, can be easily dockerized or used in serverless contexts, and relies only on permissive OSS.</p><p>Key advantages over alternatives:\n- True async support with optimized I/O\n- Minimal dependencies (much smaller than alternatives)\n- Perfect for serverless and async web apps\n- Local processing without API calls\n- Built for modern Python codebases with rigorous typing and testing</p><p>The library is MIT licensed and open to contributions.</p>","contentLength":1289,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=43057375"},{"title":"Lessons from David Lynch: A Software Developer's Perspective","url":"https://lackofimagination.org/2025/02/lessons-from-david-lynch-a-software-developers-perspective/","date":1739612430,"author":"/u/aijan1","guid":642,"unread":true,"content":"<p>David Lynch passed away in January 2025, shortly after being evacuated from his Los Angeles home due to the Southern California wildfires. He‚Äôs perhaps best known for the groundbreaking TV series <a href=\"https://en.wikipedia.org/wiki/Twin_Peaks\">Twin Peaks</a>, which inspired countless shows, including The X-Files, The Sopranos, and Lost.</p><p>Lynch was genuinely a good human being who cared deeply for his actors and crew. He discovered extraordinary talent like Naomi Watts, who had struggled to land a major role in a Hollywood movie after 10 years of auditioning. From the interviews he gave, it quickly becomes apparent that he respected people of all kinds and never put anyone down ‚Äì even those who truly deserved it.</p><p>Lynch is famous for refusing to explain his movies. Although not a fan of his previous work, the great film critic Roger Ebert once wrote that <a href=\"https://en.wikipedia.org/wiki/Mulholland_Drive_(film)\">Mulholland Drive</a> remained compulsively watchable while refusing to yield to interpretation.</p><p>While Lynch offered very little in terms of what his movies meant, he was generous in sharing his views on creativity, work, and life in general. As a tribute to Lynch, I‚Äôd like to share my perspective on his life lessons from a software developer‚Äôs viewpoint.</p><blockquote><p>Ideas are like fish. If you want to catch little fish, you can stay in the shallow water. But if you want to catch the big fish, you‚Äôve got to go deeper.</p></blockquote><p>We‚Äôve all got hundreds or even thousands of ideas floating around in our brains. But the really big ones are few and far between. Once you catch a good one ‚Äìbecause they‚Äôre so rare‚Äì write it down immediately, says Lynch. From there, ideas attract other ideas and start to grow from their initial seed state. The final job is to translate those ideas into a medium, whether it‚Äôs a film, a painting, or software.</p><blockquote><p>The idea is the whole thing. If you stay true to the idea, it tells you everything you need to know, really. You just keep working to make it look like that idea looked, feel like it felt, sound like it sounded, and be the way it was.</p></blockquote><p>Software development is part art, part engineering. We don‚Äôt build the same software over and over again ‚Äì virtually all software is crafted by hand, sometimes with help from AI. If you ask two developers to create a non-trivial program, it‚Äôs very likely that the programs they produce will be different, even if the functionality is the same. Under the hood, the programming language, data structures, and overall architecture may be completely different. And on the surface, the user interfaces may look nothing alike.</p><p>It‚Äôs a good habit to listen to what users have to say, but they often can only describe their problems ‚Äì they rarely come up with good ideas to solve them. And that‚Äôs OK. It‚Äôs our job to find the right ideas, implement them well, and solve tricky problems in a way we, and hopefully the users, will love.</p><blockquote><p>My friend Bushnell Keeler, who was really responsible for me wanting to be a painter, said you need four hours of uninterrupted time to get one hour of good painting in, and that is really true.</p></blockquote><p>Like other creative fields, writing code requires deep concentration. We need to hold complex structures in our minds while working through problems. Switching between coding and other tasks disrupts  ‚Äì that magical state of mind where we lose track of time and produce code effortlessly. That‚Äôs why many developers hate meetings ‚Äì they are toxic to our productivity.</p><blockquote><p>I believe you need technical knowledge. And also, it‚Äôs really, really great to learn by doing. So, you should make a film.</p></blockquote><p>Software development is one of those rare fields where a college degree isn‚Äôt required to succeed. Yes, we should all know the basics, but in my experience, new college graduates often lack the practical knowledge to be effective developers.</p><p>The real learning happens through hands-on experience: building real projects, debugging tricky problems, collaborating with teams, and maintaining code over time. It‚Äôs crucial to never stop learning, experimenting, and iterating on our craft.</p><blockquote><p>Happy accidents are real gifts, and they can open the door to a future that didn‚Äôt even exist.</p></blockquote><p>Tim Berners-Lee invented the web in 1989, while working at CERN, the European Organization for Nuclear Research. Originally conceived to meet the demand for information sharing between scientists around the world, the web went mainstream within just a few years.</p><p>Linus Torvalds created Git due to a licensing dispute over BitKeeper, the original version control system used for Linux development. The need for a new tool led to Git becoming the most widely used version control system today.</p><blockquote><p>I feel that a set should be like a happy family. Almost like Thanksgiving every day, happily going down the road together.</p></blockquote><p>Be kind to your teammates, don‚Äôt embarrass them. They may not be perfect, but accept them for who they are. The most important trait of an effective software development team is psychological safety ‚Äìthat is, team members feel safe to take risks and be vulnerable in front of each other, as corroborated by <a href=\"https://rework.withgoogle.com/en/guides/understanding-team-effectiveness\">Google‚Äôs research</a> on the subject.</p><p>It‚Äôs OK to make mistakes, as long as you learn from them. Knowing that your team has your back when things go south is a wonderful feeling.</p><blockquote><p>Most of Hollywood is about making money - and I love money, but I don‚Äôt make the films thinking about money.</p></blockquote><p>Just like Lynch prioritizes creativity over financial gain, some of the most impactful software projects started with an open source model, and they literally changed the world, such as Linux, PostgreSQL, and Node.js, just to name a few.</p><p>What makes these projects remarkable is that they didn‚Äôt emerge from corporate boardrooms ‚Äì they were built by communities of passionate developers, collaborating across the world.</p><p>Money is just a means to an end. Unfortunately, many get this confused.</p><p>David, thank you for making the world a better place!</p>","contentLength":5845,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ipy01t/lessons_from_david_lynch_a_software_developers/"},{"title":"[D] What's the most promising successor to the Transformer?","url":"https://www.reddit.com/r/MachineLearning/comments/1ipvau4/d_whats_the_most_promising_successor_to_the/","date":1739600221,"author":"/u/jsonathan","guid":636,"unread":true,"content":"<p>All I know about is MAMBA, which looks promising from an efficiency perspective (inference is linear instead of quadratic), but AFAIK nobody's trained a big model yet. There's also <a href=\"https://arxiv.org/pdf/2405.04517\">xLSTM</a> and <a href=\"https://arxiv.org/pdf/2405.13956\">Aaren</a>.</p><p>What do y'all think is the most promising alternative architecture to the transformer?</p>","contentLength":283,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Kafka Delay Queue: When Messages Need a Nap Before They Work","url":"https://beyondthesyntax.substack.com/p/kafka-delay-queue-when-messages-need","date":1739596108,"author":"/u/Sushant098123","guid":641,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ipu9n3/kafka_delay_queue_when_messages_need_a_nap_before/"},{"title":"Webassembly and go 2025","url":"https://www.reddit.com/r/golang/comments/1ipu4wd/webassembly_and_go_2025/","date":1739595637,"author":"/u/KosekiBoto","guid":616,"unread":true,"content":"<div><p>so I found <a href=\"https://www.youtube.com/watch?v=HShIpUgCPp4\">this video </a>and was thinking about doing something similar for my game as a means to implement modding, however I also stumbled upon a 3 y/o post when looking into it essentially stating that it's a bad idea and I wasn't able to really find anything on the state of go wasm, so can someone please enlighten me as to the current state of WASM and Go, thank you</p></div>   submitted by   <a href=\"https://www.reddit.com/user/KosekiBoto\"> /u/KosekiBoto </a>","contentLength":402,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Vq: A Vector Quantization Library for Rust ü¶Ä","url":"https://www.reddit.com/r/rust/comments/1ipu2jg/vq_a_vector_quantization_library_for_rust/","date":1739595392,"author":"/u/West-Bottle9609","guid":619,"unread":true,"content":"<p>I've created a Rust library called Vq that implements several <a href=\"https://en.wikipedia.org/wiki/Vector_quantization\">vector quantization</a> algorithms. At the moment, these algorithms include binary, scalar, product, optimized product, tree-structured, and residual quantization. I think the library can be useful for tasks like data compression, similarity search, creating RAG pipelines, and speeding up machine learning computations.</p><p>This is my second Rust project, as I'm currently learning Rust. I'd like to get some feedback from the community and hear about any use cases you might have for the library, so I'm making this announcement.</p><p>The library is available on crates.io: <a href=\"https://crates.io/crates/vq\">vq</a>, and the source code is on GitHub: <a href=\"https://github.com/habedi/vq\">vq</a>.</p>","contentLength":664,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Modern Java Deep Dive","url":"https://www.youtube.com/watch?v=z4qsidg261E","date":1739591964,"author":"/u/BlueGoliath","guid":637,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ipt4pe/modern_java_deep_dive/"},{"title":"Bringing Nest.js to Rust: Meet Toni.rs, the Framework You‚Äôve Been Waiting For! üöÄ","url":"https://www.reddit.com/r/rust/comments/1iprsmo/bringing_nestjs_to_rust_meet_tonirs_the_framework/","date":1739587338,"author":"/u/Mysterious-Rust","guid":622,"unread":true,"content":"<p>As a Rust developer coming from TypeScript, I‚Äôve been missing a Nest.js-like framework ‚Äî its modularity, dependency injection, and CLI superpowers. But since the Rust ecosystem doesn‚Äôt have a direct counterpart (yet!), I decided to build one myself! üõ†Ô∏è</p><p>Introducing‚Ä¶ <a href=\"https://crates.io/crates/toni\">Toni.rs</a> ‚Äî a Rust framework inspired by the Nest.js architecture, designed to bring the same developer joy to our favorite language. And it‚Äôs live in beta! üéâ</p><p>Here‚Äôs what makes this project interesting:</p><p>Scalable maintainability üß©:</p><p>A modular architecture keeps your business logic decoupled and organized. Say goodbye to spaghetti code ‚Äî each module lives in its own context, clean and focused.</p><p>Need a complete CRUD setup? Just run a single CLI command. And I have lots of ideas for CLI ease. Who needs copy and paste?</p><p>Automatic Dependency Injection ü§ñ:</p><p>Stop wasting time wiring dependencies. Declare your providers, add them to your structure, and let the framework magically inject them. Less boilerplate, more coding.</p><p>Leave your thoughts below ‚Äî suggestions, questions, or even just enthusiasm! üöÄ </p>","contentLength":1089,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"How I Became A Machine Learning Engineer (No CS Degree, No Bootcamp)","url":"https://towardsdatascience.com/how-i-became-a-machine-learning-engineer-no-cs-degree-no-bootcamp/","date":1739586781,"author":"Egor Howell","guid":11,"unread":true,"content":"<p>Machine learning and <a href=\"https://towardsdatascience.com/tag/ai/\" title=\"AI\">AI</a> are among the most popular topics nowadays, especially within the tech space. I am fortunate enough to work and develop with these technologies every day as a machine learning engineer!</p><p>In this article, I will walk you through my journey to becoming a machine learning engineer, shedding some light and advice on how you can become one yourself!</p><p>In one of my previous articles, I extensively wrote about my journey from school to securing my first <a href=\"https://towardsdatascience.com/tag/data-science/\" title=\"Data Science\">Data Science</a> job. I recommend you <a href=\"https://medium.com/towards-data-science/how-i-became-a-data-scientist-no-cs-degree-no-bootcamp-82c321904986\">check out that article</a>, but I will summarise the key timeline here.</p><p>Pretty much everyone in my family studied some sort of STEM subject. My great-grandad was an engineer, both my grandparents studied physics, and my mum is a maths teacher.</p><p><em>So, my path was always paved for me.</em></p><p>I chose to study physics at university after watching The Big Bang Theory at age 12; it‚Äôs fair to say everyone was very proud!</p><p>At school, I wasn‚Äôt dumb by any means. I was actually relatively bright, but I didn‚Äôt fully apply myself. I got decent grades, but definitely not what I was fully capable of.</p><p>I was very arrogant and thought I would do well with zero work.</p><p>I applied to top universities like Oxford and Imperial College, but given my work ethic, I was delusional thinking I had a chance. On results day, I ended up in clearing as I missed my offers. This was probably one of the saddest days of my life.</p><p>Clearing in the UK is where universities offer places to students on certain courses where they have space. It‚Äôs mainly for students who don‚Äôt have a university offer.</p><p>I was lucky enough to be offered a chance to study physics at the University of Surrey, and I went on to earn a first-class master‚Äôs degree in physics!</p><p>There is genuinely no substitute for hard work. It is a cringy cliche, but it is true!</p><p>My original plan was to do a PhD and be a full-time researcher or professor, but during my degree, I did a research year, and I just felt a career in research was not for me. Everything moved so slowly, and it didn‚Äôt seem there was much opportunity in the space.</p><p>During this time, DeepMind released their<a href=\"https://www.youtube.com/watch?v=WXuK6gekU1Y&amp;t=1539s\"></a>documentary on YouTube, which popped up on my home feed.</p><p>From the video, I started to understand how AI worked and learn about neural networks, reinforcement learning, and deep learning. To be honest, to this day I am still not an expert in these areas.</p><p>Naturally, I dug deeper and found that a data scientist uses AI and machine learning algorithms to solve problems. I immediately wanted in and started applying for data science graduate roles.</p><p>I spent countless hours coding, taking courses, and working on projects. I applied to and eventually landed my first data science graduate scheme in September 2021.</p><p><em>You can hear more about my journey from a <a href=\"https://tobeadatascientist.substack.com/p/overcoming-rejection-lessons-from-egor-howell\">podcast</a>.</em></p><p>I started my career in an insurance company, where I built various supervised learning models, mainly using gradient boosted tree packages like CatBoost, XGBoost, and<a href=\"https://medium.com/towards-data-science/breaking-down-generalized-linear-models-d9212526e51d?sk=fda0298cebcb8e9e0c20cb6af8ed4f06\"> generalised linear models (GLMs)</a>.</p><p>I built models to predict:</p><ul><li>‚Ää‚Äî‚ÄäDid someone fraudulently make a claim to profit.</li><li>‚Äî‚ÄäWhat‚Äôs the premium we should give someone.</li><li>‚Äî‚ÄäHow many claims will someone have.</li><li>‚Ää‚Äî‚ÄäWhat‚Äôs the average claim value someone will have.</li></ul><p>I made around six models spanning the regression and classification space. I learned so much here, especially in statistics, as I worked very closely with Actuaries, so my maths knowledge was excellent.</p><p>However, due to the company‚Äôs structure and setup, it was difficult for my models to advance past the PoC stage, so I felt I lacked the ‚Äútech‚Äù side of my toolkit and understanding of how companies use machine learning in production.</p><p>After a year, my previous employer reached out to me asking if I wanted to apply to a junior data scientist role that specialises in<a href=\"https://medium.com/@egorhowell/list/time-series-00bbfb9f5359\"> time series forecasting</a> and<a href=\"https://medium.com/@egorhowell/list/optimisation-algorithms-069bf9c6c8d5\"> optimisation</a> problems. I really liked the company, and after a few interviews, I was offered the job!</p><p>I worked at this company for about 2.5 years, where I became an expert in forecasting and combinatorial optimisation problems.</p><p>I developed many algorithms and deployed my models to production through AWS using software engineering best practices, such as unit testing, lower environment, shadow system, CI/CD pipelines, and much more.</p><p><em>Fair to say I learned a lot.&nbsp;</em></p><p>I worked very closely with software engineers, so I picked up a lot of engineering knowledge and continued self-studying machine learning and statistics on the side.</p><p>Over time, I realised the actual value of data science is using it to make live decisions. There is a good quote by<a href=\"https://www.linkedin.com/posts/pau-labarta-bajo-4432074b_machinelearning-mlops-realworldml-activity-7195694289178214400-gZyw\"> Pau Labarta Bajo</a></p><p>ML models inside Jupyter notebooks have a business value of $0</p><p>There is no point in building a really complex and sophisticated model if it will not produce results. Seeking out that extra 0.1% accuracy by staking multiple models is often not worth it.</p><p>You are better off building something simple that you can deploy, and that will bring real financial benefit to the company.</p><p>With this in mind, I started thinking about the future of data science. In my head, there are two avenues:</p><ul><li> -&gt; You work primarily to gain insight into what the business should be doing and what it should be looking into to boost its performance.</li><li> -&gt; You ship solutions (models, decision algorithms, etc.) that bring business value.</li></ul><p>I feel the data scientist who analyses and builds PoC models will become extinct in the next few years because, as we said above, they don‚Äôt provide tangible value to a business.</p><p>That‚Äôs not to say they are entirely useless; you have to think of it from the business perspective of their return on investment. Ideally, the value you bring in should be more than your salary.</p><p>You want to say that you did ‚ÄúX that produced Y‚Äù, which the above two avenues allow you to do.</p><p>The engineering side was the most interesting and enjoyable for me. I genuinely enjoy coding and building stuff that benefits people, and that they can use, so naturally, that‚Äôs where I gravitated towards.</p><p>To move to the ML engineering side, I asked my line manager if I could deploy the algorithms and ML models I was building myself. I would get help from software engineers, but I would write all the production code, do my own system design, and set up the deployment process independently.</p><p><em>And that‚Äôs exactly what I did.</em></p><p>Coincidentally, my current employer contacted me around this time and asked if I wanted to apply for a machine learning engineer role that specialises in general ML and optimisation at their company!</p><p>Call it luck, but clearly, the universe was telling me something. After several interview rounds, I was offered the role, and I am now a fully fledged machine learning engineer!</p><p>Fortunately, a role kind of ‚Äúfell to me,‚Äù but I created my own luck through up-skilling and documenting my learning. That is why I always tell people to show their work‚Ää‚Äî‚Ääyou don‚Äôt know what may come from it.</p><p>I want to share the main bits of advice that helped me transition from a machine learning engineer to a data scientist.</p><ul><li>‚Ää‚Äî‚ÄäA machine learning engineer is  an entry-level position in my opinion. You need to be well-versed in data science, machine learning, software engineering, etc. You don‚Äôt need to be an expert in all of them, but have good fundamentals across the board. That‚Äôs why I recommend having a couple of years of experience as either a software engineer or data scientist and self-study other areas.</li><li>‚Ää‚Äî‚ÄäIf you are from data science, you must learn to write good, well-tested production code. You must know things like typing, linting, unit tests, formatting, mocking and CI/CD. It‚Äôs not too difficult, but it just requires some practice. I recommend asking your current company to work with software engineers to gain this knowledge, it worked for me!</li><li>‚Ää‚Äî‚ÄäMost companies nowadays deploy many of their architecture and systems on the cloud, and machine learning models are no exception. So, it‚Äôs best to get practice with these tools and understand how they enable models to go live. I learned most of this on the job, to be honest, but there are courses you can take.</li><li>‚Ää‚Äî‚ÄäI am sure most of you know this already, but every tech professional should be proficient in the command line. You will use it extensively when deploying and writing production code. I have a basic guide you can checkout<a href=\"https://medium.com/towards-data-science/an-introduction-to-the-shell-676ee5b899df?sk=0c6e101165b4314b98ab39d11525366c\"> here</a>.</li><li><strong>Data Structures &amp; Algorithms‚Ää</strong>‚Äî‚ÄäUnderstanding the fundamental algorithms in computer science are very useful for MLE roles. Mainly because you will likely be asked about it in interviews. It‚Äôs not too hard to learn compared to machine learning; it just takes time. Any course will do the trick.</li><li>‚Ää‚Äî‚ÄäAgain, most tech professionals should know Git, but as an MLE, it is essential. How to squash commits, do code reviews, and write outstanding pull requests are musts.</li><li>‚Ää‚Äî‚ÄäMany MLE roles I saw required you to have some specialisation in a particular area. I specialise in time series forecasting, optimisation, and general ML based on my previous experience. This helps you stand out in the market, and most companies are looking for specialists nowadays.</li></ul><p>The main theme here is that I basically up-skilled my software engineering abilities. This makes sense as I already had all the math, stats, and machine learning knowledge from being a data scientist.</p><p>If I were a software engineer, the transition would likely be the reverse. This is why securing a machine learning engineer role can be quite challenging, as it requires proficiency across a wide range of skills.</p><h3><strong>Summary &amp; Further Thoughts</strong></h3><p>I have a free newsletter, <a href=\"https://dishingthedata.substack.com/\"></a>, where I share weekly tips and advice as a practising data scientist. Plus, when you subscribe, you will get my and<strong> short PDF version of my AI roadmap</strong>!</p>","contentLength":9683,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Introducing Impressions at Netflix","url":"https://netflixtechblog.com/introducing-impressions-at-netflix-e2b67c88c9fb?source=rss----2615bd06b42e---4","date":1739582000,"author":"Netflix Technology Blog","guid":39,"unread":true,"content":"<h4>Part 1: Creating the Source of Truth for Impressions</h4><p>Imagine scrolling through Netflix, where each movie poster or promotional banner competes for your attention. Every image you hover over isn‚Äôt just a visual placeholder; it‚Äôs a critical data point that fuels our sophisticated personalization engine. At Netflix, we call these images ‚Äòimpressions,‚Äô and they play a pivotal role in transforming your interaction from simple browsing into an immersive binge-watching experience, all tailored to your unique&nbsp;tastes.</p><p>Capturing these moments and turning them into a personalized journey is no simple feat. It requires a state-of-the-art system that can track and process these impressions while maintaining a detailed history of each profile‚Äôs exposure. This nuanced integration of data and technology empowers us to offer bespoke content recommendations.</p><p>In this multi-part blog series, we take you behind the scenes of our system that processes billions of impressions daily. We will explore the challenges we encounter and unveil how we are building a resilient solution that transforms these client-side impressions into a personalized content discovery experience for every Netflix&nbsp;viewer.</p><h3>Why do we need impression history?</h3><p>To tailor recommendations more effectively, it‚Äôs crucial to track what content a user has already encountered. Having impression history helps us achieve this by allowing us to identify content that has been displayed on the homepage but not engaged with, helping us deliver fresh, engaging recommendations.</p><p>By maintaining a history of impressions, we can implement frequency capping to prevent over-exposure to the same content. This ensures users aren‚Äôt repeatedly shown identical options, keeping the viewing experience vibrant and reducing the risk of frustration or disengagement.</p><h4>Highlighting New&nbsp;Releases</h4><p>For new content, impression history helps us monitor initial user interactions and adjust our merchandising efforts accordingly. We can experiment with different content placements or promotional strategies to boost visibility and engagement.</p><p>Additionally, impression history offers insightful information for addressing a number of platform-related analytics queries. Analyzing impression history, for example, might help determine how well a specific row on the home page is functioning or assess the effectiveness of a merchandising strategy.</p><p>The first pivotal step in managing impressions begins with the creation of a Source-of-Truth (SOT) dataset. This foundational dataset is essential, as it supports various downstream workflows and enables a multitude of use&nbsp;cases.</p><h4>Collecting Raw Impression Events</h4><p>As Netflix members explore our platform, their interactions with the user interface spark a vast array of raw events. These events are promptly relayed from the client side to our servers, entering a centralized event processing queue. This queue ensures we are consistently capturing raw events from our global user&nbsp;base.</p><p>After raw events are collected into a centralized queue, a custom event extractor processes this data to identify and extract all impression events. These extracted events are then routed to an Apache Kafka topic for immediate processing needs and simultaneously stored in an Apache Iceberg table for long-term retention and historical analysis. This dual-path approach leverages Kafka‚Äôs capability for low-latency streaming and Iceberg‚Äôs efficient management of large-scale, immutable datasets, ensuring both real-time responsiveness and comprehensive historical data availability.</p><h4>Filtering &amp; Enriching Raw Impressions</h4><p>Once the raw impression events are queued, a stateless Apache Flink job takes charge, meticulously processing this data. It filters out any invalid entries and enriches the valid ones with additional metadata, such as show or movie title details, and the specific page and row location where each impression was presented to users. This refined output is then structured using an Avro schema, establishing a definitive source of truth for Netflix‚Äôs impression data. The enriched data is seamlessly accessible for both real-time applications via Kafka and historical analysis through storage in an Apache Iceberg table. This dual availability ensures immediate processing capabilities alongside comprehensive long-term data retention.</p><h4>Ensuring High Quality Impressions</h4><p>Maintaining the highest quality of impressions is a top priority. We accomplish this by gathering detailed column-level metrics that offer insights into the state and quality of each impression. These metrics include everything from validating identifiers to checking that essential columns are properly filled. The data collected feeds into a comprehensive quality dashboard and supports a tiered threshold-based alerting system. These alerts promptly notify us of any potential issues, enabling us to swiftly address regressions. Additionally, while enriching the data, we ensure that all columns are in agreement with each other, offering in-place corrections wherever possible to deliver accurate&nbsp;data.</p><p>We handle a staggering volume of 1 to 1.5 million impression events globally every second, with each event approximately 1.2KB in size. To efficiently process this massive influx in real-time, we employ Apache Flink for its low-latency stream processing capabilities, which seamlessly integrates both batch and stream processing to facilitate efficient backfilling of historical data and ensure consistency across real-time and historical analyses. Our Flink configuration includes 8 task managers per region, each equipped with 8 CPU cores and 32GB of memory, operating at a parallelism of 48, allowing us to handle the necessary scale and speed for seamless performance delivery. The Flink job‚Äôs sink is equipped with a data mesh connector, as detailed in our <a href=\"https://netflixtechblog.com/data-mesh-a-data-movement-and-processing-platform-netflix-1288bcab2873\">Data Mesh platform</a> which has two outputs: Kafka and Iceberg. This setup allows for efficient streaming of real-time data through Kafka and the preservation of historical data in Iceberg, providing a comprehensive and flexible data processing and storage solution.</p><p>We utilize the ‚Äòisland model‚Äô for deploying our Flink jobs, where all dependencies for a given application reside within a single region. This approach ensures high availability by isolating regions, so if one becomes degraded, others remain unaffected, allowing traffic to be shifted between regions to maintain service continuity. Thus, all data in one region is processed by the Flink job deployed within that&nbsp;region.</p><h4>Addressing the Challenge of Unschematized Events</h4><p>Allowing raw events to land on our centralized processing queue unschematized offers significant flexibility, but it also introduces challenges. Without a defined schema, it can be difficult to determine whether missing data was intentional or due to a logging error. We are investigating solutions to introduce schema management that maintains flexibility while providing clarity.</p><h4>Automating Performance Tuning with Autoscalers</h4><p>Tuning the performance of our Apache Flink jobs is currently a manual process. The next step is to integrate with autoscalers, which can dynamically adjust resources based on workload demands. This integration will not only optimize performance but also ensure more efficient resource utilization.</p><h4>Improving Data Quality&nbsp;Alerts</h4><p>Right now, there‚Äôs a lot of business rules dictating when a data quality alert needs to be fired. This leads to a lot of false positives that require manual judgement. A lot of times it is difficult to track changes leading to regression due to inadequate data lineage information. We are investing in building a comprehensive data quality platform that more intelligently identifies anomalies in our impression stream, keeps track of data lineage and data governance, and also, generates alerts notifying producers of any regressions. This approach will enhance efficiency, reduce manual oversight, and ensure a higher standard of data integrity.</p><p>Creating a reliable source of truth for impressions is a complex but essential task that enhances personalization and discovery experience. Stay tuned for the next part of this series, where we‚Äôll delve into how we use this SOT dataset to create a microservice that provides impression histories. We invite you to share your thoughts in the comments and continue with us on this journey of discovering impressions.</p><p>We are genuinely grateful to our amazing colleagues whose contributions were essential to the success of Impressions: Julian Jaffe, Bryan Keller, Yun Wang, Brandon Bremen, Kyle Alford, Ron Brown and Shriya&nbsp;Arora.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=e2b67c88c9fb\" width=\"1\" height=\"1\" alt=\"\">","contentLength":8607,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Tabiew 0.8.4 Released","url":"https://www.reddit.com/r/rust/comments/1ipp72r/tabiew_084_released/","date":1739578902,"author":"/u/shshemi","guid":623,"unread":true,"content":"<p>Tabiew is a lightweight TUI application that allows users to view and query tabular data files, such as CSV, Parquet, Arrow, Sqlite, and ...</p><ul><li>üìä Support for CSV, Parquet, JSON, JSONL, Arrow, FWF, and Sqlite</li><li>üóÇÔ∏è Multi-table functionality</li></ul><ul><li>UI is updated to be more modern and responsive</li><li>Horizontally scrollable tables</li><li>Visible data frame can be referenced with name \"_\"</li><li>Compatibility with older versions of glibc</li><li>Two new themes (Tokyo Night and Catppuccin)</li></ul>","contentLength":450,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Conditional types in TypeScript","url":"https://2ality.com/2025/02/conditional-types-typescript.html","date":1739577600,"author":"Dr. Axel Rauschmayer","guid":353,"unread":true,"content":"<p>In TypeScript, conditional types let us make decisions (think if-then-else expressions) ‚Äì which is especially useful in generic types. They are also an essential tool for working with union types because they let use ‚Äúloop‚Äù over them. Read on if you want to know how all of that works.</p>","contentLength":291,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Show HN: VimLM ‚Äì A Local, Offline Coding Assistant for Vim","url":"https://github.com/JosefAlbers/VimLM","date":1739576081,"author":"JosefAlbers","guid":324,"unread":true,"content":"<p>VimLM is a local, offline coding assistant for Vim. It‚Äôs like Copilot but runs entirely on your machine‚Äîno APIs, no tracking, no cloud.</p><p>- Deep Context: Understands your codebase (current file, selections, references).  \n- Conversational: Iterate with follow-ups like \"Add error handling\".  \n- Vim-Native: Keybindings like `Ctrl-l` for prompts, `Ctrl-p` to replace code.  \n- Inline Commands: `!include` files, `!deploy` code, `!continue` long responses.</p><p>Perfect for privacy-conscious devs or air-gapped environments.</p><p>Try it:  \n```\npip install vimlm\nvimlm\n```</p>","contentLength":558,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=43054244"},{"title":"GOGC & GOMEMLIMIT ?","url":"https://www.reddit.com/r/golang/comments/1ipnxxk/gogc_gomemlimit/","date":1739575182,"author":"/u/mistyrouge","guid":614,"unread":true,"content":"<div><p>If the GC cost is fixed with regards to the amount of memory being freed up. Why would I not want to put  and  to say 70% of the memory I have available? Specially in an application that is known to be cpu bound.</p></div>   submitted by   <a href=\"https://www.reddit.com/user/mistyrouge\"> /u/mistyrouge </a>","contentLength":245,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Dell Nears $5 Billion AI Server Deal for Elon Musk‚Äôs xAI","url":"https://www.bnnbloomberg.ca/business/technology/2025/02/14/dell-nears-us5-billion-ai-server-deal-for-elon-musks-xai/","date":1739571937,"author":"/u/F0urLeafCl0ver","guid":631,"unread":true,"content":"<p>(Bloomberg) -- Dell Technologies Inc. is in advanced stages of securing a deal worth more than $5 billion to provide Elon Musk‚Äôs xAI with servers optimized for artificial intelligence work.</p><p>The company will sell servers containing Nvidia Corp. GB200 semiconductors to Musk‚Äôs AI startup for delivery this year, according to people familiar with the matter, who asked to not to be named because the work is private. Some details are being finalized and still may change, some of the people added.&nbsp;</p><p>Demand for computing to run AI workloads has led to a boom for makers of high-powered servers like Dell, Super Micro Computer Inc. and Hewlett Packard Enterprise Co. Musk‚Äôs companies, including carmaker Tesla Inc. and xAI, have emerged as major customers for the hardware.&nbsp;</p><p>Dell and Nvidia declined to comment. xAI didn‚Äôt respond to a request for comment.</p><p>Dell shares jumped as much as 6% to $116.88 Friday on the news before paring some gains. The stock had slipped 4.3% this year through Thursday‚Äôs close.</p><p>A supercomputer project being built by xAI in Memphis has used a mix of Dell and Super Micro servers. In December, Dell said it had deployed tens of thousands of graphics processing units, or GPUs, there and was working to win an ‚Äúunfair share‚Äù of the remaining build-out. GPUs are the key chips to power AI workloads and Nvidia is the top maker of those processing units.</p><p>Analysts expect Dell will have shipped more than $10 billion of AI servers in the fiscal year ending last month and project that value will jump to $14 billion in the fiscal year ending in January 2026. Dell is scheduled to report fiscal fourth-quarter earnings on Feb. 27, with the AI server business a major focus for investors.</p><p>The deal with xAI ‚Äúwould firmly establish the company as a leading AI-server provider and boost sales, though the impact on profitability is less clear,‚Äù wrote Woo Jin Ho, an analyst at Bloomberg Intelligence.</p><p>AI startup xAI‚Äôs main product, a chatbot called Grok, has primarily been available to paying users of X, the social network formerly known as Twitter. Firms that Musk runs are known to share employees, technology and computing power.</p><p>--With assistance from Ian King and Kurt Wagner.</p><p>(Updates with comments from analyst in the eighth paragraph.)</p>","contentLength":2274,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/artificial/comments/1ipmsdv/dell_nears_5_billion_ai_server_deal_for_elon/"},{"title":"Django Weblog: DjangoCongress JP 2025 Announcement and Live Streaming!","url":"https://www.djangoproject.com/weblog/2025/feb/14/djangocongress-jp-2025-announcement-and-livestream/","date":1739571130,"author":"","guid":285,"unread":true,"content":"<p>It will be streamed on the following YouTube Live channels:</p><p>This year there will be talks not only about Django, but also about FastAPI and other asynchronous web topics. There will also be talks on Django core development, Django Software Foundation (DSF) governance, and other topics from around the world. Simultaneous translation will be provided in both English and Japanese.</p><ul><li>The Async Django ORM: Where Is it?</li><li>Speed at Scale for Django Web Applications</li><li>Implementing Agentic AI Solutions in Django from scratch</li><li>Diving into DSF governance: past, present and future</li></ul><ul><li>Getting Knowledge from Django Hits: Using Grafana and Prometheus</li><li>Culture Eats Strategy for Breakfast: Why Psychological Safety Matters in Open Source</li><li>¬µDjango. The next step in the evolution of asynchronous microservices technology.</li></ul><p>A public viewing of the event will also be held in Tokyo. A reception will also be held, so please check the following connpass page if you plan to attend.</p>","contentLength":948,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Eli Bendersky: Decorator JITs - Python as a DSL","url":"https://eli.thegreenplace.net/2025/decorator-jits-python-as-a-dsl/","date":1739569771,"author":"","guid":284,"unread":true,"content":"<p>Spend enough time looking at Python programs and packages for machine learning,\nand you'll notice that the \"JIT decorator\" pattern is pretty popular. For\nexample, this JAX snippet:</p><div><pre></pre></div><div><pre></pre></div><p>In both cases, the function decorated with  doesn't get executed by the\nPython interpreter in the normal sense. Instead, the code inside is more like\na DSL (Domain Specific Language) processed by a special purpose compiler built\ninto the library (JAX or Triton). Another way to think about it is that Python\nis used as a  to describe computations.</p><p>In this post I will describe some implementation strategies used by libraries to\nmake this possible.</p><div><h2>Preface - where we're going</h2><p>The goal is to explain how different kinds of  decorators work by using\na simplified, educational example that implements several approaches from\nscratch. All the approaches featured in this post will be using this flow:</p> Expr IR --&gt; LLVM IR --&gt; Execution\" /&gt; Expr IR --&gt; LLVM IR --&gt; Execution\" class=\"align-center\" src=\"https://eli.thegreenplace.net/images/2025/decjit-python.png\" /&gt;\n<p>These are the steps that happen when a Python function wrapped with\nour educational  decorator is called:</p><ol><li>The function is translated to an \"expression IR\" - .</li><li>This expression IR is converted to LLVM IR.</li><li>Finally, the LLVM IR is JIT-executed.</li></ol><p>First, let's look at the  IR. Here we'll make a big simplification -\nonly supporting functions that define a single expression, e.g.:</p><div><pre></pre></div><p>Naturally, this can be easily generalized - after all, LLVM IR can be used to\nexpress fully general computations.</p><p>Here are the  data structures:</p><div><pre></pre></div><p>To convert an  into LLVM IR and JIT-execute it, we'll use this function:</p><div><pre></pre></div><p>It uses the  class to actually generate LLVM IR from .\nThis process is straightforward and covered extensively in the resources I\nlinked to earlier; take a look at <a href=\"https://github.com/eliben/code-for-blog/blob/main/2025/decjit/exprcode.py\">the full code here</a>.</p><p>My goal with this architecture is to make things simple, but .\nOn one hand - there are several simplifications: only single expressions are\nsupported, very limited set of operators, etc. It's very easy to extend this!\nOn the other hand, we could have just trivially evaluated the \nwithout resorting to LLVM IR; I do want to show a more complete compilation\npipeline, though, to demonstrate that an arbitrary amount of complexity can\nbe hidden behind these simple interfaces.</p><p>With these building blocks in hand, we can review the strategies used by\n decorators to convert Python functions into s.</p></div><div><p>Python comes with powerful code reflection and introspection capabilities out\nof the box. Here's the  decorator:</p><div><pre></pre></div><p>This is a standard Python decorator. It takes a function and returns another\nfunction that will be used in its place ( ensures that\nfunction attributes like the name and docstring of the wrapper match the\nwrapped function).</p><div><pre></pre></div><p>After  is applied to , what  holds is the\nwrapper. When  is called, the wrapper is invoked with\n.</p><p>The wrapper obtains the AST of the wrapped function, and then uses\n to convert this AST into an :</p><div><pre></pre></div><p>When  finishes visiting the AST it's given, its\n field will contain the  representing the function's\nreturn value. The wrapper then invokes  with this .</p><p>Note how our decorator interjects into the regular Python execution process.\nWhen  is called, instead of the standard Python compilation and\nexecution process (code is compiled into bytecode, which is then executed\nby the VM), we translate its code to our own representation and emit LLVM from\nit, and then JIT execute the LLVM IR. While it seems kinda pointless in this\nartificial example, in reality this means we can execute the function's code\nin any way we like.</p><div><h3>AST JIT case study: Triton</h3><p>This approach is almost exactly how the Triton language works. The body of a\nfunction decorated with  gets parsed to a Python AST, which then\n- through a series of internal IRs - ends up in LLVM IR; this in turn is lowered\nto <a href=\"https://docs.nvidia.com/cuda/parallel-thread-execution/\">PTX</a> by the\n<a href=\"https://llvm.org/docs/NVPTXUsage.html\">NVPTX LLVM backend</a>.\nThen, the code runs on a GPU using a standard CUDA pipeline.</p><p>Naturally, the subset of Python that can be compiled down to a GPU is limited;\nbut it's sufficient to run performant kernels, in a language that's much\nfriendlier than CUDA and - more importantly - lives in the same file with the\n\"host\" part written in regular Python. For example, if you want testing and\ndebugging, you can run Triton in \"interpreter mode\" which will just run the\nsame kernels locally on a CPU.</p><p>Note that Triton lets us import names from the  package\nand use them inside kernels; these serve as the  for the language\n- special calls the compiler handles directly.</p></div></div><div><p>Python is a fairly complicated language with  of features. Therefore,\nif our JIT has to support some large portion of Python semantics, it may make\nsense to leverage more of Python's own compiler. Concretely, we can have it\ncompile the wrapped function all the way <a href=\"https://github.com/python/cpython/blob/main/InternalDocs/interpreter.md\">to bytecode</a>,\nand start our translation from there.</p><p>Here's the  decorator that does just this :</p><div><pre></pre></div><p>The Python VM is a stack machine; so we emulate a stack to convert the\nfunction's bytecode to  IR (a bit like an <a href=\"https://en.wikipedia.org/wiki/Reverse_Polish_notation\">RPN evaluator</a>).\nAs before, we then use our  utility function to lower\n to LLVM IR and JIT execute it.</p><p>Using this JIT is as simple as the previous one - just swap \nfor :</p><div><pre></pre></div><div><h3>Bytecode JIT case study: Numba</h3><p><a href=\"https://numba.pydata.org/\">Numba</a> is a compiler for Python itself. The idea\nis that you can speed up specific functions in your code by slapping a\n decorator on them. What happens next is similar in spirit to\nour simple , but of course much more complicated because it\nsupports a very large portion of Python semantics.</p><p>Numba uses the Python compiler to emit bytecode, just as we did; it then\nconverts it into its own IR, and then to LLVM using .</p><p>By starting with the bytecode, Numba makes its life easier (no need to rewrite\nthe entire Python compiler). On the other hand, it also makes some analyses\n, because by the time we're in bytecode, a lot of semantic information\nexisting in higher-level representations is lost. For example, Numba has to\nsweat a bit to recover control flow information from the bytecode (by\nrunning it through a special interpreter first).</p></div></div><div><p>The two approaches we've seen so far are similar in many ways - both rely on\nPython's introspection capabilities to compile the source code of the JIT-ed\nfunction to some extent (one to AST, the other all the way to bytecode), and\nthen work on this lowered representation.</p><p>The tracing strategy is very different. It doesn't analyze the source code of\nthe wrapped function at all - instead, it  its execution by means of\nspecially-boxed arguments, leveraging overloaded operators and functions, and\nthen works on the generated trace.</p><p>The code implementing this for our smile demo is surprisingly compact:</p><div><pre></pre></div><p>Each runtime argument of the wrapped function is assigned a , and\nthat is placed in a , a placeholder class which lets us\ndo operator overloading:</p><div><pre></pre></div><p>The remaining key function is :</p><div><pre></pre></div><p>To understand how this works, consider this trivial example:</p><div><pre></pre></div><p>After the decorated function is defined,  holds the wrapper function\ndefined inside . When  is called, the wrapper runs:</p><ol><li>For each argument of  itself (that is  and ), it creates\na new  holding a . This denotes a named variable in\nthe  IR.</li><li>It then calls the wrapped function, passing it the boxes as runtime\nparameters.</li><li>When (the wrapped)  runs, it invokes . This is caught by the overloaded\n operator of , and it creates a new  with\nthe s representing  and  as children. This\n is then returned .</li><li>The wrapper unboxes the returned  and passes it to\n to emit LLVM IR from it and JIT execute it with the\nactual runtime arguments of the call: .</li></ol><p>This might be a little mind-bending at first, because there are two different\nexecutions that happen:</p><ul><li>The first is calling the wrapped  function itself, letting the Python\ninterpreter run it as usual, but with special arguments that build up the IR\ninstead of doing any computations. This is the .</li><li>The second is lowering this IR our tracing step built into LLVM IR and then\nJIT executing it with the actual runtime argument values ; this is\nthe .</li></ul><p>This tracing approach has some interesting characteristics. Since we don't\nhave to analyze the source of the wrapped functions but only trace through\nthe execution, we can \"magically\" support a much richer set of programs, e.g.:</p><div><pre></pre></div><p>This  with our basic . Since Python variables are\nplaceholders (references) for values, our tracing step is oblivious to them - it\nfollows the flow of values. Another example:</p><div><pre></pre></div><p>This also just works! The created  will be a long chain of \nadditions of 's runtime values through the loop, added to the \nfor .</p><p>This last example also leads us to a limitation of the tracing approach; the\nloop cannot be  - it cannot depend on the function's arguments,\nbecause the tracing step has no concept of runtime values and wouldn't know\nhow many iterations to run through; or at least, it doesn't know this unless\nwe want to perform the tracing run for every runtime execution .</p><div><h3>Tracing JIT case study: JAX</h3><p>The <a href=\"https://jax.readthedocs.io/en/latest/\">JAX ML framework</a> uses a tracing\napproach very similar to the one described here. The first code sample in this\npost shows the JAX notation. JAX cleverly wraps Numpy with its own version which\nis traced (similar to our , but JAX calls these boxes \"tracers\"),\nletting you write regular-feeling Numpy code that can be JIT optimized and\nexecuted on accelerators like GPUs and TPUs via <a href=\"https://github.com/openxla\">XLA</a>. JAX's tracer builds up an underlying IR (called\n<a href=\"https://jax.readthedocs.io/en/latest/jaxpr.html\">jaxpr</a>) which can then be\nemitted to XLA ops and passed to XLA for further lowering and execution.</p><p>For a fairly deep overview of how JAX works, I recommend reading the\n<a href=\"https://jax.readthedocs.io/en/latest/autodidax.html\">autodidax doc</a>.</p><p>As mentioned earlier, JAX has <a href=\"https://jax.readthedocs.io/en/latest/jit-compilation.html\">some limitations</a>\nwith things like data-dependent control flow in native Python. This won't work,\nbecause there's control flow\nthat depends on a runtime value ():</p><div><pre></pre></div><p>When  is executed, JAX will throw an exception, saying something\nlike:</p><blockquote>\nThis concrete value was not available in Python because it depends on the\nvalue of the argument count.</blockquote><p>As a remedy, JAX has its\nown built-in intrinsics from the <a href=\"https://jax.readthedocs.io/en/latest/jax.lax.html\">jax.lax package</a>.\nHere's the example rewritten in a way that actually works:</p><div><pre></pre></div><p> (and many other built-ins in the  package) is something JAX\ncan trace through, generating a corresponding XLA operation (XLA has support for\n<a href=\"https://openxla.org/xla/operation_semantics\">While loops</a>, to which this\n can be lowered).</p><p>The tracing approach has clear benefits for JAX as well; because it only cares\nabout the flow of values, it can handle arbitrarily complicated Python code,\nas long as the flow of values can be traced. Just like the local variables and\ndata-independent loops shown earlier, but also things like closures. This makes\nmeta-programming and templating easy .</p></div></div><div><p>The full code for this post is available <a href=\"https://github.com/eliben/code-for-blog/tree/main/2025/decjit\">on GitHub</a>.</p></div>","contentLength":10514,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"An art exhibit in Japan where a chained robot dog will try to attack you to showcase the need for AI safety.","url":"https://v.redd.it/sglstazd96je1","date":1739568243,"author":"/u/eternviking","guid":633,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/artificial/comments/1iple9t/an_art_exhibit_in_japan_where_a_chained_robot_dog/"},{"title":"GitHub - Clivern/Peanut: üê∫ Deploy Databases and Services Easily for Development and Testing Pipelines.","url":"https://github.com/Clivern/Peanut","date":1739567268,"author":"/u/Clivern","guid":615,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1ipl12p/github_clivernpeanut_deploy_databases_and/"},{"title":"Shutdown Go server","url":"https://www.reddit.com/r/golang/comments/1ipj5zn/shutdown_go_server/","date":1739562402,"author":"/u/Kennedy-Vanilla","guid":618,"unread":true,"content":"<div><p>Hi, recently I saw that many people shutdown their servers like this or similar</p><pre><code>serverCtx, serverStopCtx serverCtx, serverStopCtx := context.WithCancel(context.Background()) sig := make(chan os.Signal, 1) signal.Notify(sig, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT) go func() { &lt;-sig shutdownCtx, cancelShutdown := context.WithTimeout(serverCtx, 30*time.Second) defer cancelShutdown() go func() { &lt;-shutdownCtx.Done() if shutdownCtx.Err() == context.DeadlineExceeded { log.Fatal(\"graceful shutdown timed out.. forcing exit.\") } }() err := server.Shutdown(shutdownCtx) if err != nil { log.Printf(\"error shutting down server: %v\", err) } serverStopCtx() }() log.Printf(\"Server starting on port %s...\\n\", port) err = server.ListenAndServe() if err != nil &amp;&amp; err != http.ErrServerClosed { log.Printf(\"error starting server: %v\", err) os.Exit(1) } &lt;-serverCtx.Done() log.Println(\"Server stopped\") } := context.WithCancel(context.Background()) sig := make(chan os.Signal, 1) signal.Notify(sig, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT) go func() { &lt;-sig shutdownCtx, cancelShutdown := context.WithTimeout(serverCtx, 30*time.Second) defer cancelShutdown() go func() { &lt;-shutdownCtx.Done() if shutdownCtx.Err() == context.DeadlineExceeded { log.Fatal(\"graceful shutdown timed out.. forcing exit.\") } }() err := server.Shutdown(shutdownCtx) if err != nil { log.Printf(\"error shutting down server: %v\", err) } serverStopCtx() }() log.Printf(\"Server starting on port %s...\\n\", port) err = server.ListenAndServe() if err != nil &amp;&amp; err != http.ErrServerClosed { log.Printf(\"error starting server: %v\", err) os.Exit(1) } &lt;-serverCtx.Done() log.Println(\"Server stopped\") </code></pre><p>Is it necessary? Like it's so many code for the simple operation</p></div>   submitted by   <a href=\"https://www.reddit.com/user/Kennedy-Vanilla\"> /u/Kennedy-Vanilla </a>","contentLength":1805,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"the ref keyword","url":"https://www.reddit.com/r/rust/comments/1ipixny/the_ref_keyword/","date":1739561817,"author":"/u/Tickstart","guid":621,"unread":true,"content":"<p>I've made a quick mock situation which is analogous to my situation the other day:</p><pre><code>fn main() { let mut v: Option&lt;Vec&lt;usize&gt;&gt; = None; let mut h = 20; while h.ne(&amp;0) { if (h % 3).ge(&amp;1) { match v { Some(ref mut v) =&gt; (*v).push(h), None =&gt; v = Some(vec![h]) } } h -= 1 } println!(\"{v:?}\") } </code></pre><p>I was a bit confused on how it \"should\" be solved. My issue is the \"ref mut\". It made sense to me that I didn't want to consume the vector v, just add to it if it existed and I tried adding ref (then mut), which worked. When I goodled, it seemed ref was a legacy thing and not needed anymore. My question is, how is the idiomatic way to write this? Perhaps it's possible to do in a much simpler way and I just found a way to complicate it for no reason.</p><p>Also, don't worry I know this is a terrible pattern, it was mostly for tesing something.</p>","contentLength":828,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Macro-Less, Highly Integrated OpenAPI Document Generation in Rust with Ohkami","url":"https://medium.com/@kanarus786/macro-less-highly-integrated-openapi-document-generation-in-rust-with-ohkami-912de388adc1","date":1739557605,"author":"/u/kanarus","guid":620,"unread":true,"content":"<p>In Rust web dev, <a href=\"https://github.com/juhaku/utoipa\" rel=\"noopener ugc nofollow\" target=\"_blank\">utoipa</a> is the most popular crate for generating OpenAPI document from server code. While it‚Äôs a great tool, it can be frustrating due to excessive macro use.</p><p>A new web framework Ohkami offers a ,  way to generate OpenAPI document with its ‚Äúopenapi‚Äù feature.</p><p>Let‚Äôs take following code as an example. It‚Äôs the same sample from the ‚Äúopenapi‚Äù section of the README, but with openapi-related parts removed:</p><pre></pre><p>While this compiles and works as a pseudo user management server, activating ‚Äúopenapi‚Äù feature causes a compile error, telling that User and CreateUser don‚Äôt implement ohkami::openapi::Schema.</p><p>As indicated by this, Ohkami with ‚Äúopenapi‚Äù feature effectively handles type information and intelligently collects its endpoints‚Äô metadata. It allows code like:</p><pre></pre><p>to assemble metadata into an OpenAPI document and output it to a file .</p><p>Then, how we implement Schema? Actually we can easily impl Schema by hand, or just #[derive(Schema)] is available! In this case, derive is enough:</p><pre></pre><p>That‚Äôs it! Just adding these derives allows Ohkami::generate to output following file:</p><pre></pre><p>Additionally, it‚Äôs easy to define the User schema as a component instead of duplicating inline schemas. In derive, just add #[openapi(component)] helper attribute:</p><pre></pre><pre></pre><p>And  #[operation] attribute is available to set summary, description, and override operationId and each response‚Äôs description:</p><pre></pre><pre></pre><p>Let‚Äôs take a look at how this document generation works!</p><p>First, the #[derive(Schema)]s are expanded as following:</p><pre></pre><pre></pre><p>The DSL enables to easily impl manually.</p><p>Schema trait links the struct to an item of type called ‚ÄúSchemaRef‚Äù.</p><h2>2. openapi_* hooks of FromParam, FromRequest, IntoResponse</h2><p>FromParam, FromRequest and IntoResponse are Ohkami‚Äôs core traits appeared in the handler bound:</p><pre></pre><p>When ‚Äúopenapi‚Äù feature is activated, they additionally have following methods:</p><pre></pre><p>Ohkami leverages these methods in IntoHandler to generate consistent openapi::Operation, reflecting the actual handler signature like <a href=\"https://github.com/ohkami-rs/ohkami/blob/6e243ac823e21f286aca2660f9d38f7bde381c5a/ohkami/src/fang/handler/into_handler.rs#L328-L335\" rel=\"noopener ugc nofollow\" target=\"_blank\">this</a>.</p><p>Moreover, Ohkami properly propagates schema information in common cases like <a href=\"https://github.com/ohkami-rs/ohkami/blob/6e243ac823e21f286aca2660f9d38f7bde381c5a/ohkami/src/response/into_response.rs#L114-L128\" rel=\"noopener ugc nofollow\" target=\"_blank\">this</a>, allowing users to focus only on the types and schemas of their app.</p><h2>3. routes metadata of Router</h2><p>In Ohkami, what‚Äôs called router::base::Router <a href=\"https://github.com/ohkami-rs/ohkami/blob/6e243ac823e21f286aca2660f9d38f7bde381c5a/ohkami/src/router/base.rs#L8-L18\" rel=\"noopener ugc nofollow\" target=\"_blank\">has ‚Äúroutes‚Äù property</a> that stores all the routes belonging to an Ohkami instance. This is returned alongside router::final::Router from ‚Äúfinalize‚Äù step, and is used to assemble metadata of all endpoints.</p><p>What Ohkami::generate itself does is just to serialize an item of type openapi::document::Document and write it to a file.</p><p>The openapi::document::Document item is created by<a href=\"https://github.com/ohkami-rs/ohkami/blob/6e243ac823e21f286aca2660f9d38f7bde381c5a/ohkami/src/router/final.rs#L54-L59\" rel=\"noopener ugc nofollow\" target=\"_blank\"> ‚Äúgen_openapi_doc‚Äù of router::final::Router</a>, summarized as follows:</p><pre></pre><p>That‚Äôs how Ohkami generates OpenAPI document!</p><p>There is, however, a problem in , Cloudflare Workers: Ohkami is loaded to Miniflare or Cloudflare Workers as WASM, so it can only generate OpenAPI document andcannot write it to the user‚Äôs local file system.</p><p>To work around this, Ohkami provides a CLI tool <a href=\"https://github.com/ohkami-rs/ohkami/blob/6e243ac823e21f286aca2660f9d38f7bde381c5a/scripts/workers_openapi.js\" rel=\"noopener ugc nofollow\" target=\"_blank\">scripts/workers_openapi.js</a>. This is, for example, used in package.json of Cloudflare Workers + OpenAPI template:</p><pre></pre><p>generates OpenAPI document!</p>","contentLength":3119,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1iph9lk/macroless_highly_integrated_openapi_document/"},{"title":"OpenAI: The Age of AI Is Here!","url":"https://www.youtube.com/watch?v=97kQRYwL3P0","date":1739557087,"author":"Two Minute Papers","guid":522,"unread":true,"content":"<article>‚ù§Ô∏è Check out Lambda here and sign up for their GPU Cloud: https://lambdalabs.com/papers\n\nüìù The paper \"Competitive Programming with Large Reasoning Models\" is available here:\nhttps://arxiv.org/abs/2502.06807\n\nüìù My paper on simulations that look almost like reality is available for free here:\nhttps://rdcu.be/cWPfD \n\nOr this is the orig. Nature Physics link with clickable citations:\nhttps://www.nature.com/articles/s41567-022-01788-5\n\nüôè We would like to thank our generous Patreon supporters who make Two Minute Papers possible:\nBenji Rabhan, B Shang, Christian Ahlin, Gordon Child, John Le, Juan Benet, Kyle Davis, Loyal Alchemist, Lukas Biewald, Michael Tedder, Owen Skarpness, Richard Sundvall, Steef, Taras Bobrovytsky, Thomas Krcmar, Tybie Fitzhugh, Ueli GallizziIf you wish to appear here or pick up other perks, click here: https://www.patreon.com/TwoMinutePapers\n\nMy research: https://cg.tuwien.ac.at/~zsolnai/\nX/Twitter: https://twitter.com/twominutepapers\nThumbnail design: Fel√≠cia Zsolnai-Feh√©r - http://felicia.hu</article>","contentLength":1040,"flags":null,"enclosureUrl":"https://www.youtube.com/v/97kQRYwL3P0?version=3","enclosureMime":"","commentsUrl":null},{"title":"[P] GNNs for time series anomaly detection","url":"https://www.reddit.com/r/MachineLearning/comments/1ipgk8p/p_gnns_for_time_series_anomaly_detection/","date":1739555819,"author":"/u/Important-Gear-325","guid":635,"unread":true,"content":"<p>For the past few months, my partner and I have been working on a project exploring the use of Graph Neural Networks (GNNs) for Time Series Anomaly Detection (TSAD). As we are near the completion of our work, I‚Äôd love to get feedback from this amazing community!</p><p>Any comments, suggestions, or discussions are more than welcome! If you find the repo interesting, dropping a ‚≠ê would mean a lot. : )</p><p>We're also planning to publish a detailed report with our findings and insights in the coming months, so stay tuned!</p><p>The repo is still under development so don't be too harsh :)</p><p>Looking forward to hearing your thoughts!</p>","contentLength":615,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Roadmap to Becoming a Data Scientist, Part 4: Advanced Machine Learning","url":"https://towardsdatascience.com/roadmap-to-becoming-a-data-scientist-part-4-advanced-machine-learning/","date":1739552400,"author":"Vyacheslav Efimov","guid":10,"unread":true,"content":"<p>Data science is undoubtedly one of the most fascinating fields today.&nbsp;Following significant breakthroughs in machine learning about a decade ago, data science has surged in popularity within the tech community.&nbsp;Each year, we witness increasingly powerful tools that once seemed unimaginable.&nbsp;Innovations such as the&nbsp;,&nbsp;, the&nbsp;<em>Retrieval-Augmented Generation (RAG</em>) framework, and state-of-the-art&nbsp;&nbsp;‚Äî including&nbsp;&nbsp;‚Äî have had a profound impact on our world.</p><p>However, with the abundance of tools and the ongoing hype surrounding AI, it can be overwhelming ‚Äî especially for beginners ‚Äî to determine which skills to prioritize when aiming for a career in data science.&nbsp;Moreover, this field is highly demanding, requiring substantial dedication and perseverance.</p><p>The first three parts of this series outlined the necessary skills to become a data scientist in three key areas: <a href=\"https://towardsdatascience.com/roadmap-to-becoming-a-data-scientist-part-1-maths-2dc9beb69b27/\">math</a>, <a href=\"https://towardsdatascience.com/roadmap-to-becoming-a-data-scientist-part-2-software-engineering-e2fee3fe4d71/\">software engineering</a>, and <a href=\"https://towardsdatascience.com/roadmap-to-becoming-a-data-scientist-part-3-machine-learning-628248c96cb5/\">machine learning</a>.&nbsp;While knowledge of classical <a href=\"https://towardsdatascience.com/tag/machine-learning/\" title=\"Machine Learning\">Machine Learning</a> and neural network algorithms is an excellent starting point for aspiring data specialists, there are still many&nbsp;important topics in machine learning that must be mastered to work on more advanced projects.</p><blockquote><p><em>This article will focus solely on the math skills necessary to start a career in Data Science.&nbsp;Whether pursuing this path is a worthwhile choice based on your background and other factors will be discussed in a separate article.</em></p></blockquote><h2>The importance of learning evolution of methods in machine learning</h2><blockquote><p><em>The section below provides information about the evolution of methods in natural language processing (NLP).</em></p></blockquote><p>In contrast to previous articles in this series, I have decided to change the format in which I present the necessary skills for aspiring data scientists. Instead of directly listing specific competencies to develop and the motivation behind mastering them, I will briefly outline the most important approaches, presenting them in chronological order as they have been developed and used over the past decades in machine learning.</p><p>The reason is that I believe it is crucial to study these algorithms from the very beginning. In machine learning, many new methods are built upon older approaches, which is especially true for <a href=\"https://towardsdatascience.com/tag/nlp/\" title=\"NLP\">NLP</a> and computer vision.</p><p>For example, jumping directly into the implementation details of modern&nbsp;large language models (LLMs)&nbsp;without any preliminary knowledge may make it very difficult for beginners to grasp the motivation and underlying ideas of specific mechanisms.</p><p><em>Given this, in the next two sections, I will highlight in&nbsp;</em><em>&nbsp;the key concepts that should be studied.</em></p><p><strong>Natural language processing (NLP)</strong>&nbsp;is a broad field that focuses on processing textual information. Machine learning algorithms cannot work directly with raw text, which is why text is usually preprocessed and converted into numerical vectors that are then fed into neural networks.</p><p>Before being converted into vectors, words undergo&nbsp;, which includes simple techniques such as&nbsp;,&nbsp;<strong>stemming, lemmatization, normalization</strong>, or removing&nbsp;. After preprocessing, the resulting text is encoded into&nbsp;. Tokens represent the smallest textual elements in a collection of documents. Generally, a token can be a part of a word, a sequence of symbols, or an individual symbol. Ultimately, tokens are converted into numerical vectors.</p><p>The&nbsp;&nbsp;method is the most basic way to encode tokens, focusing on counting the frequency of tokens in each document. However, in practice, this is usually not sufficient, as it is also necessary to account for token importance ‚Äî a concept introduced in the&nbsp;&nbsp;and&nbsp;&nbsp;methods. While TF-IDF improves upon the naive counting approach of bag of words, researchers have developed a completely new approach called embeddings.</p><p>&nbsp;are numerical vectors whose components preserve the semantic meanings of words. Because of this, embeddings play a crucial role in NLP, enabling input data to be trained or used for model inference. Additionally, embeddings can be used to compare text similarity, allowing for the retrieval of the most relevant documents from a collection.</p><blockquote><p><em>Embeddings can also be used to encode other unstructured data, including images, audio, and videos.</em></p></blockquote><p>As a field, NLP has been evolving rapidly over the last 10‚Äì20 years to efficiently solve various text-related problems. Complex tasks like text translation and text generation were initially addressed using&nbsp;<strong>recurrent neural networks (RNNs)</strong>, which introduced the concept of memory, allowing neural networks to capture and retain key contextual information in long documents.</p><p>Although RNN performance gradually improved, it remained suboptimal for certain tasks. Moreover, RNNs are relatively slow, and their sequential prediction process does not allow for parallelization during training and inference, making them less efficient.</p><p>Additionally, the original Transformer architecture can be decomposed into two separate modules:&nbsp;&nbsp;and&nbsp;. Both of these form the foundation of the most state-of-the-art models used today to solve various NLP problems. Understanding their principles is valuable knowledge that will help learners advance further when studying or working with other&nbsp;<strong>large language models (LLMs)</strong>.</p><p>When it comes to LLMs, I strongly recommend studying the evolution of at least the first three GPT models, as they have had a significant impact on the AI world we know today. In particular, I would like to highlight the concepts of&nbsp;&nbsp;and&nbsp;, introduced in&nbsp;GPT-2, which enable LLMs to solve text generation tasks without explicitly receiving any training examples for them.</p><p>Another important technique developed in recent years is&nbsp;<strong>retrieval-augmented generation (RAG)</strong>.&nbsp;<em>The main limitation of LLMs is that they are only aware of the context used during their training.</em>&nbsp;As a result, they lack knowledge of any information beyond their training data.</p><p>The retriever converts the input prompt into an embedding, which is then used to query a vector database. The database returns the most relevant context based on the similarity to the embedding. This retrieved context is then combined with the original prompt and passed to a generative model. The model processes both the initial prompt and the additional context to generate a more informed and contextually accurate response.</p><blockquote><p><em>A good example of this limitation is the first version of the ChatGPT model, which was trained on data up to the year 2022 and had no knowledge of events that occurred from 2023 onward.</em></p></blockquote><p>To address this limitation, OpenAI researchers developed a RAG pipeline, which includes a constantly updated database containing new information from external sources. When ChatGPT is given a task that requires external knowledge, it queries the database to retrieve the most relevant context and integrates it into the final prompt sent to the machine learning model.</p><p>The goal of distillation is to create a smaller model that can imitate a larger one. In practice, this means that if a large model makes a prediction, the smaller model is expected to produce a similar result.</p><p>In the modern era, LLM development has led to models with millions or even billions of parameters. As a consequence, the overall size of these models may exceed the hardware limitations of standard computers or small portable devices, which come with many constraints.</p><p>Quantization is the process of reducing the memory required to store numerical values representing a model‚Äôs weights.</p><p>This is where optimization techniques become particularly useful, allowing LLMs to be compressed without significantly compromising their performance. The most commonly used techniques today include&nbsp;,, and&nbsp;.</p><p>Pruning refers to discarding the least important weights of a model.</p><p>Regardless of the area in which you wish to specialize, knowledge of&nbsp;&nbsp;is a must-have skill! Fine-tuning is a powerful concept that allows you to efficiently adapt a pre-trained model to a new task.</p><p>Fine-tuning is especially useful when working with very large models. For example, imagine you want to use BERT to perform semantic analysis on a specific dataset. While BERT is trained on general data, it might not fully understand the context of your dataset. At the same time, training BERT from scratch for your specific task would require a massive amount of resources.</p><p>Here is where fine-tuning comes in: it involves taking a pre-trained BERT (or another model) and freezing some of its layers (usually those at the beginning). As a result, BERT is retrained, but this time only on the new dataset provided. Since BERT updates only a subset of its weights and the new dataset is likely much smaller than the original one BERT was trained on, fine-tuning becomes a very efficient technique for adapting BERT‚Äôs rich knowledge to a specific domain.</p><blockquote><p><em>Fine-tuning is widely used not only in NLP but also across many other domains.</em></p></blockquote><p>As the name suggests,&nbsp;&nbsp;involves analyzing images and videos using machine learning. The most common tasks include image classification, object detection, image segmentation, and generation.</p><p>Most CV algorithms are based on neural networks, so it is essential to understand how they work in detail. In particular, CV uses a special type of network called&nbsp;<strong>convolutional neural networks (CNNs)</strong>. These are similar to fully connected networks, except that they typically begin with a set of specialized mathematical operations called&nbsp;.</p><blockquote><p><em>In simple terms, convolutions act as filters, enabling the model to extract the most important features from an image, which are then passed to fully connected layers for further analysis.</em></p></blockquote><p>The next step is to study the most popular CNN architectures for classification tasks, such as&nbsp;<strong>AlexNet, VGG, Inception, ImageNet</strong>, and&nbsp;.</p><p>Speaking of the object detection task, the&nbsp;&nbsp;algorithm is a clear winner. It is not necessary to study all of the dozens of versions of YOLO. In reality, going through the original paper of the first YOLO should be sufficient to understand how a relatively difficult problem like object detection is elegantly transformed into both classification and regression problems. This approach in YOLO also provides a nice intuition on how more complex CV tasks can be reformulated in simpler terms.</p><p>While there are many architectures for performing image segmentation, I would strongly recommend learning about&nbsp;, which introduces an encoder-decoder architecture.</p><p>Finally, image generation is probably one of the most challenging tasks in CV. Personally, I consider it an optional topic for learners, as it involves many advanced concepts. Nevertheless, gaining a high-level intuition of how&nbsp;<strong>generative adversial networks (GAN)</strong>&nbsp;function to generate images is a good way to broaden one‚Äôs horizons.</p><blockquote><p><em>In some problems, the training data might not be enough to build a performant model. In such cases, the data augmentation technique is commonly used. It involves the artificial generation of training data from already existing data (images). By feeding the model more diverse data, it becomes capable of learning and recognizing more patterns.</em></p></blockquote><p>It would be very hard to present in detail the <a href=\"https://towardsdatascience.com/tag/roadmaps/\" title=\"Roadmaps\">Roadmaps</a> for all existing machine learning domains in a single article. That is why, in this section, I would like to briefly list and explain some of the other most popular areas in data science worth exploring.</p><p>First of all,&nbsp;<strong>recommender systems (RecSys)</strong>&nbsp;have gained a lot of popularity in recent years. They are increasingly implemented in online shops, social networks, and streaming services. The key idea of most algorithms is to take a large initial matrix of all users and items and decompose it into a product of several matrices in a way that associates every user and every item with a high-dimensional embedding. This approach is very flexible, as it then allows different types of comparison operations on embeddings to find the most relevant items for a given user. Moreover, it is much more rapid to perform analysis on small matrices rather than the original, which usually tends to have huge dimensions.</p><p> often goes hand in hand with RecSys. When a RecSys has identified a set of the most relevant items for the user, ranking algorithms are used to sort them to determine the order in which they will be shown or proposed to the user. A good example of their usage is search engines, which filter query results from top to bottom on a web page.</p><p>Closely related to ranking, there is also a&nbsp;&nbsp;problem that aims to optimally map objects from two sets, A and B, in a way that, on average, every object pair&nbsp;is mapped ‚Äúwell‚Äù according to a matching criterion. A use case example might include distributing a group of students to different university disciplines, where the number of spots in each class is limited.</p><p>&nbsp;is an unsupervised machine learning task whose objective is to split a dataset into several regions (clusters), with each dataset object belonging to one of these clusters. The splitting criteria can vary depending on the task. Clustering is useful because it allows for grouping similar objects together. Moreover, further analysis can be applied to treat objects in each cluster separately.</p><p>The goal of clustering is to group dataset objects (on the left) into several categories (on the right) based on their similarity.</p><p>&nbsp;is another unsupervised problem, where the goal is to compress an input dataset. When the dimensionality of the dataset is large, it takes more time and resources for machine learning algorithms to analyze it. By identifying and removing noisy dataset features or those that do not provide much valuable information, the data analysis process becomes considerably easier.</p><p>&nbsp;is an area that focuses on designing algorithms and data structures (indexes) to optimize searches in a large database of embeddings (vector database). More precisely, given an input embedding and a vector database, the goal is to&nbsp;&nbsp;find the most similar embedding in the database relative to the input embedding.</p><p>The goal of similarity search is to approximately find the most similar embedding in a vector database relative to a query embedding.</p><p>The word ‚Äúapproximately‚Äù means that the search is not guaranteed to be 100% precise. Nevertheless, this is the main idea behind similarity search algorithms ‚Äî sacrificing a bit of accuracy in exchange for significant gains in prediction speed or data compression.</p><p>&nbsp;involves studying the behavior of a target variable over time. This problem can be solved using classical tabular algorithms. However, the presence of time introduces new factors that cannot be captured by standard algorithms. For instance:</p><ul><li>the target variable can have an overall&nbsp;, where in the long term its values increase or decrease&nbsp;<em>(e.g., the average yearly temperature rising due to global warming)</em>.</li><li>the target variable can have a&nbsp;&nbsp;which makes its values change based on the currently given period&nbsp;<em>(e.g. temperature is lower in winter and higher in summer)</em>.</li></ul><p>Most of the time series models take both of these factors into account. In general, time series models are mainly used a lot in financial, stock or demographic analysis.</p><p>Another advanced area I would recommend exploring is&nbsp;, which fundamentally changes the algorithm design compared to classical machine learning.&nbsp;In simple terms, its goal is to train an agent in an environment to make optimal decisions based on a reward system (also known as the&nbsp;<em>‚Äútrial and error approach‚Äù</em>).&nbsp;By taking an action, the agent receives a reward, which helps it understand whether the chosen action had a positive or negative effect.&nbsp;After that, the agent slightly adjusts its strategy, and the entire cycle repeats.</p><p>Reinforcement learning is particularly popular in complex environments where classical algorithms are not capable of solving a problem.&nbsp;Given the complexity of reinforcement learning algorithms and the computational resources they require, this area is not yet fully mature, but it has high potential to gain even more popularity in the future.</p><p>Currently the most popular applications are:</p><ul><li>.&nbsp;Existing approaches can design optimal game strategies and outperform humans.&nbsp;The most well-known examples are chess and Go.</li><li>.&nbsp;Advanced algorithms can be incorporated into robots to help them move, carry objects or complete routine tasks at home.</li><li>.&nbsp;Reinforcement learning methods can be developed to automatically drive cars, control helicopters or drones.</li></ul><p>This article was a logical continuation of the previous part and expanded the skill set needed to become a data scientist. While most of the mentioned topics require time to master, they can add significant value to your portfolio. This is especially true for the NLP and CV domains, which are in high demand today.</p><blockquote><p>After reaching a high level of expertise in data science, it is still crucial to stay motivated and consistently push yourself to learn new topics and explore emerging algorithms.</p></blockquote><p>Data science is a constantly evolving field, and in the coming years, we might witness the development of new state-of-the-art approaches that we could not have imagined in the past.</p><p><em>All images are by the author unless noted otherwise.</em></p>","contentLength":17044,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Siren Call of SQLite on the Server","url":"https://pid1.dev/posts/siren-call-of-sqlite-on-the-server/","date":1739551579,"author":"/u/sausagefeet","guid":640,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ipevoh/siren_call_of_sqlite_on_the_server/"},{"title":"Unlocking global AI potential with next-generation subsea infrastructure","url":"https://engineering.fb.com/2025/02/14/connectivity/project-waterworth-ai-subsea-infrastructure/","date":1739550486,"author":"","guid":472,"unread":true,"content":"<p><a href=\"https://globaldigitalinclusion.org/wp-content/uploads/2024/01/GDIP-Good-Practices-for-Subsea-Cables-Policy-Investing-in-Digital-Inclusion.pdf\"></a></p><p><a href=\"https://engineering.fb.com/2021/03/28/connectivity/echo-bifrost/\"></a><a href=\"https://engineering.fb.com/2021/09/28/connectivity/2africa-pearls/\"></a></p>","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"I'm very impressed by how Rust supports both beginners and pro's","url":"https://www.reddit.com/r/rust/comments/1ipe6m7/im_very_impressed_by_how_rust_supports_both/","date":1739549777,"author":"/u/ConstructionShot2026","guid":624,"unread":true,"content":"<p>I would go as far saying it supports a syntax abstraction that is simpler than python to read.</p><p>I just find it amazing, with a performance level so close to C++.</p><p>Its your choice how many complex features you want to add for control and optimization, and the compiler is so cool, that it can add them automatically if I don't see it necessary.</p><p>I believe if more knew how simple it could be, more would use it outside systems programming :D</p>","contentLength":434,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Publish Interactive Data Visualizations for Free with Python and Marimo","url":"https://towardsdatascience.com/publish-interactive-data-visualizations-for-free-with-python-and-marimo/","date":1739548800,"author":"Sam Minot","guid":9,"unread":true,"content":"<p>Working in <a href=\"https://towardsdatascience.com/tag/data-science/\" title=\"Data Science\">Data Science</a>, it can be hard to share insights from complex datasets using only static figures. All the facets that describe the shape and meaning of interesting data are not always captured in a handful of pre-generated figures. While we have powerful technologies available for presenting interactive figures‚Ää‚Äî‚Ääwhere a viewer can rotate, filter, zoom, and generally explore complex data‚Ää ‚Äî‚Ää they always come with tradeoffs.</p><p>Here I present my experience using a recently released Python library‚Ää‚Äî‚Ää<a href=\"https://marimo.io\">marimo</a>‚Ää‚Äî‚Ääwhich opens up exciting new opportunities for publishing interactive visualizations across the entire field of data science.</p><h2>Interactive Data Visualization</h2><p>The tradeoffs to consider when selecting an approach for presenting data visualizations can be broken into three categories:</p><ul><li>‚Ää‚Äî‚Ääwhat visualizations and interactivity am I able to present to the user?</li><li>‚Ää‚Äî‚Ääwhat are the resources needed for displaying this visualization to users (e.g. running servers, hosting websites)?</li><li> ‚Äì how much of a new skillset / codebase do I need to learn upfront?</li></ul><p> is the foundation of portable interactivity. Every user has a web browser installed on their computer and there are many different frameworks available for displaying any degree of interactivity or visualization you might imagine (for example, this <a href=\"https://threejs.org/\">gallery of amazing things people have made with three.js</a>). Since the application is running on the user‚Äôs computer, no costly servers are needed. However, a significant drawback for the data science community is ease of use, as JS does not have many of the high-level (i.e. easy-to-use) libraries that data scientists use for data manipulation, plotting, and interactivity.</p><p> provides a useful point of comparison. Because of its <a href=\"https://flatironschool.com/blog/python-popularity-the-rise-of-a-global-programming-language/\">continually growing popularity</a>, some have called this the <a href=\"https://towardsdatascience.com/we-are-living-in-the-era-of-python-bc032d595f6a\">‚ÄúEra of Python‚Äù</a>. For data scientists in particular, Python stands alongside R as one of the foundational languages for quickly and effectively wielding complex data. While Python may be easier to use than Javascript, there are fewer options for presenting interactive visualizations. Some popular projects providing interactivity and visualization have been <a href=\"https://flask.palletsprojects.com/en/stable/\">Flask</a>, <a href=\"https://dash.plotly.com/\">Dash</a>, and <a href=\"https://streamlit.io/\">Streamlit</a> (also worth mentioning‚Ää‚Äî‚Ää<a href=\"https://docs.bokeh.org/en/latest/docs/gallery.html\">bokeh</a>, <a href=\"https://holoviews.org/\">HoloViews</a>, <a href=\"https://altair-viz.github.io/altair-tutorial/README.html\">altair</a>, and <a href=\"https://plotly.com/python/\">plotly</a>). The biggest tradeoff for using Python has been the cost for publishing ‚Äì delivering the tool to users. In the same way that <a href=\"https://www.shinyapps.io/\">shinyapps</a> require a running computer to serve up the visualization, these Python-based frameworks have exclusively been server-based. This is by no means prohibitive for authors with a budget to spend, but it does limit the number of users who can take advantage of a particular project.</p><p><a href=\"https://pyodide.org/en/stable/\"></a> is an intriguing middle ground‚Ää‚Äî‚ÄäPython code running directly in the web browser using <a href=\"https://webassembly.org/\">WebAssembly</a> (WASM). There are resource limitations (only 1 thread and 2GB memory) that make this impractical for doing the heavy lifting of data science. , this can be more than sufficient for building visualizations and updating based on user input. Because it runs in the browser, no servers are required for hosting. Tools that use Pyodide as a foundation are interesting to explore because they give data scientists an opportunity to write Python code which runs directly on users‚Äô computers without their having to install or run anything outside of the web browser.</p><p>As an aside, <a href=\"https://towardsdatascience.com/python-based-data-viz-with-no-installation-required-aaf2358c881\">I‚Äôve been interested previously in</a> one project that has tried this approach: <a href=\"https://github.com/whitphx/stlite\">stlite</a>, <a href=\"https://edit.share.stlite.net/\">an in-browser implementation of Streamlit</a> that lets you deploy these flexible and powerful apps to a broad range of users. However, a core limitation is that Streamlit itself is distinct from stlite (the port of Streamlit to WASM), which means that not all features are supported and that advancement of the project is dependent on two separate groups working along compatible lines.</p><ul><li>The interface resembles a Jupyter , which will be familiar to users.</li><li>Execution of cells is , so that updating one cell will rerun all cells which depend on its output.</li><li> can be captured with a flexible set of UI components.</li><li>Notebooks can be quickly converted into , hiding the code and showing only the input/output elements.</li><li>Apps can be run locally or converted into using WASM/Pyodide.</li></ul><p>marimo balances the tradeoffs of technology in a way that is well suited to the skill set of the typical data scientists:</p><ul><li>‚Ää‚Äî‚Ääuser input and visual display features are rather extensive, <a href=\"https://docs.marimo.io/guides/working_with_data/plotting/#reactive-plots\">supporting user input</a> via Altair and Plotly plots.</li><li>‚Ää‚Äî‚Äädeploying as static webpages is basically free‚Ää‚Äî‚Ääno servers required</li><li>‚Ää‚Äî‚Ääfor users familiar with Python notebooks, marimo will feel very familiar and be easy to pick up.</li></ul><h2>Publishing Marimo Apps on the Web</h2><p>As a simple example of the type of display that can be useful in data science, consisting of explanatory text interspersed with interactive displays, I have created a barebones <a href=\"https://github.com/FredHutch/marimo-publication\">GitHub repository</a>. Try it out yourself <a href=\"https://fredhutch.github.io/marimo-publication/\">here</a>.</p><p>Using just a little bit of code, users can:</p><ul><li>Generate visualizations with flexible interactivity</li><li>Write narrative text describing their findings</li><li>Publish to the web for free (i.e. using GitHub Pages)</li></ul><h2>Public App / Private Data</h2><p>This new technology offers an exciting new opportunity for collaboration‚Ää‚Äî‚Ääpublish the app publicly to the world, but users can only see specific datasets that they have permission to access.</p><p>Rather than building a dedicated data backend for every app, user data can be stored in a generic backend which can be securely authenticated and accessed using a Python client library‚Ää‚Äî‚Ääall contained within the user‚Äôs web browser. For example, the user is given an OAuth login link that will authenticate them with the backend and allow the app to temporarily access input data.</p><p>As a proof of concept, I built a simple visualization app which connects to <a href=\"https://cirro.bio\">the Cirro data platform</a>, which is used at my institution to manage scientific data. Full disclosure: I was part of the team that built this platform before it spun out as an independent company. In this manner users can:</p><ul><li>Load the public visualization app‚Ää‚Äî‚Äähosted on GitHub Pages</li><li>Connect securely to their private data store</li><li>Load the appropriate dataset for display</li><li>Share a link which will direct authorized collaborators to the same data</li></ul><p>As a data scientist, this approach of publishing free and open-source visualization apps which can be used to interact with private datasets is extremely exciting. Building and publishing a new app can take hours and days instead of weeks and years, letting researchers quickly share their insights with collaborators and then publish them to the wider world.</p>","contentLength":6594,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Hugo van Kemenade: Improving licence metadata","url":"https://hugovk.dev/blog/2025/improving-licence-metadata/","date":1739545860,"author":"","guid":283,"unread":true,"content":"<p><a href=\"https://peps.python.org/pep-0639/\" target=\"_blank\" rel=\"noreferrer\">PEP 639</a> defines a spec on how to document licences\nused in Python projects.</p><p>Change  as follows.</p><p>I usually use Hatchling as a build backend, and support was added in 1.27:</p><div><pre tabindex=\"0\"><code></code></pre></div><p>Replace the freeform  field with a valid SPDX license expression, and add\n which points to the licence files in the repo. There‚Äôs often only one,\nbut if you have more than one, list them all:</p><div><pre tabindex=\"0\"><code></code></pre></div><p>Optionally delete the deprecated licence classifier:</p><div><pre tabindex=\"0\"><code></code></pre></div><p>Then make sure to use a PyPI uploader that supports this.</p><p>pip can also show you the metadata:</p><div><pre tabindex=\"0\"><code></code></pre></div><p>A lot of work went into this. Thank you to PEP authors\n<a href=\"https://github.com/pombredanne\" target=\"_blank\" rel=\"noreferrer\">Philippe Ombredanne</a> for creating the first draft in\n2019, to <a href=\"https://github.com/cam-gerlach\" target=\"_blank\" rel=\"noreferrer\">C.A.M. Gerlach</a> for the second draft in 2021,\nand especially to <a href=\"https://karolinasurma.eu/\" target=\"_blank\" rel=\"noreferrer\">Karolina Surma</a> for getting the third\ndraft finish line and helping with the implementation.</p><p>And many projects were updated to support this, thanks to the maintainers and\ncontributors of at least:</p>","contentLength":878,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"5 Tips for Building a Data Science Portfolio","url":"https://www.kdnuggets.com/5-tips-building-data-science-portfolio","date":1739545225,"author":"Nate Rosidi","guid":590,"unread":true,"content":"<article>Not every data science portfolio is worth showcasing. Follow these five tips to build a portfolio that impresses employers and gets you a job.</article>","contentLength":142,"flags":null,"enclosureUrl":"https://www.kdnuggets.com/wp-content/uploads/Rosidi_5_Tips_for_Building_a_DS_Portfolio_4.png","enclosureMime":"","commentsUrl":null},{"title":"Show HN: Transform your codebase into a single Markdown doc for feeding into AI","url":"https://tesserato.web.app/posts/2025-02-12-CodeWeaver-launch/index.html","date":1739539403,"author":"tesserato","guid":323,"unread":true,"content":"<p>CodeWeaver is a command-line tool designed to weave your codebase into a single, easy-to-navigate Markdown document. It recursively scans a directory, generating a structured representation of your project's file hierarchy and embedding the content of each file within code blocks. This tool simplifies codebase sharing, documentation, and integration with AI/ML code analysis tools by providing a consolidated and readable Markdown output.\nThe output for the current repository can be found <a href=\"https://github.com/tesserato/CodeWeaver/blob/main/codebase.md\">here</a>.</p><ul><li><strong>Comprehensive Codebase Documentation:</strong> Generates a Markdown file that meticulously outlines your project's directory and file structure in a clear, tree-like format.</li><li> Embeds the complete content of each file directly within the Markdown document, enclosed in syntax-highlighted code blocks based on file extensions.</li><li>  Utilize regular expressions to define ignore patterns, allowing you to exclude specific files and directories from the generated documentation (e.g., , build artifacts, specific file types).</li><li> Choose to save lists of included and excluded file paths to separate files for detailed tracking and debugging of your ignore rules.</li><li><strong>Simple Command-Line Interface:</strong>  Offers an intuitive command-line interface with straightforward options for customization.</li></ul><p>If you have Go installed, run <code>go install github.com/tesserato/CodeWeaver@latest</code>to install the latest version of CodeWeaver or <code>go install github.com/tesserato/CodeWeaver@vX.Y.Z</code> to install a specific version.</p><p>Alternatively, download the appropriate pre built executable from the <a href=\"https://github.com/tesserato/CodeWeaver/releases\">releases page</a>.</p><p>If necessary, make the  executable by using the  command:</p><table><thead><tr></tr></thead><tbody><tr><td>The root directory to scan and document.</td></tr><tr><td>The name of the output Markdown file.</td></tr><tr><td><code>-ignore \"&lt;regex patterns&gt;\"</code></td><td>Comma-separated list of regular expression patterns for paths to exclude.</td></tr><tr><td><code>-included-paths-file &lt;filename&gt;</code></td><td>File to save the list of paths that were included in the documentation.</td></tr><tr><td><code>-excluded-paths-file &lt;filename&gt;</code></td><td>File to save the list of paths that were excluded from the documentation.</td></tr><tr><td>Display this help message and exit.</td></tr></tbody></table><h2><strong>Generate documentation for the current directory:</strong></h2><p>This will create a file named  in the current directory, documenting the structure and content of the current directory and its subdirectories (excluding paths matching the default ignore pattern ).</p><h2><strong>Specify a different input directory and output file:</strong></h2><pre><code>./codeweaver -dir=my_project -output=project_docs.md\n</code></pre><p>This command will process the  directory and save the documentation to .</p><h2><strong>Ignore specific file types and directories:</strong></h2><pre><code>./codeweaver -ignore=\"\\.log,temp,build\" -output=detailed_docs.md\n</code></pre><p>This example will generate , excluding any files or directories with names containing , , or . Regular expression patterns are comma-separated.</p><h2><strong>Save lists of included and excluded paths:</strong></h2><pre><code>./codeweaver -ignore=\"node_modules\" -included-paths-file=included.txt -excluded-paths-file=excluded.txt -output=code_overview.md\n</code></pre><p>This command will create  while also saving the list of included paths to  and the list of excluded paths (due to the  ignore pattern) to .</p><p>Contributions are welcome! If you encounter any issues, have suggestions for new features, or want to improve CodeWeaver, please feel free to open an issue or submit a pull request on the project's GitHub repository.</p><p>CodeWeaver is released under the <a href=\"https://tesserato.web.app/posts/2025-02-12-CodeWeaver-launch/LICENSE\">MIT License</a>. See the  file for complete license details.</p>","contentLength":3311,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=43048027"},{"title":"Show HN: A New Way to Learn Languages","url":"https://www.langturbo.com/","date":1739534938,"author":"sebnun","guid":322,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=43047554"},{"title":"Real Python: The Real Python Podcast ‚Äì Episode #239: Behavior-Driven vs Test-Driven Development &amp; Using Regex in Python","url":"https://realpython.com/podcasts/rpp/239/","date":1739534400,"author":"","guid":185,"unread":true,"content":"<p>What is behavior-driven development, and how does it work alongside test-driven development? How do you communicate requirements between teams in an organization? Christopher Trudeau is back on the show this week, bringing another batch of PyCoder's Weekly articles and projects.</p>","contentLength":279,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Daniel Roy Greenfeld: Building a playing card deck","url":"https://daniel.feldroy.com/posts/2025-02-deck-of-cards","date":1739526604,"author":"","guid":282,"unread":true,"content":"<article>Today is Valentine's Day. That makes it the perfect day to write a blog post about showing how to not just build a deck of cards, but show off cards from the heart suite.</article>","contentLength":170,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Building a Data Engineering Center of Excellence","url":"https://towardsdatascience.com/building-a-data-engineering-center-of-excellence/","date":1739500548,"author":"Richie Bachala","guid":8,"unread":true,"content":"<p>As data continues to grow in importance and become more complex, the need for skilled data engineers has never been greater. But what is data engineering, and why is it so important? In this blog post, we will discuss the essential components of a functioning data engineering practice and why data engineering is becoming increasingly critical for businesses today, and how you can build your very own Data Engineering Center of Excellence!</p><p>I‚Äôve had the privilege to build, manage, lead, and foster a sizeable high-performing team of data warehouse &amp; ELT engineers for many years. With the help of my team, I have spent a considerable amount of time every year consciously planning and preparing to manage the growth of our data month-over-month and address the changing reporting and analytics needs for our&nbsp;<em>20000+ global data consumers</em>. We built many data warehouses to store and centralize massive amounts of data generated from many OLTP sources. We‚Äôve implemented Kimball methodology by creating star schemas both within our on-premise data warehouses and in the ones in the cloud.</p><p>The objective is to enable our user-base to perform fast analytics and reporting on the data; so our analysts‚Äô community and business users can make accurate data-driven decisions.</p><p>It took me about three years to transform&nbsp;&nbsp;() of data warehouse and ETL programmers into one cohesive Data Engineering team.</p><p><em>I have compiled some of my learnings building a global data engineering team in this post in hopes that Data professionals and leaders of all levels of technical proficiency can benefit.</em></p><h2>Evolution of the Data Engineer</h2><p>It has never been a better time to be a data engineer. Over the last decade, we have seen a massive awakening of enterprises now recognizing their data as the company‚Äôs heartbeat, making data engineering the job function that ensures accurate, current, and quality data flow to the solutions that depend on it.</p><p>Historically, the role of Data Engineers has evolved from that of&nbsp;<strong><em>data warehouse developers&nbsp;</em></strong>and the&nbsp;&nbsp;(extract, transform and load).</p><p>The data warehouse developers are responsible for designing, building, developing, administering, and maintaining data warehouses to meet an enterprise‚Äôs reporting needs. This is done primarily via extracting data from operational and transactional systems and piping it using extract transform load methodology (ETL/ ELT) to a storage layer like a data warehouse or a data lake. The data warehouse or the data lake is where data analysts, data scientists, and business users consume data. The developers also perform transformations to conform the ingested data to a data model with aggregated data for easy analysis.</p><blockquote><p>A data engineer‚Äôs prime responsibility is to produce and make data securely available for multiple consumers.</p></blockquote><p>Data engineers oversee the ingestion, transformation, modeling, delivery, and movement of data through every part of an organization. Data extraction happens from many different data sources &amp; applications. Data Engineers load the data into data warehouses and data lakes, which are transformed not just for the <a href=\"https://towardsdatascience.com/tag/data-science/\" title=\"Data Science\">Data Science</a> &amp; predictive analytics initiatives (as everyone likes to talk about) but primarily for data analysts. Data analysts &amp; data scientists perform operational reporting, exploratory analytics, service-level agreement (SLA) based business intelligence reports and dashboards on the catered data. In this book, we will address all of these job functions.</p><p>The role of a data engineer is to acquire, store, and aggregate data from both cloud and on-premise, new, and existing systems, with data modeling and feasible data architecture. Without the data engineers, analysts and data scientists won‚Äôt have valuable data to work with, and hence, data engineers are the first to be hired at the inception of every new data team. Based on the data and analytics tools available within an enterprise, data engineering teams‚Äô role profiles, constructs, and approaches have several options for what should be included in their responsibilities which we will discuss in this chapter.</p><p>Software is increasingly automating the historically manual and tedious tasks of data engineers. Data processing tools and technologies have evolved massively over several years and will continue to grow. For example, cloud-based data warehouses (Snowflake, for instance) have made data storage and processing affordable and fast. Data pipeline services (like&nbsp;<a href=\"https://www.informatica.com/blogs/welcome-to-informatica-intelligent-cloud-services.html\" rel=\"noreferrer noopener\" target=\"_blank\">Informatica IICS</a>,&nbsp;<a href=\"https://airflow.apache.org/\" rel=\"noreferrer noopener\" target=\"_blank\">Apache Airflow</a>,&nbsp;<a href=\"https://www.matillion.com/\" rel=\"noreferrer noopener\" target=\"_blank\">Matillion</a>,&nbsp;<a href=\"http://fivetran.com/\" rel=\"noreferrer noopener\" target=\"_blank\">Fivetran</a>) have turned data extraction into work that can be completed quickly and efficiently. The data engineering team should be leveraging such technologies as force multipliers, taking a consistent and cohesive approach to integration and management of enterprise data, not just relying on legacy siloed approaches to building custom data pipelines with fragile, non-performant, hard to maintain code. Continuing with the latter approach will stifle the pace of innovation within the said enterprise and force the future focus to be around managing data infrastructure issues rather than how to help generate value for your business.</p><p>The primary role of an enterprise Data Engineering team should be to&nbsp;&nbsp;into a shape that‚Äôs ready for analysis ‚Äî laying the foundation for real-world analytics and data science application.</p><p>The Data Engineering team should serve as the&nbsp;&nbsp;for enterprise-level data with the responsibility to curate the organization‚Äôs data and act as a resource for those who want to make use of it, such as Reporting &amp; Analytics teams, Data Science teams, and other groups that are doing more self-service or business group driven analytics leveraging the enterprise data platform. This team should serve as the&nbsp;&nbsp;of organizational knowledge, managing and refining the catalog so that analysis can be done more effectively. Let‚Äôs look at the essential responsibilities of a well-functioning Data Engineering team.</p><h2>Responsibilities of a Data Engineering Team</h2><p>The Data Engineering team should provide a&nbsp;&nbsp;within the enterprise that cuts across to support both the Reporting/Analytics and Data Science capabilities to provide access to clean, transformed, formatted, scalable, and secure data ready for analysis. The Data Engineering teams‚Äô core responsibilities should include:</p><blockquote><p>¬∑ Build, manage, and optimize the core data platform infrastructure</p><p>¬∑ Build and maintain custom and off-the-shelf data integrations and ingestion pipelines from a variety of structured and unstructured sources</p><p>¬∑ Manage overall data pipeline orchestration</p><p>¬∑ Manage transformation of data either before or after load of raw data through both technical processes and business logic</p><p>¬∑ Support analytics teams with design and performance optimizations of data warehouses</p></blockquote><p><strong><em>Data is an Enterprise Asset.</em></strong></p><p><strong><em>Data as an Asset should be shared and protected.</em></strong></p><p>Data should be valued as an Enterprise asset, leveraged across all Business Units to enhance the company‚Äôs value to its respective customer base by accelerating decision making, and improving competitive advantage with the help of data. Good data stewardship, legal and regulatory requirements dictate that we protect the data owned from unauthorized access and disclosure.</p><p>In other words,&nbsp;<strong><em>managing Security is a crucial responsibility.</em></strong></p><h2>Why Create a Centralized Data Engineering Team?</h2><p>Treating Data Engineering as a standard and core capability that underpins both the Analytics and Data Science capabilities will help an enterprise evolve how to approach Data and Analytics. The enterprise needs to stop vertically treating data based on the technology stack involved as we tend to see often and move to more of a horizontal approach of managing a&nbsp;&nbsp;or&nbsp;&nbsp;that cuts across the organization and can connect to various technologies as needed drive analytic initiatives. This is a new way of thinking and working, but it can drive efficiency as the various data organizations look to scale. Additionally ‚Äî there is value in creating a dedicated structure and career path for Data Engineering resources. Data engineering skill sets are in high demand in the market; therefore, hiring outside the company can be costly. Companies must enable programmers, database administrators, and software developers with a career path to gain the needed experience with the above-defined skillsets by working across technologies. Usually, forming a data engineering center of excellence or a capability center would be the first step for making such progression possible.</p><h2>Challenges for creating a centralized Data Engineering Team</h2><p>The centralization of the Data Engineering team as a service approach is different from how Reporting &amp; Analytics and Data Science teams operate. It does, in principle, mean&nbsp;<strong><em>giving up some level of control of resources</em></strong>&nbsp;and establishing new processes for how these teams will collaborate and work together to deliver initiatives.</p><p>The Data Engineering team will need to demonstrate that it can effectively support the needs of both Reporting &amp; Analytics and Data Science teams, no matter how large these teams are. Data Engineering teams must&nbsp;<strong><em>effectively prioritize workloads&nbsp;</em></strong>while ensuring they can bring the right skillsets and experience to assigned projects.</p><p>Data engineering is essential because it serves as the backbone of data-driven companies. It enables analysts to work with clean and well-organized data, necessary for deriving insights and making sound decisions. To build a functioning data engineering practice, you need the following critical components:</p><p>The Data Engineering team should be a core capability within the enterprise, but it should effectively serve as a support function involved in almost everything data-related. It should interact with the Reporting and Analytics and Data Science teams in a collaborative support role to make the entire team successful.</p><p>The&nbsp;<em>Data Engineering team doesn‚Äôt create direct business value</em>&nbsp;‚Äî but the value should come in making the Reporting and Analytics, and Data Science teams more productive and efficient to ensure delivery of maximum value to business stakeholders through Data &amp; Analytics initiatives. To make that possible, the six key responsibilities within the data engineering capability center would be as follow ‚Äì</p><p>Let‚Äôs review the&nbsp;<strong><em>6 pillars of responsibilities</em></strong>:</p><p><strong>1. Determine Central Data Location for Collation and Wrangling</strong></p><p>Understanding and having a strategy for a&nbsp;(<em>a centralized data repository or data warehouse for the mass consumption of data for analysis</em>). Defining requisite data tables and where they will be joined in the context of data engineering and subsequently converting raw data into digestible and valuable formats.</p><p><strong>2. Data Ingestion and Transformation</strong></p><p>Moving data from one or more sources to a new destination (<em>your data lake or cloud data warehouse)&nbsp;</em>where it can be stored and further analyzed and then converting data from the format of the source system to that of the destination</p><p>Extracting, transforming, and loading data from one or more sources into a destination system to represent the data in a new context or style.</p><p>Data modeling is an essential function of a data engineering team, granted not all data engineers excel with this capability. Formalizing relationships between data objects and business rules into a conceptual representation through understanding information system workflows, modeling required queries, designing tables, determining primary keys, and effectively utilizing data to create informed output.</p><p>I‚Äôve seen engineers in interviews mess up more with this than coding in technical discussions. It‚Äôs essential to understand the differences between Dimensions, Facts, Aggregate tables.</p><p>Ensuring that sensitive data is protected and implementing proper authentication and authorization to reduce the risk of a data breach</p><p><strong>6. Architecture and Administration</strong></p><p>Defining the models, policies, and standards that administer what data is collected, where and how it is stored, and how it such data is integrated into various analytical systems.</p><blockquote><p>The six pillars of responsibilities for data engineering capabilities center on the ability to determine a central data location for collation and wrangling, ingest and transform data, execute ETL/ELT operations, model data, secure access and administer an architecture. While all companies have their own specific needs with regards to these functions, it is important to ensure that your team has the necessary skillset in order to build a foundation for big data success.</p></blockquote><p>Besides the Data Engineering following are the other capability centers that need to be considered within an enterprise:</p><h2>Analytics Capability Center</h2><p>The analytics capability center enables consistent, effective, and efficient BI, analytics, and advanced analytics capabilities across the company. Assist business functions in triaging, prioritizing, and achieving their objectives and goals through reporting, analytics, and dashboard solutions, while providing operational reports and visualizations, self-service analytics, and required tools to automate the generation of such insights.</p><h2>Data Science Capability Center</h2><p>The data science capability center is for exploring cutting-edge technologies and concepts to unlock new insights and opportunities, better inform employees and create a culture of prescriptive information usage using Automated AI and Automated ML solutions such as&nbsp;<a href=\"https://medium.com/u/9aea625dfc27?source=post_page---user_mention--b83d51cedb6a---------------------------------------\" rel=\"noreferrer noopener\" target=\"_blank\">H2O.ai</a>,&nbsp;<a href=\"https://medium.com/u/27e43843bc9f?source=post_page---user_mention--b83d51cedb6a---------------------------------------\" rel=\"noreferrer noopener\" target=\"_blank\">Dataiku</a>,&nbsp;<a href=\"http://www.aible.com/\" rel=\"noreferrer noopener\" target=\"_blank\">Aible</a>, DataRobot,&nbsp;<a href=\"https://medium.com/u/3aaaf223f1e?source=post_page---user_mention--b83d51cedb6a---------------------------------------\" rel=\"noreferrer noopener\" target=\"_blank\">C3.ai</a></p><p>The data governance office empowers users with trusted, understood, and timely data to drive effectiveness while keeping the integrity and sanctity of data in the right hands for mass consumption.</p><blockquote><p><em>As your company grows, you will want to make sure that the data engineering capabilities are in place to support the six pillars of responsibilities. By doing this, you will be able to ensure that all aspects of data management and analysis are covered and that your data is safe and accessible by those who need it. Have you started thinking about how your company will grow? What steps have you taken to put a centralized data engineering team in place?</em></p></blockquote>","contentLength":14079,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"It's time to go ESM-only","url":"https://javascriptweekly.com/issues/723","date":1739491200,"author":"","guid":601,"unread":true,"content":"<p>ü§Ø Pfft, vehicle data is a joke without <a href=\"https://javascriptweekly.com/link/165818/rss\">CarsXE</a>. API goes brrrrr. VIN decoding, plate lookup, market value reports. <a href=\"https://javascriptweekly.com/link/165818/rss\">Get&nbsp;Serious!</a></p>","contentLength":130,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Mapped types in TypeScript","url":"https://2ality.com/2025/02/mapped-types-typescript.html","date":1739491200,"author":"Dr. Axel Rauschmayer","guid":352,"unread":true,"content":"<p>A mapped type is a loop over keys that produces an object or tuple type and looks as follows:</p><pre><code>{[]: }\n</code></pre><p>In this blog post, we examine how mapped types work and see examples of using them. Their most importing use cases are transforming objects and mapping tuples.</p>","contentLength":259,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Show HN: SQL Noir ‚Äì Learn SQL by solving crimes","url":"https://www.sqlnoir.com/","date":1739483356,"author":"chrisBHappy","guid":321,"unread":true,"content":"<!DOCTYPE html>","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=43041827"},{"title":"Bojan Mihelac: Prefixed Parameters for Django querystring tag","url":"http://code.informatikamihelac.com/en/query-string-with-prefixed-parameters/","date":1739482638,"author":"","guid":281,"unread":true,"content":"<article>An overview of Django 5.1's new querystring tag and how to add support for prefixed parameters.</article>","contentLength":95,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Learnings from a Machine Learning Engineer ‚Äî Part 5: The Training","url":"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-5-the-training/","date":1739480672,"author":"David Martin","guid":7,"unread":true,"content":"<p>In this fifth part of my series, I will outline the steps for creating a Docker container for training your image classification model, evaluating performance, and preparing for deployment.</p><p>AI/ML engineers would prefer to focus on model training and data engineering, but the reality is that we also need to understand the infrastructure and mechanics behind the scenes.</p><p>I hope to share some tips, not only to get your training run running, but how to streamline the process in a cost efficient manner on cloud resources such as Kubernetes.</p><p>I will reference elements from my previous articles for getting the best model performance, so be sure to check out&nbsp;<a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-1-the-data/\">Part 1</a>&nbsp;and&nbsp;<a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-2-the-data-sets/\">Part 2</a>&nbsp;on the data sets, as well as&nbsp;<a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-3-the-evaluation/\">Part 3</a>&nbsp;and&nbsp;<a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-4-the-model/\">Part 4</a>&nbsp;on model evaluation.</p><p>Here are the learnings that I will share with you, once we lay the groundwork on the infrastructure:</p><ul><li>Building your Docker container</li><li>Executing your training run</li></ul><p>First, let me provide a brief description of the setup that I created, specifically around Kubernetes. Your setup may be entirely different, and that is just fine. I simply want to set the stage on the infrastructure so that the rest of the discussion makes sense.</p><p>This is a server you deploy that provides a user interface to for your subject matter experts to label and evaluate images for the image classification application. The server can run as a pod on your Kubernetes cluster, but you may find that running a dedicated server with faster disk may be better.</p><p>Image files are stored in a directory structure like the following, which is self-documenting and easily modified.</p><pre><code>Image_Library/\n  - cats/\n    - image1001.png\n  - dogs/\n    - image2001.png</code></pre><p>Ideally, these files would reside on local server storage (instead of cloud or cluster storage) for better performance. The reason for this will become clear as we see what happens as the image library grows.</p><p><a href=\"https://towardsdatascience.com/tag/cloud-storage/\" title=\"Cloud Storage\">Cloud Storage</a> allows for a virtually limitless and convenient way to share files between systems. In this case, the image library on your management system could access the same files as your Kubernetes cluster or Docker engine.</p><p>However, the downside of cloud storage is the latency to open a file. Your image library will have&nbsp;&nbsp;of images, and the latency to read each file will have a significant impact on your training run time. Longer training runs means more cost for using the expensive GPU processors!</p><p>The way that I found to speed things up is to create a&nbsp;&nbsp;file of your image library on your management system and copy them to cloud storage. Even better would be to create multiple tar files&nbsp;, each containing 10,000 to 20,000 images.</p><p>This way you only have network latency on a handful of files (which contain thousands, once extracted) and you start your training run much sooner.</p><h3>Kubernetes or Docker engine</h3><p>A Kubernetes cluster, with proper configuration, will allow you to dynamically scale up/down nodes, so you can perform your model training on GPU hardware as needed. Kubernetes is a rather heavy setup, and there are other container engines that will work.</p><blockquote><p>The technology options change constantly!</p></blockquote><p>The main idea is that you want to spin up the resources you need ‚Äî for only as long as you need them ‚Äî then scale down to reduce your time (and therefore cost) of running expensive GPU resources.</p><p>Once your GPU node is started and your <a href=\"https://towardsdatascience.com/tag/docker/\" title=\"Docker\">Docker</a> container is running, you can extract the&nbsp;&nbsp;files above to&nbsp;&nbsp;storage, such as an&nbsp;, on your node. The node typically has high-speed SSD disk, ideal for this type of workload. There is one caveat ‚Äî the storage capacity on your node must be able to handle your image library.</p><p>Assuming we are good, let‚Äôs talk about building your Docker container so that you can train your model on your image library.</p><h2>Building your Docker container</h2><p>Being able to execute a training run in a consistent manner lends itself perfectly to building a Docker container. You can ‚Äúpin‚Äù the version of libraries so you know exactly how your scripts will run every time. You can version control your containers as well, and revert to a known good image in a pinch. What is really nice about Docker is you can run the container pretty much anywhere.</p><p>The tradeoff when running in a container, especially with an <a href=\"https://towardsdatascience.com/tag/image-classification/\" title=\"Image Classification\">Image Classification</a> model, is the speed of file storage. You can attach any number of volumes to your container, but they are usually&nbsp;&nbsp;attached, so there is latency on each file read. This may not be a problem if you have a small number of files. But when dealing with hundreds of thousands of files like image data, that latency adds up!</p><p>This is why using the&nbsp;&nbsp;file method outlined above can be beneficial.</p><p>Also, keep in mind that Docker containers could be terminated unexpectedly, so you should make sure to store important information outside the container, on cloud storage or a database. I‚Äôll show you how below.</p><p>Knowing that you will need to run on GPU hardware (here I will assume Nvidia), be sure to select the right base image for your Dockerfile, such as&nbsp;&nbsp;with the ‚Äúdevel&nbsp;flavor that will contain the right drivers.</p><p>Next, you will add the script files to your container, along with a ‚Äúbatch‚Äù script to coordinate the execution. Here is an example Dockerfile, and then I‚Äôll describe what each of the scripts will be doing.</p><pre><code>#####   Dockerfile   #####\nFROM nvidia/cuda:12.8.0-devel-ubuntu24.04\n\n# Install system software\nRUN apt-get -y update &amp;&amp; apg-get -y upgrade\nRUN apt-get install -y python3-pip python3-dev\n\n# Setup python\nWORKDIR /app\nCOPY requirements.txt\nRUN python3 -m pip install --upgrade pip\nRUN python3 -m pip install -r requirements.txt\n\n# Pythong and batch scripts\nCOPY ExtractImageLibrary.py .\nCOPY Training.py .\nCOPY Evaluation.py .\nCOPY ScorePerformance.py .\nCOPY ExportModel.py .\nCOPY BulkIdentification.py .\nCOPY BatchControl.sh .\n\n# Allow for interactive shell\nCMD tail -f /dev/null</code></pre><p>Dockerfiles are declarative, almost like a cookbook for building a small server ‚Äî you know what you‚Äôll get every time. Python libraries benefit, too, from this declarative approach. Here is a sample&nbsp;&nbsp;file that loads the TensorFlow libraries with CUDA support for GPU acceleration.</p><pre><code>#####   requirements.txt   #####\nnumpy==1.26.3\npandas==2.1.4\nscipy==1.11.4\nkeras==2.15.0\ntensorflow[and-cuda]</code></pre><h3>Extract Image Library script</h3><p>In <a href=\"https://towardsdatascience.com/tag/kubernetes/\" title=\"Kubernetes\">Kubernetes</a>, the Docker container can access local, high speed storage on the physical node. This can be achieved via the&nbsp;&nbsp;volume type. As mentioned before, this will only work if the local storage on your node can handle the size of your library.</p><pre><code>#####   sample 25GB emptyDir volume in Kubernetes   #####\ncontainers:\n  - name: training-container\n    volumeMounts:\n      - name: image-library\n        mountPath: /mnt/image-library\nvolumes:\n  - name: image-library\n    emptyDir:\n      sizeLimit: 25Gi</code></pre><p>You would want to have another&nbsp;&nbsp;to your cloud storage where you have the&nbsp;&nbsp;files. What this looks like will depend on your provider, or if you are using a persistent volume claim, so I won‚Äôt go into detail here.</p><p>Now you can extract the&nbsp;&nbsp;files ‚Äî ideally in parallel for an added performance boost ‚Äî to the local mount point.</p><p>As AI/ML engineers, the model training is where we want to spend most of our time.</p><blockquote><p>This is where the magic happens!</p></blockquote><p>With your image library now extracted, we can create our train-validation-test sets, load a pre-trained model or build a new one, fit the model, and save the results.</p><p>One key technique that has served me well is to load the most recently trained model as my base. I discuss this in more detail in&nbsp;<a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-4-the-model/\">Part 4</a>&nbsp;under ‚ÄúFine tuning‚Äù, this results in faster training time and significantly improved model performance.</p><p>Be sure to take advantage of the local storage to checkpoint your model during training since the models are quite large and you are paying for the GPU even while it sits idle writing to disk.</p><p>This of course raises a concern about what happens if the Docker container dies part-way though the training. The risk is (hopefully) low from a cloud provider, and you may not want an incomplete training anyway. But if that does happen, you will at least want to understand&nbsp;, and this is where saving the main log file to cloud storage (described below) or to a package like MLflow comes in handy.</p><p>After your training run has completed and you have taken proper precaution on saving your work, it is time to see how well it performed.</p><p>Normally this evaluation script will pick up on the model that just finished. But you may decide to point it at a previous model version through an interactive session. This is why have the script as stand-alone.</p><p>With it being a separate script, that means it will need to read the completed model from disk ‚Äî ideally local disk for speed. I like having two separate scripts (training and evaluation), but you might find it better to combine these to avoid reloading the model.</p><p>Now that the model is loaded, the evaluation script should generate predictions on&nbsp;&nbsp;image in the training, validation, test, and benchmark sets. I save the results as a&nbsp;&nbsp;matrix with the softmax confidence score for each class label. So, if there are 1,000 classes and 100,000 images, that‚Äôs a table with 100 million scores!</p><p>I save these results in&nbsp;&nbsp;files that are then used in the score generation next.</p><p>Taking the matrix of scores produced by the evaluation script above, we can now create various metrics of model performance. Again, this process could be combined with the evaluation script above, but my preference is for independent scripts. For example, I might want to regenerate scores on previous training runs. See what works for you.</p><p>Here are some of the&nbsp;&nbsp;functions that produce useful insights like F1, log loss, AUC-ROC, Matthews correlation coefficient.</p><pre><code>from sklearn.metrics import average_precision_score, classification_report\nfrom sklearn.metrics import log_loss, matthews_corrcoef, roc_auc_score</code></pre><p>Aside from these basic statistical analyses for each dataset (train, validation, test, and benchmark), it is also useful to identify:</p><ul><li>Which&nbsp;&nbsp;labels get the most number of errors?</li><li>Which&nbsp;&nbsp;labels get the most number of incorrect guesses?</li><li>How many&nbsp;<strong>ground-truth-to-predicted</strong>&nbsp;label pairs are there? In other words, which classes are easily confused?</li><li>What is the&nbsp;&nbsp;when applying a minimum softmax confidence score threshold?</li><li>What is the&nbsp;&nbsp;above that softmax threshold?</li><li>For the ‚Äúdifficult‚Äù benchmark sets, do you get a sufficiently&nbsp;&nbsp;score?</li><li>For the ‚Äúout-of-scope‚Äù benchmark sets, do you get a sufficiently&nbsp;&nbsp;score?</li></ul><p>As you can see, there are multiple calculations and it‚Äôs not easy to come up with a single evaluation to decide if the trained model is good enough to be moved to production.</p><p>In fact, for an image classification model, it is helpful to manually review the images that the model got wrong, as well as the ones that got a low softmax confidence score. Use the scores from this script to create a list of images to manually review, and then get a&nbsp;&nbsp;for how well the model performs.</p><p>Check out&nbsp;<a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-3-the-evaluation/\">Part 3</a>&nbsp;for more in-depth discussion on evaluation and scoring.</p><p>All of the heavy lifting is done by this point. Since your Docker container will be shutdown soon, now is the time to copy the model artifacts to cloud storage and prepare them for being put to use.</p><p>The example Python code snippet below is more geared to Keras and TensorFlow. This will take the trained model and export it as a&nbsp;. Later, I will show how this is used by TensorFlow Serving in the&nbsp;&nbsp;section below.</p><pre><code># Increment current version of model and create new directory\nnext_version_dir, version_number = create_new_version_folder()\n\n# Copy model artifacts to the new directory\ncopy_model_artifacts(next_version_dir)\n\n# Create the directory to save the model export\nsaved_model_dir = os.path.join(next_version_dir, str(version_number))\n\n# Save the model export for use with TensorFlow Serving\ntf.keras.backend.set_learning_phase(0)\nmodel = tf.keras.models.load_model(keras_model_file)\ntf.saved_model.save(model, export_dir=saved_model_dir)</code></pre><p>This script also copies the other training run artifacts such as the model evaluation results, score summaries, and log files generated from model training. Don‚Äôt forget about your label map so you can give human readable names to your classes!</p><h3>Bulk identification script</h3><p>Your training run is complete, your model has been scored, and a new version is exported and ready to be served. Now is the time to use this latest model to assist you on trying to identify unlabeled images.</p><p>As I described in&nbsp;<a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-4-the-model/\">Part 4</a>, you may have a collection of ‚Äúunknowns‚Äù ‚Äî really good pictures, but no idea what they are. Let your new model provide a best guess on these and record the results to a file or a database. Now you can create filters based on closest match and by high/low scores. This allows your subject matter experts to leverage these filters to find new image classes, add to existing classes, or to remove images that have very low scores and are no good.</p><p>By the way, I put this step inside the GPU container since you may have thousands of ‚Äúunknown‚Äù images to process and the accelerated hardware will make light work of it. However, if you are not in a hurry, you could perform this step on a separate CPU node, and shutdown your GPU node sooner to save cost. This would especially make sense if your ‚Äúunknowns‚Äù folder is on slower cloud storage.</p><p>All of the scripts described above perform a specific task ‚Äî from extracting your image library, executing model training, performing evaluation and scoring, exporting the model artifacts for deployment, and perhaps even bulk identification.</p><blockquote><p>One script to rule them all</p></blockquote><p>To coordinate the entire show, this batch script gives you the entry point for your container and an easy way to trigger everything. Be sure to produce a log file in case you need to analyze any failures along the way. Also, be sure to write the log to your cloud storage in case the container dies unexpectedly.</p><pre><code>#!/bin/bash\n# Main batch control script\n\n# Redirect standard output and standard error to a log file\nexec &gt; /cloud_storage/batch-logfile.txt 2&gt;&amp;1\n\n/app/ExtractImageLibrary.py\n/app/Training.py\n/app/Evaluation.py\n/app/ScorePerformance.py\n/app/ExportModel.py\n/app/BulkIdentification.py</code></pre><h2>Executing your training run</h2><p>So, now it‚Äôs time to put everything in motion‚Ä¶</p><p>Let‚Äôs go through the steps to prepare your image library, fire up your Docker container to train your model, and then examine the results.</p><h3>Image library ‚Äòtar‚Äô files</h3><p>Your image management system should now create a&nbsp;&nbsp;file backup of your data. Since&nbsp;&nbsp;is a single-threaded function, you will get significant speed improvement by creating multiple tar files in parallel, each with a portion of you data.</p><p>Now these files can be copied to your shared cloud storage for the next step.</p><p>All the hard work you put into creating your container (described above) will be put to the test. If you are running Kubernetes, you can create a Job that will execute the&nbsp;&nbsp;script.</p><p>Inside the Kubernetes Job definition, you can pass environment variables to adjust the execution of your script. For example, the batch size and number of epochs are set here and then pulled into your Python scripts, so you can alter the behavior without changing your code.</p><pre><code>#####   sample Job in Kubernetes   #####\ncontainers:\n  - name: training-job\n    env:\n      - name: BATCH_SIZE\n        value: 50\n      - name: NUM_EPOCHS\n        value: 30\n    command: [\"/app/BatchControl.sh\"]</code></pre><p>Once the Job is completed, be sure to verify that the GPU node properly scales back down to zero according to your scaling configuration in Kubernetes ‚Äî you don‚Äôt want to be saddled with a huge bill over a simple configuration error.</p><p>With the training run complete, you should now have model artifacts saved and can examine the performance. Look through the metrics, such as F1 and log loss, and benchmark accuracy for high softmax confidence scores.</p><p>As mentioned earlier, the reports only tell part of the story. It is worth the time and effort to manually review the images that the model got wrong or where it produced a low confidence score.</p><p>Don‚Äôt forget about the bulk identification. Be sure to leverage these to locate new images to fill out your data set, or to find new classes.</p><p>Once you have reviewed your model performance and are satisfied with the results, it is time to modify your TensorFlow Serving container to put the new model into production.</p><p>TensorFlow Serving is available as a Docker container and provides a very quick and convenient way to serve your model. This container can listen and respond to API calls for your model.</p><p>Let‚Äôs say your new model is version 7, and your&nbsp;&nbsp;script (see above) has saved the model in your cloud share as&nbsp;<em>/image_application/models/007</em>. You can start the TensorFlow Serving container with that volume mount. In this example, the&nbsp;&nbsp;points to folder for version 007.</p><pre><code>#####   sample TensorFlow pod in Kubernetes   #####\ncontainers:\n  - name: tensorflow-serving\n    image: bitnami/tensorflow-serving:2.18.0\n    ports:\n      - containerPort: 8501\n    env:\n      - name: TENSORFLOW_SERVING_MODEL_NAME\n        value: \"image_application\"\n    volumeMounts:\n      - name: models-subfolder\n        mountPath: \"/bitnami/model-data\"\n\nvolumes:\n  - name: models-subfolder\n    azureFile:\n      shareName: \"image_application/models/007\"</code></pre><p>A subtle note here ‚Äî the export script should create a sub-folder, named 007 (same as the base folder), with the saved model export. This may seem a little confusing, but TensorFlow Serving will mount this share folder as&nbsp;&nbsp;and detect the numbered sub-folder inside it for the version to serve. This will allow you to query the API for the model version as well as the identification.</p><p>As I mentioned at the start of this article, this setup has worked for my situation. This is certainly not the only way to approach this challenge, and I invite you to customize your own solution.</p><p>I wanted to share my hard-fought learnings as I embraced cloud services in Kubernetes, with the desire to keep costs under control. Of course, doing all this while maintaining a high level of model performance is an added challenge, but one that you can achieve.</p><p>I hope I have provided enough information here to help you with your own endeavors. Happy learnings!</p>","contentLength":18226,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Learnings from a Machine Learning Engineer ‚Äî Part 3: The Evaluation","url":"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-3-the-evaluation/","date":1739480406,"author":"David Martin","guid":6,"unread":true,"content":"<p>In this third part of my series, I will explore the evaluation process which is a critical piece that will lead to a cleaner data set and elevate your model performance. We will see the difference between evaluation of a&nbsp;&nbsp;model (one not yet in production), and evaluation of a&nbsp;&nbsp;model (one making real-world predictions).</p><p>In&nbsp;<a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-1-the-data/\">Part 1</a>, I discussed the process of labelling your image data that you use in your <a href=\"https://towardsdatascience.com/tag/image-classification/\" title=\"Image Classification\">Image Classification</a> project. I showed how to define ‚Äúgood‚Äù images and create sub-classes. In&nbsp;<a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-2-the-data-sets/\">Part 2</a>, I went over various data sets, beyond the usual train-validation-test sets, such as benchmark sets, plus how to handle synthetic data and duplicate images.</p><h2><strong>Evaluation of the trained model</strong></h2><p>As machine learning engineers we look at accuracy, F1, log loss, and other metrics to decide if a model is ready to move to production. These are all important measures, but from my experience, these scores can be deceiving especially as the number of classes grows.</p><p>Although it can be time consuming, I find it very important to manually review the images that the model gets&nbsp;, as well as the images that the model gives a&nbsp;&nbsp;softmax ‚Äúconfidence‚Äù score to. This means adding a step immediately after your training run completes to calculate scores for&nbsp;&nbsp;images ‚Äî training, validation, test, and the benchmark sets. You only need to bring up for manual review the ones that the model had problems with. This should only be a small percentage of the total number of images. See the Double-check process below</p><p>What you do during the manual evaluation is to put yourself in a ‚Äú‚Äù to ensure that the labelling standards are being followed that you setup in <a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-1-the-data/\">Part 1</a>. Ask yourself:</p><ul><li>‚ÄúIs this a good image?‚Äù Is the subject front and center, and can you clearly see all the features?</li><li>‚ÄúIs this the correct label?‚Äù Don‚Äôt be surprised if you find wrong labels.</li></ul><p>You can either remove the bad images or fix the labels if they are wrong. Otherwise you can keep them in the data set and force the model to do better next time. Other questions I ask are:</p><ul><li>‚ÄúWhy did the model get this wrong?‚Äù</li><li>‚ÄúWhy did this image get a low score?‚Äù</li><li>‚ÄúWhat is it about the image that caused confusion?‚Äù</li></ul><p>Sometimes the answer has nothing to do with&nbsp;&nbsp;specific image. Frequently, it has to do with the&nbsp;&nbsp;images, either in the ground truth class or in the predicted class. It is worth the effort to Double-check all images in both sets if you see a consistently bad guess. Again, don‚Äôt be surprised if you find poor images or wrong labels.</p><p>When doing the evaluation of the trained model (above), we apply a lot of subjective analysis ‚Äî ‚ÄúWhy did the model get this wrong?‚Äù and ‚ÄúIs this a good image?‚Äù From these, you may only get a&nbsp;.</p><p>Frequently, I will decide to hold off moving a model forward to production based on that gut feel. But how can you justify to your manager that you want to hit the brakes? This is where putting a more&nbsp;&nbsp;analysis comes in by creating a weighted average of the softmax ‚Äúconfidence‚Äù scores.</p><p>In order to apply a weighted evaluation, we need to identify sets of classes that deserve adjustments to the score. Here is where I create a list of ‚Äúcommonly confused‚Äù classes.</p><h2><strong>Commonly confused classes</strong></h2><p>Certain animals at our zoo can easily be mistaken. For example, African elephants and Asian elephants have different ear shapes. If your model gets these two mixed up, that is not as bad as guessing a giraffe! So perhaps you give partial credit here. You and your subject matter experts (SMEs) can come up with a list of these pairs and a weighted adjustment for each.</p><p>This weight can be factored into a modified cross-entropy loss function in the equation below. The back half of this equation will reduce the impact of being wrong for specific pairs of ground truth and prediction by using the ‚Äúweight‚Äù function as a lookup. By default, the weighted adjustment would be 1 for all pairings, and the commonly confused classes would get something like 0.5.</p><p>In other words, it‚Äôs better to be unsure (have a&nbsp;&nbsp;confidence score) when you are wrong, compared to being super confident and wrong.</p><p>Once this weighted log loss is calculated, I can compare to previous training runs to see if the new model is ready for production.</p><h2><strong>Confidence threshold report</strong></h2><p>Another valuable measure that incorporates the confidence threshold (in my example, 95) is to report on accuracy and false positive rates. Recall that when we apply the confidence threshold before presenting results, we help reduce false positives from being shown to the end user.</p><p>In this table, we look at the breakdown of ‚Äútrue positive above 95‚Äù for each data set. We get a sense that when a ‚Äúgood‚Äù picture comes through (like the ones from our train-validation-test set) it is very likely to surpass the threshold, thus the user is ‚Äúhappy‚Äù with the outcome. Conversely, the ‚Äúfalse positive above 95‚Äù is extremely low for good pictures, thus only a small number of our users will be ‚Äúsad‚Äù about the results.</p><p>We expect the train-validation-test set results to be exceptional since our data is curated. So, as long as people take ‚Äúgood‚Äù pictures, the model should do very well. But to get a sense of how it does on extreme situations, let‚Äôs take a look at our benchmarks.</p><p>The ‚Äúdifficult‚Äù benchmark has more modest true positive and false positive rates, which reflects the fact that the images are more challenging. These values are much easier to compare across training runs, so that lets me set a min/max target. So for example, if I target a minimum of 80% for true positive, and maximum of 5% for false positive on this benchmark, then I can feel confident moving this to production.</p><p>The ‚Äúout-of-scope‚Äù benchmark has no true positive rate because&nbsp;&nbsp;of the images belong to any class the model can identify. Remember, we picked things like a bag of popcorn, etc., that are not zoo animals, so there cannot be any true positives. But we do get a false positive rate, which means the model gave a confident score to that bag of popcorn as some animal. And if we set a target maximum of 10% for this benchmark, then we may not want to move it to production.</p><p>Right now, you may be thinking, ‚ÄúWell, what animal did it pick for the bag of popcorn?‚Äù Excellent question! Now you understand the importance of doing a manual review of the images that get bad results.</p><h2><strong>Evaluation of the deployed model</strong></h2><p>The evaluation that I described above applies to a model immediately after&nbsp;. Now, you want to evaluate how your model is doing in the&nbsp;. The process is similar, but requires you to shift to a ‚Äú‚Äù and asking yourself, ‚ÄúDid the model get this correct?‚Äù and ‚ÄúShould it have gotten this correct?‚Äù and ‚ÄúDid we tell the user the right thing?‚Äù</p><p>So, imagine that you are logging in for the morning ‚Äî after sipping on your&nbsp;<a href=\"https://medium.com/@dmartin0409/cold-brew-coffee-0aabd53a1f3e\">cold brew coffee</a>, of course ‚Äî and are presented with 500 images that your zoo guests took yesterday of different animals. Your job is to determine how satisfied the guests were using your model to identify the zoo animals.</p><p>Using the softmax ‚Äúconfidence‚Äù score for each image, we have a threshold before presenting results. Above the threshold, we tell the guest what the model predicted. I‚Äôll call this the ‚Äúhappy path‚Äù. And below the threshold is the ‚Äúsad path‚Äù where we ask them to try again.</p><p>Your review interface will first show you all the ‚Äúhappy path‚Äù images one at a time. This is where you ask yourself, ‚ÄúDid we get this right?‚Äù Hopefully, yes!</p><p>But if not, this is where things get tricky. So now you have to ask, ‚ÄúWhy not?‚Äù Here are some things that it could be:</p><ul><li>‚ÄúBad‚Äù picture ‚Äî Poor lighting, bad angle, zoomed out, etc ‚Äî refer to your labelling standards.</li><li>Out-of-scope ‚Äî It‚Äôs a zoo animal, but unfortunately one that isn‚Äôt found in&nbsp;&nbsp;zoo. Maybe it belongs to another zoo (your guest likes to travel and try out your app). Consider adding these to your data set.</li><li>Out-of-scope ‚Äî It‚Äôs not a zoo animal. It could be an animal in your zoo, but not one typically&nbsp;&nbsp;there, like a neighborhood sparrow or mallard duck. This might be a candidate to add.</li><li>Out-of-scope ‚Äî It‚Äôs something found in the zoo. A zoo usually has interesting trees and shrubs, so people might try to identify those. Another candidate to add.</li><li>Prankster ‚Äî Completely out-of-scope. Because people like to play with technology, there‚Äôs the possibility you have a prankster that took a picture of a bag of popcorn, or a soft drink cup, or even a selfie. These are hard to prevent, but hopefully get a low enough score (below the threshold) so the model did not identify it as a zoo animal. If you see enough pattern in these, consider creating a class with special handling on the front-end.</li></ul><p>After reviewing the ‚Äúhappy path‚Äù images, you move on to the ‚Äúsad path‚Äù images ‚Äî the ones that got a low confidence score and the app gave a ‚Äúsorry, try again‚Äù message. This time you ask yourself, ‚Äú&nbsp;the model have given this image a higher score?‚Äù which would have put it in the ‚Äúhappy path‚Äù. If so, then you want to ensure these images are added to the training set so next time it will do better. But most of time, the low score reflects many of the ‚Äúbad‚Äù or out-of-scope situations mentioned above.</p><p>Perhaps your model performance is suffering and it has nothing to do with your model. Maybe it is the ways you users interacting with the app. Keep an eye out of non-technical problems and share your observations with the rest of your team. For example:</p><ul><li>Are your users using the application in the ways you expected?</li><li>Are they not following the instructions?</li><li>Do the instructions need to be stated more clearly?</li><li>Is there anything you can do to improve the experience?</li></ul><h2><strong>Collect statistics and new images</strong></h2><p>Both of the manual evaluations above open a gold mine of data. So, be sure to collect these statistics and feed them into a dashboard ‚Äî your manager and your future self will thank you!</p><p>Keep track of these stats and generate reports that you and your can reference:</p><ul><li>How often the model is being called?</li><li>What times of the day, what days of the week is it used?</li><li>Are your system resources able to handle the peak load?</li><li>What classes are the most common?</li><li>After evaluation, what is the accuracy for each class?</li><li>What is the breakdown for confidence scores?</li><li>How many scores are above and below the confidence threshold?</li></ul><p>The single best thing you get from a deployed model is the additional real-world images! You can add these now images to improve coverage of your existing zoo animals. But more importantly, they provide you insight on&nbsp;&nbsp;classes to add. For example, let‚Äôs say people enjoy taking a picture of the large walrus statue at the gate. Some of these may make sense to incorporate into your data set to provide a better user experience.</p><p>Creating a new class, like the walrus statue, is not a huge effort, and it avoids the false positive responses. It would be more embarrassing to identify a walrus statue as an elephant! As for the prankster and the bag of popcorn, you can configure your front-end to quietly handle these. You might even get creative and have fun with it like, ‚ÄúThank you for visiting the food court.‚Äù</p><p>It is a good idea to double-check your image set when you suspect there may be problems with your data. I‚Äôm not suggesting a top-to-bottom check, because that would a monumental effort! Rather specific classes that you suspect could contain bad data that is degrading your model performance.</p><p>Immediately after my training run completes, I have a script that will use this new model to generate predictions for my&nbsp;&nbsp;data set. When this is complete, it will take the list of incorrect identifications, as well as the low scoring predictions, and automatically feed that list into the Double-check interface.</p><p>This interface will show, one at a time, the image in question, alongside an example image of the ground truth and an example image of what the model predicted. I can visually compare the three, side-by-side. The first thing I do is ensure the original image is a ‚Äúgood‚Äù picture, following my labelling standards. Then I check if the ground-truth label is indeed correct, or if there is something that made the model think it was the predicted label.</p><ul><li>Remove the original image if the image quality is poor.</li><li>Relabel the image if it belongs in a different class.</li></ul><p>During this manual evaluation, you might notice dozens of the same wrong prediction. Ask yourself why the model made this mistake when the images seem perfectly fine. The answer may be some incorrect labels on images in the ground truth, or even in the predicted class!</p><p>Don‚Äôt hesitate to add those classes and sub-classes back into the Double-check interface and step through them all. You may have 100‚Äì200 pictures to review, but there is a good chance that one or two of the images will stand out as being the culprit.</p><p>With a different mindset for a trained model versus a deployed model, we can now evaluate performances to decide which models are ready for production, and how well a production model is going to serve the public. This relies on a solid Double-check process and a critical eye on your data. And beyond the ‚Äúgut feel‚Äù of your model, we can rely on the benchmark scores to support us.</p><p>In&nbsp;<a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-4-the-model/\">Part 4</a>, we kick off the training run, but there are some subtle techniques to get the most out of the process and even ways to leverage throw-away models to expand your library image data.<a href=\"https://medium.com/tag/machine-learning?source=post_page-----e4a8dbb035e0---------------------------------------\"></a></p>","contentLength":13463,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Build a dynamic, role-based AI agent using Amazon Bedrock inline agents","url":"https://aws.amazon.com/blogs/machine-learning/build-a-dynamic-role-based-ai-agent-using-amazon-bedrock-inline-agents/","date":1739480188,"author":"Ishan Singh","guid":236,"unread":true,"content":"<p>AI agents continue to gain momentum, as businesses use the power of generative AI to reinvent customer experiences and automate complex workflows. We are seeing <a href=\"https://aws.amazon.com/bedrock/agents/\" target=\"_blank\" rel=\"noopener\">Amazon Bedrock Agents</a> applied in investment research, insurance claims processing, root cause analysis, advertising campaigns, and much more. Agents use the reasoning capability of foundation models (FMs) to break down user-requested tasks into multiple steps. They use developer-provided instructions to create an orchestration plan and carry out that plan by securely invoking company APIs and accessing knowledge bases using Retrieval Augmented Generation (RAG) to accurately handle the user‚Äôs request.</p><p>Although organizations see the benefit of agents that are defined, configured, and tested as managed resources, we have increasingly seen the need for an additional, more dynamic way to invoke agents. Organizations need solutions that adjust on the fly‚Äîwhether to test new approaches, respond to changing business rules, or customize solutions for different clients. This is where the new <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/agents-create-inline.html\" target=\"_blank\" rel=\"noopener\">inline agents</a> capability in Amazon Bedrock Agents becomes transformative. It allows you to dynamically adjust your agent‚Äôs behavior at runtime by changing its instructions, tools, guardrails, knowledge bases, prompts, and even the FMs it uses‚Äîall without redeploying your application.</p><p>In this post, we explore how to build an application using Amazon Bedrock inline agents, demonstrating how a single AI assistant can adapt its capabilities dynamically based on user roles.</p><h2>Inline agents in Amazon Bedrock Agents</h2><p>This runtime flexibility enabled by inline agents opens powerful new possibilities, such as:</p><ul><li> ‚Äì Inline agents minimize the time-consuming create/update/prepare cycles traditionally required for agent configuration changes. Developers can instantly test different combinations of models, tools, and knowledge bases, dramatically accelerating the development process.</li><li><strong>A/B testing and experimentation</strong> ‚Äì Data science teams can systematically evaluate different model-tool combinations, measure performance metrics, and analyze response patterns in controlled environments. This empirical approach enables quantitative comparison of configurations before production deployment.</li><li><strong>Subscription-based personalization</strong> ‚Äì Software companies can adapt features based on each customer‚Äôs subscription level, providing more advanced tools for premium users.</li><li><strong>Persona-based data source integration</strong> ‚Äì Institutions can adjust content complexity and tone based on the user‚Äôs profile, providing persona-appropriate explanations and resources by changing the knowledge bases associated to the agent on the fly.</li><li> ‚Äì Developers can create applications with hundreds of APIs, and quickly and accurately carry out tasks by dynamically choosing a small subset of APIs for the agent to consider for a given request. This is particularly helpful for large software as a service (SaaS) platforms needing multi-tenant scaling.</li></ul><p>Inline agents expand your options for building and deploying agentic solutions with Amazon Bedrock Agents. For workloads needing managed and versioned agent resources with a pre-determined and tested configuration (specific model, instructions, tools, and so on), developers can continue to use InvokeAgent on resources created with CreateAgent. For workloads that need dynamic runtime behavior changes for each agent invocation, you can use the new <a href=\"https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeInlineAgent.html\" target=\"_blank\" rel=\"noopener\">InvokeInlineAgent API</a>. With either approach, your agents will be secure and scalable, with configurable guardrails, a flexible set of model inference options, native access to knowledge bases, code interpretation, session memory, and more.</p><p>Our HR assistant example shows how to build a single AI assistant that adapts to different user roles using the new inline agent capabilities in Amazon Bedrock Agents. When users interact with the assistant, the assistant dynamically configures agent capabilities (such as model, instructions, knowledge bases, action groups, and guardrails) based on the user‚Äôs role and their specific selections. This approach creates a flexible system that adjusts its functionality in real time, making it more efficient than creating separate agents for each user role or tool combination. The complete code for this HR assistant example is available on our <a href=\"https://github.com/awslabs/amazon-bedrock-agent-samples/tree/main/examples/agents_ux/inline-agent-hr-assistant\" target=\"_blank\" rel=\"noopener\">GitHub repo</a>.</p><p>This dynamic tool selection enables a personalized experience. When an employee logs in without direct reports, they see a set of tools that they have access to based on their role. They can select from options like requesting vacation time, checking company policies using the knowledge base, using a code interpreter for data analysis, or submitting expense reports. The inline agent assistant is then configured with only these selected tools, allowing it to assist the employee with their chosen tasks. In a real-world example, the user would not need to make the selection, because the application would make that decision and automatically configure the agent invocation at runtime. We make it explicit in this application so that you can demonstrate the impact.</p><p>Similarly, when a manager logs in to the same system, they see an extended set of tools reflecting their additional permissions. In addition to the employee-level tools, managers have access to capabilities like running performance reviews. They can select which tools they want to use for their current session, instantly configuring the inline agent with their choices.</p><p>The inclusion of knowledge bases is also adjusted based on the user‚Äôs role. Employees and managers see different levels of company policy information, with managers getting additional access to confidential data like performance review and compensation details. For this demo, we‚Äôve implemented <a href=\"https://aws.amazon.com/blogs/machine-learning/amazon-bedrock-knowledge-bases-now-supports-metadata-filtering-to-improve-retrieval-accuracy/\" target=\"_blank\" rel=\"noopener\">metadata filtering</a> to retrieve only the appropriate level of documents based on the user‚Äôs access level, further enhancing efficiency and security.</p><p>Let‚Äôs look at how the interface adapts to different user roles.</p><p>The employee view provides access to essential HR functions like vacation requests, expense submissions, and company policy lookups. Users can select which of these tools they want to use for their current session.</p><p>The manager view extends these options to include supervisory functions like compensation management, demonstrating how the inline agent can be configured with a broader set of tools based on user permissions.</p><p>The manager view extends these capabilities to include supervisory functions like compensation management, demonstrating how the inline agent dynamically adjusts its available tools based on user permissions. Without inline agents, we would need to build and maintain two separate agents.</p><p>As shown in the preceding screenshots, the same HR assistant offers different tool selections based on the user‚Äôs role. An employee sees options like Knowledge Base, Apply Vacation Tool, and Submit Expense, whereas a manager has additional options like Performance Evaluation. Users can select which tools they want to add to the agent for their current interaction.</p><p>This flexibility allows for quick adaptation to user needs and preferences. For instance, if the company introduces a new policy for creating business travel requests, the tool catalog can be quickly updated to include a Create Business Travel Reservation tool. Employees can then choose to add this new tool to their agent configuration when they need to plan a business trip, or the application could automatically do so based on their role.</p><p>With Amazon Bedrock inline agents, you can create a catalog of actions that is dynamically selected by the application or by users of the application. This increases the level of flexibility and adaptability of your solutions, making them a perfect fit for navigating the complex, ever-changing landscape of modern business operations. Users have more control over their AI assistant‚Äôs capabilities, and the system remains efficient by only loading the necessary tools for each interaction.</p><h2>Technical foundation: Dynamic configuration and action selection</h2><p>Inline agents allow dynamic configuration at runtime, enabling a single agent to effectively perform the work of many. By specifying action groups and modifying instructions on the fly, even within the same session, you can create versatile AI applications that adapt to various scenarios without multiple agent deployments.</p><p>The following are key points about inline agents:</p><ul><li> ‚Äì Change the agent‚Äôs configuration, including its FM, at runtime. This enables rapid experimentation and adaptation without redeploying the application, reducing development cycles.</li><li> ‚Äì Apply governance and access control at the tool level. With agents changing dynamically at runtime, tool-level governance helps maintain security and compliance regardless of the agent‚Äôs configuration.</li><li> ‚Äì Provide only necessary tools and instructions at runtime to reduce token usage and improve the agent accuracy. With fewer tools to choose from, it‚Äôs less complicated for the agent to select the right one, reducing hallucinations in the tool selection process. This approach can also lead to lower costs and improved latency compared to static agents because removing unnecessary tools, knowledge bases, and instructions reduces the number of input and output tokens being processed by the agent‚Äôs large language model (LLM).</li><li> ‚Äì Create reusable actions for dynamic selection based on specific needs. This modular approach simplifies maintenance, updates, and scalability of your AI applications.</li></ul><p>The following are examples of reusable actions:</p><ul><li><strong>Enterprise system integration</strong> ‚Äì Connect with systems like Salesforce, GitHub, or databases</li><li> ‚Äì Perform common tasks such as sending emails or managing calendars</li><li> ‚Äì Interact with specialized internal tools and services</li><li> ‚Äì Analyze text, structured data, or other information</li><li> ‚Äì Fetch weather updates, stock prices, or perform web searches</li><li> ‚Äì Use specific machine learning (ML) models for targeted tasks</li></ul><p>When using inline agents, you configure parameters for the following:</p><ul><li>Contextual tool selection based on user intent or conversation flow</li><li>Adaptation to different user roles and permissions</li><li>Switching between communication styles or personas</li><li>Model selection based on task complexity</li></ul><p>The inline agent uses the configuration you provide at runtime, allowing for highly flexible AI assistants that efficiently handle various tasks across different business contexts.</p><h2>Building an HR assistant using inline agents</h2><p>Let‚Äôs look at how we built our HR Assistant using Amazon Bedrock inline agents:</p><ol><li> ‚Äì We developed a demo catalog of HR-related tools, including: \n  <ul type=\"a\"><li> ‚Äì Using <a href=\"https://aws.amazon.com/bedrock/knowledge-bases/\" target=\"_blank\" rel=\"noopener\">Amazon Bedrock Knowledge Bases</a> for accessing company policies and guidelines based on the role of the application user. In order to filter the knowledge base content based on the user‚Äôs role, you also need to provide a metadata file specifying the type of employee‚Äôs roles that can access each file</li><li>‚Äì For requesting and tracking time off.</li><li>‚Äì For submitting and managing expense reports.</li><li> ‚Äì For performing calculations and data analysis.</li><li>‚Äì for conducting and reviewing employee compensation assessments (manager only access).</li></ul></li><li> ‚Äì We defined multiple conversation tones to suit different interaction styles: \n  <ul><li> ‚Äì For formal, business-like interactions.</li><li> ‚Äì For friendly, everyday support.</li><li> ‚Äì For upbeat, encouraging assistance.</li></ul></li><li> ‚Äì We implemented role-based access control. The application backend checks the user‚Äôs role (employee or manager) and provides access to appropriate tools and information and passes this information to the inline agent. The role information is also used to configure metadata filtering in the knowledge bases to generate relevant responses. The system allows for dynamic tool use at runtime. Users can switch personas or add and remove tools during their session, allowing the agent to adapt to different conversation needs in real time.</li><li><strong>Integrate the agent with other services and tools</strong> ‚Äì We connected the inline agent to: \n  <ul><li>Amazon Bedrock Knowledge Bases for company policies, with metadata filtering for role-based access.</li><li><a href=\"http://aws.amazon.com/lambda\" target=\"_blank\" rel=\"noopener\">AWS Lambda</a> functions for executing specific actions (such as submitting vacation requests or expense reports).</li><li>A code interpreter tool for performing calculations and data analysis.</li></ul></li><li> ‚Äì We created a Flask-based UI that performs the following actions: \n  <ul><li>Displays available tools based on the user‚Äôs role.</li><li>Allows users to select different personas.</li><li>Provides a chat window for interacting with the HR assistant.</li></ul></li></ol><p>To understand how this dynamic role-based functionality works under the hood, let‚Äôs examine the following system architecture diagram.</p><p>As shown in preceding architecture diagram, the system works as follows:</p><ol><li>The end-user logs in and is identified as either a manager or an employee.</li><li>The user selects the tools that they have access to and makes a request to the HR assistant.</li><li>The agent breaks down the problems and uses the available tools to solve for the query in steps, which may include: \n  <ol><li>Amazon Bedrock Knowledge Bases (with metadata filtering for role-based access).</li><li>Lambda functions for specific actions.</li><li>Code interpreter tool for calculations.</li><li>Compensation tool (accessible only to managers to submit base pay raise requests).</li></ol></li><li>The application uses the Amazon Bedrock inline agent to dynamically pass in the appropriate tools based on the user‚Äôs role and request.</li><li>The agent uses the selected tools to process the request and provide a response to the user.</li></ol><p>This approach provides a flexible, scalable solution that can quickly adapt to different user roles and changing business needs.</p><p>In this post, we introduced the Amazon Bedrock inline agent functionality and highlighted its application to an HR use case. We dynamically selected tools based on the user‚Äôs roles and permissions, adapted instructions to set a conversation tone, and selected different models at runtime. With inline agents, you can transform how you build and deploy AI assistants. By dynamically adapting tools, instructions, and models at runtime, you can:</p><ul><li>Create personalized experiences for different user roles</li><li>Optimize costs by matching model capabilities to task complexity</li><li>Streamline development and maintenance</li><li>Scale efficiently without managing multiple agent configurations</li></ul><p>For organizations demanding highly dynamic behavior‚Äîwhether you‚Äôre an AI startup, SaaS provider, or enterprise solution team‚Äîinline agents offer a scalable approach to building intelligent assistants that grow with your needs. To get started, explore our <a href=\"https://github.com/aws-samples/amazon-bedrock-samples/blob/main/agents-and-function-calling/bedrock-agents/features-examples/15-invoke-inline-agents/inline-agent-api-usage.ipynb\" target=\"_blank\" rel=\"noopener\">GitHub repo</a> and <a href=\"https://github.com/awslabs/amazon-bedrock-agent-samples/tree/main/examples/agents_ux/inline-agent-hr-assistant\" target=\"_blank\" rel=\"noopener\">HR assistant demo application</a>, which demonstrate key implementation patterns and best practices.</p><p>To learn more about how to be most successful in your agent journey, read our two-part blog series:</p><p>To get started with Amazon Bedrock Agents, check out the following <a href=\"https://github.com/awslabs/amazon-bedrock-agent-samples/\" target=\"_blank\" rel=\"noopener\">GitHub repository</a> with example code.</p><p><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/02/10/blog-image-ishansin-1.jpeg\" alt=\"\" width=\"100\" height=\"133\">&nbsp;is a Generative AI Data Scientist at Amazon Web Services, where he helps customers build innovative and responsible generative AI solutions and products. With a strong background in AI/ML, Ishan specializes in building Generative AI solutions that drive business value. Outside of work, he enjoys playing volleyball, exploring local bike trails, and spending time with his wife and dog, Beau.</p><p><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/02/10/mttanke-225x300-1-1.jpg\" alt=\"\" width=\"100\" height=\"133\">&nbsp;is a Senior Generative AI Data Scientist at AWS. With a background in machine learning, she has over 10 years of experience architecting and building AI applications with customers across industries. As a technical lead, she helps customers accelerate their achievement of business value through generative AI solutions on Amazon Bedrock. In her free time, Maira enjoys traveling, playing with her cat, and spending time with her family someplace warm.</p><p><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/02/10/roymark-225x300-1-1.jpg\" alt=\"\" width=\"100\" height=\"133\"> is a Principal Machine Learning Architect for AWS, helping customers design and build generative AI solutions. His focus since early 2023 has been leading solution architecture efforts for the launch of Amazon Bedrock, the flagship generative AI offering from AWS for builders. Mark‚Äôs work covers a wide range of use cases, with a primary interest in generative AI, agents, and scaling ML across the enterprise. He has helped companies in insurance, financial services, media and entertainment, healthcare, utilities, and manufacturing. Prior to joining AWS, Mark was an architect, developer, and technology leader for over 25 years, including 19 years in financial services. Mark holds six AWS certifications, including the ML Specialty Certification.</p><p><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/02/10/enitin.jpeg\" alt=\"\" width=\"100\" height=\"133\"> is a Sr. Enterprise Solutions Architect at AWS, experienced in Software Engineering, Enterprise Architecture, and AI/ML. He is deeply passionate about exploring the possibilities of generative AI. He collaborates with customers to help them build well-architected applications on the AWS platform, and is dedicated to solving technology challenges and assisting with their cloud journey.</p><p><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/02/10/Image-from-iOS-244x300-1.jpg\" alt=\"\" width=\"100\" height=\"123\"> is a Software Development Engineer at Amazon Web Services (AWS). He specializes in backend system design, distributed architectures, and scalable solutions, contributing to the development and launch of high-impact systems at Amazon. Outside of work, he spends his time playing ping pong and hiking through Cascade trails, enjoying the outdoors as much as he enjoys building systems.</p><p> is a Software Development Engineer at Amazon Web Services (AWS), working in Agents for Amazon Bedrock. He focuses on developing scalable systems on the cloud that enable AI applications frameworks and orchestrations. Shubham also has a background in building distributed, scalable, high-volume-high-throughput systems in IoT architectures.</p><p><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2018/09/18/vivekbh-100.jpg\" alt=\"\" width=\"100\" height=\"134\"> is a Principal Engineer for Amazon Bedrock.&nbsp;He focuses on building deep learning-based AI and computer vision solutions for AWS customers. Oustide of work, Vivek enjoys trekking and following cricket.</p>","contentLength":17760,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Learnings from a Machine Learning Engineer ‚Äî Part 1: The Data","url":"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-1-the-data/","date":1739480153,"author":"David Martin","guid":5,"unread":true,"content":"<p>It is said that in order for a machine learning model to be successful, you need to have good data. While this is true (and pretty much obvious), it is extremely difficult to define, build, and sustain good data. Let me share with you the unique processes that I have learned over several years building an ever-growing image classification system and how you can apply these techniques to your own application.</p><p>With persistence and diligence, you can avoid the classic ‚Äúgarbage in, garbage out‚Äù, maximize your model accuracy, and demonstrate real business value.</p><p>In this series of articles, I will dive into the care and feeding of a multi-class, single-label image classification app and what it takes to reach the highest level of performance. I won‚Äôt get into any coding or specific user interfaces, just the main concepts that you can incorporate to suit your needs with the tools at your disposal.</p><p>Here is a brief description of the articles. You will notice that the model is last on the list since we need to focus on curating the data first and foremost:</p><p>Over the past six years, I have been primarily focused on building and maintaining an image classification application for a manufacturing company. Back when I started, most of the software did not exist or was too expensive, so I created these from scratch. In this time, I have deployed two identifier applications, the largest handles 1,500 classes and achieves 97‚Äì98% accuracy.</p><p>It was about eight years ago that I started online studies for <a href=\"https://towardsdatascience.com/tag/data-science/\" title=\"Data Science\">Data Science</a> and machine learning. So, when the exciting opportunity to create an AI application presented itself, I was prepared to build the tools I needed to leverage the latest advancements. I jumped in with both feet!</p><p>I quickly found that building and deploying a model is probably the easiest part of the job. Feeding high quality data into the model is the best way to improve performance, and that requires focus and patience. Attention to detail is what I do best, so this was a perfect fit.</p><h2><strong>It all starts with the data</strong></h2><p>I feel that so much attention is given to the model selection (deciding which neural network is best) and that the data is just an afterthought. I have found the hard way that even one or two pieces of bad data can significantly impact model performance, so that is where we need to focus.</p><p>For example, let‚Äôs say you train the classic cat versus dog image classifier. You have 50 pictures of cats and 50 pictures of dogs, however one of the ‚Äúcats‚Äù is clearly (objectively) a picture of a dog. The computer doesn‚Äôt have the luxury of ignoring the mislabelled image, and instead adjusts the model weights to make it fit. Square peg meets round hole.</p><p>Another example would be a picture of a cat that climbed up into a tree. But when you take a wholistic view of it, you would describe it as a picture of a tree (first) with a cat (second). Again, the computer doesn‚Äôt know to ignore the big tree and focus on the cat ‚Äî it will start to identify trees as cats, even if there is a dog. You can think of these pictures as outliers and should be removed.</p><p>It doesn‚Äôt matter if you have the best neural network in the world, you can count on the model making poor predictions when it is trained on ‚Äúbad‚Äù data. I‚Äôve learned that any time I see the model make mistakes, it‚Äôs time to review the data.</p><h2><strong>Example Application ‚Äî Zoo animals</strong></h2><p>For the rest of this write-up, I will use an example of identifying zoo animals. Let‚Äôs assume your goal is to create a mobile app where guests at the zoo can take pictures of the animals they see and have the app identify them. Specifically, this is a multi-class, single-label application.</p><ul><li>&nbsp;‚Äî There are a lot of different animals at the zoo and many of them look very similar.</li><li>&nbsp;‚Äî Guests using the app don‚Äôt always take good pictures (zoomed out, blurry, too dark), so we don‚Äôt want to provide an answer if the image is poor.</li><li>&nbsp;‚Äî The zoo keeps expanding and adding new species all the time.</li><li>&nbsp;‚Äî Occasionally you might find that people take pictures of the sparrows near the food court grabbing some dropped popcorn.</li><li>&nbsp;‚Äî Just for fun, guests may take a picture of the bag of popcorn just to see what it comes back with.</li></ul><p>These are all real challenges ‚Äî being able to tell the subtle differences between animals, handling out-of-scope cases, and just plain poor images.</p><p>Before we get there, let‚Äôs start from the beginning.</p><p>There are a lot of tools these days to help you with this part of the process, but the challenge remains the same ‚Äî collecting, labelling, and curating the data.</p><p>Having data to collect is challenge #1. Without images, you have nothing to train. You may need to get creative on sourcing the data, or even creating synthetic data. More on that later.</p><p>A quick note about image pre-processing. I convert all my images to the input size of my neural network and save them as PNG. Inside this square PNG, I preserve the aspect ratio of the original picture and fill the background black. I don‚Äôt stretch the image nor crop any features out. This also helps center the subject.</p><p>Challenge #2 is to establish standards for data quality‚Ä¶and ensure that these standards are followed! These standards will guide you toward that ‚Äúgood‚Äù data. And this assumes, of course, correct labels. Having both is much easier said than done!</p><p>I hope to show how ‚Äúgood‚Äù and ‚Äúcorrect‚Äù actually go hand-in-hand, and how important it is to apply these standards to every image.</p><p>First, I want to point out that the image data discussed here is for the training set. What qualifies as a good image for&nbsp;&nbsp;is a bit different than what qualifies as a good image for&nbsp;. More on that in <a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-3-the-evaluation/\">Part 3</a>.</p><p>So, what is ‚Äúgood‚Äù data when talking about images? ‚ÄúA picture is worth a thousand words‚Äù, and if the&nbsp;&nbsp;you use to describe the picture do not include the subject you are trying to label, then it is not good and you need remove it from your training set.</p><p>For example, let‚Äôs say you are shown a picture of a zebra and (removing bias toward your application) you describe it as an ‚Äúopen field with a zebra in the distance‚Äù. In other words, if ‚Äúopen field‚Äù is the first thing you notice, then you likely do&nbsp;&nbsp;want to use that image. The opposite is also true ‚Äî if the picture is way too close, you would described it as ‚Äúzebra pattern‚Äù.</p><p>What you want is a description like, ‚Äúa zebra, front and center‚Äù. This would have your subject taking up about 80‚Äì90% of the total frame. Sometimes I will take the time to crop the original image so the subject is framed properly.</p><p>Keep in mind the use of image augmentation at the time of training. Having that buffer around the edges will allow ‚Äúzoom in‚Äù augmentation. And ‚Äúzoom out‚Äù augmentation will simulate smaller subjects, so don‚Äôt start out less than 50% of the total frame for your subject since you lose detail.</p><p>Another aspect of a ‚Äúgood‚Äù image relates to the label. If you can only see the back side of your zoo animal, can you really tell, for example, that it is a cheetah versus a leopard? The key identifying features need to be visible. If a human struggles to identify it, you can‚Äôt expect the computer to learn anything.</p><p>What does a ‚Äúbad‚Äù image look like? Here is what I frequently watch out for:</p><ul><li>Wide angle lens stretching</li><li>High contrast or dark shadows</li><li>‚ÄúDoctored‚Äù images, drawn lines and arrows</li><li>‚ÄúUnusual‚Äù angles or situations</li><li>Picture of a mobile device that has a picture of your subject</li></ul><p>If you have a team of subject matter experts (SMEs) on hand to label the images, you are in a good starting position. Animal trainers at the zoo know the various species, and can spot the differences between, for example, a chimpanzee and a bonobo.</p><p>To a <a href=\"https://towardsdatascience.com/tag/machine-learning-engineer/\" title=\"Machine Learning Engineer\">Machine Learning Engineer</a>, it is easy for you to assume all labels from your SMEs are correct and move right on to training the model. However, even experts make mistakes, so if you can get a second opinion on the labels, your error rate should go down.</p><p>In reality, it can be prohibitively expensive to get one, let alone two, subject matter experts to review image labels. The SME usually has years of experience that make them more valuable to the business in other areas of work. My experience is that the machine learning engineer (that‚Äôs you and me) becomes the second opinion, and often the first opinion as well.</p><p>Over time, you can become pretty adept at labelling, but certainly not an SME. If you do have the luxury of access to an expert, explain to them the labelling standards and how these are required for the application to be successful. Emphasize ‚Äúquality over quantity‚Äù.</p><p>It goes without saying that having a&nbsp;&nbsp;label is so important. However, all it takes is one or two mislabelled images to degrade performance. These can easily slip into your data set with careless or hasty labelling. So, take the time to get it right.</p><p>Ultimately, we as the ML engineer are responsible for model performance. So, if we take the approach of only working on model training and deployment, we will find ourselves wondering why performance is falling short.</p><p>A lot of times, you will come across a really good picture of a very interesting subject, but have no idea what it is! It would be a shame to simply dispose of it. What you can do is assign it a generic label, like ‚ÄúUnknown Bird‚Äù or ‚ÄúRandom Plant‚Äù that are&nbsp;&nbsp;included in your training set. Later in <a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-4-the-model/\">Part 4</a>, you‚Äôll see how to come back to these images at a later date when you have a better idea what they are, and you‚Äôll be glad you saved them.</p><p>If you have done any image labelling, then you know how time consuming and difficult it can be. But this is where having a model, even a less-than-perfect model, can help you.</p><p>Typically, you have a large collection of unlabelled image and you need to go through them one at a time to assign labels. Simply having the model offer a best guess and display the top 3 results lets you step through each image in a matter of seconds!</p><p>Even if the top 3 results are wrong, this can help you narrow down your search. Over time, newer models will get better, and the labelling process can even be somewhat fun!</p><p>In <a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-4-the-model/\">Part 4</a>, I will show how you can bulk identify images and take this to the next level for faster labelling.</p><p>I mentioned the example above of two species that look very similar, the chimpanzee and the bonobo. When you start out building your data set, you may have very sparse coverage of one or both of these species. In machine learning terms, we these ‚Äúclasses‚Äù. One option is to roll with what you have and hope that the model picks up on the differences with only a handful of example images.</p><p>The option that I have used is to merge two or more classes into one, at least temporarily. So, in this case I would create a class called ‚Äúchimp-bonobo‚Äù, which is composed of the limited example pictures of chimpanzee and bonobo species classes. Combined, these may give me enough to train the model on ‚Äúchimp-bonobo‚Äù, with the trade-off that it‚Äôs a more generic identification.</p><p>Sub-classes can even be normal variations. For example,&nbsp;&nbsp;pink flamingos are grey instead of pink. Or, male and female orangutans have distinct facial features. You wan to have a fairly balanced number of images for these normal variations, and keeping sub-classes will allow you to accomplish this.</p><p>Don‚Äôt be concerned that you are merging completely different looking classes ‚Äî the neural network does a nice job of applying the ‚ÄúOR‚Äù operator. This works both ways ‚Äî it can help you identify male or female variations as one species, but it can hurt you when ‚Äúbad‚Äù outlier images sneak in like the example ‚Äúopen field with a zebra in the distance.‚Äù</p><p>Over time, you will (hopefully) be able to collect more images of the sub-classes and then be able to successfully split them apart (if necessary) and train the model to identify them separately. This process has worked very well for me. Just be sure to double-check all the images when you split them to ensure the labels didn‚Äôt get accidentally mixed up ‚Äî it will be time well spent.</p><p>All of this certainly depends on your user requirements, and you can handle this in different ways either by creating a unique class label like ‚Äúchimp-bonobo‚Äù, or at the front-end presentation layer where you notify the user that you have intentionally merged these classes and provide guidance on further refining the results. Even after you decide to split the two classes, you may want to caution the user that the model could be wrong since the two classes are so similar.</p><p>I realize this was a long write-up for something that on the surface seems intuitive, but these are all areas that I have tripped me up in the past because I didn‚Äôt give them enough attention. Once you have a solid understanding of these principles, you can go on to build a successful application.</p><p>In&nbsp;<a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-2-the-data-sets/\">Part 2</a>, we will take the curated data we collected here to create the classic data sets, with a custom benchmark set that will further enhance your data. Then we will see how best to evaluate our trained model using a specific ‚Äútraining mindset‚Äù, and switch to a ‚Äúproduction mindset‚Äù when evaluating a deployed model.</p>","contentLength":13198,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Learnings from a Machine Learning Engineer ‚Äî Part 4: The Model","url":"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-4-the-model/","date":1739480022,"author":"David Martin","guid":4,"unread":true,"content":"<p>In this latest part of my series, I will share what I have learned on selecting a model for <a href=\"https://towardsdatascience.com/tag/image-classification/\" title=\"Image Classification\">Image Classification</a> and how to fine tune that model. I will also show how you can leverage the model to accelerate your labelling process, and finally how to justify your efforts by generating usage and performance statistics.</p><p>In&nbsp;<a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-1-the-data/\">Part 1</a>, I discussed the process of labelling your image data that you use in your image classification project. I showed how define ‚Äúgood‚Äù images and create sub-classes. In&nbsp;<a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-2-the-data-sets/\">Part 2</a>, I went over various data sets, beyond the usual train-validation-test sets, with benchmark sets, plus how to handle synthetic data and duplicate images. In <a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-3-the-evaluation/\">Part 3</a>, I explained how to apply different evaluation criteria to a trained model versus a deployed model, and using benchmarks to determine when to deploy a model.</p><p>So far I have focused a lot of time on labelling and curating the set of images, and also evaluating model performance, which is like putting the cart before the horse. I‚Äôm not trying to minimize what it takes to design a massive neural network ‚Äî this is a very important part of the application you are building. In my case, I spent a few weeks experimenting with different available models before settling on one that fit the bill.</p><p>Once you pick a model structure, you usually don‚Äôt make any major changes to it. For me, six years into deployment, I‚Äôm still using the same one. Specifically, I chose Inception V4 because it has a large input image size and an adequate number of layers to pick up on subtle image features. It also performs inference fast enough on CPU, so I don‚Äôt need to run expensive hardware to serve the model.</p><p>Your mileage may vary. But again, the main takeaway is that focusing on your data will pay dividends versus searching for the best model.</p><p>I will share a process that I found to work extremely well. Once I decided on the model to use, I randomly initialized the weights and let the model train for about 120 epoch before improvements plateau at a fairly modest accuracy, like 93%. At this point, I performed the evaluation of the trained model (see <a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-3-the-evaluation/\">Part 3</a>) to clean up the data set. I also incorporated new images as part of the data pipeline (see <a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-1-the-data/\">Part 1</a>) and prepared the data sets for the next training run.</p><p>Before starting the next training run, I simply take the last trained model, pop the output layer, and add it back in with random weights. Since the number of output classes are constantly increasing in my case, I have to pop that layer anyway to account for the new number of classes. Importantly, I leave the rest of the trained weights as they were and allow them to continue updating for the new classes.</p><p>This allows the model to train much faster before improvements stall. After repeating this process dozens of times, the training reaches plateau after about 20 epochs, and the test accuracy can reach 99%! The model is building upon the low-level features that it established from the previous runs while re-learning the output weights to prevent overfitting.</p><p>It took me a while to trust this process, and for a few years I would train from scratch every time. But after I attempted this and saw the training time (not to mention the cost of cloud GPU) go down while the accuracy continued to go up, I started to embrace the process. More importantly, I continue to see the evaluation metrics of the deployed model return solid performances.</p><p>During training, you can apply transformations on your images (called ‚Äúaugmentation‚Äù) to give you more diversity from you data set. With our zoo animals, it is fairly safe to apply left-right flop, slight rotations clockwise and counterclockwise, and slight resize that will zoom in and out.</p><p>With these transformations in mind, make sure your images are still able to act as good training images. In other words, an image where the subject is already small will be even smaller with a zoom out, so you probably want to discard the original. Also, some of your original pictures may need to be re-oriented by 90 degrees to be upright since a further rotation would make them look unusual.</p><p>As I mentioned in <a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-1-the-data/\">Part 1</a>, you can use the trained model to assist you in labelling images one at a time. But the way to take this even further is to have your newly trained model identify hundreds at a time while building a list of the results that you can then filter.</p><p>Typically, we have large collections of&nbsp;&nbsp;images that have come in either through regular usage of the application or some other means. Recall from <a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-1-the-data/\">Part 1</a> assigning ‚Äúunknown‚Äù labels to interesting pictures but you have no clue what it is. By using the bulk identification method, we can sift through the collections quickly to target the labelling once we know what they are.</p><p>By combining your current image counts with the bulk identification results, you can target classes that need expanded coverage. Here are a few ways you can leverage bulk identification:</p><ul><li><strong>Increase low image counts</strong>&nbsp;‚Äî Some of your classes may have just barely made the cutoff to be included in the training set, which means you need more examples to improve coverage. Filter for images that have low counts.</li><li><strong>Replace staged or synthetic images</strong>&nbsp;‚Äî Some classes may be built entirely using non-real-world images. These pictures may be good enough to get started with, but may cause performance issues down the road because they look different than what typically comes through. Filter for classes that depend on staged images.</li><li>&nbsp;‚Äî A class in your data set may look like another one. For example, let‚Äôs say your model can identify an antelope, and that looks like a gazelle which your model cannot identify yet. Setting a filter for antelope and a lower confidence score may reveal gazelle images that you can label.</li><li>&nbsp;‚Äî You may not have known how to identify the dozens of cute wallaby pictures, so you saved them under ‚ÄúUnknown‚Äù because it was a good image. Now that you know what it is, you can filter for its look-alike kangaroo and quickly add a new class.</li><li><strong>Mass removal of low scores</strong>&nbsp;‚Äî As a way to clean out your large collection of unlabelled images that have nothing worth labelling, set a filter for lowest scores.</li></ul><p>Recall the decision I made to have image cutoffs from <a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-2-the-data-sets/\">Part 2</a>, which allows us to ensure an adequate number of example images of a class before we train and server a model to the public. The problem is that you may have a number of classes that are&nbsp;&nbsp;below your cutoff (in my case, 40) and don‚Äôt make it into the model.</p><p>The way I approach this is with a ‚Äúthrow-away‚Äù training run that I do not intend to move to production. I will decrease the lower cutoff from 40 to perhaps 35, build my train-validation-test sets, then train and evaluate like I normally do. The most important part of this is the bulk identification at the end!</p><p>There is a chance that somewhere in the large collection of unlabelled images I will find the few that I need. Doing the bulk identification with this throw-away model helps find them.</p><p>One very important aspect of any machine learning application is being able to show usage and performance reports. Your manager will likely want to see how many times the application is being used to justify the expense, and you as the ML engineer will want to see how the latest model is performing compared to the previous one.</p><p>You should build logging into your model serving to record every transaction going through the system. Also, the manual evaluations from <a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-3-the-evaluation/\">Part 3</a> should be recorded so you can report on performance for such things as accuracy over time, by model version, by confidence scores, by class, etc. You will be able to detect trends and make adjustments to improve the overall solution.</p><p>There are a lot of reporting tools, so I won‚Äôt recommend one over the other. Just make sure you are collecting as much information as you can to build these dashboards. This will justify the time, effort, and cost associated with maintaining the application.</p><p>We covered a lot of ground across this four-part series on building an image classification project and deploying it in the real world. It all starts with the data, and by investing the time and effort into maintaining the highest quality image library, you can reach impressive levels of model performance that will gain the trust and confidence of your business partners.</p><p>As a <a href=\"https://towardsdatascience.com/tag/machine-learning-engineer/\" title=\"Machine Learning Engineer\">Machine Learning Engineer</a>, you are primarily responsible for building and deploying your model. But it doesn‚Äôt stop there ‚Äî dive into the data. The more familiar you are with the data, the better you will understand the strengths and weaknesses of your model. Take a close look at the evaluations and use them as an opportunity to adjust the data set.</p><p>I hope these articles have helped you find new ways to improve your own machine learning project. And by the way, don‚Äôt let the machine do all the learning ‚Äî as humans, our job is to continue our own learning, so don‚Äôt ever stop!</p><p>Thank you for taking this deep dive with me into a data-driven approach to model optimization. I look forward to your feedback and how you can apply this to your own application.<a href=\"https://medium.com/tag/machine-learning?source=post_page-----7f530bc91383---------------------------------------\"></a></p>","contentLength":9124,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Use language embeddings for zero-shot classification and semantic search with Amazon Bedrock","url":"https://aws.amazon.com/blogs/machine-learning/use-language-embeddings-for-zero-shot-classification-and-semantic-search-with-amazon-bedrock/","date":1739480012,"author":"Tom Rogers","guid":235,"unread":true,"content":"<p>In this post, we discuss what embeddings are, show how to practically use language embeddings, and explore how to use them to add functionality such as zero-shot classification and semantic search. We then use <a href=\"https://aws.amazon.com/bedrock/\" target=\"_blank\" rel=\"noopener\">Amazon Bedrock</a> and language embeddings to add these features to a <a href=\"https://en.wikipedia.org/wiki/RSS\" target=\"_blank\" rel=\"noopener\">really simple syndication (RSS)</a> aggregator application.</p><p>Amazon Bedrock is a fully managed service that makes <a href=\"https://aws.amazon.com/what-is/foundation-models/\" target=\"_blank\" rel=\"noopener\">foundation models</a> (FMs) from leading AI startups and Amazon available through an API, so you can choose from a wide range of FMs to find the model that is best suited for your use case. Amazon Bedrock offers a serverless experience, so you can get started quickly, privately customize FMs with your own data, and integrate and deploy them into your applications using <a href=\"https://aws.amazon.com/\" target=\"_blank\" rel=\"noopener\">Amazon Web Services</a> (AWS) services without having to manage infrastructure. For this post, we use the <a href=\"https://aws.amazon.com/bedrock/cohere-command-embed/\" target=\"_blank\" rel=\"noopener\">Cohere v3 Embed</a> model on Amazon Bedrock to create our language embeddings.</p><p>To demonstrate some of the possible uses of these language embeddings, we developed an RSS aggregator website. RSS is a web feed that allows publications to publish updates in a standardized, computer-readable way. On our website, users can subscribe to an RSS feed and have an aggregated, categorized list of the new articles. We use embeddings to add the following functionalities:</p><p>This post uses this application as a reference point to discuss the technical implementation of the semantic search and zero-shot classification features.</p><p>This solution uses the following services:</p><p>The following diagram illustrates the solution architecture.</p><p>This section offers a quick primer on what embeddings are and how they can be used.</p><p>Embeddings are numerical representations of concepts or objects, such as language or images. In this post, we discuss language embeddings. By reducing these concepts to numerical representations, we can then use them in a way that a computer can understand and operate on.</p><p>Let‚Äôs take Berlin and Paris as an example. As humans, we understand the conceptual links between these two words. Berlin and Paris are both cities, they‚Äôre capitals of their respective countries, and they‚Äôre both in Europe. We understand their conceptual similarities almost instinctively, because we can create a model of the world in our head. However, computers have no built-in way of representing these concepts.</p><p>To represent these concepts in a way a computer can understand, we convert them into language embeddings. Language embeddings are high dimensional vectors that learn their relationships with each other through the training of a neural network. During training, the neural network is exposed to enormous amounts of text and learns patterns based on how words are colocated and relate to each other in different contexts.</p><p>Embedding vectors allow computers to model the world from language. For instance, if we embed ‚ÄúBerlin‚Äù and ‚ÄúParis,‚Äù we can now perform mathematical operations on these embeddings. We can then observe some fairly interesting relationships. For instance, we could do the following: Paris ‚Äì France + Germany ~= Berlin. This is because the embeddings capture the relationships between the words ‚ÄúParis‚Äù and ‚ÄúFrance‚Äù and between ‚ÄúGermany‚Äù and ‚ÄúBerlin‚Äù‚Äîspecifically, that Paris and Berlin are both capital cities of their respective countries.</p><p>The following graph shows the word vector distance between countries and their respective capitals.</p><p>Subtracting ‚ÄúFrance‚Äù from ‚ÄúParis‚Äù removes the country semantics, leaving a vector representing the concept of a capital city. Adding ‚ÄúGermany‚Äù to this vector, we are left with something closely resembling ‚ÄúBerlin,‚Äù the capital of Germany. The vectors for this relationship are shown in the following graph.</p><p>For our use case, we use the pre-trained Cohere Embeddings model in Amazon Bedrock, which embeds entire texts rather than a single word. The embeddings represent the meaning of the text and can be operated on using mathematical operations. This property can be useful to map relationships such as similarity between texts.</p><p>One way in which we use language embeddings is by using their properties to calculate how similar an article is to one of the topics.</p><p>To do this, we break down a topic into a series of different and related embeddings. For instance, for culture, we have a set of embeddings for sports, TV programs, music, books, and so on. We then embed the incoming title and description of the RSS articles, and calculate the similarity against the topic embeddings. From this, we can assign topic labels to an article.</p><p>The following figure illustrates how this works. The embeddings that Cohere generates are highly dimensional, containing 1,024 values (or dimensions). However, to demonstrate how this system works, we use an algorithm designed to reduce the dimensionality of the embeddings, <a href=\"https://en.wikipedia.org/wiki/T-distributed_stochastic_neighbor_embedding\" target=\"_blank\" rel=\"noopener\">t-distributed Stochastic Neighbor Embedding (t-SNE)</a>, so that we can view them in two dimensions. The following image uses these embeddings to visualize how topics are clustered based on similarity and meaning.</p><p>You can use the embedding of an article and check the similarity of the article against the preceding embeddings. You can then say that if an article is clustered closely to one of these embeddings, it can be classified with the associated topic.</p><p>This is the <a href=\"https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm\" target=\"_blank\" rel=\"noopener\">k-nearest neighbor (k-NN) algorithm</a>. This algorithm is used to perform classification and regression tasks. In k-NN, you can make assumptions around a data point based on its proximity to other data points. For instance, you can say that an article that has proximity to the music topic shown in the preceding diagram can be tagged with the culture topic.</p><p>The following figure demonstrates this with an <a href=\"https://arstechnica.com/science/2024/07/the-climate-is-changing-so-fast-that-we-havent-seen-how-bad-extreme-weather-could-get/\" target=\"_blank\" rel=\"noopener\">ArsTechnica article</a>. We plot against the embedding of an article‚Äôs title and description: (The climate is changing so fast that we haven‚Äôt seen how bad extreme weather could get: Decades-old statistics no longer represent what is possible in the present day).</p><p>The advantage of this approach is that you can add custom, user-generated topics. You can create a topic by first creating a series of embeddings of conceptually related items. For instance, an AI topic would be similar to the embeddings for AI, Generative AI, LLM, and Anthropic, as shown in the following screenshot.</p><p>In a traditional classification system, we‚Äôd be required to train a classifier‚Äîa supervised learning task where we‚Äôd need to provide a series of examples to establish whether an article belongs to its respective topic. Doing so can be quite an intensive task, requiring labeled data and training the model. For our use case, we can provide examples, create a cluster, and tag articles without having to provide labeled examples or train additional models. This is shown in the following screenshot of results page of our website.</p><p>In our application, we ingest new articles on a schedule. We use EventBridge schedules to periodically call a Lambda function, which checks if there are new articles. If there are, it creates an embedding from them using Amazon Bedrock and Cohere.</p><p>We calculate the article‚Äôs distance to the different topic embeddings, and can then determine whether the article belongs to that category. This is done with Aurora PostgreSQL with pgvector. We store the embeddings of the topics and then calculate their distance using the following SQL query:</p><div><pre><code>const topics = await sqlClient.then(it=&gt; it.query(\n    `SELECT name, embedding_description, similarity\n     FROM (SELECT topic_id as name, embedding_description, (1- ABS( 1 ‚Äì(embed.embedding &lt;-&gt; $1))) AS \"similarity\" FROM topic_embedding_link embed)  topics\n     ORDER BY similarity desc`,\n    [toSql(articleEmbedding)]\n  ))\n</code></pre></div><p>The &lt;-&gt; operator in the preceding code calculates the Euclidean distance between the article and the topic embedding. This number allows us to understand how close an article is to one of the topics. We can then determine the appropriateness of a topic based on this ranking.</p><p>We then tag the article with the topic. We do this so that the subsequent request for a topic is as computationally as light as possible; we do a simple join rather than calculating the Euclidean distance.</p><div><div><pre><code>const formattedTopicInsert = pgformat(\n    `INSERT INTO feed_article_topic_link(topic_id, feed_article_id) VALUES %L ON CONFLICT DO NOTHING`,\n    topicLinks\n  )</code></pre></div></div><p>We also cache a specific topic/feed combination because these are calculated hourly and aren‚Äôt expected to change in the interim.</p><p>As previously discussed, the embeddings produced by Cohere contain a multitude of features; they embed the meanings and semantics of a word of phrase. We‚Äôve also found that we can perform mathematical operations on these embeddings to do things such as calculate the similarity between two phrases or words.</p><p>We can use these embeddings and calculate the similarity between a search term and an embedding of an article with the k-NN algorithm to find articles that have similar semantics and meanings to the search term we‚Äôve provided.</p><p>For example, in one of our RSS feeds, we have a lot of different articles that rate products. In a traditional search system, we‚Äôd rely on keyword matches to provide relevant results. Although it might be simple to find a specific article (for example, by searching ‚Äúbest digital notebooks‚Äù), we would need a different method to capture multiple product list articles.</p><p>In a semantic search system, we first transform the term ‚ÄúProduct list‚Äù in an embedding. We can then use the properties of this embedding to perform a search within our embedding space. Using the k-NN algorithm, we can find articles that are semantically similar. As shown in the following screenshot, despite not containing the text ‚ÄúProduct list‚Äù in either the title or description, we‚Äôve been able to find articles that contain a product list. This is because we were able to capture the semantics of the query and match it to the existing embeddings we have for each article.</p><p>In our application, we store these embeddings using pgvector on Aurora PostgreSQL. pgvector is an open source extension that enables vector similarity search in PostgreSQL. We transform our search term into an embedding using Amazon Bedrock and Cohere v3 Embed.</p><p>After we‚Äôve converted the search term to an embedding, we can compare it with the embeddings on the article that have been saved during the ingestion process. We can then use pgvector to find articles that are clustered together. The SQL code for that is as follows:</p><div><pre><code>SELECT *\nFROM (\n    SELECT feed_articles.id as id, title, feed_articles.feed_id as feed, feedName, slug, description, url, author, image, published_at as published, 1 - ABS(1 - (embedding &lt;-&gt; $2)) AS \"similarity\"\n    FROM feed_articles\n    INNER JOIN (select feed_id, name as feedName from feed_user_subscription fus where fus.user_id=$1) sub on feed_articles.feed_id=sub.feed_id\n    ${feedId != undefined ? `WHERE feed_articles.feed_id = $4` : \"\"}\n)\nWHERE similarity &gt; 0.95\nORDER BY similarity desc\nLIMIT $3;\n</code></pre></div><p>This code calculates the distance between the topics, and the embedding of this article as ‚Äúsimilarity.‚Äù If this distance is close, then we can assume that the topic of the article is related, and we therefore attach the topic to the article.</p><p>To deploy this application in your own account, you need the following prerequisites:</p><ul><li>Model access for Cohere Embed English. On the Amazon Bedrock console, choose  in the navigation pane, then choose . Select the FMs of your choice and request access.</li></ul><p>When the prerequisite steps are complete, you‚Äôre ready to set up the solution:</p><ol start=\"2\"><li>Navigate to the solution directory:</li></ol><ol start=\"3\"><li>In your terminal, export your AWS credentials for a role or user in ACCOUNT_ID. The role needs to have all necessary permissions for AWS CDK deployment: \n  <ul><li><strong>export AWS_REGION=‚Äù&lt;region&gt;‚Äù</strong> ‚Äì The <a href=\"https://docs.aws.amazon.com/glossary/latest/reference/glos-chap.html#region\" target=\"_blank\" rel=\"noopener\">AWS Region</a> you want to deploy the application to</li><li><strong>export AWS_ACCESS_KEY_ID=‚Äù&lt;access-key&gt;‚Äù</strong> ‚Äì The access key of your role or user</li><li><strong>export AWS_SECRET_ACCESS_KEY=‚Äù&lt;secret-key&gt;‚Äù</strong> ‚Äì The secret key of your role or user</li></ul></li></ol><ol start=\"4\"><li>If you‚Äôre deploying the AWS CDK for the first time, run the following command:</li></ol><ol start=\"5\"><li>To synthesize the <a href=\"http://aws.amazon.com/cloudformation\" target=\"_blank\" rel=\"noopener\">AWS CloudFormation</a> template, run the following command:<code>cdk synth -c vpc_id=&lt;ID Of your VPC&gt;</code></li></ol><ol start=\"6\"><li>To deploy, use the following command:<code>cdk deploy -c vpc_id=&lt;ID Of your VPC&gt;</code></li></ol><p>When deployment is finished, you can check these deployed stacks by visiting the AWS CloudFormation console, as shown in the following screenshot.</p><p>Run the following command in the terminal to delete the CloudFormation stack provisioned using the AWS CDK:</p><p>In this post, we explored what language embeddings are and how they can be used to enhance your application. We‚Äôve learned how, by using the properties of embeddings, we can implement a real-time zero-shot classifier and can add powerful features such as semantic search.</p><p>The code for this application can be found on the accompanying <a href=\"https://github.com/aws-samples/rss-aggregator-using-cohere-embeddings-bedrock\" target=\"_blank\" rel=\"noopener\">GitHub repo</a>. We encourage you to experiment with language embeddings and find out what powerful features they can enable for your applications!</p><p><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/02/06/ML-17434-About-Author.jpeg\" alt=\"About the Author\" width=\"100\" height=\"133\">is a Solutions Architect based in Amsterdam, the Netherlands. He has a background in software engineering. At AWS, Thomas helps customers build cloud solutions, focusing on modernization, data, and integrations.</p>","contentLength":13247,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Learnings from a Machine Learning Engineer ‚Äî Part 2: The Data Sets","url":"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-2-the-data-sets/","date":1739478579,"author":"David Martin","guid":3,"unread":true,"content":"<p>In&nbsp;<a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-1-the-data/\">Part 1</a>, we discussed the importance of collecting good image data and assigning proper labels for your <a href=\"https://towardsdatascience.com/tag/image-classification/\" title=\"Image Classification\">Image Classification</a> project to be successful. Also, we talked about classes and sub-classes of your data. These may seem pretty straight forward concepts, but it‚Äôs important to have a solid understanding going forward. So, if you haven‚Äôt, please check it out.</p><p>Now we will discuss how to build the various data sets and the techniques that have worked well for my application. Then in the <a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-3-the-evaluation/\">next part</a>, we will dive into the evaluation of your models, beyond simple accuracy.</p><p>I will again use the example zoo animals image classification app.</p><p>As machine learning engineers, we are all familiar with the train-validation-test sets, but when we include the concept of sub-classes discussed in <a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-1-the-data/\">Part 1</a>, and incorporate to concepts discussed below to set a minimum and maximum image count per class, as well as staged and synthetic data to the mix, the process gets a bit more complicated. I had to create a custom script to handle these options.</p><p>I will walk you through these concepts before we split the data for training:</p><ul><li>&nbsp;‚Äî Too few images and your model performance will suffer. Too many and you spend more time training than it‚Äôs worth.</li><li>&nbsp;‚Äî Your model indicates how confident it is in the predictions. Let‚Äôs use that to decide when to present results to the user.</li><li>&nbsp;‚Äî Real-world data is messy and the benchmark sets should reflect that. These need to stretch the model to the limit and help us decide when it is ready for production.</li><li><strong>Staged and synthetic data</strong>&nbsp;‚Äî Real-world data is king, but sometimes you need to produce the your own or even generate data to get off the ground. Be careful it doesn‚Äôt hurt performance.</li><li>&nbsp;‚Äî Repeat data can skew your results and give you a false sense of performance. Make sure your data is diverse.</li><li>&nbsp;‚Äî Combine sub-classes, apply cutoffs, and create your train-validation-test sets. Now we are ready to get the show started.</li></ul><p>In my experience, using a minimum of 40 images per class provides descent performance. Since I like to use 10% each for the test set and validation set, that means at least 4 images will be used to check the training set, which feels just barely adequate. Using fewer than 40 images per class, I notice my model evaluation tends to suffer.</p><p>On the other end, I set a maximum of about 125 images per class. I have found that the performance gains tend to plateau beyond this, so having more data will slow down the training run with little to show for it. Having more than the maximum is fine, and these ‚Äúoverflow‚Äù can be added to the test set, so they don‚Äôt go to waste.</p><p>There are times when I will drop the minimum cutoff to, say 35, with no intention of moving the trained model to production. Instead, the purpose is to leverage this throw-away model to find more images from my unlabelled set. This is a technique that I will go into more detail in <a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-3-the-evaluation/\">Part 3</a>.</p><p>You are likely familiar with the softmax score. As a reminder, softmax is the probability assigned to each label. I like to think of it as a confidence score, and we are interested in the class that receives the highest confidence. Softmax is a value between zero and one, but I find it easier to interpret confidence scores between zero and 100, like a percentage.</p><p>In order to decide if the model is confident enough with its prediction, I have chosen a threshold of 95. I use this threshold when determining if I want to present results to the user.</p><p>Scores above the threshold have a better changes of being right, so I can confidently provide the results. Scores below the threshold may not be right ‚Äî in fact it could be ‚Äúout-of-scope‚Äù, meaning it‚Äôs something the model doesn‚Äôt know how to identify. So, instead of taking the risk of presenting incorrect results, I instead prompt the user to try again and offer suggestions on how to take a ‚Äúgood‚Äù picture.</p><p>Admittedly this is somewhat arbitrary cutoff, and you should decide for your use-case what is appropriate. In fact, this score could probably be adjusted for each trained model, but this would make it harder to compare performance across models.</p><p>I will refer to this confidence score frequently in the evaluations section in <a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-3-the-evaluation/\">Part 3</a>.</p><p>Let me introduce what I call the benchmark sets, which you can think of as extended test sets. These are hand-picked images designed to stretch the limits of your model, and provide a measure for specific classes of your data. Use these benchmarks to justify moving your model to production, and for an objective measure to show to your manager.</p><ul><li>&nbsp;‚Äî These are the ‚Äúextra credit‚Äù images, like the bonus questions a professor would add to the quiz to see which students are paying attention. You need a keen eye to spot the difference between the ground truth and a similar looking class. For example, a cheetah sleeping in the shade that could pass as a leopard if you don‚Äôt look closely.</li><li>&nbsp;‚Äî These are the ‚Äútrick question‚Äù images. Our model is trained on zoo animals, but people are known for not following the rules. For example, a zoo guest takes a picture of their child wearing cheetah face paint.</li><li>&nbsp;‚Äî These are your ‚Äúbread and butter‚Äù classes that need to get near perfect scores and zero errors. This would be a make-or-break benchmark for moving to production.</li><li>&nbsp;‚Äî These are your ‚Äúrare but exceptional‚Äù classes that again need to be correct, but reach a minimum score like the confidence threshold.</li></ul><p>When looking for images to add to the benchmarks, you can likely find them in real-world images from your deployed model. See the evaluation in <a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-3-the-evaluation/\">Part 3</a>.</p><p>For each benchmark, calculate the min, max, median, and mean scores, and also how many images get scores above and below the confidence threshold. Now you can compare these measures against what is currently in production, and against your minimum requirements, to help decide if the new model is production worthy.</p><p>Perhaps the biggest hurdle to any supervised machine learning application is having data to train the model. Clearly, ‚Äúreal-world‚Äù data that comes from actual users of the application is ideal. However you can‚Äôt really collect these until the model is deployed. Chicken and egg problem.</p><p>One way to get started to is to have volunteers collect ‚Äústaged‚Äù images for you, trying to act like real users. So, let‚Äôs have our zoo staff go around taking pictures of the animals. This is a good start, but there will be a certain level of bias introduced in these images. For example, the staff may take the photos over a few days, so you may not get the year-round weather conditions.</p><p>Another way to get pictures is use computer-generated ‚Äúsynthetic‚Äù images. I would avoid these at all costs, to be honest. Based on my experience, the model struggles with these because they look‚Ä¶different. The lighting is not natural, the subject may superimposed on a background and so the edges look too sharp, etc. Granted, some of the AI generated images look very realistic, but if you look closely you may spot something unusual. The neural network in your model will notice these, so be careful.</p><p>The way that I handle these staged or synthetic images is as a sub-class that gets merged into the training set, but only&nbsp;&nbsp;giving preference to the real-world images. I cap the number of staged images to 60, so if I have 10 real-world, I now only need 50 staged. Eventually, these staged and synthetic images are phased out completely, and I rely entirely on real-world.</p><p>One problem that can creep into your image set are duplicate images. These can be exact copies of pictures, or they can be extremely similar. You may think that this is harmless, but imagine having 100 pictures of an elephant that are exactly the same ‚Äî your model will not know what to do with a different angle of the elephant.</p><p>Now, let‚Äôs say you have only&nbsp;&nbsp;pictures that are nearly the same. Not so bad, right? Well, here is what can happen to them:</p><ul><li>Both pictures go in the training set ‚Äî The model doesn‚Äôt learn anything from the repeated image and it wastes time processing them.</li><li>One goes into the training set, the other goes into the test set ‚Äî Your test score will be higher, but it is not an accurate evaluation.</li><li>Both are in the test set ‚Äî Your test score will be compounded either higher or lower than it should be.</li></ul><p>None of these will help your model.</p><p>There are a few ways to find duplicates. The approach I have taken is to calculate a hamming distance on all the pictures and identify the ones that are very close. I have an interface that displays the duplicates and I decide which one I like best, and remove the other.</p><p>Another way (I haven‚Äôt tried this yet) is to create a vector representation of your images. Store these a vector database, and you can do a similarity search to find nearly identical images.</p><p>Whatever method you use, it is important to clean up the duplicates.</p><p>Now we are ready to build the traditional training, validation, and test sets. This is no longer a straight forward task since I want to:</p><ol><li>Merge sub-classes into a main class.</li><li>Prioritize real-world images over staged or synthetic images.</li><li>Apply a minimum number of images per class.</li><li>Apply a maximum number of images per class, sending the ‚Äúoverflow‚Äù to the test set.</li></ol><p>This process is somewhat complicated and depends on how you manage your image library. First, I would recommend keeping your images in a folder structure that has sub-class folders. You can get image counts by using a script to simply read the folders. Second is to keep a configuration of how the sub-classes are merged. To really set yourself up for success, put these image counts and merge rules in a database for faster lookups.</p><p>My train-validation-test set splits are usually 90‚Äì10‚Äì0. I originally started out using 80‚Äì10‚Äì10, but with diligence on keeping the entire data set clean, I noticed validation and test scores became pretty even. This allowed me to increase the training set size, and use ‚Äúoverflow‚Äù to become the test set, as well as using the benchmark sets.</p><p>In this part, we‚Äôve built our data sets by merging sub-classes and using the image count cutoffs. Plus we handle staged and synthetic data as well as cleaning up duplicate images. We also created benchmark sets and defined confidence thresholds, which help us decide when to move a model to production.</p><p>In&nbsp;<a href=\"https://towardsdatascience.com/learnings-from-a-machine-learning-engineer-part-3-the-evaluation/\">Part 3</a>, we will discuss how we are going to evaluate the different model performances. And then finally we will get to the actual model training and the techniques to enhance accuracy.<a href=\"https://medium.com/tag/machine-learning?source=post_page-----1948daf60483---------------------------------------\"></a></p>","contentLength":10545,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Coding Interviews were HARD Until I Learned These 20 Tips","url":"https://blog.algomaster.io/p/20-coding-interviews-tips","date":1739467827,"author":"Ashish Pratap Singh","guid":751,"unread":true,"content":"<p>I gave my first  in 2016‚Äîand failed. I failed the next five interviews as well before finally landing my first job at .</p><p>Since then, I‚Äôve interviewed with many companies and faced my fair share of rejections. However, over the years, my failure rate in coding interviews dropped significantly.</p><p>By 2022, with just 1.5 months of focused preparation, I successfully cleared interviews at  and .</p><p>Surprisingly, my success wasn‚Äôt due to a dramatic improvement in problem-solving skills. The real game-changer was my approach‚Äî and  during the interview.</p><p>In this article, I‚Äôll share  that made coding interviews significantly easier for me.</p><p>These tips cover everything you need to know, including:</p><ul><li><p>How to systematically approach coding interview problems</p></li><li><p>Key concepts and patterns you should know</p></li><li><p>The type of problems you should practice</p></li><li><p>How to choose the right algorithm for a given problem</p></li><li><p>Techniques to optimize your solution</p></li><li><p>How to communicate your thought process effectively</p></li></ul><p>By applying these strategies, you‚Äôll be able to tackle coding interviews with confidence and massively increase your chances of success.</p><p>In a coding interview, interviewers want to see how well you , , and  under pressure.</p><p>Here's a breakdown of what they look for:</p><ol><li><p><strong>Understanding the problem</strong>: Do you ask clarifying questions instead of making assumptions to ensure you fully understand the problem?</p></li><li><p>: Can you decompose the problem into smaller, manageable parts?</p></li><li><p>: Can you design an optimal solution in terms of time and space complexity?</p></li><li><p>: Do you handle edge cases like empty inputs, duplicates, large values, or special conditions?</p></li><li><p>: Can you explain why one approach is better than another?</p></li><li><p>: Do you have a strong grasp of data structures and algorithms, and can you choose the right one for the problem?</p></li><li><p>Can you quickly compute the time and space complexity of your solution?</p></li><li><p><strong>Explaining your thought process</strong>: Can you clearly articulate your approach and why it works?</p></li><li><p>: Are you receptive to hints and able to adjust your approach accordingly?</p></li><li><p>: Do you follow good coding practices (meaningful variable names, proper indentation, modular functions etc..)?</p></li><li><p><strong>Improving the initial solution</strong>: Can you optimize and refine your first solution when prompted?</p></li><li><p>Are you able to tackle variations of the original problem?</p></li><li><p>Can you manually walk through your code with sample inputs to verify correctness?</p></li></ol><p>Most coding interviews last </p><p>Depending on the company and interviewer, you may be asked to solve 2-3easy/medium problems or 1 hard problem with follow-ups.</p><p>Lets assume you are given one problem, with a follow up in a 45-minute interview. Here‚Äôs how you can optimally allocate your time:</p><ol><li><p>The interviewer may ask you to introduce yourself. Prepare a concise 1-2 minute introduction that highlights your background, experience, and key strengths. Practice it beforehand so that you can deliver it smoothly.</p></li><li><p><strong>Understand the Problem (5-10 mins):  </strong>Carefully read the problem statement, ask clarifying questions, and walk through sample inputs and expected outputs.</p></li><li><p><strong>Plan the Approach (10-20 mins): </strong>Brainstorm possible solutions, evaluate trade-offs, and discuss time and space complexity.</p></li><li><p><strong>Implement the Code (20-30 mins): </strong>Write a clean, modular and readable code.</p></li><li><p>Dry-run your code with sample inputs, debug any issues, and ensure edge cases are handled.</p></li><li><p><strong>Follow-ups and Wrap Up (35-45 mins): </strong>Answer follow up questions, and ask thoughtful questions to the interviewer about the company, role, or team.</p></li></ol><p>One of the biggest mistakes candidates make in coding interviews is jumping into coding too soon.</p><p>If you don't fully understand the question, you might end up solving the </p><p>Here‚Äôs how to ensure you grasp the problem before coding:</p><h4><strong>Read the Problem Carefully</strong></h4><p>Take a moment to absorb the problem statement. Rephrase it in your own words to confirm your understanding. </p><p>Identify the expected input/output format and any hidden constraints.</p><p>If anything is unclear, ask questions before diving into the solution. Interviewers appreciate when you seek clarity. Never assume details that aren‚Äôt explicitly mentioned in the problem statement.</p><p>Common clarifications include:</p><ul><li><p>Are there duplicate values?</p></li><li><p>Can the input be empty? If so, what should the output be?</p></li><li><p>Should the solution handle negative numbers?</p></li><li><p>Should the output maintain the original order of elements?</p></li><li><p>Is the graph directed or undirected?</p></li><li><p>Does the input contain only lowercase English letters, or can it have uppercase, digits, or special characters?</p></li><li><p>What should happen if multiple solutions exist? Should I return any valid solution, or does the problem have specific requirements?</p></li></ul><h4><strong>Walk Through Input/Output Examples</strong></h4><p>Once you understand the problem statement and constraints, go over a few input and output examples to make sure you get it.</p><p>Draw them out if it helps, especially for visual data structures like trees or graphs.</p><p>Try to take examples that cover different scenarios of the problem. Think about any  that might come up.</p>","contentLength":4908,"flags":null,"enclosureUrl":"https://substack-post-media.s3.amazonaws.com/public/images/61c3f6c0-4027-4d37-b4a7-a30fc183fa12_1602x1032.png","enclosureMime":"","commentsUrl":null},{"title":"Looking back at our Bug Bounty program in 2024","url":"https://engineering.fb.com/2025/02/13/security/looking-back-at-our-bug-bounty-program-in-2024/","date":1739466046,"author":"","guid":471,"unread":true,"content":"<ul><li aria-level=\"1\"><a href=\"https://about.fb.com/news/2019/01/designing-security-for-billions/\" target=\"_blank\" rel=\"noopener\"></a></li></ul><h2></h2><ul></ul><h2></h2><h2></h2><p><b>Ads audience tools designed to help people choose a target audience for their ads: </b><a href=\"https://bugbounty.meta.com/payout-guidelines/ads-audience/\" target=\"_blank\" rel=\"noopener\"></a><a href=\"https://www.facebook.com/business/help/717368264947302\" target=\"_blank\" rel=\"noopener\"></a><a href=\"https://bugbounty.meta.com/payout-guidelines/ads-audience/\" target=\"_blank\" rel=\"noopener\"></a></p><p><b>Mixed reality hardware products:</b><a href=\"http://hardwear.io\" target=\"_blank\" rel=\"noopener\"></a></p><h2></h2><p><b>Organizing community events and presenting joint research:</b></p><p><b>Providing resources and timely updates for the research community:</b></p>","contentLength":239,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"A new tool for visualizing Rust lifetimes","url":"https://www.youtube.com/watch?v=NV6Xo_el_2o","date":1739458834,"author":"Let's Get Rusty","guid":475,"unread":true,"content":"<article>See how RustOwl can help you understand lifetimes in a real Rust codebase. A brand-new tool designed to visualize Rust lifetimes and make learning Rust easier. Check it out and see how it can change the way you write Rust!\n\nFree Rust training: https://letsgetrusty.com/bootcamp\n\nRustOwl: https://github.com/cordx56/rustowl\n\nCorrections:\n- Bacon is a CLI tool, not a library. Check it out here: https://github.com/Canop/bacon</article>","contentLength":424,"flags":null,"enclosureUrl":"https://www.youtube.com/v/NV6Xo_el_2o?version=3","enclosureMime":"","commentsUrl":null},{"title":"Bridging the Gap: Democratizing AI for All","url":"https://www.kdnuggets.com/bridging-gap-democratizing-ai","date":1739458803,"author":"Vidhi Chugh","guid":589,"unread":true,"content":"<article>Let‚Äôs explore how democratizing AI can level the playing field and create opportunities for all, no matter the background or resources.</article>","contentLength":137,"flags":null,"enclosureUrl":"https://www.kdnuggets.com/wp-content/uploads/chugh_Bridging-the-Gap-Democratizing-AI-for-All_1.png","enclosureMime":"","commentsUrl":null},{"title":"Rust vs C++ Performance","url":"https://www.youtube.com/watch?v=WnMin9cf78g","date":1739457041,"author":"Anton Putra","guid":537,"unread":true,"content":"<article>C++ vs Rust Speed.\n\nüî¥ To support my channel, I'd like to offer Mentorship/On-the-Job Support/Consulting (me@antonputra.com)\n\nüçø Benchmarks: https://youtube.com/playlist?list=PLiMWaCMwGJXmcDLvMQeORJ-j_jayKaLVn&amp;si=p-UOaVM_6_SFx52H\n\nüëã AWS is expensive - Infra Support Fund: https://buymeacoffee.com/antonputra\n\n‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨ Experience &amp; Location üíº ‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨\n‚ñ∫  I‚Äôm a Senior Software Engineer at Juniper Networks (13+ years of experience)\n‚ñ∫  Located in San Francisco Bay Area, CA (US citizen)\n\n‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨ Connect with me üëã ‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨\n‚ñ∫  LinkedIn: https://www.linkedin.com/in/anton-putra\n‚ñ∫  Twitter/X: https://twitter.com/antonvputra\n‚ñ∫  GitHub: https://github.com/antonputra\n‚ñ∫  Email: me@antonputra.com\n\n‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨ Source Code üìö ‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨\n‚ñ∫ Original Source Code: https://github.com/antonputra/tutorials/tree/245/lessons/245\n\nPR to improve Rust - https://github.com/antonputra/tutorials/pull/429\nPR to improve Rust - https://github.com/antonputra/tutorials/pull/431\nPR to improve Rust - https://github.com/antonputra/tutorials/pull/433\n\n#rust #golang #devops</article>","contentLength":1133,"flags":null,"enclosureUrl":"https://www.youtube.com/v/WnMin9cf78g?version=3","enclosureMime":"","commentsUrl":null},{"title":"How to Scale Sklearn with Dask","url":"https://www.kdnuggets.com/how-to-scale-sklearn-dask","date":1739451649,"author":"Iv√°n Palomares Carrascosa","guid":588,"unread":true,"content":"<article>Here's how Dask applies the building blocks of sklearn to bring ML modeling workflows to the next level of scalability via high-performance parallel computing</article>","contentLength":158,"flags":null,"enclosureUrl":"https://www.kdnuggets.com/wp-content/uploads/crVYYGyvTE2Jilsmvukhpw.jpeg","enclosureMime":"","commentsUrl":null},{"title":"Peter Bengtsson: get in JavaScript is the same as property in Python","url":"http://www.peterbe.com/plog/get-in-javascript-is-the-same-as-property-in-python","date":1739450516,"author":"","guid":280,"unread":true,"content":"<article>Prefix a function, in an object or class, with `get` and then that acts as a function call without brackets. Just like Python's `property` decorator.</article>","contentLength":149,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"GenAI Patterns: Reranker","url":"https://martinfowler.com/articles/gen-ai-patterns/#reranker","date":1739441760,"author":"Martin Fowler","guid":300,"unread":true,"content":"<p>LLMs struggle with large amounts of context. <b>Bharani\n      Subramaniam</b> and I explain how to mitigate this common RAG\n      problem with a <a href=\"https://martinfowler.com/articles/gen-ai-patterns/#reranker\">Reranker</a> which takes the document\n      fragments from the retriever, and ranks them according to their usefulness.</p>","contentLength":253,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"EuroPython: EuroPython February 2025 Newsletter","url":"https://blog.europython.eu/europython-february-2025-newsletter/","date":1739435771,"author":"","guid":279,"unread":true,"content":"<p>Hope you&amp;aposre all having a fantastic February. We sure have been busy and got some exciting updates for you as we gear up for EuroPython 2025, which is taking place once again in the beautiful city of Prague. So let&amp;aposs dive right in!</p><p>EuroPython 2025 is right around the corner and our programme team is hard at work putting together an amazing lineup. But we need your help to shape the conference! We received over 572 fantastic proposals, and now it‚Äôs time for Community Voting! üéâ If you&amp;aposve attended EuroPython before or submitted a proposal this year, you‚Äôre eligible to vote.</p><p>üì¢ More votes = a stronger, more diverse programme! Spread the word and get your EuroPython friends to cast their votes too.</p><p>üèÉThe deadline is , so don‚Äôt miss your chance!</p><p>Want to play a key role in building an incredible conference? Join our review team and help select the best talks for EuroPython 2025! Whether you&amp;aposre a Python expert or an enthusiastic community member, your insights matter.</p><p>We‚Äôd like to also thank the over 100 people who have already signed up to review! For those who haven‚Äôt done so yet, please remember to accept your Pretalx link and get your reviews in by </p><p>You can already start reviewing proposals, and each review takes as little as 5 minutes. We encourage reviewers to go through at least 20-30 proposals, but if you can do more, even better! With almost 600 submissions to pick from, your help ensures we curate a diverse and engaging programme.</p><p>üèÉThe deadline is Monday next week, so don‚Äôt delay!</p><p>EuroPython isn‚Äôt just present at other Python events‚Äîwe actively support them too! As a community sponsor, we love helping local PyCons grow and thrive. We love giving back to the community and strengthening Python events across Europe! üêçüíô</p><p>The EuroPython team had a fantastic time at PyCon + Web in Berlin, meeting fellow Pythonistas, exchanging ideas, and spreading the word about EuroPython 2025. It was great to connect with speakers, organizers, and attendees.&nbsp;</p><p>Ever wondered how long it takes to walk from Berlin to Prague? A huge thank you to our co-organizers, Cheuk, Artur, and Cristi√°n, for answering that in their fantastic lightning talk about EuroPython!</p><img src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXeeVCMBckwBAVXDAhKyHXq8LJVHJysbWS61RNAeilg_qHzHZgzbC1SALu5u3qS-YjyjSQoUE3zIzVCcSHNj26mzPf43RP4PgcV3iUJPzcu_gAEXO25atB6gn7ZQ8O4Pu6vGttw_MQ?key=7MRGElcwE05wjMSe8jkdrI9g\" alt=\"alt\" width=\"512\" height=\"344\"><p>We had some members of the EuroPython team at FOSDEM 2025, connecting with the open-source community and spreading the Python love! üéâ We enjoyed meeting fellow enthusiasts, sharing insights about the EuroPython Society, and giving away the first EuroPython 2025 stickers. If you stopped by‚Äîthank you and we hope to see you in Prague this July.</p><img src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXd6Dp3RdSY2Wm04WwjDJE6NP1fW_NRCUEVZws-cdneLjGf0gvbq7WWphC8AHEwS0qJsAT6ao4Nm36N3e2QhN15S-w1Xmv1AJxEo0480IWXXwLAVhXZ_TcR5qDW31Hf40hYeDKJzyw?key=7MRGElcwE05wjMSe8jkdrI9g\" alt=\"alt\" width=\"517\" height=\"388\"><h2>ü¶í Speaker Mentorship Programme</h2><p>The signups for The Speaker Mentorship Programme closed on 22nd January 2025. We‚Äôre excited to have matched 43 mentees with 24 mentors from our community. We had an increase in the number of mentees who signed up and that‚Äôs amazing! We‚Äôre glad to be contributing to the journey of new speakers in the Python community. A massive thank you to our mentors for supporting the mentees and to our mentees; we‚Äôre proud of you for taking this step in your journey as a speaker.&nbsp;</p><p>26 mentees submitted at least 1 proposal. Out of this number, 13 mentees submitted 1 proposal, 9 mentees submitted 2 proposals, 2 mentees submitted 3 proposals, 1 mentee submitted 4 proposals and lastly, 1 mentee submitted 5 proposals. We wish our mentees the best of luck. We look forward to the acceptance of their proposals.</p><p>In a few weeks, we will host an online panel session with 2‚Äì3 experienced community members who will share their advice with first-time speakers. At the end of the panel, there will be a Q&amp;A session to answer all the participants‚Äô questions.</p><p>You can watch the recording of the previous year‚Äôs workshop here:</p><p>EuroPython is one of the largest Python conferences in Europe, and it wouldn‚Äôt be possible without our sponsors. We are so grateful for the companies who have already expressed interest. If you‚Äôre interested in sponsoring EuroPython 2025 as well, please reach out to us at <a href=\"mailto:sponsoring@europython.eu\">sponsoring@europython.eu</a>.</p><h2>üé§ EuroPython Speakers Share Their Experiences</h2><p>We asked our past speakers to share their experiences speaking at EuroPython. These videos have been published on YouTube as shorts, and we&amp;aposve compiled them into brief clips for you to watch.</p><p>A big thanks goes to Sebastian Witowski, Jan Smitka, Yuliia Barabash, Jodie Burchell, Max Kahan, and Cheuk Ting Ho for sharing their experiences.</p><p>Why You Should Submit a Proposal for EuroPython? Part 2</p><p>Why You Should Submit a Proposal for EuroPython? Part 3</p><h2>üìä EuroPython Society Board Report&nbsp;</h2><p>The EuroPython conference wouldn‚Äôt be what it is without the incredible volunteers who make it all happen. üíû Behind the scenes, there‚Äôs also the EuroPython Society‚Äîa volunteer-led non-profit that manages the fiscal and legal aspects of running the conference, oversees its organization, and works on a few smaller projects like the grants programme. To keep everyone in the loop and promote transparency, the Board is sharing regular updates on what we‚Äôre working on.</p><p>That&amp;aposs all for now! Keep an eye on your inbox and our website for more news and announcements. We&amp;aposre counting down the days until we can come together in Prague to celebrate our shared love for Python. üêç‚ù§Ô∏è</p><p>Cheers,The EuroPython Team</p>","contentLength":5275,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Extensible Wasm Applications with Go","url":"https://go.dev/blog/wasmexport","date":1739404800,"author":"Cherry Mui","guid":243,"unread":true,"content":"<p>\n      Cherry Mui\n      13 February 2025\n      </p><p>Go 1.24 enhances its WebAssembly (Wasm) capabilities with the\naddition of the  directive and the ability to build a reactor\nfor WebAssembly System Interface (WASI).\nThese features enable Go developers to export Go functions to Wasm,\nfacilitating better integration with Wasm hosts and expanding the possibilities\nfor Go-based Wasm applications.</p><h2>WebAssembly and the WebAssembly System Interface</h2><p><a href=\"https://webassembly.org/\" rel=\"noreferrer\" target=\"_blank\">WebAssembly (Wasm)</a> is a binary instruction format\nthat was initially created for web browsers, providing the execution of\nhigh-performance, low-level code at speeds approaching native performance.\nSince then, Wasm‚Äôs utility has expanded, and it is now used in various\nenvironments beyond the browser.\nNotably, cloud providers offer services that directly execute Wasm\nexecutables, taking advantage of the\n<a href=\"https://wasi.dev/\" rel=\"noreferrer\" target=\"_blank\">WebAssembly System Interface (WASI)</a> system call API.\nWASI allows these executables to interact with system resources.</p><p>Go first added support for compiling to Wasm in the 1.11 release, through the\n port.\nGo 1.21 added a new port targeting the WASI preview 1 syscall API through the\nnew  port.</p><h2>Exporting Go Functions to Wasm with </h2><p>Go 1.24 introduces a new compiler directive, , which allows\ndevelopers to export Go functions to be called from outside of the\nWasm module, typically from a host application that runs the Wasm runtime.\nThis directive instructs the compiler to make the annotated function available\nas a Wasm <a href=\"https://webassembly.github.io/spec/core/valid/modules.html?highlight=export#exports\" rel=\"noreferrer\" target=\"_blank\">export</a>\nin the resulting Wasm binary.</p><p>To use the  directive, simply add it to a function definition:</p><pre><code>//go:wasmexport add\nfunc add(a, b int32) int32 { return a + b }\n</code></pre><p>With this, the Wasm module will have an exported function named  that\ncan be called from the host.</p><p>This is analogous to the <a href=\"https://go.dev/cmd/cgo#hdr-C_references_to_Go\">cgo  directive</a>,\nwhich makes the function available to be called from C,\nthough  uses a different, simpler mechanism.</p><p>A WASI reactor is a WebAssembly module that operates continuously, and\ncan be called upon multiple times to react on events or requests.\nUnlike a ‚Äúcommand‚Äù module, which terminates after its main function finishes,\na reactor instance remains live after initialization, and its exports remain\naccessible.</p><p>With Go 1.24, one can build a WASI reactor with the  build\nflag.</p><pre><code>$ GOOS=wasip1 GOARCH=wasm go build -buildmode=c-shared -o reactor.wasm\n</code></pre><p>The build flag signals to the linker not to generate the  function\n(the entry point for a command module), and instead generate an\n function, which performs runtime and package initialization,\nalong with any exported functions and their dependencies.\nThe  function must be called before any other exported functions.\nThe  function will not be automatically invoked.</p><p>To use a WASI reactor, the host application first initializes it by calling\n, then simply invoke the exported functions.\nHere is an example using <a href=\"https://wazero.io/\" rel=\"noreferrer\" target=\"_blank\">Wazero</a>, a Go-based Wasm runtime\nimplementation:</p><pre><code>// Create a Wasm runtime, set up WASI.\nr := wazero.NewRuntime(ctx)\ndefer r.Close(ctx)\nwasi_snapshot_preview1.MustInstantiate(ctx, r)\n\n// Configure the module to initialize the reactor.\nconfig := wazero.NewModuleConfig().WithStartFunctions(\"_initialize\")\n\n// Instantiate the module.\nwasmModule, _ := r.InstantiateWithConfig(ctx, wasmFile, config)\n\n// Call the exported function.\nfn := wasmModule.ExportedFunction(\"add\")\nvar a, b int32 = 1, 2\nres, _ := fn.Call(ctx, api.EncodeI32(a), api.EncodeI32(b))\nc := api.DecodeI32(res[0])\nfmt.Printf(\"add(%d, %d) = %d\\n\", a, b, c)\n\n// The instance is still alive. We can call the function again.\nres, _ = fn.Call(ctx, api.EncodeI32(b), api.EncodeI32(c))\nfmt.Printf(\"add(%d, %d) = %d\\n\", b, c, api.DecodeI32(res[0]))\n</code></pre><p>The  directive and the reactor build mode allow applications to\nbe extended by calling into Go-based Wasm code.\nThis is particularly valuable for applications that have adopted Wasm as a\nplugin or extension mechanism with well-defined interfaces.\nBy exporting Go functions, applications can leverage the Go Wasm modules to\nprovide functionality without needing to recompile the entire application.\nFurthermore, building as a reactor ensures that the exported functions can be\ncalled multiple times without requiring reinitialization, making it suitable\nfor long-running applications or services.</p><h2>Supporting rich types between the host and the client</h2><p>Go 1.24 also relaxes the constraints on types that can be used as input and\nresult parameters with  functions.\nFor example, one can pass a bool, a string, a pointer to an , or a\npointer to a struct which embeds  and contains supported\nfield types\n(see the <a href=\"https://go.dev/cmd/compile#hdr-WebAssembly_Directives\">documentation</a> for detail).\nThis allows Go Wasm applications to be written in a more natural and ergonomic\nway, and removes some unnecessary type conversions.</p><p>While Go 1.24 has made significant enhancements to its Wasm capabilities,\nthere are still some notable limitations.</p><p>Wasm is a single-threaded architecture with no parallelism.\nA  function can spawn new goroutines.\nBut if a function creates a background goroutine, it will not continue\nexecuting when the  function returns, until calling back into\nthe Go-based Wasm module.</p><p>While some type restrictions have been relaxed in Go 1.24, there are still\nlimitations on the types that can be used with  and\n functions.\nDue to the unfortunate mismatch between the 64-bit architecture of the client\nand the 32-bit architecture of the host, it is not possible to pass pointers in\nmemory.\nFor example, a  function cannot take a pointer to a struct that\ncontains a pointer-typed field.</p><p>The addition of the ability to build a WASI reactor and export Go functions to\nWasm in Go 1.24 represent a significant step forward for Go‚Äôs WebAssembly\ncapabilities.\nThese features empower developers to create more versatile and powerful Go-based\nWasm applications, opening up new possibilities for Go in the Wasm ecosystem.</p>","contentLength":5777,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"2024 State of Rust Survey Results","url":"https://blog.rust-lang.org/2025/02/13/2024-State-Of-Rust-Survey-results.html","date":1739404800,"author":"The Rust Survey Team","guid":241,"unread":true,"content":"<p>The Rust Survey Team is excited to share the results of our <a href=\"https://blog.rust-lang.org/2024/12/05/annual-survey-2024-launch.html\">2024 survey on the Rust Programming language</a>, conducted between December 5, 2024 and December 23, 2024.\nAs in previous years, the 2024 State of Rust Survey was focused on gathering insights and feedback from Rust users, and all those who are interested in the future of Rust more generally.</p><p>This ninth edition of the survey surfaced new insights and learning opportunities straight from the global Rust language community, which we will summarize below. In addition to this blog post,  containing charts with aggregated results of all questions in the survey.</p><p><strong>Our sincerest thanks to every community member who took the time to express their opinions and experiences with Rust over the past year. Your participation will help us make Rust better for everyone.</strong></p><p>There's a lot of data to go through, so strap in and enjoy!</p><table><thead><tr></tr></thead><tbody><tr></tr><tr></tr></tbody></table><p>As shown above, in 2024, we have received fewer survey views than in the previous year. This was likely caused simply by the fact that the survey ran only for two weeks, while in the previous year it ran for almost a month. However, the completion rate has also dropped, which seems to suggest that the survey might be a bit too long. We will take this into consideration for the next edition of the survey.</p><p>The State of Rust survey not only gives us excellent insight into how many Rust users around the world are using and experiencing the language but also gives us insight into the makeup of our global community. This information gives us a sense of where the language is being used and where access gaps might exist for us to address over time. We hope that this data and our related analysis help further important discussions about how we can continue to prioritize global access and inclusivity in the Rust community.</p><p>Same as every year, we asked our respondents in which country they live in. The top 10 countries represented were, in order: United States (22%), Germany (14%), United Kingdom (6%), France (6%), China (5%), Canada (3%), Netherlands (3%), Russia (3%), Australia (2%), and Sweden (2%). We are happy to see that Rust is enjoyed by users from all around the world! You can try to find your country in the chart below:</p><p>We also asked whether respondents consider themselves members of a marginalized community. Out of those who answered, 74.5% selected no, 15.5% selected yes, and 10% preferred not to say.</p><p>We have asked the group that selected ‚Äúyes‚Äù which specific groups they identified as being a member of. The majority of those who consider themselves a member of an underrepresented or marginalized group in technology identify as lesbian, gay, bisexual, or otherwise non-heterosexual. The second most selected option was neurodivergent at 46% followed by trans at 35%.</p><p>Each year, we must acknowledge the diversity, equity, and inclusivity (DEI) related gaps in the Rust community and open source as a whole. We believe that excellent work is underway at the Rust Foundation to advance global access to Rust community gatherings and distribute grants to a diverse pool of maintainers each cycle, which you can learn more about <a href=\"https://rustfoundation.org/community\">here</a>. Even so, global inclusion and access is just one element of DEI, and the survey working group will continue to advocate for progress in this domain.</p><p>The number of respondents that self-identify as a Rust user was quite similar to last year, around 92%. This high number is not surprising, since we primarily target existing Rust developers with this survey.</p><p>Similarly as last year, around 31% of those who did not identify as Rust users cited the perception of difficulty as the primary reason for not using Rust. The most common reason for not using Rust was that the respondents simply haven‚Äôt had the chance to try it yet.</p><p>Of the former Rust users who participated in the 2024 survey, 36% cited factors outside their control as a reason why they no longer use Rust, which is a 10pp decrease from last year. This year, we also asked respondents if they would consider using Rust again if an opportunity comes up, which turns out to be true for a large fraction of the respondents (63%). That is good to hear!</p><blockquote><p>Closed answers marked with N/A were not present in the previous version(s) of the survey.</p></blockquote><p>Those not using Rust anymore told us that it is because they don't really need it (or the goals of their company changed) or because it was not the right tool for the job. A few reported being overwhelmed by the language or its ecosystem in general or that switching to or introducing Rust would have been too expensive in terms of human effort.</p><p>Of those who used Rust in 2024, 53% did so on a daily (or nearly daily) basis ‚Äî an increase of 4pp from the previous year. We can observe an upward trend in the frequency of Rust usage over the past few years, which suggests that Rust is being increasingly used at work. This is also confirmed by other answers mentioned in the Rust at Work section later below.</p><p>Rust expertise is also continually increasing amongst our respondents! 20% of respondents can write (only) simple programs in Rust (a decrease of 3pp from 2023), while 53% consider themselves productive using Rust ‚Äî up from 47% in 2023. While the survey is just one tool to measure the changes in Rust expertise overall, these numbers are heartening as they represent knowledge growth for many Rustaceans returning to the survey year over year.</p><p>Unsurprisingly, the most popular version of Rust is , either the most recent one or whichever comes with the users' Linux distribution. Almost a third of users also use the latest nightly release, due to various reasons (see below). However, it seems that the beta toolchain is not used much, which is a bit unfortunate. We would like to encourage Rust users to use the beta toolchain more (e.g. in CI environments) to help test soon-to-be stabilized versions of Rust.</p><p>People that use the nightly toolchain mostly do it to gain access to specific unstable language features. Several users have also mentioned that rustfmt works better for them on nightly or that they use the nightly compiler because of faster compilation times.</p><p>To use Rust, programmers first have to learn it, so we are always interested in finding out how do they approach that. Based on the survey results, it seems that most users learn from Rust documentation and also from <a href=\"https://doc.rust-lang.org/book/\">The Rust Programming Language</a> book, which has been a favourite learning resource of new Rustaceans for a long time. Many people also seem to learn by reading the source code of Rust crates. The fact that both the documentation and source code of tens of thousands of Rust crates is available on <a href=\"https://docs.rs\">docs.rs</a> and GitHub makes this easier.</p><p>In terms of answers belonging to the \"Other\" category, they can be clustered into three categories: people using LLM (large language model) assistants (Copilot, ChatGPT, Claude, etc.), reading the official Rust forums (Discord, <a href=\"https://users.rust-lang.org/\">URLO</a>) or being mentored while contributing to Rust projects. We would like to extend a big thank you to those making our spaces friendly and welcoming for newcomers, as it is important work and it pays off. Interestingly, a non-trivial number of people \"learned by doing\" and used rustc error messages and clippy as a guide, which is a good indicator of the quality of Rust diagnostics.</p><p>In terms of formal education, it seems that Rust has not yet penetrated university curriculums, as this is typically a very slowly moving area. Only a very small number of respondents (around 3%) have taken a university Rust course or used university learning materials.</p><p>In terms of operating systems used by Rustaceans, Linux was the most popular choice, and it seems that it is getting increasingly popular year after year. It is followed by macOS and Windows, which have a very similar share of usage.</p><blockquote><p>As you can see in the <a href=\"https://blog.rust-lang.org/images/2025-02-13-rust-survey-2024/which-os-do-you-use-wordcloud.png\">wordcloud</a>, there are also a few users that prefer Arch, btw.</p></blockquote><p>Rust programmers target a diverse set of platforms with their Rust programs. We saw a slight uptick in users targeting embedded and mobile platforms, but otherwise the distribution of platforms stayed mostly the same as last year. Since the WebAssembly target is quite diverse, we have split it into two separate categories this time. Based on the results it is clear that when using WebAssembly, it is mostly in the context of browsers (23%) rather than other use-cases (7%).</p><p>We cannot of course forget the favourite topic of many programmers: which IDE (developer environment) they use. Although Visual Studio Code still remains the most popular option, its share has dropped by 5pp this year. On the other hand, the Zed editor seems to have gained considerable traction recently. The small percentage of those who selected \"Other\" are using a wide range of different tools: from CursorAI to classics like Kate or Notepad++. Special mention to the 3 people using \"ed\", that's quite an achievement.</p><blockquote><p>You can also take a look at the linked <a href=\"https://blog.rust-lang.org/images/2025-02-13-rust-survey-2024/what-ide-do-you-use-wordcloud.png\">wordcloud</a> that summarizes open answers to this question (the \"Other\" category), to see what other editors are also popular.</p></blockquote><p>We were excited to see that more and more people use Rust at work for the majority of their coding, 38% vs 34% from last year. There is a clear upward trend in this metric over the past few years.</p><p>The usage of Rust within companies also seems to be rising, as 45% of respondents answered that their organisation makes non-trivial use of Rust, which is a 7pp increase from 2023.</p><p>Once again, the top reason employers of our survey respondents invested in Rust was the ability to build relatively correct and bug-free software. The second most popular reason was Rust‚Äôs performance characteristics. 21% of respondents that use Rust at work do so because they already know it, and it's thus their default choice, an uptick of 5pp from 2023. This seems to suggest that Rust is becoming one of the baseline languages of choice for more and more companies.</p><p>Similarly to the previous year, a large percentage of respondents (82%) report that Rust helped their company achieve its goals. In general, it seems that programmers and companies are quite happy with their usage of Rust, which is great!</p><p>In terms of technology domains, the situation is quite similar to the previous year. Rust seems to be especially popular for creating server backends, web and networking services and cloud technologies. It also seems to be gaining more traction for embedded use-cases.</p><blockquote><p>You can scroll the chart to the right to see more domains. Note that the Automotive domain was not offered as a closed answer in the 2023 survey (it was merely entered through open answers), which might explain the large jump.</p></blockquote><p>It is exciting to see the continued growth of professional Rust usage and the confidence so many users feel in its performance, control, security and safety, enjoyability, and more!</p><p>As always, one of the main goals of the State of Rust survey is to shed light on challenges, concerns, and priorities on Rustaceans‚Äô minds over the past year.</p><p>We have asked our users about aspects of Rust that limit their productivity. Perhaps unsurprisingly, slow compilation was at the top of the list, as it seems to be a perennial concern of Rust users. As always, there are efforts underway to improve the speed of the compiler, such as enabling the <a href=\"https://blog.rust-lang.org/2023/11/09/parallel-rustc.html\">parallel frontend</a> or switching to a <a href=\"https://blog.rust-lang.org/2024/05/17/enabling-rust-lld-on-linux.html\">faster linker by default</a>. We invite you to test these improvements and let us know if you encounter any issues.</p><p>Other challenges included subpar support for debugging Rust and high disk usage of Rust compiler artifacts. On the other hand, most Rust users seem to be very happy with its runtime performance, the correctness and stability of the compiler and also Rust's documentation.</p><p>In terms of specific unstable (or missing) features that Rust users want to be stabilized (or implemented), the most desired ones were async closures and if/let while chains. Well, we have good news! Async closures will be stabilized in the next version of Rust (1.85), and if/let while chains will hopefully follow <a href=\"https://github.com/rust-lang/rust/pull/132833\">soon after</a>, once Edition 2024 is released (which will also happen in Rust 1.85).</p><p>Other coveted features are generators (both sync and async) and more powerful generic const expressions. You can follow the <a href=\"https://rust-lang.github.io/rust-project-goals/2025h1/goals.html\">Rust Project Goals</a> to track the progress of these (and other) features.</p><p>In the open answers to this question, people were really helpful and tried hard to describe the most notable issues limiting their productivity. We have seen mentions of struggles with async programming (an all-time favourite), debuggability of errors (which people generally love, but they are not perfect for everyone) or Rust tooling being slow or resource intensive (rust-analyzer and rustfmt). Some users also want a better IDE story and improved interoperability with other languages.</p><p>This year, we have also included a new question about the speed of Rust's evolution. While most people seem to be content with the status quo, more than a quarter of people who responded to this question would like Rust to stabilize and/or add features more quickly, and only 7% of respondents would prefer Rust to slow down or completely stop adding new features.</p><p>Interestingly, when we asked respondents about their main worries for the future of Rust, one of the top answers remained the worry that Rust will become too complex. This seems to be in contrast with the answers to the previous question. Perhaps Rust users still seem to consider the complexity of Rust to be manageable, but they worry that one day it might become too much.</p><p>We are happy to see that the amount of respondents concerned about Rust Project governance and lacking support of the Rust Foundation has dropped by about 6pp from 2023.</p><p>Each year, the results of the State of Rust survey help reveal the areas that need improvement in many areas across the Rust Project and ecosystem, as well as the aspects that are working well for our community.</p><p>If you have any suggestions for the Rust Annual survey, please <a href=\"https://github.com/rust-lang/surveys/issues\">let us know</a>!</p><p>We are immensely grateful to those who participated in the 2024 State of Rust Survey and facilitated its creation. While there are always challenges associated with developing and maintaining a programming language, this year we were pleased to see a high level of survey participation and candid feedback that will truly help us make Rust work better for everyone.</p><p>If you‚Äôd like to dig into more details, we recommend you to browse through the full <a href=\"https://raw.githubusercontent.com/rust-lang/surveys/main/surveys/2024-annual-survey/report/annual-survey-2024-report.pdf\">survey report</a>.</p>","contentLength":14399,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Giampaolo Rodola: psutil: drop Python 2.7 support","url":"https://gmpy.dev/blog/2025/psutil-drop-python-27-support","date":1739401200,"author":"","guid":277,"unread":true,"content":"<p>About dropping Python 2.7 support in psutil, 3 years ago\n<a href=\"https://github.com/giampaolo/psutil/issues/2014#issuecomment-969263432\">I stated</a>:</p><blockquote><p>Not a chance, for many years to come. [Python 2.7] currently represents 7-10%\nof total downloads, meaning around 70k / 100k downloads per day.</p></blockquote><p>Only 3 years later, and to my surprise, <strong>downloads for Python 2.7 dropped to\n0.36%</strong>! As such, as of psutil 7.0.0, I finally decided to drop support for\nPython 2.7!</p><p>These are downloads per month:</p><div><pre><code></code></pre></div><p>According to <a href=\"https://archive.is/wip/knzql\">pypistats.org</a> Python 2.7 downloads\nrepresents the 0.28% of the total, around 15.000 downloads per day.</p><p>Maintaining 2.7 support in psutil had become increasingly difficult, but still\npossible. E.g. I could still run tests by using <a href=\"https://github.com/giampaolo/psutil/blob/fbb6d9ce98f930d3d101b7df5a4f4d0f1d2b35a3/setup.py#L76-L85\">old PYPI\nbackports</a>.\nGitHub Actions could still be\n<a href=\"https://github.com/giampaolo/psutil/blob/fbb6d9ce98f930d3d101b7df5a4f4d0f1d2b35a3/.github/workflows/build.yml#L77-L112\">tweaked</a>\nto run tests and produce 2.7 wheels on Linux and macOS. Not on Windows though,\nfor which I had to use a separate service (Appveyor). Still, the amount of\nhacks in psutil source code necessary to support Python 2.7 piled up over the\nyears, and became quite big. Some disadvantages that come to mind:</p><ul><li>Having to maintain a Python compatibility layers like\n  <a href=\"https://github.com/giampaolo/psutil/blob/fbb6d9ce98f930d3d101b7df5a4f4d0f1d2b35a3/psutil/_compat.py\">psutil/_compat.py</a>.\n  This translated in extra extra code and extra imports.</li><li>The C compatibility layer to differentiate between Python 2 and 3 (<code>#if\n  PY_MAJOR_VERSION &lt;= 3</code>, etc.).</li><li>Dealing with the string vs. unicode differences, both in Python and in C.</li><li>Inability to use modern language features, especially f-strings.</li><li>Inability to freely use s, which created a difference on how CONSTANTS\n  were exposed in terms of API.</li><li>Having to install a specific version of  and other (outdated)\n  <a href=\"https://github.com/giampaolo/psutil/blob/fbb6d9ce98f930d3d101b7df5a4f4d0f1d2b35a3/setup.py#L76-L85\">deps</a>.</li><li>Relying on the third-party Appveyor CI service to run tests and produce 2.7\n  wheels.</li><li>Running 4 extra CI jobs on every commit (Linux, macOS, Windows 32-bit,\n  Windows 64-bit) making the CI slower and more subject to failures (we have\n  quite a bit of flaky tests).</li><li>The distribution of 7 wheels specific for Python 2.7. E.g. in the previous\n  release I had to upload:</li></ul><div><pre><code>psutil-6.1.1-cp27-cp27m-macosx_10_9_x86_64.whl\npsutil-6.1.1-cp27-none-win32.whl\npsutil-6.1.1-cp27-none-win_amd64.whl\npsutil-6.1.1-cp27-cp27m-manylinux2010_i686.whl\npsutil-6.1.1-cp27-cp27m-manylinux2010_x86_64.whl\npsutil-6.1.1-cp27-cp27mu-manylinux2010_i686.whl\npsutil-6.1.1-cp27-cp27mu-manylinux2010_x86_64.whl\n</code></pre></div><p>The removal was done in\n<a href=\"https://github.com/giampaolo/psutil/pull/2481\">PR-2841</a>, which removed around\n1500 lines of code (nice!). . In doing so, in the doc I\nstill made the promise that the 6.1.* serie will keep supporting Python 2.7\nand will receive  (no new features). It will be\nmaintained in a specific <a href=\"https://github.com/giampaolo/psutil/tree/python2\">python2\nbranch</a>. I explicitly kept\nthe\n<a href=\"https://github.com/giampaolo/psutil/blob/fbb6d9ce98f930d3d101b7df5a4f4d0f1d2b35a3/setup.py\">setup.py</a>\nscript compatible with Python 2.7 in terms of syntax, so that, when the tarball\nis fetched from PYPI, it will emit an informative error message on . The user trying to install psutil on Python 2.7 will see:</p><div><pre><code>$pip2installpsutil\nAsofversion.0.0psutilnolongersupportsPython.7.\nLatestversionsupportingPython.7ispsutil.1.X.\nInstallitwith:.\n</code></pre></div><p>As the informative message states, users that are still on Python 2.7 can still\nuse psutil with:</p><div><pre><code>pip2 install psutil==6.1.*\n</code></pre></div>","contentLength":2975,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Kay Hayen: Nuitka Release 2.6","url":"https://nuitka.net/posts/nuitka-release-26.html","date":1739401200,"author":"","guid":278,"unread":true,"content":"<li><p> Path normalization to native Windows format was required\nin more places for the  variant of .</p><p>The  function doesn‚Äôt normalize to native Win32\npaths with MSYS2, instead using forward slashes. This required manual\nnormalization in additional areas. (Fixed in 2.5.1)</p></li><li><p> Fix, give a proper error when extension modules asked to\ninclude failed to be located. instead of a proper error message.\n(Fixed in 2.5.1)</p></li><li><p>Fix, files with illegal module names (containing ) in their\nbasename were incorrectly considered as potential sub-modules for\n. These are now skipped. (Fixed in 2.5.1)</p></li><li><p> Improved stability by preventing crashes when stubgen\nencounters code it cannot handle. Exceptions from it are now ignored.\n(Fixed in 2.5.1)</p></li><li><p> Addressed a crash that occurred when encountering\nassignments to non-variables. (Fixed in 2.5.1)</p></li><li><p> Fixed a regression introduced in 2.5 release that could\nlead to segmentation faults in exception handling for generators.\n(Fixed in 2.5.2)</p></li><li><p> Corrected an issue where dictionary copies of large\nsplit directories could become corrupted. This primarily affected\ninstance dictionaries, which are created as copies until updated,\npotentially causing problems when adding new keys. (Fixed in 2.5.2)</p></li><li><p> Removed the assumption that module dictionaries\nalways contain only strings as keys. Some modules, like\n on macOS, use non-string keys. (Fixed in 2.5.2)</p></li><li><p> Ensured that the  option correctly\naffects the C compilation process. Previously, only individual\ndisables were applied. (Fixed in 2.5.2)</p></li><li><p> Fixed a crash that could occur during compilation\nwhen unary operations were used within binary operations. (Fixed in\n2.5.3)</p></li><li><p> Corrected the handling of\n<code></code>, which could lead to crashes. (Fixed\nin 2.5.4)</p></li><li><p> Resolved a segmentation fault occurring at runtime\nwhen calling  with only keyword arguments.\n(Fixed in 2.5.5)</p></li><li><p> Harmless warnings generated for x64 DLLs on arm64 with\nnewer macOS versions are now ignored. (Fixed in 2.5.5)</p></li><li><p> Addressed a crash in Nuitka‚Äôs dictionary code that\noccurred when copying dictionaries due to internal changes in Python\n3.13. (Fixed in 2.5.6)</p></li><li><p> Improved onefile mode signing by applying\n to the signature of binaries, not just\napp bundles. (Fixed in 2.5.6)</p></li><li><p> Corrected an issue where too many paths were added as\nextra directories from the Nuitka package configuration. This\nprimarily affected the  package, which currently relies\non the  import hack. (Fixed in 2.5.6)</p></li><li><p> Prevented crashes on macOS when creating onefile\nbundles with Python 2 by handling negative CRC32 values. This issue\nmay have affected other versions as well. (Fixed in 2.5.6)</p></li><li><p> Restored the functionality of code provided in\n, which was no longer being applied due to a\nregression. (Fixed in 2.5.6)</p></li><li><p> Suppressed the app bundle mode recommendation when it is\nalready in use. (Fixed in 2.5.6)</p></li><li><p> Corrected path normalization when the output directory\nargument includes ‚Äú~‚Äù.</p></li><li><p> GitHub Actions Python is now correctly identified as a\nHomebrew Python to ensure proper DLL resolution. (Fixed in 2.5.7)</p></li><li><p> Fixed a reference leak that could occur with\nvalues sent to generator objects. Asyncgen and coroutines were not\naffected. (Fixed in 2.5.7)</p></li><li><p> The  scan now correctly handles\ncases where both a package init file and competing Python files\nexist, preventing compile-time conflicts. (Fixed in 2.5.7)</p></li><li><p> Resolved an issue where handling string constants in\nmodules created for Python 3.12 could trigger assertions, and modules\ncreated with 3.12.7 or newer failed to load on older Python 3.12\nversions when compiled with Nuitka 2.5.5-2.5.6. (Fixed in 2.5.7)</p></li><li><p> Corrected the tuple code used when calling certain\nmethod descriptors. This issue primarily affected a Python 2\nassertion, which was not impacted in practice. (Fixed in 2.5.7)</p></li><li><p> Updated resource readers to accept multiple\narguments for <code></code>, and correctly handle\n and  as keyword-only arguments.</p></li><li><p> The platform encoding is no longer used to decode\n logs. Instead,  is used, as it is sufficient for\nmatching filenames across log lines and avoids potential encoding\nerrors. (Fixed in 2.5.7)</p></li><li><p> Requests to statically link libraries for \nare now ignored, as these libraries do not exist. (Fixed in 2.5.7)</p></li><li><p> Fixed a memory leak affecting the results of\nfunctions called via specs. This primarily impacted overloaded hard\nimport operations. (Fixed in 2.5.7)</p></li><li><p> When multiple distributions for a package are found,\nthe one with the most accurate file matching is now selected. This\nimproves handling of cases where an older version of a package (e.g.,\n) is overwritten with a different variant (e.g.,\n), ensuring the correct version is used for\nNuitka package configuration and reporting. (Fixed in 2.5.8)</p></li><li><p> Prevented a potential crash during onefile\ninitialization on Python 2 by passing the directory name directly\nfrom the onefile bootstrap, avoiding the use of  which\nmay not be fully loaded at that point. (Fixed in 2.5.8)</p></li><li><p> Preserved necessary  environment variables on\nWindows for packages that require loading DLLs from those locations.\nOnly  entries not pointing inside the installation prefix are\nremoved. (Fixed in 2.5.8)</p></li><li><p> Corrected the  check to function\nproperly when distribution names and package names differ. (Fixed in\n2.5.8)</p></li><li><p> Improved package name resolution for Anaconda\ndistributions by checking conda metadata when file metadata is\nunavailable through the usual methods. (Fixed in 2.5.8)</p></li><li><p> Normalized the downloaded gcc path to use native Windows\nslashes, preventing potential compilation failures. (Fixed in 2.5.9)</p></li><li><p> Restored static libpython functionality on Linux by\nadapting to a signature change in an unexposed API. (Fixed in 2.5.9)</p></li><li><p> Prevented  from being resurrected when a\nfinalizer is attached, resolving memory leaks that could occur with\n in the presence of exceptions. (Fixed in 2.5.10)</p></li><li><p> Suppressed the gcc download prompt that could appear during\n output on Windows systems without MSVC or with an\nimproperly installed gcc.</p></li><li><p>Ensured compatibility with monkey patched  or \nfunctions, which are used in some testing scenarios.</p></li><li><p> Improved the determinism of the JSON statistics\noutput by sorting keys, enabling reliable build comparisons.</p></li><li><p> Fixed a memory leak in  with finalizers,\nwhich could lead to significant memory consumption when using\n and encountering exceptions.</p></li><li><p> Optimized empty generators (an optimization result) to\navoid generating unused context code, eliminating C compilation\nwarnings.</p></li><li><p> Fixed a reference leak affecting the  value\nin . While typically , this could lead to\nobservable reference leaks in certain cases.</p></li><li><p> Improved handling of  and \nresurrection, preventing memory leaks with  and\n, and ensuring correct execution of  code in\ncoroutines.</p></li><li><p> Corrected the handling of  objects\nresurrecting during deallocation. While not explicitly demonstrated,\nthis addresses potential issues similar to those encountered with\ncoroutines, particularly for old-style coroutines created with the\n decorator.</p></li><li><p> Fixed a potential crash during runtime trace collection by\nensuring timely initialization of the output mechanism.</p></li>","contentLength":6936,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Show HN: I made my own OS from scratch because I was bored","url":"https://jotalea.com.ar/misc/jotaleaos/","date":1739393712,"author":"Jotalea","guid":320,"unread":true,"content":"<!DOCTYPE html>","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=43029686"},{"title":"Show HN: yknotify ‚Äì Notify when YubiKey needs touch on macOS","url":"https://github.com/noperator/yknotify","date":1739391899,"author":"noperator","guid":319,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=43029385"},{"title":"Show HN: A no-build fullstack SSR TypeScript web framework","url":"https://jsr.io/@fullsoak/fullsoak","date":1739390092,"author":"thesephi","guid":318,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=43029089"},{"title":"Oracle's Ellison Calls for Governments To Unify Data To Feed AI","url":"https://developers.slashdot.org/story/25/02/12/1857208/oracles-ellison-calls-for-governments-to-unify-data-to-feed-ai?utm_source=rss1.0mainlinkanon&utm_medium=feed","date":1739386560,"author":"msmash","guid":368,"unread":true,"content":"Oracle co-founder and chairman Larry Ellison said governments should consolidate all national data for consumption by AI models, calling this step the \"missing link\" for them to take full advantage of the technology. From a report: Fragmented sets of data about a population's health, agriculture, infrastructure, procurement and borders should be unified into a single, secure database that can be accessed by AI models, Ellison said in an on-stage interview with former British Prime Minister Tony Blair at the World Government Summit in Dubai. \n\nCountries with rich population data sets, such as the UK and United Arab Emirates, could cut costs and improve public services, particularly health care, with this approach, Ellison said. Upgrading government digital infrastructure could also help identify wastage and fraud, Ellison said. IT systems used by the US government are so primitive that it makes it difficult to identify \"vast amounts of fraud,\" he added, pointing to efforts by Elon Musk's team at the Department of Government Efficiency to weed it out.","contentLength":1065,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Fine-tune LLMs with synthetic data for context-based Q&A using Amazon Bedrock","url":"https://aws.amazon.com/blogs/machine-learning/fine-tune-llms-with-synthetic-data-for-context-based-qa-using-amazon-bedrock/","date":1739382250,"author":"Sue Cha","guid":234,"unread":true,"content":"<p>There‚Äôs a growing demand from customers to incorporate generative AI into their businesses. Many use cases involve using pre-trained large language models (LLMs) through approaches like Retrieval Augmented Generation (RAG). However, for advanced, domain-specific tasks or those requiring specific formats, model customization techniques such as fine-tuning are sometimes necessary. <a href=\"https://aws.amazon.com/bedrock/\" target=\"_blank\" rel=\"noopener\">Amazon Bedrock</a> provides you with the ability to customize leading foundation models (FMs) such as Anthropic‚Äôs Claude 3 Haiku and Meta‚Äôs Llama 3.1.</p><p>Amazon Bedrock is a fully managed service that makes FMs from leading AI startups and Amazon available through an API, so you can choose from a wide range of FMs to find the model that is best suited for your use case. Amazon Bedrock offers a serverless experience, so you can get started quickly, privately customize FMs with your own data, and integrate and deploy them into your applications using AWS tools without having to manage any infrastructure.</p><p>Fine-tuning is a supervised training process where labeled prompt and response pairs are used to further train a pre-trained model to improve its performance for a particular use case. One consistent pain point of fine-tuning is the lack of data to effectively customize these models. Gathering relevant data is difficult, and maintaining its quality is another hurdle. Furthermore, fine-tuning LLMs requires substantial resource commitment. In such scenarios, synthetic data generation offers a promising solution. You can create synthetic training data using a larger language model and use it to fine-tune a smaller model, which has the benefit of a quicker turnaround time.</p><p>In this post, we explore how to use Amazon Bedrock to generate synthetic training data to fine-tune an LLM. Additionally, we provide concrete evaluation results that showcase the power of synthetic data in fine-tuning when data is scarce.</p><p>The solution comprises two main steps:</p><ol><li>Generate synthetic data using the Amazon Bedrock InvokeModel API.</li><li>Fine-tune using an Amazon Bedrock custom model.</li></ol><p>For synthetic data generation, we use a larger language model (such as <a href=\"https://aws.amazon.com/bedrock/claude/\" target=\"_blank\" rel=\"noopener\">Anthropic‚Äôs Claude 3 Sonnet on Amazon Bedrock</a>) as the teacher model, and a smaller language model (such as Anthropic‚Äôs Claude Instant 1.2 or Claude 3 Haiku on Amazon Bedrock) as the student model for fine-tuning. We use the larger teacher model to generate new data based on its knowledge, which is then used to train the smaller student model. This concept is similar to knowledge distillation used in deep learning, except that we‚Äôre using the teacher model to generate a new dataset from its knowledge rather than directly modifying the architecture of the student model.</p><p>The following diagram illustrates the overall flow of the solution.</p><p>Finally, we share our experiment results, where we compare the performance of the model fine-tuned with synthetic data to the baseline (not fine-tuned) model and to a model fine-tuned with an equal amount of original training data.</p><p>To generate synthetic data and fine-tune models using Amazon Bedrock, you first need to create an <a href=\"https://aws.amazon.com/iam/\" target=\"_blank\" rel=\"noopener\">AWS Identity and Access Management (IAM)</a> service role with the appropriate permissions. This role is used by Amazon Bedrock to access the necessary resources on your behalf.</p><p>If you‚Äôre running this code using an <a href=\"https://aws.amazon.com/sagemaker/\" target=\"_blank\" rel=\"noopener\">Amazon SageMaker</a> notebook instance, edit the IAM role that‚Äôs attached to the notebook (for example, AmazonSageMaker-ExecutionRole-XXX) instead of creating a new role. Follow <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/model-customization-iam-role.html\" target=\"_blank\" rel=\"noopener\">Create a service role for model customization</a> to modify the trust relationship and add the S3 bucket permission. Additionally, on the role‚Äôs tab, create the following inline policies:</p><ol><li>Policy name: bedrock-customization</li></ol><div><pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"VisualEditor0\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"bedrock:InvokeModel\",\n                \"bedrock:ListModelCustomizationJobs\",\n                \"bedrock:DeleteCustomModel\",\n                \"bedrock:CreateModelCustomizationJob\",\n                \"bedrock:StopModelCustomizationJob\",\n                \"bedrock:ListCustomModels\",\n                \"bedrock:GetCustomModel\",\n                \"bedrock:GetModelCustomizationJob\"\n            ],\n            \"Resource\": \"*\"\n        }\n    ]\n}\n</code></pre></div><ol start=\"2\"><li>Policy name: iam-pass-role</li></ol><div><pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"VisualEditor0\",\n            \"Effect\": \"Allow\",\n            \"Action\": \"iam:PassRole\",\n            \"Resource\": [\n                \"${sagemaker-execution-role-arn}\"\n            ]\n        }\n    ]\n}</code></pre></div><p>The final permission policies for the SageMaker execution role should look like the following, which include AmazonSageMaker-ExecutionPolicy, AmazonSageMakerFullAccess, bedrock-customization, and iam-pass-role.</p><h2>Generate synthetic data using the Amazon Bedrock InvokeModel API</h2><p>We use the <a href=\"https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_InvokeModel.html\" target=\"_blank\" rel=\"noopener\">Amazon Bedrock InvokeModel API</a> to generate synthetic data for fine-tuning. You can use the API to programmatically send an inference (text generation) request to the model of your choice. All you need is a well-crafted prompt tailored for data synthesis. We used the following sample prompt for our use case:</p><div><pre><code>PROMPT = \"\"\"\nYou are an AI assistant who is an expert in Amazon services. Your task is to understand a system that takes in a list of documents, and based on that, answers a question by providing citations for the documents that it referred the answer from.\n\nYour job is to generate three new Question/Answer pairs, emulating the tone, style, and grammar of the original data provided.\n\nHere is the original data :\nInput Documents and Question : {document}\\n\\nQuestion: {question}\nOutput Answer : {answer}\n\nStrictly return a jsonl with the keys (question, answer, topic). Every topic should be different. The answers should be in the exact same format as the original. The question and the answer should be different in content from the original data provided, and all questions should be diverse and different from each other. Do not answer in any other format. The response should be parsable as a jsonl.\n\"\"\"</code></pre></div><p>The goal of our use case was to fine-tune a model to generate a relevant and coherent answer based on a given reference document and a question. RAG is a popular technique used for such Q&amp;A tasks; however, one significant challenge with RAG is the potential for retrieving unrelated or irrelevant documents, which can lead to inaccurate responses. You can apply fine-tuning to guide the model to better focus on the relevance of the documents to the question instead of using the provided documents without context to answer the question.</p><p>Our dataset includes Q&amp;A pairs with reference documents regarding AWS services. Each sample has up to five reference documents as context, and a single-line question follows. The following table shows an example.</p><table border=\"1px\" cellpadding=\"10px\"><tbody><tr><td width=\"677\"><p>Step 1: Prepare to work with AWS CodeStar projects</p><p>In this step, you create an AWS CodeStar service role and an Amazon EC2 key pair, so that you can begin creating and working with AWS CodeStar projects. If you have used AWS CodeStar before, skip ahead to Step 2</p><p>Step 2: Create a Project in AWS CodeStar.</p><p>For this step, follow the instructions in Setting Up AWS CodeStar in the AWS CodeStar User Guide. Do not create a new AWS account, IAM user, or IAM group as part of those instructions. Use the ones you created or identified in Team Setup for AWS Cloud9. When you finish following those instructions, return to this topic.</p><p>Before you can start using AWS CodeStar, you must complete the following steps.</p><p>Step 1: Create an account</p><p>Step 2: Create the AWS CodeStar Service Role</p><p>Step 3: Configure the User‚Äôs IAM Permissions</p><p>Step 4: Create an Amazon EC2 Key Pair for AWS CodeStar Projects</p><p>Step 5: Open the AWS CodeStar Console</p><p>How Do I Get Started with AWS CodeStar?</p><p>To get started with AWS CodeStar:</p><p>Prepare to use AWS CodeStar by following the steps in Setting Up AWS CodeStar.</p><p>Experiment with AWS CodeStar by following the steps in the Getting Started with AWS CodeStar tutorial.</p><p>Share your project with other developers by following the steps in Add Team Members to an AWS CodeStar Project.</p><p>Integrate your favorite IDE by following the steps in Use an IDE with AWS CodeStar.</p><p>Step 2: Create a project in AWS CodeStar</p><p>In this step, you create a project in AWS CodeStar.</p><p>If you already have a project in AWS CodeStar you want to use, skip ahead to Step 3: Create an AWS Cloud9 Development Environment and Connect It to the Project.</p><p>For this step, follow the instructions in Create a Project in AWS CodeStar in the AWS CodeStar User Guide. In the AWS CodeStar create project wizard, when you get to the Setup tools page or Connect to your source repository page, choose Skip, and then return to this topic.</p><p>Create a Project in AWS CodeStar</p><p>You use the AWS CodeStar console to create a project. If you use a project template, it sets up the required resources for you. The template also includes sample code that you can use to start coding.</p><p>To create a project, sign in to the AWS Management Console with an IAM user that has the AWSCodeStarFullAccess policy or equivalent permissions. For more information, see Setting Up AWS CodeStar.</p><p>Note: You must complete the steps in Setting Up AWS CodeStar before you can complete the procedures in this topic.</p><p>Create a Project in AWS CodeStar (Console)</p><p>Create a Project in AWS CodeStar (AWS CLI)</p><p>Answer the following question to the best of your ability. Use and paraphrase the information in the context, if it answers the question. Otherwise, rely on your knowledge and memory.</p></td></tr><tr><td width=\"677\">How do I get started with AWS CodeStar?</td></tr><tr><td width=\"677\"><p>To get started with AWS CodeStar, follow these steps:</p><p>1.&nbsp;Prepare to work with AWS CodeStar projects:</p><p>a. Create an AWS CodeStar service role by following the instructions in ‚ÄúSetting Up AWS CodeStar‚Äù (Document 2) in the AWS CodeStar User Guide [1].</p><p>b. Create an Amazon EC2 key pair for AWS CodeStar projects, as described in the same guide [1].</p><p>2.&nbsp;Create a project in AWS CodeStar:</p><p>a. Sign in to the AWS Management Console with an IAM user that has the AWSCodeStarFullAccess policy or equivalent permissions [2].</p><p>b. In the AWS CodeStar console, select one of the available project templates, which will automatically provision all the required resources for your project [3].</p><p>c. Once your project is provisioned, you can see your running application from the Application endpoints tile [3].</p><p>3.&nbsp;Connect to the AWS CodeCommit source repository for your project:</p><p>a. Use the steps provided in the CodeStar console to connect to the AWS CodeCommit source repository for your project [3].</p><p>b. Begin coding and making changes to your project\\‚Äôs source code.</p><p>4.&nbsp;Track and manage changes in the release process:</p><p>a. Use the project dashboard to track and manage changes in the release process [3].</p><p>b. View the most recent project activity on the dashboard.</p><p>5.&nbsp;Share your project with other developers:</p><p>a. Follow the steps in ‚ÄúAdd Team Members to an AWS CodeStar Project‚Äù to share your project with other developers [3].</p><p>6.&nbsp;Integrate your favorite IDE:</p><p>a. Follow the steps in ‚ÄúUse an IDE with AWS CodeStar‚Äù to integrate your preferred Integrated Development Environment (IDE) with AWS CodeStar [3].</p><p>[1] https://docs.aws.amazon.com/codestar/latest/userguide/setting-up.html</p><p>[2] https://docs.aws.amazon.com/codestar/latest/userguide/create-project.html</p><p>[3] https://docs.aws.amazon.com/codestar/latest/userguide/getting-started.html</p></td></tr></tbody></table><p>For data synthesis, we asked the model to generate three new Q&amp;A pairs per reference document. However, you can adjust the number as needed. The crucial part is to make the model think deeply about a variety of topics. Because the purpose of generating synthetic data is to enrich the training dataset, it‚Äôs more beneficial to have the model look at different parts of the documents and create Q&amp;A pairs with different topics than the original.</p><p>The following example shows how to generate synthetic data with the Amazon Bedrock InvokeModel API. We tested the preceding prompt with Anthropic‚Äôs Claude 3 Sonnet. If you want to test a different model, retrieve the corresponding model ID from <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/model-ids.html\" target=\"_blank\" rel=\"noopener\">Amazon Bedrock model IDs</a>, and replace the modelId variable in the function.</p><div><pre><code>import boto3\nimport json\n\nbedrock = boto3.client(service_name=\"bedrock-runtime\")\n\ndef generate_synthetic_data(document, question, answer):\n    \n    values = {\n        \"document\": document,\n        \"question\": question,\n        \"answer\": answer\n    }\n    \n    body = {\n        \"messages\": [{\n            \"role\": \"user\", \"content\": PROMPT.format(**values)\n        }],\n        \"anthropic_version\": \"bedrock-2023-05-31\",\n        \"max_tokens\": 2048,\n        \"temperature\" : 0.5\n    }\n    \n    response = bedrock.invoke_model(\n        body=json.dumps(body),\n        modelId=\"anthropic.claude-3-sonnet-20240229-v1:0\",\n        accept=\"application/json\",\n        contentType=\"application/json\"\n    )\n    \n    response_body = json.loads(response.get('body').read())\n    \n    return response_body['content'][0]['text']\n</code></pre></div><p>The preceding function returns three JSONL records in strings with question, answer, and topic as keys. The following parse_llm_output function loads the strings and uses regular expressions to retrieve the generated questions and answers. Then, the create_synthetic_samples function combines those two functionalities to produce the final synthetic training samples.</p><div><pre><code>import re\nimport pd\n\ndef parse_llm_output(jsonl_string):\n    \n    question_pattern = re.compile(r'\"question\":\\s*\"([^\"]+)\"')\n    answer_pattern = re.compile(r'\"answer\":\\s*\"(.*?)\"\\s*,\\s*\"topic\"') \n    questions = question_pattern.findall(jsonl_string)\n    answers = answer_pattern.findall(jsonl_string)\n    \n    return questions, answers\n\n\ndef create_synthetic_samples(row: pd.Series) -&gt; pd.DataFrame:\n\n    jsonl_string = generate_synthetic_data(row['document'], row['question'], row['answer'])\n    questions, answers = parse_llm_output(jsonl_string)\n    \n    return pd.DataFrame({\n        \"document\": [row['document']] * len(questions),\n        \"question\": questions,\n        \"answer\": answers\n    })\n\n\ndef to_customization_format(row):\n\n    msg = {\n        \"messages\": [\n            {\"role\": \"user\", \"content\": f\"{row['document']}\\n\\nQuestion: {row['question']}\"},\n            {\"role\": \"assistant\", \"content\": row['answer']}\n        ]\n    }\n    \n    return msg\n</code></pre></div><p>The following script combines all of the preceding functions and gives you the final training set with both original and synthetic samples. We convert the samples into the format required by the customization job using the to_customization_format function and save them as train.jsonl. Assume the input data is a CSV file with three columns: document, question, and answer.</p><div><pre><code>import pandas as pd\n\n# Load original training samples\noriginal_train = pd.read_csv(input_df_path)\n\n# Create synthetic training samples\nsynthetic_train = pd.concat(original_train.apply(create_synthetic_samples, axis=1).tolist())\n\n# Combine original and synthetic samples\nfinal_train_df = pd.concat([original_train, synthetic_train])\n\n# Convert to the format required by the customization job\nfinal_train = final_train_df.apply(to_customization_format, axis=1).tolist()\n\n# Write to JSONL file    \nwith open('train.jsonl', 'w') as file:\n    for item in final_train:\n        json.dump(item, file)\n        file.write('\\n')\n</code></pre></div><h2>Fine-tune using an Amazon Bedrock custom model</h2><p>Now that you have the synthetic data generated by the teacher model along with your original data, it‚Äôs time to train the student model. We fine-tune the student model using the Amazon Bedrock custom model functionality.</p><p>Model customization is the process of providing training data to an FM to improve its performance for specific use cases. Amazon Bedrock offers three model customization methods as of this writing:</p><ul></ul><p>You can create your own custom model using any of these methods through the Amazon Bedrock console or API. For more information on supported models and AWS Regions with various customization methods, please see <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models.html\" target=\"_blank\" rel=\"noopener\">User guide for model customization</a>. In this section, we focus on how to fine-tune a model using the API.</p><p>To create a fine-tuning job in Amazon Bedrock, complete the following prerequisite steps:</p><ol><li>Upload the jsonl file to the training data bucket.</li><li>Make sure that you have created an IAM role, as described in the <a href=\"https://aws.amazon.com/blogs/machine-learning/fine-tune-llms-with-synthetic-data-for-context-based-qa-using-amazon-bedrock/#_Prerequisites\" target=\"_blank\" rel=\"noopener\">Prerequisites</a></li></ol><p>When these steps are complete, run the following code to submit a new fine-tuning job. In our use case, the student model was Anthropic‚Äôs Claude Instant 1.2. At the time of writing, Anthropic‚Äôs Claude 3 Haiku is generally available, and we recommend following the rest of the code using Anthropic‚Äôs Claude 3 Haiku. For the release announcement, see <a href=\"https://aws.amazon.com/about-aws/whats-new/2024/11/fine-tuning-anthropics-claude-3-haiku-amazon-bedrock/\" target=\"_blank\" rel=\"noopener\">Fine-tuning for Anthropic‚Äôs Claude 3 Haiku in Amazon Bedrock is now generally available</a>.</p><p>If you want to try different models, you must check the model provider‚Äôs terms of service yourself. Many providers restrict using their models to train competing models. For the latest model support information, see <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/custom-model-supported.html\" target=\"_blank\" rel=\"noopener\">Supported Regions and models for model customization</a>, and replace baseModelIdentifier accordingly. Different models have different hyperparameters. For more information, see <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models-hp.html\" target=\"_blank\" rel=\"noopener\">Custom model hyperparameters</a>.</p><div><pre><code>import boto3\nimport json\nimport time\n\nbedrock = boto3.client(service_name='bedrock')\n    \n# Set parameters\ncustomizationType = \"FINE_TUNING\"\nbaseModelIdentifier = \"arn:aws:bedrock:us-east-1::foundation-model/anthropic.claude-instant-v1:2:100k\"\nroleArn = \"${customization-role-arn}\"\njobName = \"${customization-job-name}\"\ncustomModelName = \"${customization-model-name}\"\nhyperParameters = {\n    \"epochCount\": \"1\",\n    \"batchSize\": \"96\",\n    \"learningRateMultiplier\": \"0.5\",\n }\ntrainingDataConfig = {\"s3Uri\": \"s3://${training-bucket}/train.jsonl\"}\noutputDataConfig = {\"s3Uri\": \"s3://${output-bucket}/myOutputData\"}\n\n# Create job\nresponse_ft = bedrock.create_model_customization_job(\n    jobName=jobName, \n    customModelName=customModelName,\n    roleArn=roleArn,\n    baseModelIdentifier=baseModelIdentifier,\n    hyperParameters=hyperParameters,\n    trainingDataConfig=trainingDataConfig,\n    outputDataConfig=outputDataConfig\n)\n\njobArn = response_ft.get('jobArn')\n\n# Check job status\nwhile True:\n    status = bedrock.get_model_customization_job(jobIdentifier=jobArn).get('status')\n    if status != 'InProgress':\n        print(status)\n        break\n    else:\n        print(status)\n    time.sleep(30)\n</code></pre></div><p>When the status changes to , your fine-tuned student model is ready for use. To run an inference with this custom model, you need to purchase . A flexible option is available for custom models, which can be turned off when not in use and billed by the hour. A cost estimate is provided on the console prior to purchasing provisioned throughput.</p><p>On the Amazon Bedrock console, choose in the navigation pane. Select the model you fine-tuned and choose <strong>Purchase provisioned throughput</strong>.</p><p>The model name and type are automatically selected for you. Select  for . After you make this selection, the estimated cost is shown. If you‚Äôre okay with the pricing, choose .</p><p>When the Provisioned Throughput becomes available, retrieve the ARN of the provisioned custom model and run the inference:</p><div><pre><code>import boto3\nimport json\n\nbedrock = boto3.client(service_name=\"bedrock-runtime\")\n\ndef run_student_model(document, question):\n    \n    values = {\n        \"document\": document,\n        \"question\": question,\n    }\n    \n    body = {\n        \"messages\": [{\n            \"role\": \"user\", \"content\": PROMPT.format(**values)\n        }],\n        \"max_tokens\": 2048,\n        \"temperature\" : 0.5\n    }\n    \n    response = bedrock.invoke_model(\n        body=json.dumps(body),\n        modelId=\"${provisioned_model_arn}\",\n        accept=\"application/json\",\n        contentType=\"application/json\"\n    )\n    \n    response_body = json.loads(response.get('body').read())\n    \n    return response_body['content'][0]['text']\n</code></pre></div><p>In this section, we share our experiment results to provide data points on how the synthetic data generated by a teacher model can improve the performance of a student model. For evaluation methods, we used an LLM-as-a-judge approach, where a judge model compares responses from two different models and picks a better response. Additionally, we conducted a manual evaluation on a small subset to assess whether the LLM-as-a-judge and human judges have aligned preferences.</p><p>We carried out controlled experiments where we compared four different models as follows: 1,500 synthetic training samples for the 4 model were generated by Anthropic‚Äôs Claude 3 Sonnet, and we created three synthetic samples per one original reference document (3 samples * 500 original reference documents = 1,500 synthetic samples).</p><table border=\"1px\" cellpadding=\"10px\"><tbody><tr><td width=\"634\">Anthropic‚Äôs Claude Instant without any customization</td></tr><tr><td width=\"634\">Anthropic‚Äôs Claude Instant fine-tuned with 500 original training samples</td></tr><tr><td width=\"169\"></td><td width=\"634\">Anthropic‚Äôs Claude Instant fine-tuned with 2,000 original training samples</td></tr><tr><td width=\"169\"></td><td width=\"634\">Anthropic‚Äôs Claude Instant fine-tuned with 500 original training samples plus 1,500 synthetic training samples</td></tr></tbody></table><p>LLM output evaluation is an important step in developing generative AI applications, but it is expensive and takes considerable time if done manually. An alternative solution to systematically evaluate output quality in large volume is the LLM-as-a-judge approach, where an LLM is used to evaluate another LLM‚Äôs responses.</p><p>For our use case, we used Anthropic‚Äôs Claude 3 Sonnet and Meta Llama 3 70B as the judges. We asked the LLM judges to compare outputs from two different models and choose one over the other or state a tie. The following chart summarizes the judges‚Äô decisions. Each number represents the percentage of times when the respective model was selected as providing a better answer, excluding tie cases. The test set contained 343 samples.</p><p>As shown in the preceding chart, the Anthropic‚Äôs Claude 3 Sonnet judge preferred the response from the fine-tuned model with synthetic examples over the Anthropic‚Äôs Claude Instant base model (84.8% preference) and the fine-tuned model with original 500 samples (72.3% preference). However, the judge concluded that the fine-tuned model with 2,000 original examples was preferred over the fine-tuned model with synthetic examples (32.3% preference). This aligns with the expectation that when large, high-quality original data is available, it‚Äôs better to use the large training data that accurately reflects the target data distribution.</p><p>The Meta Llama judge reached a similar conclusion. As shown in the preceding chart, it preferred the response from the fine-tuned model with synthetic samples over the Anthropic‚Äôs Claude Instant base model (75.6% preference) and the fine-tuned model with original 500 examples (76.4% preference), but the fine-tuned model with 2,000 original examples was the ultimate winner.</p><p>To complement the LLM-as-a-judge result, we conducted manual evaluation with two human judges. We asked the two human evaluators to perform the same pairwise comparison task as the LLM judge, but for 20 examples. The following chart summarizes the results.</p><p>As shown in the preceding chart, the two human evaluators reached a similar conclusion, reinforcing the LLM-as-a-judge result. The fine-tuned model with synthetic examples produced outputs that were more preferable than the Anthropic‚Äôs Claude Instant base model and the fine-tuned model with the original 500 examples; however, it didn‚Äôt outperform the fine-tuned model with the 2,000 original examples.</p><p>These comparative evaluation results from both the LLM judges and human judges strongly demonstrate the power and potential of using data synthesis when training data is scarce. Moreover, by using high-quality data from the teacher model, we can effectively train the student model, which is lightweight and cost-effective for deployment in a production environment.</p><h3>Amazon Bedrock evaluations</h3><p>Running LLM-as-a-judge and human evaluation has become much easier with Amazon Bedrock. Model evaluation on Amazon Bedrock allows you to evaluate, compare, and select the best FMs for your use case. Human evaluation workflows can use your own employees or an AWS-managed team as reviewers. For more information on how to set up a human evaluation workflow, see <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/model-evaluation-type-human.html\" target=\"_blank\" rel=\"noopener\">Creating your first model evaluation that uses human workers</a>. The latest feature, LLM-as-a-judge, is now in preview and allows you to assess multiple quality dimensions including correctness, helpfulness, and responsible AI criteria such as answer refusal and harmfulness. For step-by-step instructions, see <a href=\"https://aws.amazon.com/blogs/aws/new-rag-evaluation-and-llm-as-a-judge-capabilities-in-amazon-bedrock/\" target=\"_blank\" rel=\"noopener\">New RAG evaluation and LLM-as-a-judge capabilities in Amazon Bedrock</a>.</p><p>Make sure to delete the following resources to avoid incurring cost:</p><ul><li>Provisioned throughput for the custom model</li><li>The training_bucket and output_bucket S3 buckets</li></ul><p>In this post, we explored how to use Amazon Bedrock to generate synthetic training data using a large teacher language model and fine-tune a smaller student model with synthetic data. We provided instructions on generating synthetic data using the Amazon Bedrock InvokeModel API and fine-tuning the student model using an Amazon Bedrock custom model. Our evaluation results, based on both an LLM-as-a-judge approach and human evaluation, demonstrated the effectiveness of synthetic data in improving the student model‚Äôs performance when original training data is limited.</p><p>Although fine-tuning with a large amount of high-quality original data remains the ideal approach, our findings highlight the promising potential of synthetic data generation as a viable solution when dealing with data scarcity. This technique can enable more efficient and cost-effective model customization for domain-specific or specialized use cases.</p><p>If you‚Äôre interested in working with the AWS Generative AI Innovation Center and learning more about LLM customization and other generative AI use cases, visit <a href=\"https://aws.amazon.com/ai/generative-ai/innovation-center/\" target=\"_blank\" rel=\"noopener\">Generative AI Innovation Center</a>.</p><p> is a Deep Learning Architect at the AWS Generative AI Innovation Center, where she specializes in model customization and optimization. She has extensive hands-on experience in solving customers‚Äô business use cases by utilizing generative AI as well as traditional AI/ML solutions. Sujeong holds a M.S. degree in Data Science from New York University.</p><p><strong><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/01/31/Arijit-Intro-2.jpg\" alt=\"\" width=\"100\" height=\"116\">Arijit Ghosh Chowdhury</strong> is a Scientist with the AWS Generative AI Innovation Center, where he works on model customization and optimization. In his role, he works on applied research in fine-tuning and model evaluations to enable GenAI for various industries. He has a Master‚Äôs degree in Computer Science from the University of Illinois at Urbana Champaign, where his research focused on question answering, search and domain adaptation.</p><p> is a Senior Applied Scientist at Amazon Generative AI Innovation Center where he helps expedite the variety of use cases of AWS customers. Before joining Amazon, Sungmin was a postdoctoral research fellow at Harvard Medical School. He holds Ph.D. in Computer Science from New York University. Outside of work, Sungmin enjoys hiking, reading and cooking.</p><p> is an Applied Scientist II at the AWS Generative AI Innovation Center, where she develops generative AI solutions for AWS customers. Her expertise encompasses designing and implementing innovative AI-driven and deep learning techniques, focusing on natural language processing, computer vision, multi-modal learning, and graph learning. Yiyue holds a Ph.D. in Computer Science from the University of Notre Dame, where her research centered on advanced machine learning and deep learning methodologies. Outside of work, she enjoys sports, hiking, and traveling.</p><p> is a Machine Learning Engineer at the AWS Generative AI Innovation Center, where he works on model customization and optimization for LLMs. He also builds tools to help his team tackle various aspects of the LLM development life cycle‚Äîincluding fine-tuning, benchmarking, and load-testing‚Äîthat accelerating the adoption of diverse use cases for AWS customers. He holds an M.S. degree in Computer Science from UC Davis.</p><p> is a Senior Manager of Model Customization at the AWS Generative AI Innovation Center. Her team specializes in helping customers develop differentiating Generative AI solutions using their unique and proprietary data to achieve key business outcomes. She holds a Ph.D in Physics from the University of Iowa, with a focus on astronomical X-ray analysis and instrumentation development. Outside of work, she can be found hiking, mountain biking, and skiing around the mountains in Colorado.</p>","contentLength":28436,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Achieve ~2x speed-up in LLM inference with Medusa-1 on Amazon SageMaker AI","url":"https://aws.amazon.com/blogs/machine-learning/achieve-2x-speed-up-in-llm-inference-with-medusa-1-on-amazon-sagemaker-ai/","date":1739382093,"author":"Daniel Zagyva","guid":233,"unread":true,"content":"<p><em>This blog post is co-written with Moran Beladev, Manos Stergiadis, and Ilya Gusev from Booking.com.</em></p><p><a href=\"https://aws.amazon.com/what-is/large-language-model/\" target=\"_blank\" rel=\"noopener\">Large language models</a> (LLMs) have revolutionized the field of natural language processing with their ability to understand and generate humanlike text. Trained on broad, generic datasets spanning a wide range of topics and domains, LLMs use their parametric knowledge to perform increasingly complex and versatile tasks across multiple business use cases. Furthermore, companies are increasingly investing resources in customizing LLMs through few-shot learning and fine-tuning to optimize their performance for specialized applications.</p><p>However, the impressive performance of LLMs comes at the cost of significant computational requirements, driven by their large number of parameters and autoregressive decoding process which is sequential in nature. This combination makes achieving low latency a challenge for use cases such as real-time text completion, simultaneous translation, or conversational voice assistants, where subsecond response times are critical.</p><p>Researchers developed <a href=\"https://arxiv.org/abs/2401.10774\" target=\"_blank\" rel=\"noopener\">Medusa</a>, a framework to speed up LLM inference by adding extra heads to predict multiple tokens simultaneously. This post demonstrates how to use Medusa-1, the first version of the framework, to speed up an LLM by fine-tuning it on <a href=\"https://aws.amazon.com/sagemaker-ai/\" target=\"_blank\" rel=\"noopener\">Amazon SageMaker AI</a> and confirms the speed up with deployment and a simple load test. Medusa-1 achieves an inference speedup of around two times without sacrificing model quality, with the exact improvement varying based on model size and data used. In this post, we demonstrate its effectiveness with a 1.8 times speedup observed on a sample dataset.</p><h2>Introduction to Medusa and its benefits for LLM inference speed</h2><p>LLMs generate text in a sequential manner, which involves autoregressive sampling, with each new token conditional on the previous ones. Generating K tokens necessitates K sequential executions of the model. This token-by-token processing introduces an inherent latency and computational overhead because the model needs to perform a separate forward pass for each new token in the output sequence. The following diagram from <a href=\"https://www.researchgate.net/publication/371123751_Role-Play_with_Large_Language_Models\" target=\"_blank\" rel=\"noopener\">Role-Play with Large Language Models</a> illustrates this flow.</p><p>Speculative decoding tackles this challenge by using a smaller, faster draft model to generate multiple potential token continuations in parallel, which are then verified by a larger, more accurate target model. This parallelization speeds up text generation while maintaining the quality of the target model because the verification task is faster than autoregressive token generation. For a detailed explanation of the concept, refer to the paper <a href=\"https://arxiv.org/abs/2302.01318\" target=\"_blank\" rel=\"noopener\">Accelerating Large Language Model Decoding with Speculative Sampling</a>. The speculative decoding technique can be implemented using the <a href=\"https://aws.amazon.com/blogs/machine-learning/achieve-up-to-2x-higher-throughput-while-reducing-costs-by-50-for-generative-ai-inference-on-amazon-sagemaker-with-the-new-inference-optimization-toolkit-part-1/\" target=\"_blank\" rel=\"noopener\">inference optimization toolkit</a> on <a href=\"https://aws.amazon.com/sagemaker-ai/jumpstart/\" target=\"_blank\" rel=\"noopener\">Amazon SageMaker Jumpstart</a>.</p><p>The paper <a href=\"https://arxiv.org/abs/2401.10774\" target=\"_blank\" rel=\"noopener\">Medusa: Simple LLM Inference Acceleration Framework with Multiple Decoding Heads</a> introduced Medusa as an alternative to speculative decoding. Instead of adding a separate draft model, it adds extra decoding heads to the LLM that generate candidate continuations simultaneously. These candidates are then evaluated in parallel using a tree-based attention mechanism. This parallel processing reduces the number of sequential steps needed, leading to faster inference times. The main advantage of Medusa over speculative decoding is that it eliminates the need to acquire and maintain a separate draft model while achieving higher speedups. For example, when tested on the <a href=\"https://arxiv.org/abs/2402.14762\" target=\"_blank\" rel=\"noopener\">MT-Bench dataset</a>, the paper reports that Medusa-2 (the second version of Medusa) speeds up inference time by 2.8 times. This outperforms speculative decoding, which only manages to speed up inference time by 1.5 times on the same dataset.</p><p>The Medusa framework currently supports Llama and Mistral models. Although it offers significant speed improvements, it does come with a memory trade-off (similar to speculative decoding). For instance, adding five Medusa heads to the 7-billion-parameter Mistral model increases the total parameter count by 750 million (150 million per head), which means these additional parameters must be stored in GPU memory, leading to a higher memory requirement. However, in most cases, this increase doesn‚Äôt necessitate switching to a higher GPU memory instance. For example, you can still use an  instance with 24 GB of GPU memory to host your 7-billion-parameter Llama or Mistral model with extra Medusa heads.</p><p>Training Medusa heads requires additional development time and computational resources, which should be factored into project planning and resource allocation. Another important limitation to mention is that the current framework, when deployed on an Amazon SageMaker AI endpoint, only supports a batch size of one‚Äîa configuration typically used for low-latency applications.</p><p>The following diagram from the original Medusa paper authors‚Äô <a href=\"https://github.com/FasterDecoding/Medusa\" target=\"_blank\" rel=\"noopener\">FasterDecoding repository</a> gives a visual Medusa framework overview.</p><p>There are two main variants of Medusa:</p><ol><li> ‚Äì Requires a two-stage approach where you first fine-tune your LLM and then add Medusa heads and train them on top of your frozen fine-tuned LLM</li><li> ‚Äì Introduced later as an improvement, fine-tunes both the additional heads and the backbone LLM parameters together, enabling potentially even further latency speedups</li></ol><p>The Medusa paper reports that across models of varying sizes, you can achieve inference speedups of around two times for Medusa-1 and around three times for Medusa-2. With Medusa-1, the predictions are identical to those of the originally fine-tuned LLM. In contrast, with Medusa-2, we might observe slightly different results compared to simple fine-tuning of the LLM because both the heads and the backbone LLM parameters are updated together. In this post, we focus on Medusa-1.</p><p>We cover the following steps in our solution:</p><ul><li>Load and prepare the dataset</li><li>Fine-tune an LLM using a SageMaker AI training job</li><li>Train Medusa heads on top of a frozen fine-tuned LLM using a SageMaker AI training job</li><li>Deploy the fine-tuned LLM with Medusa heads on a SageMaker AI endpoint</li><li>Demonstrate LLM inference speedup</li></ul><p>By following this solution, you can accelerate LLM inference in your applications, leading to faster response times and improved user experience.</p><p>To build the solution yourself, there are the following prerequisites:</p><h3>Load and prepare the dataset</h3><p>Now that you have cloned the <a href=\"https://github.com/aws-samples/speedup-llm-inference-with-medusa-framework-on-amazon-sagemaker\">GitHub repository</a> and opened the  notebook, you will load and prepare the dataset in the notebook. We encourage you to read this post while running the code in the notebook. For this post, we use a dataset called <a href=\"https://huggingface.co/datasets/b-mc2/sql-create-context\" target=\"_blank\" rel=\"noopener\">sql-create-context</a>, which contains samples of natural language instructions, schema definitions and the corresponding SQL query. It contains 78,577 examples of natural language queries, SQL CREATE TABLE statements, and SQL queries answering the question using the CREATE statement as context. For demonstration purposes, we select 3,000 samples and split them into train, validation, and test sets.</p><p>You need to run the ‚ÄúLoad and prepare the dataset‚Äù section of the  to prepare the dataset for fine-tuning. We also included a data exploration script to analyze the length of input and output tokens. After data exploration, we prepare the train, validation, and test sets and upload them to <a href=\"https://aws.amazon.com/s3/\" target=\"_blank\" rel=\"noopener\">Amazon Simple Storage Service</a> (Amazon S3).</p><h3>Fine-tune an LLM using SageMaker AI training job</h3><p>We use the <a href=\"https://huggingface.co/HuggingFaceH4/zephyr-7b-beta\" target=\"_blank\" rel=\"noopener\">Zephyr 7B Œ≤</a> model as our backbone LLM. Zephyr is a series of language models trained to act as helpful assistants, and Zephyr 7B Œ≤ is a fine-tuned version of <a href=\"https://huggingface.co/mistralai/Mistral-7B-v0.1\" target=\"_blank\" rel=\"noopener\">Mistral-7B-v0.1</a>, trained on a mix of publicly available and synthetic datasets using <a href=\"https://arxiv.org/abs/2305.18290\" target=\"_blank\" rel=\"noopener\">Direct Preference Optimization</a>.</p><p>To launch a SageMaker AI training job, we need to use the PyTorch or Hugging Face estimator. SageMaker AI starts and manages all the necessary <a href=\"https://aws.amazon.com/ec2/\" target=\"_blank\" rel=\"noopener\">Amazon Elastic Compute Cloud</a> (Amazon EC2) instances for us, supplies the appropriate containers, downloads data from our S3 bucket to the container and uploads and runs the specified training script, in our case . We select the hyperparameters based on the <a href=\"https://arxiv.org/pdf/2305.14314\" target=\"_blank\" rel=\"noopener\">QLoRA paper</a>, but we encourage you to experiment with your own combinations. To expedite the execution of this code, we set the number of epochs to 1. However, for better results, it‚Äôs generally recommended to set the number of epochs to at least 2 or 3.</p><div><pre><code>from sagemaker.pytorch.estimator import PyTorch\nfrom sagemaker.debugger import TensorBoardOutputConfig\nimport time\nimport os\n\ndef get_current_time():\n    return time.strftime(\"%Y-%m-%d-%H-%M-%S\", time.localtime())\n\ndef create_estimator(hyperparameters_dict, job_name, role, sess, train_scipt_path):\n    metric=[\n        {\"Name\": \"loss\", \"Regex\": r\"'loss':\\s*([0-9.]+)\"},\n        {\"Name\": \"epoch\", \"Regex\": r\"'epoch':\\s*([0-9.]+)\"},\n    ]\n\n    tensorboard_s3_output_path = os.path.join(\n       \"s3://\", sess.default_bucket(), job_name, 'tensorboard'\n    )\n    print(\"Tensorboard output path:\", tensorboard_s3_output_path)\n\n    tensorboard_output_config = TensorBoardOutputConfig(\n        s3_output_path=tensorboard_s3_output_path,\n        container_local_output_path=hyperparameters_dict['logging_dir']\n    )\n    estimator = PyTorch(\n        sagemaker_session    = sess,\n        entry_point          = train_scipt_path,    # train script\n        source_dir           = 'train',      # directory which includes all the files needed for training\n        instance_type        = 'ml.g5.4xlarge',   # instances type used for the training job, \"local_gpu\" for local mode\n        metric_definitions   = metric,\n        instance_count       = 1,                 # the number of instances used for training\n        role                 = role,              # Iam role used in training job to access AWS ressources, e.g. S3\n        volume_size          = 300,               # the size of the EBS volume in GB\n        framework_version      = '2.1.0',             # the pytorch_version version used in the training job\n        py_version           = 'py310',           # the python version used in the training job\n        hyperparameters      =  hyperparameters_dict,  # the hyperparameters passed to the training job\n        disable_output_compression = True,        # not compress output to save training time and cost\n        tensorboard_output_config = tensorboard_output_config\n    )\n    return estimator\n    \n# hyperparameters, which are passed into the training job\nsft_hyperparameters = {\n  ### SCRIPT PARAMETERS ###\n  'train_dataset_path': '/opt/ml/input/data/train/train_dataset.json', # path where sagemaker will save training dataset\n  'eval_dataset_path': '/opt/ml/input/data/eval/eval_dataset.json', # path where sagemaker will save evaluation dataset\n  'model_id': model_id,\n  'max_seq_len': 256,                               # max sequence length for model and packing of the dataset\n  'use_qlora': True,                                 # use QLoRA model\n  ### TRAINING PARAMETERS ###\n  'num_train_epochs': 1,                             # number of training epochs\n  'per_device_train_batch_size': 1,                  # batch size per device during training\n  'gradient_accumulation_steps': 16,                  # number of steps before performing a backward/update pass\n  'gradient_checkpointing': True,                    # use gradient checkpointing to save memory\n  'optim': \"adamw_8bit\",                             # use fused adamw 8bit optimizer\n  'logging_steps': 15,                               # log every 10 steps\n  'save_strategy': \"steps\",                          # save checkpoint every epoch\n  'save_steps': 15,\n  'save_total_limit': 2,\n  'eval_strategy': \"steps\",\n  'eval_steps': 15,\n  'learning_rate': 1e-4,                             # learning rate, based on QLoRA paper\n  'bf16': True,                                      # use bfloat16 precision\n  'max_grad_norm': 10,                              # max gradient norm based on QLoRA paper\n  'warmup_ratio': 0.03,                              # warmup ratio based on QLoRA paper\n  'lr_scheduler_type': \"constant\",                   # use constant learning rate scheduler\n  'output_dir': '/opt/ml/checkpoints/',              # Temporary output directory for model checkpoints\n  'merge_adapters': True,                            # merge LoRA adapters into model for easier deployment\n  'report_to': \"tensorboard\",                        # report metrics to tensorboard\n  'logging_dir': \"/opt/ml/output/tensorboard\"        # tensorboard logging directory\n}\n \nsft_job_name = f\"sft-qlora-text-to-sql-{get_current_time()}\"\ndata = {\n    'train': train_dataset_path,\n    'eval': eval_dataset_path\n}\n\nsft_estimator = create_estimator(sft_hyperparameters, sft_job_name, role, sess, \"fine_tune_llm.py\")\n\nsft_estimator.fit(job_name=sft_job_name, inputs=data, wait=False)</code></pre></div><p>When our training job has completed successfully after approximately 1 hour, we can use the fine-tuned model artifact for the next step, training the Medusa heads on top of it. To visualize the training metrics in Tensorboard, you can follow the guidance in this documentation: <a href=\"https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-htb-access-tb-data.html\" target=\"_blank\" rel=\"noopener\">Load and visualize output tensors using the TensorBoard application</a></p><h3>Train Medusa heads on top of frozen fine-tuned LLM using a SageMaker AI training job</h3><p>For training Medusa heads, we can reuse the functions previously mentioned to launch the training job. We selected hyperparameters based on a combination of what the Medusa paper reported and what we found to be best performing after a few experiments. We set the number of Medusa heads to 5 and used the 8-bit AdamW optimizer, as recommended by the paper. For simplicity, we maintained a constant learning rate of 1e-4 with a constant scheduler, similar to the previous fine-tuning step. Although the paper recommends an increased learning rate and a cosine scheduler, we found that our chosen combination of hyperparameters performed well on this dataset. However, we encourage you to experiment with your own hyperparameter settings to potentially achieve even better results.</p><div><pre><code># hyperparameters, which are passed into the training job\nmedusa_hyperparameters = {\n  ### SCRIPT PARAMETERS ###\n  'train_dataset_path': '/opt/ml/input/data/train/train_dataset.json', # path where sagemaker will save training dataset\n  'eval_dataset_path': '/opt/ml/input/data/eval/eval_dataset.json', # path where sagemaker will save evaluation dataset\n  'model_path': '/opt/ml/input/data/fine-tuned-model/',\n  'max_seq_len': 256,                               # max sequence length for model and packing of the dataset\n  'medusa_num_heads': 5,\n  ### TRAINING PARAMETERS ###\n  'num_train_epochs': 3,                             # number of training epochs\n  'per_device_train_batch_size': 1,                  # batch size per device during training\n  'gradient_accumulation_steps': 16,                  # number of steps before performing a backward/update pass\n  'gradient_checkpointing': True,                    # use gradient checkpointing to save memory\n  'optim': \"adamw_8bit\",                             # use fused adamw 8bit optimizer\n  'logging_steps': 15,                               # log every 10 steps\n  'save_strategy': \"steps\",                          # save checkpoint every epoch\n  'save_steps': 15,\n  'save_total_limit':2,\n  'eval_strategy': \"steps\",\n  'eval_steps': 15,\n  'learning_rate': 1e-4,                             # learning rate\n  'bf16': True,                                      # use bfloat16 precision\n  'max_grad_norm': 10,                              # max gradient norm based on QLoRA paper\n  'warmup_ratio': 0.03,                              # warmup ratio based on QLoRA paper\n  'lr_scheduler_type': \"constant\",                   # use constant learning rate scheduler\n  'output_dir': '/opt/ml/checkpoints/',              # Temporary output directory for model checkpoints\n  'report_to': \"tensorboard\",                        # report metrics to tensorboard\n  'logging_dir': \"/opt/ml/output/tensorboard\"        # tensorboard logging directory\n}\n\nmedusa_train_job_name = f\"medusa-text-to-sql-{get_current_time()}\"\ndata = {\n    'train': train_dataset_path,\n    'eval': eval_dataset_path,\n    'fine-tuned-model': fine_tuned_model_path\n}\n\nmedusa_estimator = create_estimator(medusa_hyperparameters, medusa_train_job_name, role, sess, \"train_medusa_heads.py\")\n\nmedusa_estimator.fit(job_name=medusa_train_job_name, inputs=data, wait=False)</code></pre></div><p>We found that after 3 epochs, the evaluation loss of Medusa heads was converging, which can be observed in the TensorBoard graph in the following image.</p><p>Besides the hyperparameters, the main difference is that we pass  as the training entrypoint, where we first add Medusa heads, then freeze the fine-tuned LLM, and we create custom MedusaSFTTrainer class, which is a subclass of the transformers SFTTrainer.</p><div><pre><code># Add medusa heads and freeze base model\nadd_medusa_heads(\n    model,\n    medusa_num_heads=script_args.medusa_num_heads,\n)\nfreeze_layers(model)\nmodel.config.torch_dtype = torch_dtype\nmodel.config.use_cache = False\n\nlogger.info(\"Finished loading model and medusa heads\")\n\ntokenizer = AutoTokenizer.from_pretrained(script_args.model_path, use_fast=True)\ntokenizer.pad_token = tokenizer.eos_token\n\n################\n# Training\n################\ntrainer = MedusaSFTTrainer(\n    model=model,\n    args=training_args,\n    train_dataset=train_dataset,\n    eval_dataset=eval_dataset,\n    max_seq_length=script_args.max_seq_length,\n    tokenizer=tokenizer,\n    dataset_kwargs={\n        \"add_special_tokens\": False,  # We template with special tokens\n        \"append_concat_token\": False,  # No need to add additional separator token\n    },\n    medusa_num_heads=script_args.medusa_num_heads,\n    medusa_heads_coefficient=script_args.medusa_heads_coefficient,\n    medusa_decay_coefficient=script_args.medusa_decay_coefficient,\n    medusa_scheduler=script_args.medusa_scheduler,\n    train_only_medusa_heads=script_args.train_only_medusa_heads,\n    medusa_lr_multiplier=script_args.medusa_lr_multiplier\n)\ntrainer.train()</code></pre></div><p>In the  function, we add the residual blocks of the Medusa heads, and also override the forward pass for our model to make sure not to train the frozen backbone LLM:</p><div><pre><code>def add_medusa_heads(\n    model,\n    medusa_num_heads,\n):\n    \"\"\"\n    Args:\n        model (nn.Module): The base language model to be used.\n        medusa_num_heads (int, optional): Number of additional tokens to predict\n    \"\"\"\n    hidden_size = model.lm_head.weight.shape[-1]\n    vocab_size = model.lm_head.weight.shape[0]\n    model.config.medusa_num_layers = 1\n    model.config.medusa_num_heads = medusa_num_heads\n    model.medusa_num_heads = medusa_num_heads\n    # Create a list of Medusa heads\n    model.medusa_heads = nn.ModuleList(\n        [\n            nn.Sequential(\n                ResBlock(hidden_size),\n                nn.Linear(hidden_size, vocab_size, bias=False),\n            )\n            for _ in range(medusa_num_heads)\n        ]\n    )\n\n    # Ensure medusa_head's dtype and device align with the base_model\n    model.medusa_heads.to(model.dtype).to(model.device)\n    logger.info(f\"Loading medusa heads in {str(model.dtype)} to device {model.device}\")\n\n    for i in range(medusa_num_heads):\n        # Initialize the weights of each medusa_head using the base model's weights\n        model.medusa_heads[i][-1].weight.data[:] = model.lm_head.weight.data[:]\n\n    def forward(\n        self,\n        input_ids: torch.LongTensor = None,\n        attention_mask: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        past_key_values: Optional[List[torch.FloatTensor]] = None,\n        inputs_embeds: Optional[torch.FloatTensor] = None,\n        labels: Optional[torch.LongTensor] = None,\n        use_cache: Optional[bool] = None,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        return_dict: Optional[bool] = None,\n        train_only_medusa_heads: bool = False,\n    ):\n        \"\"\"Forward pass of the MedusaModel.\n        Returns:\n            torch.Tensor: A tensor containing predictions from all Medusa heads.\n            (Optional) Original predictions from the base model's LM head.\n        \"\"\"\n        maybe_grad = torch.no_grad() if train_only_medusa_heads else nullcontext()\n        with maybe_grad:\n            outputs = self.model(\n                input_ids=input_ids,\n                attention_mask=attention_mask,\n                position_ids=position_ids,\n                past_key_values=past_key_values,\n                inputs_embeds=inputs_embeds,\n                use_cache=use_cache,\n                output_attentions=output_attentions,\n                output_hidden_states=output_hidden_states,\n                return_dict=return_dict,\n            )\n            hidden_states = outputs[0]\n            medusa_logits = [self.lm_head(hidden_states)]\n        for i in range(self.medusa_num_heads):\n            medusa_logits.append(self.medusa_heads[i](hidden_states))\n        return torch.stack(medusa_logits, dim=0)\n\n    model.forward = types.MethodType(forward, model)</code></pre></div><p>After the model training is finished (which takes 1 hour), we prepare the model artefacts for deployment and upload it to Amazon S3. Your final model artifact contains both the original fine-tuned model from the previous step under the  prefix and the trained Medusa heads in a file named .</p><h3>Deploy the fine-tuned LLM with Medusa heads on a SageMaker AI endpoint</h3><p>First, we create a SageMaker AI HuggingFaceModel object and then deploy the model to an endpoint with the following function:</p><div><pre><code>import json\nfrom sagemaker.huggingface import HuggingFaceModel, get_huggingface_llm_image_uri\n\n\ndef deploy_model(endpoint_name, instance_type, model_s3_path=None, hf_model_id=None):\n    llm_image = get_huggingface_llm_image_uri(\n      \"huggingface\",\n      version=\"2.2.0\",\n      session=sess,\n    )\n\n    print(f\"llm image uri: {llm_image}\")\n\n    model_data = None\n    if model_s3_path:\n        model_data = {'S3DataSource': {'S3Uri': model_s3_path, 'S3DataType': 'S3Prefix', 'CompressionType': 'None'}}\n        hf_model_id = \"/opt/ml/model\"\n    else:\n        assert hf_model_id, \"You need to provide either pretrained HF model id, or S3 model data to deploy\"\n    config = {\n      'HF_MODEL_ID': hf_model_id,  # path to where sagemaker stores the model\n      'SM_NUM_GPUS': json.dumps(1),  # Number of GPU used per replica\n      'MAX_INPUT_LENGTH': json.dumps(1024),  # Max length of input text\n      'MAX_TOTAL_TOKENS': json.dumps(2048),  # Max length of the generation (including input text)\n    }\n\n    llm_model = HuggingFaceModel(\n      name=endpoint_name,\n      role=role,\n      image_uri=llm_image,\n      model_data=model_data,\n      env=config\n    )\n\n    deployed_llm = llm_model.deploy(\n      endpoint_name=endpoint_name,\n      initial_instance_count=1,\n      instance_type=instance_type,\n      container_startup_health_check_timeout=300,\n    )\n    return deployed_llm</code></pre></div><p>We deploy three LLMs on three SageMaker AI endpoints:</p><ol><li>Base LLM which isn‚Äôt fine-tuned</li><li>The LLM that we fine-tuned</li><li>The fine-tuned LLM that also has trained Medusa heads</li></ol><p>You can deploy the three models in parallel by using a function that we included in the notebook, or you can deploy the models one by one by running the code below:</p><div><pre><code>base_deployed_llm = deploy_model( f\"base-{get_current_time()}\", instance_type=\"ml.g5.4xlarge\", model_s3_path=None, hf_model_id=model_id )\nsft_deployed_llm = deploy_model( f\"sft-{get_current_time()}\", instance_type=\"ml.g5.4xlarge\", model_s3_path=fine_tuned_model_path )\nmedusa_deployed_llm = deploy_model( f\"medusa-{get_current_time()}\", instance_type=\"ml.g5.4xlarge\", model_s3_path=medusa_trained_model_path )\n</code></pre></div><p>After the status for each endpoint becomes , which should take around 15 minutes, we can invoke them for inference. We send the following input:</p><div><pre><code>‚ÄúYou are a text to SQL query translator. Users will ask you questions in English and you will generate a SQL query based on the provided SCHEMA. SCHEMA: CREATE TABLE table_name_32 (time VARCHAR, heat VARCHAR, name VARCHAR)\nWhat was Liu Limin's time in heat 4?‚Äú</code></pre></div><p>We can observe the following responses:</p><ol><li>The base LLM response contains extra words that aren‚Äôt needed:</li></ol><div><pre><code>‚ÄúTo retrieve the time of Liu Limin in heat 4 based on the provided SCHEMA, we need to write a SQL query. Since the table name is not provided, let 's assume it's \"my_table\".  Assuming the table has a primary key (which is not mentioned in the SCHEMA), we can join the table with itself to compare the heat and name of Liu Limin in heat 4 with all the records in the table.  Here's the SQL query:  ``sql SELECT t1.time FROM my_table t1 JOIN my_table t2 ON t1.name = t2.name AND t2.heat = 4 WHERE t1.name = 'Liu Limin' AND t1.heat &lt;&gt; 4; `  Explanation:  1. We're selecting the time` column from the first table (t1) in the FROM clause. 2. We're joining the table with itself (my_table t1 JOIN my_table t2) to compare the name and heat of Liu Limin in heat 4 with all the records in the table. 3. We're filtering the results using the WHERE clause. We're selecting only the records where the name is 'Liu Limin' and the heat is not equal to 4 (i.e., not heat 4). This is to ensure that we're selecting the time of Liu Limin in heat 3.  Note: This query assumes that the table has a unique primary key. If the table doesn't have a primary key, you may need to add additional conditions to the JOIN and WHERE clauses to ensure that we're selecting the correct records.‚Äú</code></pre></div><ol start=\"2\"><li>The fine-tuned LLM response is improved significantly, and contains only the required output:</li></ol><div><pre><code>'SELECT time FROM table_name_32 WHERE heat = 4 AND name = \"liu limin\"'</code></pre></div><ol start=\"3\"><li>The fine-tuned LLM with trained Medusa heads provides the exact same response as the fine-tuned model, demonstrating that Medusa-1, by design, maintains the output (quality) of the original model:</li></ol><div><pre><code>'SELECT time FROM table_name_32 WHERE heat = 4 AND name = \"liu limin\"'</code></pre></div><h3>Demonstrate LLM inference speedup</h3><p>To measure the inference speed improvements, we compare the response times of the deployed fine-tuned LLM and the fine-tuned LLM with Medusa heads on 450 test observations with the following code:</p><div><pre><code>import time\nimport numpy as np\nfrom tqdm import tqdm\n\ndef request(sample, deployed_llm):\n    prompt = tokenizer.apply_chat_template(sample, tokenize=False, add_generation_prompt=True)\n    outputs = deployed_llm.predict({\n      \"inputs\": prompt,\n      \"parameters\": {\n        \"max_new_tokens\": 512,\n        \"do_sample\": False,\n        \"return_full_text\": False,\n      }\n    })\n    return {\"role\": \"assistant\", \"content\": outputs[0][\"generated_text\"].strip()}\n\ndef predict(deployed_llm, test_dataset):\n    predicted_answers = []\n    latencies = []\n\n    for sample in tqdm(test_dataset):\n        start_time = time.time()\n        predicted_answer = request(sample[\"messages\"][:2], deployed_llm)\n        end_time = time.time()\n\n        latency = end_time - start_time\n        latencies.append(latency)\n        predicted_answers.append(predicted_answer)\n\n    # Calculate p90 and average latencies\n    p90_latency = np.percentile(latencies, 90)\n    avg_latency = np.mean(latencies)\n\n    print(f\"P90 Latency: {p90_latency:.2f} seconds\")\n    print(f\"Average Latency: {avg_latency:.2f} seconds\")\n\n    return predicted_answers</code></pre></div><p>First, we run predictions using the fine-tuned LLM:</p><div><pre><code>sft_predictions = predict(sft_deployed_llm, test_dataset)\nP90 Latency: 1.28 seconds\nAverage Latency: 0.95 seconds</code></pre></div><p>Then, we run predictions using the fine-tuned LLM with Medusa heads:</p><div><pre><code>medusa_predictions = predict(medusa_deployed_llm, test_dataset)\nP90 Latency: 0.80 seconds\nAverage Latency: 0.53 seconds</code></pre></div><p>The prediction runs should take around 8 and 4 minutes respectively. We can observe that the average latency decreased from 950 to 530 milliseconds, which is an improvement of 1.8 times. You can achieve even higher improvements if your dataset contains longer inputs and outputs. In our dataset, we only had an average of 18 input tokens and 30 output tokens.</p><p>We want to once again highlight that, with this technique, the output quality is fully maintained, and all the prediction outputs are the same. The model responses for the test set of 450 observations are the same for both with Medusa heads and without Medusa heads:</p><div><pre><code>match_percentage = sum(a[\"content\"] == b[\"content\"] for a, b in zip(sft_predictions, medusa_predictions)) / len(sft_predictions) * 100\nprint(f\"Predictions with the fine-tuned model with medusa heads are the same as without medusa heads: {match_percentage:.2f}% of test set \")\n\nPredictions with fine-tuned model with medusa heads are the same as without medusa heads: 100.00% of test set </code></pre></div><p>You might notice in your run that a few observations aren‚Äôt exactly matching, and you might get a 99% match due to small errors in floating point operations caused by optimizations on GPUs.</p><p>At the end of this experiment, don‚Äôt forget to delete the SageMaker AI endpoints you created:</p><div><pre><code>base_deployed_llm.delete_model()\nbase_deployed_llm.delete_endpoint()\nsft_deployed_llm.delete_model()\nsft_deployed_llm.delete_endpoint()\nmedusa_deployed_llm.delete_model()\nmedusa_deployed_llm.delete_endpoint()</code></pre></div><p>In this post, we demonstrated how to fine-tune and deploy an LLM with Medusa heads using the Medusa-1 technique on Amazon SageMaker AI to accelerate LLM inference. By using this framework and SageMaker AI scalable infrastructure, we showed how to achieve up to twofold speedups in LLM inference while maintaining model quality. This solution is particularly beneficial for applications requiring low-latency text generation, such as customer service chat assistants, content creation, and recommendation systems.</p><p>As a next step, you can explore fine-tuning your own LLM with Medusa heads on your own dataset and benchmark the results for your specific use case, using the provided <a href=\"https://github.com/aws-samples/speedup-llm-inference-with-medusa-framework-on-amazon-sagemaker\" target=\"_blank\" rel=\"noopener\">GitHub repository</a>.</p><p><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/02/05/ml_17442_dzagyva.jpg\" alt=\"\" width=\"100\" height=\"133\"> is a Senior ML Engineer at AWS Professional Services. He specializes in developing scalable, production-grade machine learning solutions for AWS customers. His experience extends across different areas, including natural language processing, generative AI and machine learning operations.</p><p><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/02/05/ml_17442_adokic.jpg\" alt=\"\" width=\"100\" height=\"129\"> is a Senior Data Scientist at AWS Professional Services. She enjoys supporting customers to build innovative AI/ML solutions on AWS and she is excited about business transformations through the power of data.</p><p><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/02/05/ml_17442_mbeladev.png\" alt=\"\" width=\"100\" height=\"100\"> is a Senior ML Manager at Booking.com. She is leading the content intelligence track which is focused on building, training and deploying content models (computer vision, NLP and generative AI) using the most advanced technologies and models. Moran is also a PhD candidate, researching applying NLP models on social graphs.</p><p><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/02/05/ml_17442_mstergiadis.jpg\" alt=\"\" width=\"100\" height=\"100\"> is a Senior ML Scientist at Booking.com. He specializes in generative NLP and has experience researching, implementing and deploying large deep learning models at scale.</p><p><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/02/05/ml_17442_igusev.jpg\" alt=\"\" width=\"100\" height=\"158\"> is a Senior Machine Learning Engineer at Booking.com. He leads the development of the several LLM systems inside Booking.com. His work focuses on building production ML systems that help millions of travelers plan their trips effectively.</p><p><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/02/05/ml_17442_lvandermaas-727x1024-1.jpg\" alt=\"\" width=\"100\" height=\"141\"> is a Machine Learning Engineer at AWS Professional Services. He works closely with customers building their machine learning solutions on AWS, specializes in natural language processing, experimentation and responsible AI, and is passionate about using machine learning to drive meaningful change in the world.</p>","contentLength":31295,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"LLM-as-a-judge on Amazon Bedrock Model Evaluation","url":"https://aws.amazon.com/blogs/machine-learning/llm-as-a-judge-on-amazon-bedrock-model-evaluation/","date":1739381817,"author":"Adewale Akinfaderin","guid":232,"unread":true,"content":"<p>The evaluation of large language model (LLM) performance, particularly in response to a variety of prompts, is crucial for organizations aiming to harness the full potential of this rapidly evolving technology. The introduction of an  framework represents a significant step forward in simplifying and streamlining the model evaluation process. This approach allows organizations to assess their AI models‚Äô effectiveness using pre-defined metrics, making sure that the technology aligns with their specific needs and objectives. By adopting this method, companies can more accurately gauge the performance of their AI systems, making informed decisions about model selection, optimization, and deployment. This not only enhances the reliability and efficiency of AI applications, but also contributes to a more strategic and informed approach to technology adoption within the organization.</p><p><a href=\"https://aws.amazon.com/bedrock\" target=\"_blank\" rel=\"noopener\">Amazon Bedrock</a>, a fully managed service offering high-performing foundation models from leading AI companies through a single API, has recently introduced two significant evaluation capabilities: <a href=\"https://aws.amazon.com/blogs/aws/new-rag-evaluation-and-llm-as-a-judge-capabilities-in-amazon-bedrock/\" target=\"_blank\" rel=\"noopener\">LLM-as-a-judge under Amazon Bedrock Model Evaluation and RAG evaluation for Amazon Bedrock Knowledge Bases</a>. Both features use the LLM-as-a-judge technique behind the scenes but evaluate different things. This blog post explores LLM-as-a-judge on Amazon Bedrock Model Evaluation, providing comprehensive guidance on feature setup, evaluating job initiation through both the console and Python SDK and APIs, and demonstrating how this innovative evaluation feature can enhance generative AI applications across multiple metric categories including quality, user experience, instruction following, and safety.</p><p>Before we explore the technical aspects and implementation details, let‚Äôs examine the key features that make LLM-as-a-judge on Amazon Bedrock Model Evaluation particularly powerful and distinguish it from traditional evaluation methods. Understanding these core capabilities will help illuminate why this feature represents a significant advancement in AI model evaluation.</p><h2>Key features of LLM-as-a-judge</h2><ol><li><strong>Automated intelligent evaluation</strong>: LLM-as-a-judge uses pre-trained models to evaluate responses automatically, providing human-like evaluation quality with up to 98% cost savings. The system dramatically reduces evaluation time from weeks to hours while maintaining consistent evaluation standards across large datasets.</li><li><strong>Comprehensive metric categories</strong>: The evaluation system covers four key metric areas: quality assessment (correctness, completeness, faithfulness), user experience (helpfulness, coherence, relevance), instruction compliance (following instructions, professional style), and safety monitoring (harmfulness, stereotyping, refusal handling).</li><li>: The feature integrates directly with Amazon Bedrock and remains compatible with existing Amazon Bedrock Model Evaluation features. Users can access the functionality through the AWS Management Console for Amazon Bedrock and quickly integrate their custom datasets for evaluation purposes.</li><li>: The system supports the evaluation of models hosted on Amazon Bedrock, custom fine-tuned models, and imported models. Users can seamlessly connect their evaluation datasets through <a href=\"https://aws.amazon.com/s3\" target=\"_blank\" rel=\"noopener\">Amazon Simple Storage Service (Amazon S3)</a> buckets, making the evaluation process streamlined and efficient.</li><li>: Amazon Bedrock provides pre-selected, high-quality evaluation models with optimized prompt engineering for accurate assessments. Users don‚Äôt need to bring external judge models, because the Amazon Bedrock team maintains and updates a selection of judge models and associated evaluation judge prompts.</li><li>: The feature enables organizations to perform comprehensive model evaluations at scale without the traditional costs and time investments associated with human evaluation. The automated process maintains high-quality assessments while significantly reducing operational overhead.</li></ol><p>These features create a powerful evaluation framework that helps organizations optimize their AI model performance while maintaining high standards of quality and safety, all within their secure AWS environment.</p><p>Now that you understand the key features of LLM-as-a-judge, let‚Äôs examine how to implement and use this capability within Amazon Bedrock Model Evaluation. This section provides a comprehensive overview of the architecture and walks through each component, demonstrating how they work together to deliver accurate and efficient model evaluations.</p><p>LLM-as-a-judge on Amazon Bedrock Model Evaluation provides a comprehensive, end-to-end solution for assessing and optimizing AI model performance. This automated process uses the power of LLMs to evaluate responses across multiple metric categories, offering insights that can significantly improve your AI applications. Let‚Äôs walk through the key components of this solution as shown in the following diagram:</p><p>LLM-as-a-judge on Amazon Bedrock Model Evaluation follows a streamlined workflow that enables systematic model evaluation. Here‚Äôs how each component works together in the evaluation process:</p><ul><li>: The process begins with a prepared dataset containing prompts that will be used to test the model‚Äôs performance. The evaluation can be conducted with or without ground truth responses‚Äîwhile including ground truth provides additional comparison points, it‚Äôs entirely optional and not required for successful evaluation.</li><li>: The prompt dataset is converted into JSONL format, which is specifically structured for LLM-as-a-judge evaluation jobs. This format promotes proper processing of evaluation data.</li><li>: The prepared JSONL file is uploaded to an S3 bucket, serving as the secure storage location for the evaluation data.</li><li>: The Amazon Bedrock LLM-as-a-judge model evaluation job processes the stored data, running comprehensive assessments across the selected metric categories (including quality, user experience, instruction following, and safety).</li><li><strong>Automated report generation</strong>: Upon completion, the system generates detailed evaluation reports containing metrics, scores, and insights at both aggregate and individual response levels.</li><li>: Data scientists or machine learning engineers analyze the generated reports to derive actionable insights and make informed decisions.</li></ul><p>With this solution architecture in mind, let‚Äôs explore how to implement LLM-as-a-judge model evaluations effectively, making sure that you get the most valuable insights from your assessment process.</p><p>To use the LLM-as-a-judge model evaluation, make sure that you have satisfied the following requirements:</p><ul><li>Selected  and  models enabled in Amazon Bedrock. You can confirm that the models are enabled for your account on the  page of the Amazon Bedrock console.</li><li>If you‚Äôre using a custom model instead of an on-demand model for your generator model, make sure that you have sufficient quota for running a <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/prov-throughput.html\" target=\"_blank\" rel=\"noopener\">Provisioned Throughput</a> during inference. \n  <ul><li>Go to the AWS Service Quotas console, and check the following quotas: \n    <ul><li>Model units no-commitment Provisioned Throughputs across custom models.</li><li>Model units per provisioned model for [your custom model name].</li><li>Both of these fields need to have enough quota to support your Provisioned Throughput model unit. Request a quota increase if necessary to accommodate your expected inference workload.</li></ul></li></ul></li></ul><p>When preparing your dataset for LLM-as-a-judge model evaluation jobs, each prompt must include specific key-value pairs. Here are the required and optional fields:</p><ul><li>: This key indicates the input for various tasks. It can be used for general text generation where the model needs to provide a response, question-answering tasks where the model must answer a specific question, text summarization tasks where the model needs to summarize a given text, or classification tasks where the model must categorize the provided text.</li><li><strong>referenceResponse (used for specific metrics with ground truth)</strong>: This key contains the ground truth or correct response. It serves as the reference point against which the model‚Äôs responses will be evaluated if it is provided.</li><li>: This key is used to generate evaluation scores reported by category, helping organize and segment evaluation results for better analysis.</li></ul><ul><li>Each line must be a valid JSON object</li><li>The file must use JSONL format</li><li>The dataset should be stored in an Amazon S3 bucket</li></ul><p>Example JSONL format without ground truth ( is optional):</p><div><pre><code>{\n    \"prompt\": \"What is machine learning?\"\n    \"category\": \"technical\"\n}\n{\n    \"prompt\": \"Summarize climate change impacts\",\n    \"category\": \"environmental\"\n}\n</code></pre></div><p>Example JSONL format with ground truth ( is optional):</p><div><pre><code>{\n    \"prompt\": \"What is machine learning?\",\n    \"referenceResponse\": \"Machine learning is a subset of artificial intelligence that enables systems to learn and improve from experience without being explicitly programmed. It uses algorithms and statistical models to analyze and draw inferences from patterns in data, allowing computers to perform specific tasks without explicit instructions.\",\n    \"category\": \"technical\"\n}\n{\n    \"prompt\": \"Summarize climate change impacts\",\n    \"referenceResponse\": \"Climate change leads to rising global temperatures, extreme weather events, sea level rise, and disruption of ecosystems. These changes result in more frequent natural disasters, threats to food security, loss of biodiversity, and various public health challenges. The impacts affect agriculture, coastal communities, and vulnerable populations disproportionately.\",\n    \"category\": \"environmental\"\n}</code></pre></div><h2>Start an LLM-as-a-judge model evaluation job using the console</h2><p>You can use LLM-as-a-judge on Amazon Bedrock Model Evaluation to assess model performance through a user-friendly console interface. Follow these steps to start an evaluation job:</p><ol><li>In the Amazon Bedrock console, choose and then select . On the page, choose the </li></ol><ol start=\"2\"><li>Choose  and select <strong>Automatic: LLM-as-a-judge</strong>.</li><li>Enter a name and description and select an . This model will be used as a judge to evaluate the response of a prompt or model from your generative AI application.</li></ol><ol start=\"4\"><li>Choose  and select the model to be used for generating responses in this evaluation job.</li></ol><ol start=\"5\"><li>Select the metrics you want to use to evaluate the model response (such as helpfulness, correctness, faithfulness, relevance, and harmfulness).</li></ol><ol start=\"6\"><li>Select the  for  and for . You can use theoption.</li></ol><ol start=\"7\"><li>Select or create an IAM service role with the <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/model-evaluation-type-judge.html\">proper permissions</a>. This includes service access to Amazon Bedrock, the S3 buckets in the evaluation job, and the models being used in the job. If you create a new IAM role in the evaluation setup, the service will automatically give the role the proper permissions for the job. Specify the output S3 bucket and choose .</li></ol><ol start=\"8\"><li>You will be able to see the evaluation job is .&nbsp;Wait for the job status to change to .</li></ol><ol start=\"9\"><li>When complete, select the job to see its details. The following is the metrics summary (such as 0.83 for helpfulness, 1.00 for correctness, 1.00 for faithfulness, 1.00 for relevance, and 0.00 for harmfulness).</li></ol><ol start=\"10\"><li>To view generation metrics details, scroll down in the model evaluation report and choose any individual metric (like helpfulness or correctness) to see its detailed breakdown.</li></ol><ol start=\"11\"><li>To see each record‚Äôs prompt input, generation output, ground truth, and individual scores, choose a metric and select ‚ÄúPrompt details‚Äù. Hover over any individual score to view its detailed explanation.</li></ol><h2>Start an LLM-as-a-judge evaluation job using Python SDK and APIs</h2><p>To use the Python SDK for creating an LLM-as-a-judge model evaluation job, use the following steps. First, set up the required configurations:</p><div><pre><code>import boto3\nfrom datetime import datetime\n\n# Generate unique name for the job\njob_name = f\"Model-evaluation-{datetime.now().strftime('%Y-%m-%d-%H-%M-%S')}\"\n\n# Configure your knowledge base and model settings\nevaluator_model = \"mistral.mistral-large-2402-v1:0\"\ngenerator_model = \"amazon.nova-pro-v1:0\"\nrole_arn = \"arn:aws:iam::&lt;YOUR_ACCOUNT_ID&gt;:role/&lt;YOUR_IAM_ROLE&gt;\"\n\n# Specify S3 locations for evaluation data and output\ninput_data = \"s3://&lt;YOUR_BUCKET&gt;/evaluation_data/input.jsonl\"\noutput_path = \"s3://&lt;YOUR_BUCKET&gt;/evaluation_output/\"\n\n# Create Bedrock client\nbedrock_client = boto3.client('bedrock')</code></pre></div><p>To create an LLM-as-a-judge model evaluation job:</p><div><pre><code>def create_llm_judge_evaluation(\n    client,\n    job_name: str,\n    role_arn: str,\n    input_s3_uri: str,\n    output_s3_uri: str,\n    evaluator_model_id: str,\n    generator_model_id: str,\n    dataset_name: str = None,\n    task_type: str = \"General\" # must be General for LLMaaJ\n):    \n    # All available LLM-as-judge metrics\n    llm_judge_metrics = [\n        \"Builtin.Correctness\",\n        \"Builtin.Completeness\", \n        \"Builtin.Faithfulness\",\n        \"Builtin.Helpfulness\",\n        \"Builtin.Coherence\",\n        \"Builtin.Relevance\",\n        \"Builtin.FollowingInstructions\",\n        \"Builtin.ProfessionalStyleAndTone\",\n        \"Builtin.Harmfulness\",\n        \"Builtin.Stereotyping\",\n        \"Builtin.Refusal\"\n    ]\n\n    # Configure dataset\n    dataset_config = {\n        \"name\": dataset_name or \"CustomDataset\",\n        \"datasetLocation\": {\n            \"s3Uri\": input_s3_uri\n        }\n    }\n\n    try:\n        response = client.create_evaluation_job(\n            jobName=job_name,\n            roleArn=role_arn,\n            applicationType=\"ModelEvaluation\",\n            evaluationConfig={\n                \"automated\": {\n                    \"datasetMetricConfigs\": [\n                        {\n                            \"taskType\": task_type,\n                            \"dataset\": dataset_config,\n                            \"metricNames\": llm_judge_metrics\n                        }\n                    ],\n                    \"evaluatorModelConfig\": {\n                        \"bedrockEvaluatorModels\": [\n                            {\n                                \"modelIdentifier\": evaluator_model_id\n                            }\n                        ]\n                    }\n                }\n            },\n            inferenceConfig={\n                \"models\": [\n                    {\n                        \"bedrockModel\": {\n                            \"modelIdentifier\": generator_model_id\n                        }\n                    }\n                ]\n            },\n            outputDataConfig={\n                \"s3Uri\": output_s3_uri\n            }\n        )\n        return response\n        \n    except Exception as e:\n        print(f\"Error creating evaluation job: {str(e)}\")\n        raise\n        \n # Create evaluation job\ntry:\n    llm_as_judge_response = create_llm_judge_evaluation(\n        client=bedrock_client,\n        job_name=job_name,\n        role_arn=ROLE_ARN,\n        input_s3_uri=input_data,\n        output_s3_uri=output_path,\n        evaluator_model_id=evaluator_model,\n        generator_model_id=generator_model,\n        task_type=\"General\"\n    )\n    print(f\"‚úì Created evaluation job: {llm_as_judge_response['jobArn']}\")\nexcept Exception as e:\n    print(f\"‚úó Failed to create evaluation job: {str(e)}\")\n    raise\n</code></pre></div><p>To monitor the progress of your evaluation job:</p><div><pre><code># Get job ARN based on job type\nevaluation_job_arn = llm_as_judge_response['jobArn']\n# Check job status\ncheck_status = bedrock_client.get_evaluation_job(jobIdentifier=evaluation_job_arn) \nprint(f\"Job Status: {check_status['status']}\")</code></pre></div><p>You can also compare multiple foundation models to determine which one works best for your needs. By using the same evaluator model across all comparisons, you‚Äôll get consistent benchmarking results to help identify the optimal model for your use case.</p><div><pre><code># Generator Models\nGENERATOR_MODELS = [\n    \"anthropic.claude-3-haiku-20240307-v1:0\",\n    \"amazon.nova-micro-v1:0\"\n]\n\n# Consistent Evaluator\nEVALUATOR_MODEL = \"anthropic.claude-3-haiku-20240307-v1:0\"\n\ndef run_model_comparison(\n    generator_models: List[str],\n    evaluator_model: str\n) -&gt; List[Dict[str, Any]]:\n    evaluation_jobs = []\n    \n    for generator_model in generator_models:\n        job_name = f\"llmaaj-{generator_model.split('.')[0]}-{evaluator_model.split('.')[0]}-{datetime.now().strftime('%Y-%m-%d-%H-%M-%S')}\"\n        \n        try:\n            response = create_llm_judge_evaluation(\n                client=bedrock_client,\n                job_name=job_name,\n                role_arn=ROLE_ARN,\n                input_s3_uri=input_data,\n                output_s3_uri=f\"{output_path}/{job_name}/\",\n                evaluator_model_id=evaluator_model,\n                generator_model_id=generator_model,\n                task_type=\"General\"\n            )\n            \n            job_info = {\n                \"job_name\": job_name,\n                \"job_arn\": response[\"jobArn\"],\n                \"generator_model\": generator_model,\n                \"evaluator_model\": evaluator_model,\n                \"status\": \"CREATED\"\n            }\n            evaluation_jobs.append(job_info)\n            \n            print(f\"‚úì Created job: {job_name}\")\n            print(f\"  Generator: {generator_model}\")\n            print(f\"  Evaluator: {evaluator_model}\")\n            print(\"-\" * 80)\n            \n        except Exception as e:\n            print(f\"‚úó Error with {generator_model}: {str(e)}\")\n            continue\n            \n    return evaluation_jobs\n\n# Run model comparison\nevaluation_jobs = run_model_comparison(GENERATOR_MODELS, EVALUATOR_MODEL)</code></pre></div><h3>Correlation analysis for LLM-as-a-judge evaluations</h3><p>You can use the <a href=\"https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient\" target=\"_blank\" rel=\"noopener\">Spearman‚Äôs rank correlation coefficient</a> to compare evaluation results between different generator models using LLM-as-a-judge in Amazon Bedrock. After retrieving the evaluation results from your S3 bucket, containing evaluation scores across various metrics, you can begin the correlation analysis.</p><p>Using , compute the correlation coefficient between pairs of generator models, filtering out constant values or error messages to have a valid statistical comparison. The resulting correlation coefficients help identify how similarly different models respond to the same prompts. A coefficient closer to 1.0 indicates stronger agreement between the models‚Äô responses, while values closer to 0 suggest more divergent behavior. This analysis provides valuable insights into model consistency and helps identify cases where different models might produce significantly different outputs for the same input.</p><div><pre><code>import json\nimport boto3\nimport numpy as np\nfrom scipy import stats\n\ndef read_and_organize_metrics_from_s3(bucket_name, file_key):\n    s3_client = boto3.client('s3')\n    metrics_dict = {}\n    \n    try:\n        response = s3_client.get_object(Bucket=bucket_name, Key=file_key)\n        content = response['Body'].read().decode('utf-8')\n        \n        for line in content.strip().split('\\n'):\n            if line:\n                data = json.loads(line)\n                if 'automatedEvaluationResult' in data and 'scores' in data['automatedEvaluationResult']:\n                    for score in data['automatedEvaluationResult']['scores']:\n                        metric_name = score['metricName']\n                        if 'result' in score:\n                            metric_value = score['result']\n                            if metric_name not in metrics_dict:\n                                metrics_dict[metric_name] = []\n                            metrics_dict[metric_name].append(metric_value)\n        return metrics_dict\n    \n    except Exception as e:\n        print(f\"Error: {e}\")\n        return None\n\ndef get_spearmanr_correlation(scores1, scores2):\n    if len(set(scores1)) == 1 or len(set(scores2)) == 1:\n        return \"undefined (constant scores)\", \"undefined\"\n    \n    try:\n        result = stats.spearmanr(scores1, scores2)\n        return round(float(result.statistic), 4), round(float(result.pvalue), 4)\n    except Exception as e:\n        return f\"error: {str(e)}\", \"undefined\"\n\n# Extract metrics\nbucket_name = \"&lt;EVALUATION_OUTPUT_BUCKET&gt;\"\nfile_key1 = \"&lt;EVALUATION_FILE_KEY1&gt;\"\nfile_key2 = \"&lt;EVALUATION_FILE_KEY2&gt;\"\n\nmetrics1 = read_and_organize_metrics_from_s3(bucket_name, file_key1)\nmetrics2 = read_and_organize_metrics_from_s3(bucket_name, file_key2)\n\n# Calculate correlations for common metrics\ncommon_metrics = set(metrics1.keys()) &amp; set(metrics2.keys())\n\nfor metric_name in common_metrics:\n    scores1 = metrics1[metric_name]\n    scores2 = metrics2[metric_name]\n    \n    if len(scores1) == len(scores2):\n        correlation, p_value = get_spearmanr_correlation(scores1, scores2)\n        \n        print(f\"\\nMetric: {metric_name}\")\n        print(f\"Number of samples: {len(scores1)}\")\n        print(f\"Unique values in Model 1 scores: {len(set(scores1))}\")\n        print(f\"Unique values in Model 2 scores: {len(set(scores2))}\")\n        print(f\"Model 1 scores range: [{min(scores1)}, {max(scores1)}]\")\n        print(f\"Model 2 scores range: [{min(scores2)}, {max(scores2)}]\")\n        print(f\"Spearman correlation coefficient: {correlation}\")\n        print(f\"P-value: {p_value}\")\n    else:\n        print(f\"\\nMetric: {metric_name}\")\n        print(\"Error: Different number of samples between models\")</code></pre></div><h2>Best practices for LLM-as-a-judge implementation</h2><p>You can also compare multiple foundation models to determine which one works best for your needs. By using the same evaluator model across all comparisons, you‚Äôll get consistent, scalable results. The following best practices will help you establish standardized benchmarking when comparing different foundation models.</p><ul><li>Create diverse test datasets that represent real-world use cases and edge cases. For large workloads (more than 1,000 prompts), use stratified sampling to maintain comprehensive coverage while managing costs and completion time. Include both simple and complex prompts to test model capabilities across different difficulty levels.</li><li>Choose evaluation metrics that align with your specific business objectives and application requirements. Balance quality metrics (correctness, completeness) with user experience metrics (helpfulness, coherence). Include safety metrics when deploying customer-facing applications.</li><li>Maintain consistent evaluation conditions when comparing different models. Use the same evaluator model across comparisons for standardized benchmarking. Document your evaluation configuration and parameters for reproducibility.</li><li>Schedule regular evaluation jobs to track model performance over time. Monitor trends across different metric categories to identify areas for improvement. Set up performance baselines and thresholds for each metric.</li><li>Optimize batch sizes based on your evaluation needs and cost constraints. Consider using smaller test sets for rapid iteration and larger sets for comprehensive evaluation. Balance evaluation frequency with resource utilization.</li><li>Maintain detailed records of evaluation jobs, including configurations and results. Track improvements and changes in model performance over time. Document any modifications made based on evaluation insights. The optional job description field can help you here.</li><li>Use evaluation results to guide model selection and optimization. Implement feedback loops to continuously improve prompt engineering. Regularly update evaluation criteria based on emerging requirements and user feedback.</li><li>Design your evaluation framework to accommodate growing workloads. Plan for increased complexity as you add more models or use cases. Consider automated workflows for regular evaluation tasks.</li></ul><p>These best practices help establish a robust evaluation framework using LLM-as-a-judge on Amazon Bedrock. For deeper insights into the scientific validation of these practices, including case studies and correlation with human judgments, stay tuned for our upcoming technical deep-dive blog post.</p><p>LLM-as-a-judge on Amazon Bedrock Model Evaluation represents a significant advancement in automated model assessment, offering organizations a powerful tool to evaluate and optimize their AI applications systematically. This feature combines the efficiency of automated evaluation with the nuanced understanding typically associated with human assessment, enabling organizations to scale their quality assurance processes while maintaining high standards of performance and safety.</p><p>The comprehensive metric categories, flexible implementation options, and seamless integration with existing AWS services make it possible for organizations to establish robust evaluation frameworks that grow with their needs. Whether you‚Äôre developing conversational AI applications, content generation systems, or specialized enterprise solutions, LLM-as-a-judge provides the necessary tools to make sure that your models align with both technical requirements and business objectives.</p><p>We‚Äôve provided detailed implementation guidance, from initial setup to best practices, to help you use this feature effectively. The accompanying code samples and configuration examples in this post demonstrate how to implement these evaluations in practice. Through systematic evaluation and continuous improvement, organizations can build more reliable, accurate, and trustworthy AI applications.</p><p>We encourage you to explore LLM-as-a-judge capabilities in the Amazon Bedrock console and discover how automatic evaluation can enhance your AI applications. To help you get started, we‚Äôve prepared a Jupyter notebook with practical examples and code snippets that you can find on our <a href=\"https://github.com/aws-samples/amazon-bedrock-samples/tree/main/evaluation-observe/bedrock-llm-as-judge-evaluation\" target=\"_blank\" rel=\"noopener\">GitHub repository</a>.</p><p><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/02/06/wale_picture_blog.png\" alt=\"\" width=\"100\" height=\"100\"> is a Sr. Data Scientist‚ÄìGenerative AI, Amazon Bedrock, where he contributes to cutting edge innovations in foundational models and generative AI applications at AWS. His expertise is in reproducible and end-to-end AI/ML methods, practical implementations, and helping global customers formulate and develop scalable solutions to interdisciplinary problems. He has two graduate degrees in physics and a doctorate in engineering.</p><p><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/02/06/ishan.jpg\" alt=\"\" width=\"100\" height=\"99\"> is a Generative AI Data Scientist at Amazon Web Services, where he helps customers build innovative and responsible generative AI solutions and products. With a strong background in AI/ML, Ishan specializes in building Generative AI solutions that drive business value. Outside of work, he enjoys playing volleyball, exploring local bike trails, and spending time with his wife and dog, Beau.</p><p><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/02/06/Badgephoto.jpeg\" alt=\"\" width=\"100\" height=\"115\"> is a Senior Product Manager on Amazon Bedrock, the AWS Generative AI developer service. He works at the intersection of AI and human interaction with the goal of creating and improving generative AI products and services to meet our needs. Previously, Jesse held engineering team leadership roles at Apple and Lumileds, and was a senior scientist in a Silicon Valley startup. He has an M.S. and Ph.D. from the University of Florida, and an MBA from the University of California, Berkeley, Haas School of Business.</p>","contentLength":26547,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"From concept to reality: Navigating the Journey of RAG from proof of concept to production","url":"https://aws.amazon.com/blogs/machine-learning/from-concept-to-reality-navigating-the-journey-of-rag-from-proof-of-concept-to-production/","date":1739381272,"author":"Vivek Mittal","guid":231,"unread":true,"content":"<p>Generative AI has emerged as a transformative force, captivating industries with its potential to create, innovate, and solve complex problems. However, the journey from a proof of concept to a production-ready application comes with challenges and opportunities. Moving from proof of concept to production is about creating scalable, reliable, and impactful solutions that can drive business value and user satisfaction.</p><p>One of the most promising developments in this space is the rise of <a href=\"https://aws.amazon.com/what-is/retrieval-augmented-generation/\" target=\"_blank\" rel=\"noopener\">Retrieval Augmented Generation (RAG)</a> applications. RAG is the process of optimizing the output of a foundation model (FM), so it references a knowledge base outside of its training data sources before generating a response.</p><p>The following diagram illustrates a sample architecture.</p><p>In this post, we explore the movement of RAG applications from their proof of concept or minimal viable product (MVP) phase to full-fledged production systems. When transitioning a RAG application from a proof of concept to a production-ready system, optimization becomes crucial to make sure the solution is reliable, cost-effective, and high-performing. Let‚Äôs explore these optimization techniques in greater depth, setting the stage for future discussions on hosting, scaling, security, and observability considerations.</p><p>The diagram below illustrates the tradeoffs to consider for a production-ready RAG application.</p><p>The success of a production-ready RAG system is measured by its quality, cost, and latency. Machine learning (ML) engineers must make trade-offs and prioritize the most important factors for their specific use case and business requirements. For example, consider the use case of generating personalized marketing content for a luxury fashion brand. The brand might be willing to absorb the higher costs of using a more powerful and expensive FMs to achieve the highest-quality classifications, because misclassifications could lead to customer dissatisfaction and damage the brand‚Äôs reputation. Consider another use case of generating personalized product descriptions for an ecommerce site. The retailer might be willing to accept slightly longer latency to reduce infrastructure and operational costs, as long as the generated descriptions remain reasonably accurate and compelling. The optimal balance of quality, cost, and latency can vary significantly across different applications and industries.</p><p>Let‚Äôs look into practical guidelines on how you can enhance the overall quality of your RAG workflow, including the quality of the retriever and quality of the result generator using <a href=\"https://aws.amazon.com/bedrock/knowledge-bases/\" target=\"_blank\" rel=\"noopener\">Amazon Bedrock Knowledge Bases</a> and other features of <a href=\"https://aws.amazon.com/bedrock/\" target=\"_blank\" rel=\"noopener\">Amazon Bedrock</a>. Amazon Bedrock Knowledge Bases provides a fully managed capability that helps you implement the entire RAG workflow from ingestion to retrieval and prompt augmentation without having to build custom integrations to data sources and manage data flows.</p><p>An effective evaluation framework is crucial for assessing and optimizing RAG systems as they move from proof of concept to production. These frameworks typically include overall metrics for a holistic assessment of the entire RAG pipeline, as well as specific diagnostic metrics for both the retrieval and generation components. This allows for targeted improvements in each phase of the system. By implementing a robust evaluation framework, developers can continuously monitor, diagnose, and enhance their RAG systems, achieving optimal performance across quality, cost, and latency dimensions as the application scales to production levels. <a href=\"https://aws.amazon.com/bedrock/evaluations/\" target=\"_blank\" rel=\"noopener\">Amazon Bedrock Evaluations</a> can help you evaluate your retrieval or end-to-end RAG workflow in Amazon Bedrock Knowledge Bases. In the following sections, we discuss these specific metrics in different phases of the RAG workflow in more detail.</p><p>For better retrieval performance, the way the data is stored in the <a href=\"https://aws.amazon.com/blogs/machine-learning/dive-deep-into-vector-data-stores-using-amazon-bedrock-knowledge-bases/\" target=\"_blank\" rel=\"noopener\">vector store</a> has a big impact. For example, your input document might include tables within the PDF. In such cases, using an FM to parse the data will provide better results. You can use <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/kb-chunking-parsing.html#kb-advanced-parsing\" target=\"_blank\" rel=\"noopener\">advanced parsing options</a> supported by Amazon Bedrock Knowledge Bases for parsing non-textual information from documents using FMs. Many organizations store their data in structured formats within data warehouses and data lakes. Amazon Bedrock Knowledge Bases offers a feature that lets you connect your RAG workflow to <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-build-structured.html\" target=\"_blank\" rel=\"noopener\">structured data stores</a>. This fully managed out-of-the-box RAG solution can help you natively query structured data from where it resides.</p><p>Another important consideration is the way your source document is split up into chunks. If your document would benefit from inherent relationships within your document, it might be wise to use <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/kb-chunking-parsing.html#kb-hiearchical-chunking\" target=\"_blank\" rel=\"noopener\">hierarchical chunking</a>, which allows for more granular and efficient retrieval. Some documents benefit from <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/kb-chunking-parsing.html#kb-semantic-chunking\" target=\"_blank\" rel=\"noopener\">semantic chunking</a> by preserving the contextual relationship in the chunks, helping make sure that the related information stays together in logical chunks. You can also use your own custom <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/kb-chunking-parsing.html#kb-custom-transformation\" target=\"_blank\" rel=\"noopener\">chunking strategy</a> for your RAG application‚Äôs unique requirements.</p><p>RAG applications process user queries by searching across a large set of documents. However, in many situations, you might need to retrieve documents with specific attributes or content. You can use <a href=\"https://aws.amazon.com/blogs/machine-learning/amazon-bedrock-knowledge-bases-now-supports-metadata-filtering-to-improve-retrieval-accuracy/\" target=\"_blank\" rel=\"noopener\">metadata filtering</a> to narrow down search results by specifying inclusion and exclusion criteria. Amazon Bedrock Knowledge Bases now also supports <a href=\"https://aws.amazon.com/about-aws/whats-new/2024/12/amazon-bedrock-knowledge-bases-auto-generated-query-filters-improved-retrieval/\" target=\"_blank\" rel=\"noopener\">auto generated query filters</a>, which extend the existing capability of manual metadata filtering by allowing you to narrow down search results without the need to manually construct complex filter expressions. This improves retrieval accuracy by making sure the documents are relevant to the query.</p><p>Writing an effective query is just as important as any other consideration for generation accuracy. You can add a <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-templates-and-examples.html\" target=\"_blank\" rel=\"noopener\">prompt</a> providing instructions to the FM to provide an appropriate answer to the user. For example, a legal tech company would want to provide instructions to restrict the answers to be based on the input documents and not based on general information known to the FM. <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html\" target=\"_blank\" rel=\"noopener\">Query decomposition</a> by splitting the input query into multiple queries is also helpful in retrieval accuracy. In this process, the subqueries with less semantic complexity might find more targeted chunks. These chunks can then be pooled and ranked together before passing them to the FM to generate a response.</p><p><a href=\"https://aws.amazon.com/about-aws/whats-new/2024/12/amazon-bedrock-rerank-api-accuracy-rag-applications/\" target=\"_blank\" rel=\"noopener\">Reranking</a>, as a post-retrieval step, can significantly improve response quality. This technique uses LLMs to analyze the semantic relevance between the query and retrieved documents, reordering them based on their pertinence. By incorporating reranking, you make sure that only the most contextually relevant information is used for generation, leading to more accurate and coherent responses.</p><p>Adjusting <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/inference-parameters.html\" target=\"_blank\" rel=\"noopener\">inference parameters</a>, such as temperature and top-k/p sampling, can help in further refining the output.</p><p>You can use Amazon Bedrock Knowledge Bases to <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html\" target=\"_blank\" rel=\"noopener\">configure and customize</a> queries and response generation. You can also improve the relevance of your query responses with a <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/rerank.html\" target=\"_blank\" rel=\"noopener\">reranker model</a> in Amazon Bedrock.</p><p>The key metrics for retriever quality are <a href=\"https://aws.amazon.com/blogs/machine-learning/evaluate-the-reliability-of-retrieval-augmented-generation-applications-using-amazon-bedrock/\" target=\"_blank\" rel=\"noopener\">context precision</a>, <a href=\"https://aws.amazon.com/blogs/machine-learning/evaluate-the-reliability-of-retrieval-augmented-generation-applications-using-amazon-bedrock/\" target=\"_blank\" rel=\"noopener\">context recall</a>, and <a href=\"https://aws.amazon.com/blogs/machine-learning/evaluate-the-reliability-of-retrieval-augmented-generation-applications-using-amazon-bedrock/\" target=\"_blank\" rel=\"noopener\">context relevance</a>. Context precision measures how well the system ranks relevant pieces of information from the given context. It considers the question, ground truth, and context. Context recall provides the percentage of ground truth claims or key information covered by the retrieved context. Context relevance measures whether the retrieved passages or chunks are relevant for answering the given query, excluding extraneous details. Together, these three metrics offer insight into how effectively the retriever is able to surface the most relevant and focused source material to support a high-quality response.</p><p>Generator quality can be assessed through several key metrics. <a href=\"https://github.com/amazon-science/RAGChecker/blob/main/tutorial/ragchecker_tutorial_en.md#generator-metrics\" target=\"_blank\" rel=\"noopener\">Context utilization</a> examines how effectively the generator uses relevant information from the provided source material. <a href=\"https://github.com/amazon-science/RAGChecker/blob/main/tutorial/ragchecker_tutorial_en.md#generator-metrics\" target=\"_blank\" rel=\"noopener\">Noise sensitivity</a> gauges the generator‚Äôs propensity to include inaccurate details from the retrieved content. <a href=\"https://github.com/amazon-science/RAGChecker/blob/main/tutorial/ragchecker_tutorial_en.md#generator-metrics\" target=\"_blank\" rel=\"noopener\">Hallucination</a> measures the extent to which the generator produces incorrect claims not present in the source data. <a href=\"https://github.com/amazon-science/RAGChecker/blob/main/tutorial/ragchecker_tutorial_en.md#generator-metrics\" target=\"_blank\" rel=\"noopener\">Self-knowledge</a> reflects the proportion of accurate statements generated that can‚Äôt be found in the retrieved chunks. Finally, <a href=\"https://github.com/amazon-science/RAGChecker/blob/main/tutorial/ragchecker_tutorial_en.md#generator-metrics\" target=\"_blank\" rel=\"noopener\">faithfulness</a> evaluates how closely the generator‚Äôs output aligns with the information contained in the source material.</p><p>For measuring the overall generation quality, the key metrics include measuring the <a href=\"https://github.com/amazon-science/RAGChecker/blob/main/tutorial/ragchecker_tutorial_en.md#overall-metrics\" target=\"_blank\" rel=\"noopener\">precision</a>, <a href=\"https://github.com/amazon-science/RAGChecker/blob/main/tutorial/ragchecker_tutorial_en.md#overall-metrics\" target=\"_blank\" rel=\"noopener\">recall</a>, and <a href=\"https://aws.amazon.com/blogs/machine-learning/evaluate-the-reliability-of-retrieval-augmented-generation-applications-using-amazon-bedrock/\" target=\"_blank\" rel=\"noopener\">answer similarity</a>. Precision suggests the proportion of the correct claims in model‚Äôs response, whereas recall suggests the proportion of the ground truth claims covered by the model‚Äôs response. Answer similarity compares the meaning and content of a generated answer with a reference or ground truth answer. It evaluates how closely the generated answer matches the intended meaning of the ground truth answer.</p><p>Establishing a feedback loop with an evaluation framework against these quality metrics allows for continuous improvement, where the system can learn from user interactions and refine its performance over time. By optimizing these quality metrics, the RAG system can be designed to deliver reliable, cost-effective, and high-performing results for users.</p><p>Implementing responsible AI practices is crucial for maintaining ethical and safe deployment of RAG systems. This includes using guardrails to filter harmful content, deny certain topics, mask sensitive information, and ground responses in verified sources to reduce hallucinations.</p><p>Cost considers the compute resources and infrastructure required to run the system, and latency evaluates the response times experienced by end-users. To optimize cost and latency, implement <a href=\"https://aws.amazon.com/blogs/database/improve-speed-and-reduce-cost-for-generative-ai-workloads-with-a-persistent-semantic-cache-in-amazon-memorydb/\" target=\"_blank\" rel=\"noopener\">caching strategies</a> to reduce the need for expensive model inferences. Efficient <a href=\"https://docs.aws.amazon.com/bedrock/latest/userguide/batch-inference.html\" target=\"_blank\" rel=\"noopener\">query batching</a>&nbsp;can also improve overall throughput and reduce resource usage. Balance performance and resource usage to find the ideal configuration that meets your application‚Äôs requirements.</p><p>Use tools like Amazon Bedrock Knowledge Bases so you can take advantage of fully managed support for the end-to-end RAG workflow. It supports many of the <a href=\"https://aws.amazon.com/about-aws/whats-new/2024/07/knowledge-bases-amazon-bedrock-advanced-rag-capabilities/\" target=\"_blank\" rel=\"noopener\">advanced RAG capabilities</a> we discussed earlier. By addressing these optimization techniques, you can transition your RAG-powered proof of concept to a robust, production-ready system that delivers high-quality, cost-effective, and low-latency responses to your users.</p><p>In addition to the server or compute layer, you will also need to consider an orchestration tool, testing environments, and a continuous integration and delivery (CI/CD) pipeline to streamline your application deployment. Having a feedback loop established based on the quality metrics along with a CI/CD pipeline is an important first step to creating self-healing architectures.</p><p>As your application grows, you will need to make sure your infrastructure can scale to meet the increasing demand. This can involve containerization with Docker or choosing serverless options, implementing load balancing, setting up auto scaling, and choosing between on-premises, cloud, or hybrid solutions. It also includes unique scaling requirements of your frontend application and backend generative AI workflow, as well as the use of content delivery networks (CDNs) and disaster recovery and backup strategies.</p><p>The following is a sample architecture for a secure and scalable RAG-based web application. This architecture uses Amazon ECS for hosting the service, <a href=\"https://aws.amazon.com/cloudfront/\" target=\"_blank\" rel=\"noopener\">Amazon CloudFront</a> as a CDN, <a href=\"https://aws.amazon.com/waf/\" target=\"_blank\" rel=\"noopener\">AWS WAF</a> as a firewall, and <a href=\"https://aws.amazon.com/memorydb/\" target=\"_blank\" rel=\"noopener\">Amazon MemoryDB</a> for providing a semantic cache.</p><p>By carefully considering these aspects of hosting and scaling your infrastructure, you can build a resilient and adaptable system to support your growing web application or service. Stay tuned for more detailed information on these topics in upcoming blog posts.</p><h2>Data privacy, security, and observability</h2><p>Maintaining data privacy and security is of utmost importance. This includes implementing security measures at each layer of your application, from encrypting data in transit to setting up robust authentication and authorization controls. It also involves focusing on compute and storage security, as well as network security. Compliance with relevant regulations and regular security audits are essential. Securing your generative AI system is another crucial aspect. By default, Amazon Bedrock Knowledge Bases encrypts the traffic using AWS managed <a href=\"http://aws.amazon.com/kms\" target=\"_blank\" rel=\"noopener\">AWS Key Management Service</a> (AWS KMS) keys. You can also choose customer managed KMS keys for more control over encryption keys. For more information on application security, refer to <a href=\"https://aws.amazon.com/blogs/machine-learning/safeguard-a-generative-ai-travel-agent-with-prompt-engineering-and-amazon-bedrock-guardrails/\" target=\"_blank\" rel=\"noopener\">Safeguard a generative AI travel agent with prompt engineering and Amazon Bedrock Guardrails</a>.</p><p>Comprehensive logging, monitoring, and maintenance are crucial to maintaining a healthy infrastructure. This includes setting up structured logging, centralized log management, real-time monitoring, and strategies for system updates and migrations.</p><p>By addressing these critical areas, you can build a secure and resilient infrastructure to support your growing web application or service. Stay tuned for more in-depth coverage of these topics in upcoming blog posts.</p><p>To successfully transition a RAG application from a proof of concept to a production-ready system, you should focus on optimizing the solution for reliability, cost-effectiveness, and high performance. Key areas to address include enhancing retriever and generator quality, balancing cost and latency, and establishing a robust and secure infrastructure.</p><p>By using purpose-built tools like Amazon Bedrock Knowledge Bases to streamline the end-to-end RAG workflow, organizations can successfully transition their RAG-powered proofs of concept into high-performing, cost-effective, secure production-ready solutions that deliver business value.</p><p><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/02/07/vivek_phonetool.jpeg\" alt=\"\" width=\"100\" height=\"133\"> is a Solution Architect at Amazon Web Services, where he helps organizations architect and implement cutting-edge cloud solutions. With a deep passion for Generative AI, Machine Learning, and Serverless technologies, he specializes in helping customers harness these innovations to drive business transformation. He finds particular satisfaction in collaborating with customers to turn their ambitious technological visions into reality.</p><p>&nbsp;is a Sr. Enterprise Solutions Architect at AWS, experienced in Software Engineering, Enterprise Architecture, and AI/ML. He is deeply passionate about exploring the possibilities of generative AI. He collaborates with customers to help them build well-architected applications on the AWS platform, and is dedicated to solving technology challenges and assisting with their cloud journey.</p><p><img loading=\"lazy\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/02/07/mani.jpeg\" alt=\"\" width=\"100\" height=\"133\">&nbsp;is a Tech Lead ‚Äì Generative AI Specialists, author of the book Applied Machine Learning and High-Performance Computing on AWS, and a member of the Board of Directors for Women in Manufacturing Education Foundation Board. She leads machine learning projects in various domains such as computer vision, natural language processing, and generative AI. She speaks at internal and external conferences such AWS re:Invent, Women in Manufacturing West, YouTube webinars, and GHC 23. In her free time, she likes to go for long runs along the beach.</p>","contentLength":15255,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Show HN: Game Bub ‚Äì open-source FPGA retro emulation handheld","url":"https://eli.lipsitz.net/posts/introducing-gamebub/","date":1739380285,"author":"elipsitz","guid":317,"unread":true,"content":"<p>I‚Äôm excited to announce the project I‚Äôve been working on for the last year and a half: , an open-source FPGA based retro emulation handheld, with support for Game Boy, Game Boy Color, and Game Boy Advance games.</p><p>Game Bub can play physical cartridges, as well as emulated cartridges using ROM files loaded from a microSD card. Game Bub also supports the <a href=\"https://en.wikipedia.org/wiki/Game_Link_Cable\">Game Link Cable</a> in both GB and GBA modes for multiplayer games. I designed the hardware with a number of bonus features, like video out (HDMI) via a custom dock, a rumble motor, real-time clock (for certain games). Additionally, the hardware is designed with extensibility in mind, allowing future software improvements to expand its capabilities.</p><p>Game Bub has a custom-designed 6 layer PCB featuring a Xilinx XC7A100T FPGA with integrated memory,  display, speakers, rechargable battery, GB/GBA cartridge slot, all packaged up in a custom 3D-printed enclosure.</p><p>Check out the instructions, code, and design files <a href=\"https://github.com/elipsitz/gamebub\">on GitHub</a>. Note that building a Game Bub unit is fairly complex. If you might be interested in buying a complete Game Bub kit, please <a href=\"https://forms.gle/m1FFUqpCde7x5u5AA\">fill out this form</a> to help me gauge interest.</p><p>I had a lot of fun implementing a Game Boy at the hardware level, and I started thinking about how far I could take the project. I was using a Pynq-Z2 development board, which was definitely the right way to get started, but it came with a lot of limitations.</p><p>I had to use an external monitor for audio/video, and an external gamepad for input, but a real Game Boy, of course, is a portable handheld. I also wanted to add Game Boy Advance support, but the memory architecture of the Pynq-Z2 had access latency that <a href=\"https://eli.lipsitz.net/posts/fpga-gameboy-emulator/#fixing-an-audio-bug-on-the-game-boy-color\">was just barely acceptable for the Game Boy</a>, and would have been completely unacceptable for the Game Boy Advance. I also wanted to make something less ‚Äúhacky‚Äù: a real device that I could play and give to people, not just a bare PCB.</p><p>Furthermore, while there are open-source FPGA retrogaming projects (e.g. <a href=\"https://en.wikipedia.org/wiki/MiSTer\">MiSTer</a>), there doesn‚Äôt appear to be anything open-source that supports physical Game Boy and Game Boy Advance cartridges, let alone an open-source handheld device.</p><p>Thus, I somewhat naively set out to design what would become by far my most complex electrical engineering and hardware design project to date.</p><p>I set out some goals for the project:</p><ul><li>Build a standalone, rechargable battery-powered FPGA handheld</li><li>Minimize cost and complexity by using off-the-shelf components wherever possible</li><li>Capable of playing Game Boy, Game Boy Color, and Game Boy Advance games</li><li>Capable of using physical cartridges, or emulating cartridges (reading ROM files off of a microSD card)</li><li>Easy to use: graphical menu and in-game overlay</li><li>Integrated display and speakers, with headphone support</li><li>Integrated peripherals (rumble, real-time clock, accelerometer) for emulated cartridges</li><li>HDMI video output support for playing on a big screen</li><li>Decent looking design with good ergonomics</li><li>Expansion opportunities in the future: support for more systems, Wi-Fi, etc.</li></ul><p>And finally, since I was building this project for fun and learning, I wanted to be able to fully understand every single component of the system. I wanted to use my own emulator cores (e.g. not just port them from <a href=\"https://mister-devel.github.io/MkDocs_MiSTer/\">MiSTer</a>), do my own board design, and write my own drivers to interface with peripherals.</p><h3>A brief rant about FPGA retrogaming<a hidden=\"\" aria-hidden=\"true\" href=\"https://eli.lipsitz.net/posts/introducing-gamebub/#a-brief-rant-about-fpga-retrogaming\">#</a></h3><p>There‚Äôs a lot of misleading marketing and hype out there around FPGA retrogaming. Some claim that FPGA retrogaming devices are not emulators (because they supposedly ‚Äúact like [the system] at the gate level‚Äù), that they achieve ‚Äúperfect accuracy‚Äù, or that they‚Äôre superior to software emulators.</p><p>In my opinion, this is blatantly wrong and actively harmful. FPGA retrogaming devices are emulators: they pretend to be something they‚Äôre not. And they‚Äôre only as accurate as they‚Äôre programmed to be, since they‚Äôre recreations. An FPGA can make certain aspects of accuracy easier to achieve, but it doesn‚Äôt guarantee it.</p><p>Software emulators can be extremely accurate. Furthermore, perfect accuracy (if it‚Äôs even possible) is by no means a requirement to play an entire system‚Äôs library of games. Some people claim that FPGA emulators are the only way to ‚Äúpreserve‚Äù a system, but I‚Äôd argue that software emulators are a significantly more accessible (no special hardware needed!) way to further this goal.</p><p>I believe that FPGA emulators have only one real advantage over software emulators: they can more easily interface with original hardware, such as physical cartridges or other consoles via link cables.</p><p>I did this project not because I think that FPGA emulators are inherently better than software emulators, but because I think they‚Äôre interesting and fun to build.</p><p>I began work on the project by doing some initial research and sketching out a high level design.</p><p>My previous FPGA emulator project used a Xilinx Zynq chip, which integrates FPGA fabric (‚ÄúPL‚Äù) with a dual-core ARM processor running Linux (‚ÄúPS‚Äù). I implemented the entire emulator on the FPGA, and used the Linux system to configure the FPGA, render the UI, and load ROM files from the filesystem.</p><p>I decided to keep this same division of responsibilities: using the FPGA to do the core emulation, with a separate processor to do support tasks. However, to make the overall design easier to reason about, I decided to to use an FPGA-only chip (without any hard processor cores), and an external microcontroller (MCU) to do the tasks that the ARM cores did before.</p><p>The FPGA would consume input, directly interface to the game cartridges (through level shifters to support both the 3.3 volt GBA and 5 volt Game Boy), and output audio and video to the speakers and display. The MCU would handle the UI, read ROM files from the microSD card, initialize peripherals (display, DAC, IMU), handle power sequencing, and load the FPGA configuration.</p><p>I wanted to have Wi-Fi and Bluetooth support: Wi-Fi for software updates, and the possibility of emulating the <a href=\"https://en.wikipedia.org/wiki/Game_Boy_Advance_Wireless_Adapter\">Game Boy Advance Wireless Adapter</a>, and Bluetooth to support wireless game controllers (when connected to an external display). To reduce complexity (and avoid the need for careful RF design), I looked only for complete Wi-Fi/Bluetooth modules with integrated antennas.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/early-block-diagram.svg\" alt=\"An early block diagram I sketched out\"><figcaption><p>An early block diagram I sketched out</p></figcaption></figure><p>I also drew out rough sketches of what the final device might look like: placement of buttons, screen, speakers, ports, cartridge slot, and battery. I settled on a vertical Game Boy Color-esque design (as opposed to a horizontal Game Boy Advance-style design), because I felt that this would maximize the space in the back of the device for full-size Game Boy Color cartridges and a battery.</p><p>After sketching out the goals and high level design, I started component selection: picking out each non-trivial component of the system, evaluating features and requirements (e.g. how they communicate, power consumption and voltages needed).</p><p>Since I intended to have this manufactured and assembled at JLCPCB, I strongly preferred parts that were available in their part library. One technique I even used for narrowing down part choices was finding the relevant category in their part search, and sorting by their stock count.</p><p>I initially planned to use an <a href=\"https://en.wikipedia.org/wiki/RP2040\">RP2040</a> microcontroller, with a separate ESP32-WROOM module to support Wi-Fi and Bluetooth.</p><p>The ESP32 supports both Bluetooth Classic and LE, which is essential for supporting a wide range of controllers, and the RP2040 has USB host support, to support wired controllers.</p><p>During the schematic design process, I ended up simplifying the RP2040 + ESP32 combination to just a single ESP32-S3 module for a few reasons:</p><ul><li>I started running out of GPIOs on the RP2040, and I was dedicating 4 of them (2 for UART, 1 for reset, 1 for booting in firmware download mode) to communication with the ESP32. Plus, the ESP32-S3 has more GPIOs overall.</li><li>I wanted to write the MCU firmware in Rust, and the ESP32-S3 had support for the Rust standard library (via ESP-IDF and <a href=\"https://github.com/esp-rs/esp-idf-hal\">esp-idf-hal</a>). This seemed like it would be easier to get the software up and running.</li><li>Fewer components means easier routing and assembly</li><li>The ESP32-S3 has an SDIO module (for interfacing with the microSD card), and FAT filesystem support (via ESP-IDF). It would be possible to do this with the RP2040 PIO, but having a proper peripheral and driver for this makes it a lot easier.</li><li>The ESP32-S3 is more powerful than the RP2040, and would probably be able to render a smoother UI.</li></ul><p>However, the ESP32-S3 has one main disadvantage compared to the original ESP32: it doesn‚Äôt have Bluetooth Classic support, only LE. This would greatly limit the range of supported wireless controllers, but I believed the compromise was worth it. I also decided to scrap USB host support, because supporting USB-C dual role (switchable device or host) would have added a lot of additional complexity.</p><p>If the RP2350 microcontroller (the successor to the RP2040) had been available when I started this project, I may very well have chosen it, since it has even more power, PIO blocks, memory, and GPIO pins. I might have paired it with an RM2 radio module for Wi-Fi and Bluetooth.</p><p>I wanted a display that would support integer scaling for the Game Boy Advance, which has a 240x160 pixel screen. I was also looking for a screen roughly on the order of 3.0-3.5 inches wide (diagonal), to be comfortable to hold in the hand.</p><p>I found the ER-TFT035IPS-6 LCD module from <a href=\"https://www.buydisplay.com/\">EastRising</a>, with a 3.5 inch display, and a 320x480 pixel resolution. This allows for a 2x integer scale for the Game Boy Advance (and a 2x scale plus centering for the 160x144 Game Boy display). This checked off almost all of the boxes: integer scaling, a good size, available at a reasonable price, pretty good documentation (for the ILI9488 LCD controller).</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/er-tft035ips-6.jpg\" alt=\"ER-TFT035IPS-6 LCD module\" width=\"1000\" height=\"550\"><figcaption><p>ER-TFT035IPS-6 LCD module</p></figcaption></figure><p>The main issue, which actually ended up being fairly annoying, is that it‚Äôs a 320x480 display, not 480x320. Meaning, it‚Äôs oriented in portrait mode, not landscape. I rotated the device 90 degrees to fit in a landscape orientation, but this created two issues:</p><ul><li>In landscape orientation, the bottom of the display (containing the LCD driver chip and the flex cable) faces to the left or the right, which means that larger bazels are required on the left and right of the display to center the ‚Äúactive area‚Äù of the LCD within the handheld.</li><li>In landscape orientation, the display refreshes from left to right, not top to bottom.</li></ul><p>The problem with refreshing from left to right is that the Game Boy and Game Boy Advance (and almost every other system) refresh from top to bottom. This means that the display can‚Äôt be refreshed perfectly in sync with the game (zero buffering), and single buffering leads to unsightly diagonal tearing. Instead, I had to use triple buffering, where the game is writing to one framebuffer, the LCD driver is reading from another buffer, and there‚Äôs one spare swap buffer. This increases the amount of memory used ‚Äì and because it needed to be accessed by both the game and LCD driver simultaneously (dual port), it needed to be stored in internal block RAM in the FPGA, a scarce resource.</p><p>So, even though the Game Boy emulator uses &lt;10% of the total logic resources of the FPGA, and the Game Boy Advance uses around 30%, I had to use a large (more expensive, and power hungry) FPGA so that I had enough block RAM.</p><p>I also stuck a standard size HDMI port into the design, connected directly to the FPGA. HDMI has a few additional, non-video signals that need level shifting from 5V to 3.3V (I opted for discrete transistors), and it requires the source (me!) to supply a small amount of power.</p><p>I had never previously designed anything that used a lithium ion battery, so I had a fair amount of learning to do. <a href=\"https://learn.adafruit.com/li-ion-and-lipoly-batteries/overview\">Adafruit</a> was a helpful resource. I needed a way to charge the battery from USB power, and a way to measure how charged it is.</p><p>Lithium ion batteries can be dangerous if misused. Safely charging a battery is non-trivial, and requires a feedback loop and adjustable voltage sources. A dedicated IC seemed like the best way to do this. A lot of hobbyists use the ultra-cheap TP4056 1A battery charger, but I‚Äôd read about a lot of issues it has around safely charging the battery while using it. I decided instead to opt for the <a href=\"https://www.ti.com/lit/ds/symlink/bq24073.pdf\">TI BQ2407x</a> series of battery charger ICs. They seem to be widely used in commercial products, came with a comprehensive datasheet, and had a few critical features: programmable input and charge current limits, safety timers, and ‚Äúpower path management‚Äù for safely charging the battery while the device is on.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/lipo-discharge-curve.png\" alt=\"Typical discharge curve for a 3.7V lipo battery (source: Adafruit)\" width=\"579\" height=\"402\"><figcaption><p>Typical discharge curve for a 3.7V lipo battery (source: <a href=\"https://learn.adafruit.com/assets/979\">Adafruit</a>)</p></figcaption></figure><p>There are a few ways to measure the charge level of the battery, which generally relies on the fact that a lithium ion battery‚Äôs voltage depends on its charge level. A fully charged battery is about 4.2 volts, a battery with between 80% and 20% charge is about 3.7 volts, and below that a drained battery falls off pretty quickly to under 3.0 volts. If all you want is a coarse estimate of the battery level, you can use an ADC to read the voltage and estimate whether the battery is fully charged or nearly discharged. However, since the voltage curve is nearly flat between 20% and 80% charge (and is also dependent on the load), this can‚Äôt give the fine-grained battery percentage that we‚Äôre used to on phones and laptops. Instead, I opted for a discrete fuel gauge IC, the <a href=\"https://www.analog.com/en/products/max17048.html\">MAX17048</a>. It‚Äôs simple to integrate and inexpensive.</p><p>I decided to use a push button for the main power switch, because I needed to be able to do a graceful shutdown, where the microcontroller could save state (e.g. the current save file for an emulated cartridge) before it actually powered off.</p><p>I briefly considered using an ultra-low power, always on microcontroller to act as a custom <a href=\"https://en.wikipedia.org/wiki/Power_management_integrated_circuit\">PMIC</a> to provide power switch functionality (and perhaps avoid the need for a separate real-time clock IC, and even a battery gauge). While this would have been flexible and really cool, I figured it wasn‚Äôt worth the additional complexity.</p><p>The main system power ranges from about 3.4 V when the battery is discharged, to 4.2 V when the battery is fully charged, up to 5.0 V when the device is plugged in with USB.</p><p>The ESP32-S3 module required 3.3 V, and most of the other ICs in the system did too. The main exception is the FPGA, which requires a 1.0 V core power rail, a 1.8 V ‚Äúauxiliary‚Äù power rail, and a 3.3 V power rail for I/O. Moreover, according to the <a href=\"https://docs.amd.com/v/u/en-US/ds181_Artix_7_Data_Sheet\">Xilinx Artix-7 datasheet (DS181)</a>, these power rails need to be powered on in a particular sequence: for my use, this means 1.0 V, then 1.8 V, then 3.3 V. Additionally, I needed a 5.0 V supply to interface with Game Boy / Game Boy Color cartridges.</p><p>There are multi-rail power regulators available, and a lot of FPGA development boards use them. However, they all seemed to be expensive and difficult to purchase in low quantities. Instead, I opted for separate power regulators for each rail. I used <a href=\"https://en.wikipedia.org/wiki/Buck_converter\">buck converters</a> instead of <a href=\"https://en.wikipedia.org/wiki/Linear_regulator\">linear regulators</a> to maximize power efficiency.</p><p>I used the <a href=\"https://www.ti.com/product/TLV62585\">TLV62585</a> converter for the 3.3 V, 1.8 V, and 1.0 V rails. This is a simple, performant buck converter with a ‚Äúpower good‚Äù output, which is useful for power sequencing: you can connect the  output of one regulator to the  pin of the next regulator, to power on the rails in the desired order.</p><p>For the 5.0 V rail, I used the <a href=\"https://www.ti.com/product/TPS61022\">TPS61022</a> boost converter. This converter is way overkill for the 5.0 V rail (which might use 75mA ), but it was readily available, and conveniently compatible with the same 1¬µH inductor as the buck converters.</p><p>According to the FPGA datasheet, the XC7A100T consumes more than 100mW of static power. That is, it consumes that as long as it‚Äôs connected to power, even if it‚Äôs doing absolutely nothing. I figured I might want to support a low power sleep mode, so I decided to split the FPGA into a separate power domain with an explicit power enable signal from the MCU. I also used an <a href=\"https://www.diodes.com/datasheet/download/AP2191.pdf\">AP2191W</a> load switch for the FPGA‚Äôs 3.3 V rail to be able to keep the 1.0 V ‚Üí 1.8 V ‚Üí 3.3 V sequencing.</p><p>I wanted the device to have both speakers and a 3.5mm headphone jack. Ultimately, the FPGA generates an <a href=\"https://en.wikipedia.org/wiki/I%C2%B2S\">I2S</a> digital audio signal, and I needed a <a href=\"https://en.wikipedia.org/wiki/Digital-to-analog_converter\">DAC</a> to convert it to an analog audio signal, and then an amplifier to drive the speakers (or headphones). I wanted digital volume control (to support volume buttons, rather than a volume knob or slider), and I needed some way to switch the audio output between speakers and the headphones, depending on whether or not headphones are plugged in. With no real audio experience, this seemed like a daunting task.</p><p>While searching for multiple separate components, I stumbled upon the <a href=\"https://www.ti.com/product/TLV320DAC3101\">TLV320DAC3101</a>. It combines a stereo DAC with a speaker amplifier and a headphone driver. Additionally, it supports digital volume control, and headphone detection. I think this chip is a good example of how thoughtful component selection can simplify the overall design. Looking through the datasheet, it required a 1.8 V core voltage (unlike essentially every other component other than the FPGA) and a fair amount of configuration registers to set over I2C, but it had all of the features I needed.</p><p>I was originally planning to have just a single (mono) speaker, but I figured if I had a stereo DAC, I might as well put two in there. I chose the <a href=\"https://www.sameskydevices.com/product/audio/speakers/miniature-(10-mm~40-mm)/ces-20134-088pmb\">CES-20134-088PMB</a>, an enclosed microspeaker with a JST-SH connector. Having an enclosed speaker simplified audio design, because as it turns out, you can‚Äôt just stick a speaker to a board and expect it to sound okay (Same Sky, the manufacturer of that speaker, <a href=\"https://www.sameskydevices.com/blog/how-to-design-a-micro-speaker-enclosure\">has a blog post explaining some of the nuances</a>).</p><p>I prefer the feeling of clicky, tactile buttons (such as those found in the GBA SP, Nintendo DS (original), Nintendo 3DS, Switch) compared to ‚Äúmushy‚Äù membrane buttons (such as those found in the Game Boy Color, original GBA, and Nintendo DS Lite). I learned that the tactile switches used in the GBA SP are a <a href=\"https://tech.alpsalpine.com/e/products/detail/SKRRAAE010/\">widely available off-the-shelf part from Alps Alpine</a>. I used similar, but smaller buttons for the Start/Select/Home buttons, and a right-angle button from the same manufacturer for side volume and power buttons.</p><p>Although I only had plans to support Game Boy and Game Boy Advance (requiring a D-pad, A and B buttons, L and R shoulder buttons, and Start/Select), I opted to add two more ‚ÄúX‚Äù and ‚ÄúY‚Äù face buttons to leave the possibility open of supporting more systems in the future.</p><p>The L and R buttons posed an additional challenge ‚Äì I found numerous right-angle tactile buttons (to be soldered onto the back, facing towards the top). However, none of them seemed to have the actuator (the part of the button you make contact with) far enough away from the PCB to be easily pressed. At first, I thought about making a separate shoulder button board to move them at the correct distance, but then I started looking at what existing devices do for inspiration. The Game Boy Advance SP actually uses a more complex mechanism for the shoulder buttons: rather than a simple actuator like the face buttons, there‚Äôs a hinge with a <a href=\"https://en.wikipedia.org/wiki/Torsion_spring\">torsion spring</a> that hits the actuator at an angle. This is actually part of what makes the shoulder buttons pleasant to press: you don‚Äôt need to hit them from exactly the right direction, because they pivot. I ended up just going with a standard right-angle tactile button, opting to solve the problem with the mechanism in the enclosure.</p><figure><figcaption><p>GBA SP shoulder button mechanism</p></figcaption></figure><p>One of my main goals was to allow ROM files to be loaded from a microSD card, rather than only being able to be played from a physical cartridge. To do this, I‚Äôd need dedicated RAM for the FPGA to hold the game. Game Boy Advance games, typically, are a maximum of 32 MB. They don‚Äôt make SRAMs that large (and if they did, they‚Äôd be very expensive). Instead, I needed to use <a href=\"https://en.wikipedia.org/wiki/Dynamic_random-access_memory\">DRAM</a>.</p><p>Asynchronous SRAM is very simple: supply a read address to the address pins, and some amount of nanoseconds later, the data you‚Äôre reading appears on the data pins. DRAM is more complex: the simplest kind is ‚Äúsingle data rate synchronous DRAM‚Äù (SDR SDRAM, or just <a href=\"https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory\">SDRAM</a>, distinguishing it from the significantly more complex DDR SDRAM). However, even SDRAM is non-trivial to use. DRAM is organized into banks, rows, and columns, and accessing DRAM requires sending commands to ‚Äúactivate‚Äù (open) a row before reading out ‚Äúcolumns‚Äù, and then ‚Äúprecharging‚Äù (closing) a row. Handling all of this requires a DRAM controller (see this <a href=\"https://www.fpga4fun.com/SDRAM2.html\">simple description of the state machine</a> required). This isn‚Äôt terribly complex, but I was signing myself up for more work.</p><p>Alternatively, I could have chosen a PSRAM chip (essentially DRAM with an integrated controller to make it have a more SRAM-like interface). However, I couldn‚Äôt find a PSRAM part that I was happy with (cost, availability, interface), and so I ended up going with the inexpensive W9825G6KH 32MB 16-bit SDRAM.</p><p>I also decided to stick a 512 KiB SRAM chip in the design in case I ended up needing some more simple memory later, like for emulating the SRAM used for Game Boy cartridge save files. Despite being 1/64 the capacity, this chip was about 3x the cost of the SDRAM. This ended up being a wise decision, since a lot of my internal FPGA block ram was eaten up by the triple buffer for the display (see above).</p><h3>Cartridge and Link Ports<a hidden=\"\" aria-hidden=\"true\" href=\"https://eli.lipsitz.net/posts/introducing-gamebub/#cartridge-and-link-ports\">#</a></h3><p>The cartridge slot and link ports are no-name parts from AliExpress, easily available for cheap. These seem to mostly be GBA SP compatible, and are often used as repair parts.</p><p>The Game Boy Advance can play both Game Boy [Color] and Game Boy Advance games. These run at different voltages and use different protocols, so the device needed some way of determining which type of cartridge is inserted.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/gb-vs-gba-cartridge-bottom.jpg\" alt=\"GBA cartridge (top) vs GB cartridge (bottom)\" width=\"1440\" height=\"519\"><figcaption><p>GBA cartridge (top) vs GB cartridge (bottom)</p></figcaption></figure><p>The cartridges are physically different at the bottom: GBA cartridges (the top cartridge in the image) have a notch on either side. The GBA has a  that senses the absence of a notch on an inserted cartridge and switches the device into Game Boy Color mode.</p><p>I measured the size and position of this notch, and searched Digi-Key and Mouser for switches that met these constraints. In the end, I was only able to find a single switch that would work.</p><h3>Miscellaneous peripherals<a hidden=\"\" aria-hidden=\"true\" href=\"https://eli.lipsitz.net/posts/introducing-gamebub/#miscellaneous-peripherals\">#</a></h3><p>I used the surprisingly cheap <a href=\"https://www.st.com/en/mems-and-sensors/lsm6ds3tr-c.html\">LSM6DS3TR-C</a> IMU from ST. This tiny IMU has a 3-axis accelerometer and gyroscope, more than sufficient for emulating the few GB/GBA cartridges that have motion controls.</p><p>For keeping track of time even when the device was off, I used the <a href=\"https://www.nxp.com/part/PCF8563T\">PCF8563T</a> real-time clock chip. I chose this because it was 1) I2C (no additional pins required), 2) cheap, and 3) readily available from JLCPCB. Interestingly, all of the real-time clock chips I found count in seconds/minutes/hours/days/months/years. This makes sense for a really simple device with minimal computational power. However, it‚Äôs annoying for my purposes, since all I really want is a timestamp I can pass to some other datetime library, and converting between the calendar time and a unix timestamp is non-trivial due to how the chips incompletely handle leap years.</p><p>I picked up a few cheap coin vibration motors to use for vibration support (for the rare cartridge that had a built-in vibration motor).</p><p>I also used a <a href=\"https://www.ti.com/product/TCA9535\">TCA9535</a> I2C I/O expander to connect the face buttons to the MCU. I ran out of pins, and while I  have used the FPGA as a sort of I/O expander, I figured I‚Äôd make it simpler for myself (and allow the buttons to be used even if the FPGA was powered off) by letting the MCU read them itself.</p><p>For this project, as with my previous ones, I used <a href=\"https://www.kicad.org/\">KiCad</a> to create my schematic and do PCB layout. I really can‚Äôt recommend KiCad enough: it‚Äôs a great program, intuitive to use, and it‚Äôs free and open source.</p><p>This was a very ambitious project for my level of electrical engineering experience, and creating the schematic took a couple of weeks. I spent a lot of time designing the circuit for each component, because I was afraid I‚Äôd do something wrong and end up with a stack of useless boards without the skills needed to debug them. A lot of the component selection actually happened in parallel with schematic design, as I found new requirements or problems and had to change components.</p><p>I gained a lot of experience reading component datasheets. It‚Äôs a really valuable skill, both for component selection and for creating designs that use the components. Nearly every datasheet has a ‚Äútypical application‚Äù section, where the manufacturer shows how the component would fit into a circuit. At minimum, this has power supply information (e.g. these voltages to these pins with these decoupling capacitors). For more complex components like the DAC, it also has information about power sequencing, different ways the device could be connected to the rest of the system, a register list, that sort of thing. Some components also included PCB layout recommendations. This information was all really helpful, and gave me a good deal of confidence that my board would work as long as I read through the datasheet and followed the manufacturer‚Äôs recommendations.</p><p>Then I got to the FPGA. Nearly every component has a single datasheet. Some of them have an additional application note or two. Particularly complex chips (like the ESP32-S3 microcontroller) have a separate datasheet, reference manual, and hardware design guide. The Xilinx Series 7 FPGAs have . Overviews, packaging and pinout, configuration guides, BGA design rules, power specifications, clocking resources, I/O specifications, PCB layout guides, design checklists‚Ä¶ even a 4MB Excel spreadsheet for estimating power consumption! And believe me, Xilinx didn‚Äôt just write documentation for fun: there‚Äôs so much documentation because the chip  this much documentation.</p><p>Designing with the FPGA was overwhelming, and  beyond my experience level. At several points I genuinely considered dropping the project altogether. Fortunately, I persevered, and gradually internalized a lot of the information. I also read through the schematics of any open-source Artix-7 development board I could get my hands on. Seeing what other people were doing gave me more confidence that I was doing the right thing.</p><p>Eventually, after I placed all of the components, connected them, ensured all of the nets were labeled, and ran KiCad‚Äôs electrical rules checker (ERC) to find obvious mistakes, I moved on to layout.</p><p>I did PCB layout at the same time as some of the initial enclosure CAD. The mechanics of how everything fit together influenced the placement of the display connector, cartridge slot, buttons, speakers, and connectors. After I came up with a plausible enclosure design, I placed some of the first key components onto the PCB and locked them into place while I did the rest of the routing.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/early-shell-design.png\" alt=\"Rough enclosure design to help with board layout\" width=\"2000\" height=\"1298\"><figcaption><p>Rough enclosure design to help with board layout</p></figcaption></figure><p>I first focused on components that would be hardest to route. Primarily, the FPGA: the package I was using (CSG324) is a <a href=\"https://en.wikipedia.org/wiki/Ball_grid_array\">BGA</a>, 18x18 with 0.8mm pitch between pins. ‚ÄúFanning out‚Äù all of the I/O signals requires careful routing, and at 0.8mm pitch, it‚Äôs difficult to do this routing with cheap PCB manufacturing techniques. I ended up being able to do this routing with a 6-layer PCB (three signal, two ground, one power), with 0.1mm track width and spacing, and 0.4/0.25mm vias. Fortunately, this is all within the realm of JLCPCB‚Äôs capabilities.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/bga-fanout.png\" alt=\"BGA fanout with thin traces and small vias\" width=\"1442\" height=\"1102\"><figcaption><p>BGA fanout with thin traces and small vias</p></figcaption></figure><p>As I routed signals out from the FPGA to other parts, I assigned those signals to the FPGA pins. Similarly, with the MCU, I assigned signals to pins in a way that made routing easier. Certain signals had restrictions (e.g. on the FPGA, the main 50 MHz clock signal can only go into certain pins, or the configuration bitstream can only go to certain pins, or certain pins are differential pairs for HDMI output), but overall, I had a lot of flexibility with pin assignment.</p><p>KiCad has a feature where it automatically backs up your project as you work on it. I changed the settings to save every 5 minutes and not delete old backups, which allowed me to generate this timelapse of my layout process:</p><figure><figcaption><p>Revision 1 board layout timelapse</p></figcaption></figure><p>Once I finished placing and routing all of the components, I ran the design rules checker (DRC) and fixed issues. I hesitated for a while before sending the PCB for manufacturing. I re-read the schematics, reviewed the layout, and eventually felt confident enough that I was done. I submitted the order to JLCPCB, and after a few questions by their engineers about component placement, they started manufacturing it.</p><h2>Board testing and bring-up<a hidden=\"\" aria-hidden=\"true\" href=\"https://eli.lipsitz.net/posts/introducing-gamebub/#board-testing-and-bring-up\">#</a></h2><p>After two weeks or so, I received the assembled boards in the mail:</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/rev1-initial-boards.jpg\" alt=\"An assembled board and an unassembled board\" width=\"1440\" height=\"1026\"><figcaption><p>An assembled board and an unassembled board</p></figcaption></figure><p>First, I probed the power rail test points with a multimeter to check for shorts. Then, I plugged the boards in for the first time, and pressed the power button. To my delight, the green LED turned on, indicating that the power button circuit, power path, and 3.3V regulator worked. The microcontroller USB enumerated, and I could see that it logged some errors (since I hadn‚Äôt flashed anything to it yet).</p><p>I intended to write the MCU firmware in Rust, but I did initial board testing and bring-up with <a href=\"https://micropython.org/\">MicroPython</a>. This would let me interactively type in Python and write basic scripts to communicate with the peripherals on the board and make sure I had connected everything correctly. I didn‚Äôt have to worry about writing efficient or well-organized code, and could just focus on functionality.</p><p>I flashed the MicroPython firmware image, and wrote a couple lines of Python to blink the LED. I powered on the FPGA power domain, and checked that the , , and  rails had the correct voltage.</p><p>Next, I wrote a simple bitstream for the FPGA that read the state of the buttons and produced a pattern on the shared signals between the FPGA and the MCU. I wrote simple Python code to configure the FPGA, loaded up the bitstream, and polled the signals from the FPGA. Pressing buttons changed the state, and confirmed that the FPGA was properly powered, and configurable from the MCU.</p><p>After I confirmed the FPGA worked, I started writing a simple display driver to initialize the LCD and push some pixels from the MCU over SPI. The initialization sequence uses a number of LCD-specific parameters (voltages, gamma correction, etc.), that I learned from the LCD manufacturer‚Äôs example code.</p><figure><figcaption><p>(Slowly) pushing pixels to the LCD</p></figcaption></figure><p>The LCD module‚Äôs controller, an ILI9488, has a few quirks: despite claiming that it supports 16-bit colors over SPI, it actually only supports 18-bit colors. This unfortunately meant that the MCU‚Äôs LCD driver would be more inefficient than I expected, since it has to expand 16-bit colors to 18-bit before sending them over the bus. This didn‚Äôt end up being a huge issue, however, because the FPGA is the one driving the display most of the time.</p><p>Another quirk (hardware bug?) is that the ILI9488 doesn‚Äôt stop driving its SPI output line, even when its chip-select signal is inactive. This means that the chip will interfere with any other communication on the bus‚Ä¶ including the FPGA, which sits on the same bus. I never actually needed to read any data back from the LCD (and even if I did, it supports <a href=\"https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Three-wire\">three-wire SPI</a>), so I just cut the trace between the LCD‚Äôs SDO line and the SPI bus.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/lcd-debugging.jpg\" alt=\"Debugging the LCD test code\" width=\"1440\" height=\"954\"><figcaption><p>Debugging the LCD test code</p></figcaption></figure><h3>Trouble with power domains<a hidden=\"\" aria-hidden=\"true\" href=\"https://eli.lipsitz.net/posts/introducing-gamebub/#trouble-with-power-domains\">#</a></h3><p>I started trying to communicate with the I2C peripherals (I/O expander, RTC, etc.), and found that nothing was responding. A bit of probing with a logic analyzer revealed that the SCL/SDA lines were being held low, and that powering on the FPGA power domain let the lines be pulled high and communication to happen.</p><p>I deduced that this was due to the DAC, which had its IOVDD powered by , which likely caused its protection diodes to pull the IO lines (SCL and SDA) low:</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/dac-iovdd-issue.png\" alt=\"The problematic portion of the schematic\" width=\"1862\" height=\"656\"><figcaption><p>The problematic portion of the schematic</p></figcaption></figure><p>I tested out this theory by cutting the PCB traces connecting the DAC‚Äôs IOVDD and  with a knife. After this, I2C worked even with the FPGA power disabled. Then, I tested a possible fix by adding a wire to power the DAC‚Äôs IOVDD from the  rail. I confirmed that I could still talk to the other I2C devices, and once enabling FPGA power, that I could talk to the DAC too.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/dac-iovdd-rework.jpg\" alt=\"DAC IOVDD rework\" width=\"1440\" height=\"1126\"></figure><p>While bringing up the LCD, I saw that the FPGA was also pulling down the shared SPI bus lines while it was unpowered. Not enough to prevent communication with the LCD, but it still wasn‚Äôt great. Between this and the DAC issue, I learned an important EE lesson: be careful when connecting components in different power domains together. A tristate buffer, such as the <a href=\"https://www.ti.com/product/SN74LVC1G125\">74LVC1G125</a>, could have helped here to isolate the buses.</p><p>Once I2C was working, I wrote some basic driver code for the fuel gauge, real-time clock, IMU, and I/O expander, just to check that they all worked correctly. I also checked that the MCU could read from and write to the attached microSD card.</p><h4>Audio and video output from the FPGA<a hidden=\"\" aria-hidden=\"true\" href=\"https://eli.lipsitz.net/posts/introducing-gamebub/#audio-and-video-output-from-the-fpga\">#</a></h4><p>Next, I updated my testing FPGA bitstream to output a test pattern over the <a href=\"https://hackaday.com/2024/01/25/displays-we-love-hacking-parallel-rgb/\">LCD parallel interface (‚ÄúDPI‚Äù)</a>, and a test tone to the DAC over the I2S interface. Then, I began poking on the MCU side to configure the LCD controller and DAC appropriately.</p><p>With some amount of trial and error, I convinced the LCD to accept input from the FPGA. Most of the trial and error revolved around the rotation of the LCD module. Soon after, I configured the DAC properly, and it played the test tone from the FPGA over the speakers and the headphones.</p><figure><figcaption><p>WIP video output from the FPGA</p></figcaption></figure><p>At this point, much of the board was working, so I soldered on the rest of the components (cartridge slot, cartridge switch, link port, shoulder buttons).</p><p>With the cartridge slot in place, I had everything I needed to port over the Game Boy emulator from my last project. I did a quick-and-dirty port of the emulator, with some hacking around to connect the core to the audio, video, and the physical cartridge. I was able to play the first Game Boy game on the device far sooner than I was expecting:</p><figure><figcaption><p>Pokemon Silver running from cartridge</p></figcaption></figure><p>I spent the next month or so implementing things on the FPGA. I started on the SPI receiver implementation, so that the MCU and FPGA could communicate.</p><p>It was relatively straightforward to write <a href=\"https://github.com/elipsitz/gamebub/blob/handheld/fpga/src/main/scala/platform/handheld/SpiReceiver.scala\">the initial version</a>, which 4x oversampled the SPI signals from the main system clock. For the Game Boy, that was ~8 MHz, for a maximum SPI speed of 2 MHz. The MicroPython ESP32-S3 SPI implementation supported only single SPI, so that allowed for a maximum transfer speed of 256 KB/s. This was sufficient to do most of my initial testing, but I later <a href=\"https://github.com/elipsitz/gamebub/blob/handheld/fpga/src/main/scala/platform/handheld/SpiReceiverFifo.scala\">wrote an improved SPI receiver</a> to run with an internal 200 MHz clock (from a PLL that turned on and off with the chip-select signal to save power), communicating with the rest of the system via a pair of FIFOs. This added a lot of complexity and edge cases, but it greatly improved performance, allowing the bus to run at 40 MHz.</p><p>I wrote the SPI interface to the FPGA with memory-like semantics: each SPI transfer starts with a command byte, encoding whether it‚Äôs a read or write transfer, the size of each word in the transfer (8, 16, or 32 bits), and whether the ‚Äútarget address‚Äù should autoincrement as the transfer progresses. Then, a 32-bit address, followed by reading or writing the data. Each thing that the MCU might want to access (control registers, blocks of memory) are mapped into the 32-bit address space.</p><p>As with my previous FPGA project, I wrote almost all of the FPGA code in <a href=\"https://www.chisel-lang.org/\">Chisel</a>, a Scala-based HDL. The remaining bits were the top-level Verilog. Chisel made it really simple to parametrize, compose, and test the various modules that I wrote.</p><p>Once I had the SPI receiver working, I wrote controllers for the on-board SRAM and SDRAM. The SRAM was relatively simple (although I still got it slightly wrong at first). The SDRAM was a bit tricky, and even as I write this I‚Äôm not quite satisfied with its performance, and intend to rewrite it in the future.</p><p>I exposed the SRAM and SDRAM interfaces to the MCU via SPI, which allowed me to read and write to these pieces of memory from the MCU. I used this a lot for testing: writing patterns into memory and reading them back to ensure that read and write both worked.</p><p>Side note: SDRAM has to be continuously refreshed, otherwise the stored data decays over time. It depends on the chip, but typically each row has to be read and written back (or auto-refreshed, which does the same thing) at least once every 64 milliseconds to avoid losing state. What I found interesting, however, is that the data can actually persist for quite a bit longer. I discovered that when I was reconfiguring the FPGA between tests, most of the test data that I had previously written would still stick around even without being refreshed. In the first few seconds some bits would start flipping, and over the course of a few minutes, most of what was written was completely unintelligible.</p><p>With the SDRAM controller and SPI receiver written, I was then able to implement the ‚Äúemulated cartridge‚Äù part of the Game Boy emulator, where the MCU reads a ROM file off of the microSD card and sends it to the FPGA to be stored in SDRAM. Then, the FPGA ‚Äúemulates‚Äù a cartridge (rather than interfacing with a real physical cartridge). After a few stupid mistakes, I was able to run test ROMs and homebrew. As an added bonus, since I was using my own SDRAM controller directly, I didn‚Äôt have any of <a href=\"https://eli.lipsitz.net/posts/fpga-gameboy-emulator/#fixing-an-audio-bug-on-the-game-boy-color\">the performance issues I‚Äôd faced before</a> when accessing the ROM stored in memory.</p><h2>Writing the microcontroller firmware in Rust<a hidden=\"\" aria-hidden=\"true\" href=\"https://eli.lipsitz.net/posts/introducing-gamebub/#writing-the-microcontroller-firmware-in-rust\">#</a></h2><p>By this point I had tested, in some form or another, all of the different components of the system. I‚Äôm really surprised that everything worked in my first board revision ‚Äì even the rework I did early on wasn‚Äôt actually required for functionality.</p><p>I decided now was a good time to start building an interactive GUI. Up until this point, I had just been running commands in the MicroPython REPL. However, I didn‚Äôt want to build a whole UI in Python just to throw it away later, so I also started working on the ‚Äúproduction‚Äù Rust firmware.</p><p>In the last few years, a lot of progress has been made towards making Rust on the ESP32 chips work well, even on the chips that use the Xtensa ISA. I followed the <a href=\"https://docs.esp-rs.org/book/\">Rust on ESP Book</a> and quickly had an environment set up. I opted for the <a href=\"https://docs.esp-rs.org/book/overview/using-the-standard-library.html\">‚ÄúRust with the Standard Library‚Äù</a> approach, so that I could benefit from <a href=\"https://idf.espressif.com/\">ESP-IDF</a>, especially the built-in support for USB and SD cards with the FAT filesystem.</p><p>I started porting over the drivers I had written in Python. I found embedded Rust to be a bit verbose in some cases, but overall pleasant to use and worth the (little) trouble.</p><p>I starting writing my own minimal GUI framework for basic menus. I poked around with the <a href=\"https://docs.rs/embedded-graphics/latest/embedded_graphics/\"></a> library, but soon found that the typical patterns I was expecting to use weren‚Äôt a great fit for Rust. I also started planning out different screens and realized that I probably actually wanted to use a more comprehensive UI framework.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/early-gui-main-menu.png\" alt=\"Early main menu screen\" width=\"480\" height=\"320\"></figure><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/early-gui-rom-select.png\" alt=\"Early rom select screen\" width=\"480\" height=\"320\"></figure><p>Ultimately, I settled on <a href=\"https://github.com/slint-ui/slint\">Slint</a>, a Rust-native declarative GUI framework with excellent support for embedded devices. Slint has a custom DSL to describe the UI and composable components. After a bit of practice I found myself to be really productive with it. I enjoyed using Slint, and I‚Äôd use it again in the future. The authors are responsive on GitHub, and the project has steadily improved over the year or so that I‚Äôve been using it.</p><p>There were a few rough edges for my use case, however:</p><ul><li>The built-in GUI elements and examples were all heavily oriented around mouse or touchscreen navigation. Game Bub only has buttons for navigation, however, so I had to make my own widgets (buttons, lists) that worked with key navigation. This involved a few hacks, because Slint‚Äôs focus handling was a little bit simplistic.</li><li>The built-in GUI styles looked (in my opinion) bad on a low DPI screen. Text was excessively anti-aliased and hard to read at small sizes. This was also fixed by building my own widgets.</li><li>Slint doesn‚Äôt have a great story around supporting different ‚Äúscreens‚Äù ‚Äì I had to build some of my own infrastructure to be able to support navigation between the main menu, games, rom select, settings, etc.</li></ul><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/screenshot-main-menu.png\" alt=\"Main menu\" width=\"480\" height=\"320\"></figure><p>The GUI is rendered on the MCU, and then the rendered framebuffer is sent over to the FPGA. Slint supports partial rendering, where only the parts of the screen that have changed are updated, which improved performance. The FPGA maintains a copy of the framebuffer and ultimately is responsible for driving the display. This has a few advantages over driving the display directly from the MCU:</p><ul><li>Sending a framebuffer at 40 MHz QSPI to the FPGA is 16x faster than sending it to the LCD controller at 10 MHz (the fastest speed supported by the ILI9488)</li><li>The UI is rendered at 240x160 to improve performance and maintain the GBA aesthetic, but the LCD controller doesn‚Äôt have a scaler, so the MCU would have to send 4x the pixels. The FPGA can easily scale the UI framebuffer itself.</li><li>The FPGA can composite the emulator output with a semi-transparent ‚Äúoverlay‚Äù to support an in-game menu, volume / brightness bars, battery notifications, etc.</li><li>An external display (e.g. monitor or TV) can be driven by the FPGA via HDMI</li></ul><p>I spent some time making a variety of firmware improvements, mostly polish and quality-of-life. I added a settings screen to set the date and time, whether to use Game Boy (DMG) or Game Boy Color (CGB) mode when playing Game Boy games, etc.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/screenshot-settings-early.png\" alt=\"Settings screen\" width=\"480\" height=\"320\"></figure><p>Then I improved the ROM select file browser, and added a battery level indicator.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/screenshot-load-rom.png\" alt=\"Rom select screen\" width=\"480\" height=\"320\"></figure><p>I also got sick of having to take the microSD card out of the device and connect it to my computer through a series of adapters (microSD to SD to USB-A to USB-C), so I implemented a basic utility to expose the microSD card as a USB Mass Storage Device, using <a href=\"https://github.com/hathach/tinyusb\">TinyUSB</a> and the ESP32-S3‚Äôs USB-OTG capabilities.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/screenshot-usb-storage.png\" alt=\"USB Mass Storage screen\" width=\"480\" height=\"320\"></figure><p>It was a little bit more difficult than I expected, because USB Mass Storage requires the device to provide raw block access. This means that the filesystem has to be unmounted by the device, otherwise the device and host could conflict and corrupt the filesystem. The ESP32-S3 also only supports USB Full Speed, for a practical maximum transfer speed of ~600KB/sec. It‚Äôs really useful for transferring save files or updating the FPGA bitstreams, but less useful for transferring a large number of ROM files.</p><p>Later, I implemented <a href=\"https://gbdev.io/pandocs/MBC7.html\">MBC7</a> support in the Game Boy emulator for Kirby Tilt ‚Äôn Tumble, using the on-board accelerometer.</p><p>After I implemented a decent amount of software functionality, I decided to finish the enclosure design. The bare board just wasn‚Äôt cutting it anymore, and the taped LCD module/loose speakers/rubber-banded battery contraption was fragile.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/gamebub-without-shell.jpg\" alt=\"Game Bub looking rough without an enclosure\" width=\"1440\" height=\"1724\"><figcaption><p>Game Bub looking rough without an enclosure</p></figcaption></figure><p>I came into this project without any CAD or 3D printing experience. I looked at a few different CAD software packages, and I ultimately settled on <a href=\"https://www.freecad.org/\">FreeCAD</a>, primarily because it was free and open source. I learned how to use the software with some video tutorials. FreeCAD, unfortunately, was a little bit rough around the edges and I ended up running into some annoying issues. Nevertheless, I powered through and finished the design.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/enclosure-rev1-cad.png\" alt=\"FreeCAD view of the enclosure and some buttons\" width=\"2000\" height=\"1524\"><figcaption><p>FreeCAD view of the enclosure and some buttons</p></figcaption></figure><p>I found parametric modeling, where the geometry of the model is defined by constraints and dimensions, to be intuitive. However overall, I found 3D CAD to be very time consuming. I think a large part of this is my inexperience, but thinking in three dimensions is a lot more difficult than, say, a 2D PCB layout. Creating a full assembly was even more difficult: I had to visualize how the front and rear pieces would fit together, where the screws would go, and how the buttons, screen, speaker, cartridge slot, battery, and ports would all fit in. This project definitely pushed the boundaries of my (previously non-existent) product design skills.</p><p>After finishing the design, I printed out the technical drawing at a 1:1 scale and physically placed the board and other components down as a final check. Then, I sent it to JLCPCB for manufacturing. I opted for <a href=\"https://en.wikipedia.org/wiki/Stereolithography\">SLA resin printing</a>, for high precision and a smooth finish.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/shell-rev1-technical-drawing.png\" alt=\"Enclosure technical drawing\" width=\"1440\" height=\"971\"><figcaption><p>Enclosure technical drawing</p></figcaption></figure><p>After a couple weeks, I got the finished enclosure and custom buttons back.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/enclosure-rev1-outside.jpg\" alt=\"Front and rear half, outside\" width=\"1440\" height=\"1009\"><figcaption><p>Front and rear half, outside</p></figcaption></figure><p>I put the buttons, speakers, and screen into the enclosure, screwed on the PCB, and put the whole thing together.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/assembling-front.jpg\" alt=\"Assembling the front side\" width=\"1440\" height=\"1544\"><figcaption><p>Assembling the front side</p></figcaption></figure><figure><figcaption><p>Game Bub, fully assembled and functional</p></figcaption></figure><p>I wasn‚Äôt sure how dimensionally accurate the 3D printing would be, so I added a lot of extra clearance around the buttons and ports. As it turned out, the printing was very precise, so the buttons rattled around a little in the oversized button holes.</p><p>It‚Äôs a little bit chunky (smaller than an original Game Boy, though!) and the ergonomics aren‚Äôt ideal, but I was really happy to finally have an enclosure. It actually started (sort of) looking like a real product, and I wasn‚Äôt constantly worried about breaking it anymore.</p><h2>Game Boy Advance support<a hidden=\"\" aria-hidden=\"true\" href=\"https://eli.lipsitz.net/posts/introducing-gamebub/#game-boy-advance-support\">#</a></h2><p>I won‚Äôt go into all of the details of how I wrote the emulator here (this article is already long enough!). If you‚Äôre interested, my <a href=\"https://eli.lipsitz.net/posts/fpga-gameboy-emulator/\">previous article about my Game Boy FPGA emulator</a> goes into detail about the general process of writing an emulator, and for a high-level introduction to the Game Boy Advance (from a technical perspective), I recommend <a href=\"https://www.copetti.org/writings/consoles/game-boy-advance/\">Rodrigo Copetti‚Äôs article</a>. In general, I tried to implement the emulator the way it might actually have been implemented in the original hardware: each cycle of the FPGA corresponds to one actual hardware cycle (no cheating!).</p><p>As with the Game Boy, I did nearly all of my development with a simulator backed by <a href=\"https://www.veripool.org/verilator/\">Verilator</a> and <a href=\"https://www.libsdl.org\">SDL</a>. By the end of the development process, the simulator was running at about 8% of the real-time speed (on an M3 MacBook Air with excellent single-core performance), which was a bit painful.</p><p>The Game Boy Advance CPU, the <a href=\"https://en.wikipedia.org/wiki/ARM7#ARM7TDMI\">ARM7TDMI</a>, is significantly more complicated than the Game Boy‚Äôs SM83 (a <a href=\"https://en.wikipedia.org/wiki/Zilog_Z80\">Z80</a> / <a href=\"https://en.wikipedia.org/wiki/Intel_8080\">8080</a>-ish hybrid). However, in some ways, it was easier to understand and implement: the ARM7TDMI is much closer to a simple modern processor architecture, and it‚Äôs extensively documented by ARM. For example, the <a href=\"https://developer.arm.com/documentation/ddi0210/c/?lang=en\">ARM7TDMI Technical Reference Manual</a> has block diagrams and detailed cycle-by-cycle instruction timing descriptions.</p><p>I had a lot of fun <a href=\"https://github.com/elipsitz/gamebub/tree/handheld/fpga/src/main/scala/gba/cpu\">implementing the CPU</a>. The architecture has a three-stage pipeline (fetch, decode, execute) ‚Äì a division that feels natural when you implement it in hardware. The ARM7TDMI has two instruction sets: the standard 32-bit ARM instruction set, and the compressed 16-bit THUMB instruction set. I implemented the CPU the way it works in hardware, where the only difference between ARM and THUMB is the decode stage.</p><p>As I was implementing the CPU, I wrote <a href=\"https://github.com/elipsitz/gamebub/blob/handheld/fpga/src/test/scala/gba/cpu/ARM7TDMISpec.scala\">test cases</a> for each instruction. Each test checks the functionality of the instruction: processor state, register values after, as well as the cycle-by-cycle behavior and interaction with the memory bus. This was helpful for catching regressions as I implemented more and more control logic. It was also really satisfying to be able to implement individual instructions, then write the tests, and check that everything worked.</p><p>Chisel made it easy to write out the <a href=\"https://github.com/elipsitz/gamebub/blob/handheld/fpga/src/main/scala/gba/cpu/Control.scala\">CPU control logic</a>. The CPU control logic is a state machine that generates microarchitectural control signals (e.g. bus A should hold the value from the first read register, bus B should hold an immediate value, the memory unit should start fetching the computed address, etc.). Chisel allowed me to collect common functionality into functions (e.g.  to set up the signals to dispatch the next decoded instruction, or  to signal that the pipeline should be flushed and a new instruction should be fetched from the current program counter).</p><p>I found it helpful to draw out timing diagrams with <a href=\"https://wavedrom.com\">WaveDrom</a> when working through instructions, especially to deal with the pipelined memory bus.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/timing-arm7tdmi-branch.svg\" alt=\"My timing diagram of the ARM7TDMI branch instructions\"><figcaption><p>My timing diagram of the ARM7TDMI branch instructions</p></figcaption></figure><p>By mid-May (about a month later), I finished the CPU implementation (with occasional bug fixes after) and moved onto the rest of the system.</p><h3>PPU, MMIO, and everything else<a hidden=\"\" aria-hidden=\"true\" href=\"https://eli.lipsitz.net/posts/introducing-gamebub/#ppu-mmio-and-everything-else\">#</a></h3><p>Over the next month and a half, I implemented the majority of the rest of the Game Boy Advance. The CPU interacts with the rest of the system via <a href=\"http://problemkaputt.de/gbatek-gba-i-o-map.htm\">memory-mapped IO (MMIO)</a> registers. Unlike the Game Boy CPU, which can only access memory a single byte at a time, the ARM7TDMI can make 8-bit, 16-bit, and 32-bit accesses. This complicates MMIO, and the different hardware registers and memory regions in the GBA respond to different access widths in different ways.</p><p>I started with the Picture Processing Unit (PPU), which produces the video output. The author of <a href=\"https://github.com/nba-emu/NanoBoyAdvance\">NanoBoyAdvance</a>, fleroviux, had helpfully documented the <a href=\"https://nba-emu.github.io/hw-docs/ppu/ppu.html\">PPU VRAM access patterns</a>, which gave a lot of insight into how the PPU might work internally. <a href=\"https://www.coranac.com/tonc/text/toc.htm\">Tonc</a> was also immensely helpful for implementing the PPU and testing individual pieces of functionality.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/tonc-test.png\" alt=\"(Sort of) running a Tonc PPU demo\" width=\"963\" height=\"699\"><figcaption><p>(Sort of) running a Tonc PPU demo</p></figcaption></figure><p>The PPU took a few weeks, and then I moved onto DMA, followed by hardware timers, and audio. Of course, as I‚Äôd try new tests, demos, and games, I‚Äôd uncover bugs and fix them.</p><figure><figcaption><p>Kirby  in Dream Land</p></figcaption></figure><p>Game Boy and Game Boy Advance cartridges use the same 32-pin connector. However, they work very differently. The Game Boy cartridge bus is asynchronous: the game outputs the 16-bit address (64 KiB address space) on one set of pins and lowers the  pin. Some time later, the 8-bit read data from the ROM stabilizes on a separate set of pins.</p><p>For the GBA, Nintendo extended the bus data width to 16-bit and the address space to 25-bit (32 MiB). However, they kept roughly the same set of pins, accomplishing this by multiplexing the 24 data/address pins: the console outputs the address (in increments of the data word size of 16-bits, for a 24-bit physical address), then lowers the  signal to ‚Äúlatch‚Äù the address in the cartridge. Then, each time the console pulses the  pin, the cartridge increments its latched address and outputs the next data over the same pins. This allows for a continuous read of sequential data without having to send a new address for each access. The GBA also allows games to <a href=\"http://problemkaputt.de/gbatek-gba-system-control.htm\">configure cartridge access timings</a> to support different ROM chips.</p><p>I had to do a lot of my own research here. Software emulators don‚Äôt need to care about the precise timing of the cartridge bus, so there wasn‚Äôt much documentation. To figure out the exact cycle-accurate timing, I used a <a href=\"https://www.saleae.com/\">Saleae</a> logic analyzer and connected it to the cartridge bus. I wrote a test program for the GBA to do different types of accesses (reads, writes, sequential, non-sequential, DMA) with different timing configurations.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/cartridge-bus-analyzer.jpg\" alt=\"Cartridge bus analysis setup\" width=\"1440\" height=\"1080\"><figcaption><p>Cartridge bus analysis setup</p></figcaption></figure><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/trace-gba-cartridge.png\" alt=\"Portion of a trace\" width=\"2582\" height=\"734\"></figure><p>After coming up with numerous scenarios (especially around the interaction between DMA and the CPU, and starting and stopping burst accesses), I came up with a consistent model for how cartridge accesses worked. I created some timing diagrams to help:</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/cartridge-timing-diagram.svg\" alt=\"Timing diagram of a non-sequential access followed by a sequential access\"><figcaption><p>Timing diagram of a non-sequential access followed by a sequential access</p></figcaption></figure><p>Finally, I started implementing the cartridge controller state machine based on my observations, paired with an emulated cartridge implementation. With the emulated cartridge, I was able to properly run real games in the simulator.</p><p>I quickly implemented physical cartridge support, to be able to finally run it on the actual FPGA. I connected the signals, built a new bitstream, and‚Ä¶ it didn‚Äôt work at all. The Game Boy Advance boot screen ran, but it didn‚Äôt get any further than that. I implemented the emulated cartridge on the FPGA (reading ROM files from the SD card), and it worked! Which was great, but physical cartridges still didn‚Äôt.</p><p>I used the logic analyzer to observe how my emulator was interacting with the cartridge compared to how an actual GBA, and found numerous issues.</p><p>One of the first things I noticed was short <a href=\"https://en.wikipedia.org/wiki/Glitch#Electronics_glitch\">glitches</a> on the  line. I knew these had to be glitches (rather than incorrect logic), because they were 8 nanoseconds long, much shorter than the ~59.6ns clock period. Since the cartridge latches the address on a falling edge of , glitches cause it to latch an address when it shouldn‚Äôt, screwing up reads.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/cartridge-bus-glitches.png\" alt=\"Glitches on the cartridge bus\" width=\"2177\" height=\"600\"><figcaption><p>Glitches on the cartridge bus</p></figcaption></figure><p>Here, I learned an important lesson in digital design: output signals should come directly from flip-flops, with no logic in between.</p><p>After each flip-flop outputs a new value (on the rising edge of the clock), the signals propagate through the chip. As they propagate, taking different paths of different lengths throughout the chip, the output from each lookup table (LUT) is unstable. These values only stabilize near the end of the clock cycle (assuming the design met timing closure), and then each flip-flop stores the stable value at the next rising edge. If you output a signal from logic, this instability is visible from outside of the chip, manifesting as glitches in the output signal. If you instead output the signal from a flip-flop, it‚Äôll change only on each clock edge, remaining stable in the middle.</p><p>And of course, I had written the cartridge controller without thinking about this, and  of the output signals were generated from logic. I rewrote the controller to output everything from flip-flops, which had a series of cascading changes since all of the signals now had to be computed one clock cycle earlier than I expected.</p><p>There were other issues too ‚Äì part of the problem was that my emulated cartridge model was too permissive, and didn‚Äôt catch some fairly obvious incorrect behavior. After a few days of intensive debugging with the logic analyzer, I got to the point where I could play games from physical cartridges.</p><figure><figcaption><p>Metroid: Zero Mission running from the cartridge</p></figcaption></figure><h4>Cartridge prefetch buffer<a hidden=\"\" aria-hidden=\"true\" href=\"https://eli.lipsitz.net/posts/introducing-gamebub/#cartridge-prefetch-buffer\">#</a></h4><p>The ARM7TDMI has a single shared instruction and data memory bus. As a result, a long series of sequential memory accesses is rare. Even a linear piece of code without branches that includes ‚Äúload‚Äù or ‚Äústore‚Äù instructions would produce a series of non-sequential memory accesses, as the CPU fetches an instruction from one location, loads a register from a different location, and then goes back to fetching the next instruction.</p><p>This poses a real performance issue on the GBA, because every non-sequential access from the cartridge incurs a multi-cycle penalty. Nintendo attempted to mitigate this somewhat with the ‚Äúprefetch buffer‚Äù (<a href=\"https://mgba.io/2015/06/27/cycle-counting-prefetch/#game-pak-prefetch\">read this post by endrift, the author of mGBA, for more details</a>) which attempts to keep a cartridge read burst active between CPU accesses. Without emulating the prefetch buffer, some games lag (I noticed this the most in Mario Kart Super Circuit, and some rooms of Metroid: Zero Mission).</p><p>The prefetch buffer, while simple in theory, is not well documented and has a lot of corner cases and weird interactions. Emulator developers often start by taking a shortcut: making all cartridge accesses take a single cycle when the prefetch buffer is enabled. This wouldn‚Äôt work for me, since I actually had to interface with the physical cartridge.</p><p>So, I set out to do some more research to figure out exactly how the prefetch buffer worked. After making some educated guesses and tests, I came up with a reasonable model of how it might work.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/prefetch-notes.jpg\" alt=\"Notes about the prefetch state machine\" width=\"1440\" height=\"1744\"><figcaption><p>Notes about the prefetch state machine</p></figcaption></figure><p>Actually implementing it took a lot of work, and I kept stumbling upon more and more corner cases. Eventually I got to the point where all games appeared to run at full speed, and most importantly, didn‚Äôt randomly crash. My implementation isn‚Äôt perfect: there are still a few <a href=\"https://github.com/mgba-emu/suite\">mGBA test suite</a> timing tests I don‚Äôt pass, but it‚Äôs certainly sufficient to play games.</p><ul><li>: standard duplex SPI, used for communicating with accessories</li><li>: custom multi-drop UART-like protocol, used to link up to four GBAs together for multiplayer games</li><li>: the Nintendo N64 and GameCube controller protocol, used to connect to a GameCube</li><li>: duplex <a href=\"https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter\">UART</a> with flow control, </li><li>: controlling the four pins individually as <a href=\"https://en.wikipedia.org/wiki/General-purpose_input/output\">GPIO</a>, </li></ul><p>The timing of these isn‚Äôt well documented, so I did my own research.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/gba-link-multiplayer-transfer.png\" alt=\"A multiplayer mode transfer with no attached consoles\" width=\"2012\" height=\"558\"><figcaption><p>A  mode transfer with no attached consoles</p></figcaption></figure><p>I did a lot of testing with examples from the <a href=\"https://github.com/afska/gba-link-connection\">gba-link-connection</a> library, intended for homebrew GBA games, but helpful for testing the different transfer modes in a controlled environment.</p><figure><figcaption><p>Multiplayer Mario Kart with Game Bub and a GBA</p></figcaption></figure><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/animal-crossing-gamecube-link.jpg\" alt=\"Game Bub linked to a GameCube playing Animal Crossing\" width=\"1440\" height=\"1801\"><figcaption><p>Game Bub linked to a GameCube playing Animal Crossing</p></figcaption></figure><p>During the emulator development, I had used various test ROMs (mentioned before) to test basic functionality in isolation. As my emulator became mature enough to run commercial games, however, I started to shift some of my focus to accuracy-focused test ROMs.</p><p>These test ROMs (such as the <a href=\"https://github.com/mgba-emu/suite\">mGBA test suite</a>) generally test really specific hardware quirks and timing. For example, they might test what happens when you run an instruction that ARM calls ‚Äúunpredictable‚Äù, or the exact number of cycles it takes to service an interrupt in specific scenarios, or <a href=\"https://bmchtech.github.io/post/multiply/\">the value of the ‚Äúcarry‚Äù flag after performing a multiplication</a>. These are the kinds of things that don‚Äôt actually matter for playing games, but present a fun challenge and a way to ‚Äúscore‚Äù your emulator against others. This also highlights the collaborative nature of the emulation development community: people sharing their research and helping each other out.</p><p>I won‚Äôt talk about all of the tests here (for my emulator‚Äôs test results, <a href=\"https://github.com/elipsitz/gamebub/blob/handheld/docs/accuracy.md\">see this page</a>). But I do want to mention the <a href=\"https://tcrf.net/AGS_Aging_Cartridge\"></a>. This is an official test cartridge from Nintendo, likely used as part of a factory test or RMA procedure. Apparently, Nintendo has  used it to test their emulators (e.g. their GBA emulator on the Nintendo Switch). This test has generally been considered to be difficult to pass (it tests some specific hardware quirks), but it‚Äôs easier now that the tests have been <a href=\"https://github.com/DenSinH/AGSTests/\">thoroughly reverse engineered and documented</a>. Still, passing it is a nice milestone:</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/agb-aging-cartridge.png\" alt=\"Passing the AGB Aging Cartridge\" width=\"964\" height=\"700\"><figcaption><p>Passing the AGB Aging Cartridge</p></figcaption></figure><h2>Second hardware revision<a hidden=\"\" aria-hidden=\"true\" href=\"https://eli.lipsitz.net/posts/introducing-gamebub/#second-hardware-revision\">#</a></h2><p>Towards the end of 2024, approximately one year after I originally designed Game Bub, I decided to make a second hardware revision. Over the past year, I had been keeping track of all of the things I would want to change in a future revision. Since the first version of Game Bub miraculously worked without any major issues, this list was primarily minor issues and ergonomics changes.</p><p>I fixed the <a href=\"https://eli.lipsitz.net/posts/introducing-gamebub/#trouble-with-power-domains\">minor I2C power issues</a>, removed the <a href=\"https://en.wikipedia.org/wiki/Reference_designator\">reference designators</a> from the PCB silkscreen (they looked messy with the dense board, and I didn‚Äôt use them for anything anyway), and changed around some test points. I improved the rumble circuit to be more responsive, and switched to a PCB-mounted vibration motor.</p><p>The first version of Game Bub was fairly thick, measuring 12.9mm at the top and 21.9mm on the bottom. The thickness of the rear enclosure was dictated by the thickness of Game Boy cartridges, but I made several changes to the front. I moved the  (8.5mm!) link port to the back, and removed the HDMI port (more on that later). I changed the headphone jack (5.0mm tall ‚Äì no wonder they started getting removed from phones) to a mid-mount one that sunk into the PCB and reduced the overall height.</p><p>I also switched from an  module (3.1mm depth) to an  (2.4mm depth). I should have done this from the beginning, I just didn‚Äôt even know the ESP32-S3-MINI existed. This had the side effect of giving me 3 more GPIOs, which allowed me to put the FPGA and LCD on separate SPI busses, avoiding the minor issue of an unpowered FPGA interfering with LCD communication, and allowed for faster boot because the LCD could be configured at the same time as the FPGA.</p><p>I switched the speakers, from the fully-enclosed <a href=\"https://www.sameskydevices.com/product/audio/speakers/miniature-(10-mm~40-mm)/ces-20134-088pmb\">CES-20134-088PMB</a> to the <a href=\"https://www.sameskydevices.com/product/audio/speakers/miniature-(10-mm~40-mm)/cms-160903-18s-x8\">CMS-160903-18S-X8</a>. I made this change primarily for ease of assembly. The first speaker had a wire connector that plugged into the board, and I found it difficult to connect during assembly without having the wire interfere with buttons. The new speaker is smaller and has a spring contact connector, so it just presses against the PCB as the device is assembled. This required some speaker enclosure design ‚Äì an unenclosed speaker in free air sounds quiet and tinny.</p><p>I reworked the layout of the face buttons and D-pad to match the spacing of the Nintendo DSi. This allowed me to use the silicone membranes from the DSi for an improved button feel and reduced rattling. I was also hoping to use the plastic buttons from the DSi (which were higher quality compared to my 3D printed buttons), but even with the new thinner design, the buttons weren‚Äôt quite tall enough to be easily pressed.</p><p>I created another timelapse of my modifications to produce the second version of the PCB:</p><figure><figcaption><p>Revision 2 board layout timelapse</p></figcaption></figure><p>For the second revision of the enclosure, I switched to <a href=\"https://en.wikipedia.org/wiki/Fusion_360\">Fusion 360</a> for the CAD work. While I would have preferred to keep using FreeCAD, I found that it was making it harder for me to be productive. Fusion 360 has a free version for hobbyists (with some limitations that have gradually increased over time), and overall I‚Äôve found it very pleasant to use.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/enclosure-rev2-cad.png\" alt=\"Fusion 360 view of the second enclosure, fully assembled\" width=\"1774\" height=\"1472\"><figcaption><p>Fusion 360 view of the second enclosure, fully assembled</p></figcaption></figure><p>Unlike with the first revision, I waited until I had a final design for both the enclosure and the PCB before getting anything manufactured. This let me go back and forth, making small modifications to each of them as needed.</p><p>I wanted to make the end result look more polished and professional, so I contracted a factory to produce custom LCD cover glass, made out of 0.7mm thick tempered glass with a black silkscreen. It was relatively expensive for a low quantity order, but I‚Äôm really happy with how it turned out.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/lcd-cover-glass.jpg\" alt=\"Custom LCD cover glass with adhesive backing\" width=\"1440\" height=\"1369\"><figcaption><p>Custom LCD cover glass with adhesive backing</p></figcaption></figure><h3>Manufacturing and assembly<a hidden=\"\" aria-hidden=\"true\" href=\"https://eli.lipsitz.net/posts/introducing-gamebub/#manufacturing-and-assembly\">#</a></h3><p>I got the PCBs manufactured and assembled, this time with black solder mask to look .</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/pcb-rev-2.jpg\" alt=\"Assembled PCB, revision 2\" width=\"1440\" height=\"1073\"><figcaption><p>Assembled PCB, revision 2</p></figcaption></figure><p>I had two enclosures made. The first was black PA-12 Nylon, printed with <a href=\"https://en.wikipedia.org/wiki/Multi-jet_fusion\">MJF</a>. Nylon is strong and durable, and the MJF 3D printing technology produces a slightly grainy surface that‚Äôs really pleasant to hold in your hand.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/nylon-closeup.jpg\" alt=\"Closeup of the nylon grainy texture\" width=\"1440\" height=\"894\"><figcaption><p>Closeup of the nylon grainy texture</p></figcaption></figure><p>The second one was made of transparent resin (SLA, like before). This lets me show off the PCB that I worked so hard on, and evokes the transparent electronics trend from the 90s.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/gamebub-transparent.jpg\" alt=\"Transparent Game Bub\" width=\"1440\" height=\"1920\"></figure><p>Assembly was a lot easier this time around: the silicone membranes held the face buttons in place, the speakers had a spring contact instead of wires, and the shoulder button assembly was better. In the first revision, I had excessively large tolerances because I wasn‚Äôt sure how precise the 3D printing would be. In the second version, I was able to shrink these.</p><p>The final product looked and felt a lot better, too. The edges were more rounded, and the device was thinner and easier to hold. The buttons felt  better to press and didn‚Äôt rattle around, and the cover glass over the LCD added polish.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/gamebubs-side-by-side.jpg\" alt=\"First revision (left), second revision (center and right)\" width=\"1440\" height=\"742\"><figcaption><p>First revision (left), second revision (center and right)</p></figcaption></figure><p>I previously mentioned that I removed the full-size HDMI port from the first revision. I had first planned to change it to a mini-HDMI or micro-HDMI port to reduce the size, but I was worried about durability.</p><p>What I  wanted to do was output video through the USB-C port, avoiding the need for any HDMI port at all. Unfortunately, I had already concluded earlier that I wouldn‚Äôt be able to output <a href=\"https://en.wikipedia.org/wiki/DisplayPort\">DisplayPort</a> video signals from the FPGA, which meant that I couldn‚Äôt use the standard USB-C DisplayPort alternate mode.</p><p>However, an idea struck me towards the end of 2024: I didn‚Äôt actually  to use the DisplayPort alt-mode. The USB-C connector, in addition to the USB 2.0 D+/D- pins, has four differential pairs (for USB superspeed). Conveniently, HDMI  uses four differential pairs. The USB specification allows for vendor-specific alt-modes, so I could just implement my own, outputting the HDMI signal directly from the FPGA over the additional pins. Then I could build a custom dock that takes those pins and connects them to the data lines of an HDMI port.</p><p>According to the USB specification, alternate modes must be negotiated by both sides first, using the USB-C Power Delivery (USB-PD) protocol, to prevent them from interfering with devices that aren‚Äôt expecting them. I don‚Äôt actually have a USB-PD controller in Game Bub (too much added complexity), so I took a shortcut: have a microcontroller in the dock communicate with the Game Bub over regular USB and perform a handshake before enabling HDMI output from the FPGA. Once Game Bub detects that it‚Äôs been disconnected from the dock, it can just switch back to using the internal display.</p><p>I realized that the dock also presents another opportunity for controller support. I originally wanted to build wireless controller support into the handheld, but the ESP32-S3 only supports Bluetooth Low Energy, and the majority of controllers use Bluetooth Classic. Fortunately, the <a href=\"https://en.wikipedia.org/wiki/Raspberry_Pi#Raspberry_Pi_Pico\">Raspberry Pi Pico W</a> (with an RP2040 MCU) supports both types of Bluetooth, so I just decided to use that as the microcontroller on the dock. Game controllers connect to the dock over Bluetooth, and the Pico sends the controller inputs to the device. I wired up the  and  USB-C pins as a direct connection between the FPGA and the dock for low latency input.</p><p>The RP2040 acts as the USB host, and Game Bub only needs to be a device. I also added a USB hub chip and some additional USB ports on the back of the dock to allow for wired controller support too. Just like with wireless controllers, the dock handles the direct controller communication, and just passes inputs back to the main Game Bub unit.</p><p>Since the dock is so simple (comparatively), it only took about a day to design and lay out.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/dock-pcb.jpg\" alt=\"Assembled dock PCB\" width=\"1440\" height=\"1016\"></figure><p>I had also hoped to use the dock to solve another problem around HDMI output: HDMI sinks (monitors, TVs) pull the HDMI data lines up to 3.3 volts, and can actually backfeed power to the HDMI source. For Game Bub, this meant that a powered-off unit would turn itself on when connected over HDMI. I used a HDMI buffer chip in the dock to try to alleviate this problem, but the chip I used wasn‚Äôt actually properly suited to this use-case and interfered with video output, so I had to carefully rework the board to bypass the chip. I‚Äôll have to fix it in a later revision.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/dock-rework.jpg\" alt=\"Bypassing the HDMI buffer chip\" width=\"1440\" height=\"1359\"><figcaption><p>Bypassing the HDMI buffer chip</p></figcaption></figure><p>After the rework, HDMI output worked! The rest of the features are still a work in progress.</p><figure><img loading=\"lazy\" src=\"https://eli.lipsitz.net/posts/introducing-gamebub/media/bare-gamebub-in-dock.jpg\" alt=\"Game Bub PCB on the dock, connected to an external monitor\" width=\"1440\" height=\"2116\"><figcaption><p>Game Bub PCB on the dock, connected to an external monitor</p></figcaption></figure><p>Congratulations on reading this far! This writeup ended up being incredibly long, even with a lot of details left out.</p><p>I‚Äôm proud of what I accomplished over the last year and a half: I met all of my goals to produce a polished handheld FPGA retrogaming device. I pushed my electrical engineering and product design skills to the limit, and learned a lot in the process. Professional product and hardware designers deserve  respect.</p><p>I deliberately designed this project with lots of possible extension opportunities to keep me occupied for a long time. I worked hard to get to the point where I‚Äôm comfortable sharing Game Bub with the world, but I still have a long list of TODOs for the future.</p><p>In the near term, I‚Äôm going to work on finishing the dock, implementing wireless controller support (and maybe wired). I plan to use the <a href=\"https://github.com/ricardoquesada/bluepad32\">Bluepad32</a> library to do so.</p><p>I also want to improve the accuracy of my Game Boy Advance emulator: my goal here is to someday pass the entire <a href=\"https://github.com/mgba-emu/suite\">mGBA test suite</a>. I hope that I can contribute back to the wonderful  community with my emulator, and I plan to write-up some of my research around the GBA cartridge interface and link port.</p><p>I have a long list of mostly minor changes to make to the MCU firmware: improving UI render performance, bits of polish like low battery notifications, eliminating display glitching when reloading the FPGA, and that sort of thing. I also plan to add more utilities, like a cartridge dumper and save backup/restore feature.</p><p>Some day, I want to emulate the <a href=\"https://en.wikipedia.org/wiki/Game_Boy_Advance_Wireless_Adapter\">Game Boy Advance Wireless Adapter</a> over Wi-Fi, e.g. with <a href=\"https://docs.espressif.com/projects/esp-idf/en/stable/esp32s3/api-reference/network/esp_now.html\">ESP-NOW</a>. This won‚Äôt be compatible with the original wireless adapter, unfortunately, since that uses raw 2.4 GHz modulation rather than Wi-Fi.</p><p>I designed Game Bub with extremely low production volumes in mind, using off-the-shelf commodity parts to keep the overall cost down. However, there are a few things I would have liked to be able to do, but are only possible with much higher volumes:</p><ul><li>A better LCD module (likely custom): native landscape mode to avoid the need for triple-buffering. Ideally a 720x480 resolution display, to allow for 3x GBA scaling and filter effects.</li><li>High-quality injection molded case and buttons: 3D printing is great for low volume production, but an injection molded case would be great. It would be more precise (allowing for tighter tolerances), stronger, and allow for significantly more color options.</li><li>Custom battery pack: or at least customizing the length of the connector wire. The current solution is hacky and doesn‚Äôt make the best use of internal space, due to limited off-the-shelf battery options.</li><li>Smaller BGA parts for SRAM and SDRAM to free up board space (and move internal signals to 1.8 volts): this is actually something that would be possible in smaller volumes too, if I were willing to send parts from Mouser or DigiKey to JLCPCB for assembly.</li></ul>","contentLength":69379,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=43027335"}],"tags":["dev"]}