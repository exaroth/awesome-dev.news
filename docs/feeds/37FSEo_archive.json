{"id":"37FSEo","title":"Rust","displayTitle":"Rust","url":"","feedLink":"","isQuery":true,"isEmpty":false,"isHidden":false,"itemCount":19,"items":[{"title":"Building the MagicMirror in Rust with iced GUI Library ü¶Ä","url":"https://www.reddit.com/r/rust/comments/1ipzubj/building_the_magicmirror_in_rust_with_iced_gui/","date":1739620595,"author":"/u/amindiro","guid":527,"unread":true,"content":"<p>I recently embarked on a journey to build a custom MagicMirror using the Rust programming language, and I‚Äôd like to share my experiences. I wrost a blog post titled <a href=\"https://aminediro.com/posts/mirrors/#mirrors\">\"software you can love: miroir √î mon beau miroir\"</a> this project was my attempt to create a stable, resource-efficient application for the Raspberry Pi 3A.</p><p>Here's what I loved about using Rust and the iced GUI library:</p><ul><li><p><strong>Elm Architecture + Rust is a match made in heaven:</strong> iced was perfect for my needs with its Model, View, and Update paradigms. It helped keep my state management concise and leverage Rust type system</p></li><li><p> Opting for this lightweight rendering library reduced the size of the binary significantly, ending with a 9MB binary.</p></li><li><p> Although troublesome at first, I used ‚Äòcross‚Äô to cross compile Rust for armv7.</p></li></ul><p>If anyone is keen, I‚Äôm thinking of open-sourcing this project and sharing it with the community. Insights on enhancing the project's functionality or any feedback would be much appreciated!</p><p>Feel free to reach out if you're interested in the technical nitty-gritty or my experience with Rust GUI libraries in general.</p>","contentLength":1098,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Bringing Nest.js to Rust: Meet Toni.rs, the Framework You‚Äôve Been Waiting For! üöÄ","url":"https://www.reddit.com/r/rust/comments/1iprsmo/bringing_nestjs_to_rust_meet_tonirs_the_framework/","date":1739587338,"author":"/u/Mysterious-Rust","guid":530,"unread":true,"content":"<p>As a Rust developer coming from TypeScript, I‚Äôve been missing a Nest.js-like framework ‚Äî its modularity, dependency injection, and CLI superpowers. But since the Rust ecosystem doesn‚Äôt have a direct counterpart (yet!), I decided to build one myself! üõ†Ô∏è</p><p>Introducing‚Ä¶ <a href=\"https://crates.io/crates/toni\">Toni.rs</a> ‚Äî a Rust framework inspired by the Nest.js architecture, designed to bring the same developer joy to our favorite language. And it‚Äôs live in beta! üéâ</p><p>Here‚Äôs what makes this project interesting:</p><p>Scalable maintainability üß©:</p><p>A modular architecture keeps your business logic decoupled and organized. Say goodbye to spaghetti code ‚Äî each module lives in its own context, clean and focused.</p><p>Need a complete CRUD setup? Just run a single CLI command. And I have lots of ideas for CLI ease. Who needs copy and paste?</p><p>Automatic Dependency Injection ü§ñ:</p><p>Stop wasting time wiring dependencies. Declare your providers, add them to your structure, and let the framework magically inject them. Less boilerplate, more coding.</p><p>Leave your thoughts below ‚Äî suggestions, questions, or even just enthusiasm! üöÄ </p>","contentLength":1089,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Tabiew 0.8.4 Released","url":"https://www.reddit.com/r/rust/comments/1ipp72r/tabiew_084_released/","date":1739578902,"author":"/u/shshemi","guid":531,"unread":true,"content":"<p>Tabiew is a lightweight TUI application that allows users to view and query tabular data files, such as CSV, Parquet, Arrow, Sqlite, and ...</p><ul><li>üìä Support for CSV, Parquet, JSON, JSONL, Arrow, FWF, and Sqlite</li><li>üóÇÔ∏è Multi-table functionality</li></ul><ul><li>UI is updated to be more modern and responsive</li><li>Horizontally scrollable tables</li><li>Visible data frame can be referenced with name \"_\"</li><li>Compatibility with older versions of glibc</li><li>Two new themes (Tokyo Night and Catppuccin)</li></ul>","contentLength":450,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"the ref keyword","url":"https://www.reddit.com/r/rust/comments/1ipixny/the_ref_keyword/","date":1739561817,"author":"/u/Tickstart","guid":529,"unread":true,"content":"<p>I've made a quick mock situation which is analogous to my situation the other day:</p><pre><code>fn main() { let mut v: Option&lt;Vec&lt;usize&gt;&gt; = None; let mut h = 20; while h.ne(&amp;0) { if (h % 3).ge(&amp;1) { match v { Some(ref mut v) =&gt; (*v).push(h), None =&gt; v = Some(vec![h]) } } h -= 1 } println!(\"{v:?}\") } </code></pre><p>I was a bit confused on how it \"should\" be solved. My issue is the \"ref mut\". It made sense to me that I didn't want to consume the vector v, just add to it if it existed and I tried adding ref (then mut), which worked. When I goodled, it seemed ref was a legacy thing and not needed anymore. My question is, how is the idiomatic way to write this? Perhaps it's possible to do in a much simpler way and I just found a way to complicate it for no reason.</p><p>Also, don't worry I know this is a terrible pattern, it was mostly for tesing something.</p>","contentLength":828,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Macro-Less, Highly Integrated OpenAPI Document Generation in Rust with Ohkami","url":"https://medium.com/@kanarus786/macro-less-highly-integrated-openapi-document-generation-in-rust-with-ohkami-912de388adc1","date":1739557605,"author":"/u/kanarus","guid":528,"unread":true,"content":"<p>In Rust web dev, <a href=\"https://github.com/juhaku/utoipa\" rel=\"noopener ugc nofollow\" target=\"_blank\">utoipa</a> is the most popular crate for generating OpenAPI document from server code. While it‚Äôs a great tool, it can be frustrating due to excessive macro use.</p><p>A new web framework Ohkami offers a ,  way to generate OpenAPI document with its ‚Äúopenapi‚Äù feature.</p><p>Let‚Äôs take following code as an example. It‚Äôs the same sample from the ‚Äúopenapi‚Äù section of the README, but with openapi-related parts removed:</p><pre></pre><p>While this compiles and works as a pseudo user management server, activating ‚Äúopenapi‚Äù feature causes a compile error, telling that User and CreateUser don‚Äôt implement ohkami::openapi::Schema.</p><p>As indicated by this, Ohkami with ‚Äúopenapi‚Äù feature effectively handles type information and intelligently collects its endpoints‚Äô metadata. It allows code like:</p><pre></pre><p>to assemble metadata into an OpenAPI document and output it to a file .</p><p>Then, how we implement Schema? Actually we can easily impl Schema by hand, or just #[derive(Schema)] is available! In this case, derive is enough:</p><pre></pre><p>That‚Äôs it! Just adding these derives allows Ohkami::generate to output following file:</p><pre></pre><p>Additionally, it‚Äôs easy to define the User schema as a component instead of duplicating inline schemas. In derive, just add #[openapi(component)] helper attribute:</p><pre></pre><pre></pre><p>And  #[operation] attribute is available to set summary, description, and override operationId and each response‚Äôs description:</p><pre></pre><pre></pre><p>Let‚Äôs take a look at how this document generation works!</p><p>First, the #[derive(Schema)]s are expanded as following:</p><pre></pre><pre></pre><p>The DSL enables to easily impl manually.</p><p>Schema trait links the struct to an item of type called ‚ÄúSchemaRef‚Äù.</p><h2>2. openapi_* hooks of FromParam, FromRequest, IntoResponse</h2><p>FromParam, FromRequest and IntoResponse are Ohkami‚Äôs core traits appeared in the handler bound:</p><pre></pre><p>When ‚Äúopenapi‚Äù feature is activated, they additionally have following methods:</p><pre></pre><p>Ohkami leverages these methods in IntoHandler to generate consistent openapi::Operation, reflecting the actual handler signature like <a href=\"https://github.com/ohkami-rs/ohkami/blob/6e243ac823e21f286aca2660f9d38f7bde381c5a/ohkami/src/fang/handler/into_handler.rs#L328-L335\" rel=\"noopener ugc nofollow\" target=\"_blank\">this</a>.</p><p>Moreover, Ohkami properly propagates schema information in common cases like <a href=\"https://github.com/ohkami-rs/ohkami/blob/6e243ac823e21f286aca2660f9d38f7bde381c5a/ohkami/src/response/into_response.rs#L114-L128\" rel=\"noopener ugc nofollow\" target=\"_blank\">this</a>, allowing users to focus only on the types and schemas of their app.</p><h2>3. routes metadata of Router</h2><p>In Ohkami, what‚Äôs called router::base::Router <a href=\"https://github.com/ohkami-rs/ohkami/blob/6e243ac823e21f286aca2660f9d38f7bde381c5a/ohkami/src/router/base.rs#L8-L18\" rel=\"noopener ugc nofollow\" target=\"_blank\">has ‚Äúroutes‚Äù property</a> that stores all the routes belonging to an Ohkami instance. This is returned alongside router::final::Router from ‚Äúfinalize‚Äù step, and is used to assemble metadata of all endpoints.</p><p>What Ohkami::generate itself does is just to serialize an item of type openapi::document::Document and write it to a file.</p><p>The openapi::document::Document item is created by<a href=\"https://github.com/ohkami-rs/ohkami/blob/6e243ac823e21f286aca2660f9d38f7bde381c5a/ohkami/src/router/final.rs#L54-L59\" rel=\"noopener ugc nofollow\" target=\"_blank\"> ‚Äúgen_openapi_doc‚Äù of router::final::Router</a>, summarized as follows:</p><pre></pre><p>That‚Äôs how Ohkami generates OpenAPI document!</p><p>There is, however, a problem in , Cloudflare Workers: Ohkami is loaded to Miniflare or Cloudflare Workers as WASM, so it can only generate OpenAPI document andcannot write it to the user‚Äôs local file system.</p><p>To work around this, Ohkami provides a CLI tool <a href=\"https://github.com/ohkami-rs/ohkami/blob/6e243ac823e21f286aca2660f9d38f7bde381c5a/scripts/workers_openapi.js\" rel=\"noopener ugc nofollow\" target=\"_blank\">scripts/workers_openapi.js</a>. This is, for example, used in package.json of Cloudflare Workers + OpenAPI template:</p><pre></pre><p>generates OpenAPI document!</p>","contentLength":3119,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1iph9lk/macroless_highly_integrated_openapi_document/"},{"title":"I'm very impressed by how Rust supports both beginners and pro's","url":"https://www.reddit.com/r/rust/comments/1ipe6m7/im_very_impressed_by_how_rust_supports_both/","date":1739549777,"author":"/u/ConstructionShot2026","guid":532,"unread":true,"content":"<p>I would go as far saying it supports a syntax abstraction that is simpler than python to read.</p><p>I just find it amazing, with a performance level so close to C++.</p><p>Its your choice how many complex features you want to add for control and optimization, and the compiler is so cool, that it can add them automatically if I don't see it necessary.</p><p>I believe if more knew how simple it could be, more would use it outside systems programming :D</p>","contentLength":434,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"A new tool for visualizing Rust lifetimes","url":"https://www.youtube.com/watch?v=NV6Xo_el_2o","date":1739458834,"author":"Let's Get Rusty","guid":562,"unread":true,"content":"<article>See how RustOwl can help you understand lifetimes in a real Rust codebase. A brand-new tool designed to visualize Rust lifetimes and make learning Rust easier. Check it out and see how it can change the way you write Rust!\n\nFree Rust training: https://letsgetrusty.com/bootcamp\n\nRustOwl: https://github.com/cordx56/rustowl\n\nCorrections:\n- Bacon is a CLI tool, not a library. Check it out here: https://github.com/Canop/bacon</article>","contentLength":424,"flags":null,"enclosureUrl":"https://www.youtube.com/v/NV6Xo_el_2o?version=3","enclosureMime":"","commentsUrl":null},{"title":"2024 State of Rust Survey Results","url":"https://blog.rust-lang.org/2025/02/13/2024-State-Of-Rust-Survey-results.html","date":1739404800,"author":"The Rust Survey Team","guid":316,"unread":true,"content":"<p>The Rust Survey Team is excited to share the results of our <a href=\"https://blog.rust-lang.org/2024/12/05/annual-survey-2024-launch.html\">2024 survey on the Rust Programming language</a>, conducted between December 5, 2024 and December 23, 2024.\nAs in previous years, the 2024 State of Rust Survey was focused on gathering insights and feedback from Rust users, and all those who are interested in the future of Rust more generally.</p><p>This ninth edition of the survey surfaced new insights and learning opportunities straight from the global Rust language community, which we will summarize below. In addition to this blog post,  containing charts with aggregated results of all questions in the survey.</p><p><strong>Our sincerest thanks to every community member who took the time to express their opinions and experiences with Rust over the past year. Your participation will help us make Rust better for everyone.</strong></p><p>There's a lot of data to go through, so strap in and enjoy!</p><table><thead><tr></tr></thead><tbody><tr></tr><tr></tr></tbody></table><p>As shown above, in 2024, we have received fewer survey views than in the previous year. This was likely caused simply by the fact that the survey ran only for two weeks, while in the previous year it ran for almost a month. However, the completion rate has also dropped, which seems to suggest that the survey might be a bit too long. We will take this into consideration for the next edition of the survey.</p><p>The State of Rust survey not only gives us excellent insight into how many Rust users around the world are using and experiencing the language but also gives us insight into the makeup of our global community. This information gives us a sense of where the language is being used and where access gaps might exist for us to address over time. We hope that this data and our related analysis help further important discussions about how we can continue to prioritize global access and inclusivity in the Rust community.</p><p>Same as every year, we asked our respondents in which country they live in. The top 10 countries represented were, in order: United States (22%), Germany (14%), United Kingdom (6%), France (6%), China (5%), Canada (3%), Netherlands (3%), Russia (3%), Australia (2%), and Sweden (2%). We are happy to see that Rust is enjoyed by users from all around the world! You can try to find your country in the chart below:</p><p>We also asked whether respondents consider themselves members of a marginalized community. Out of those who answered, 74.5% selected no, 15.5% selected yes, and 10% preferred not to say.</p><p>We have asked the group that selected ‚Äúyes‚Äù which specific groups they identified as being a member of. The majority of those who consider themselves a member of an underrepresented or marginalized group in technology identify as lesbian, gay, bisexual, or otherwise non-heterosexual. The second most selected option was neurodivergent at 46% followed by trans at 35%.</p><p>Each year, we must acknowledge the diversity, equity, and inclusivity (DEI) related gaps in the Rust community and open source as a whole. We believe that excellent work is underway at the Rust Foundation to advance global access to Rust community gatherings and distribute grants to a diverse pool of maintainers each cycle, which you can learn more about <a href=\"https://rustfoundation.org/community\">here</a>. Even so, global inclusion and access is just one element of DEI, and the survey working group will continue to advocate for progress in this domain.</p><p>The number of respondents that self-identify as a Rust user was quite similar to last year, around 92%. This high number is not surprising, since we primarily target existing Rust developers with this survey.</p><p>Similarly as last year, around 31% of those who did not identify as Rust users cited the perception of difficulty as the primary reason for not using Rust. The most common reason for not using Rust was that the respondents simply haven‚Äôt had the chance to try it yet.</p><p>Of the former Rust users who participated in the 2024 survey, 36% cited factors outside their control as a reason why they no longer use Rust, which is a 10pp decrease from last year. This year, we also asked respondents if they would consider using Rust again if an opportunity comes up, which turns out to be true for a large fraction of the respondents (63%). That is good to hear!</p><blockquote><p>Closed answers marked with N/A were not present in the previous version(s) of the survey.</p></blockquote><p>Those not using Rust anymore told us that it is because they don't really need it (or the goals of their company changed) or because it was not the right tool for the job. A few reported being overwhelmed by the language or its ecosystem in general or that switching to or introducing Rust would have been too expensive in terms of human effort.</p><p>Of those who used Rust in 2024, 53% did so on a daily (or nearly daily) basis ‚Äî an increase of 4pp from the previous year. We can observe an upward trend in the frequency of Rust usage over the past few years, which suggests that Rust is being increasingly used at work. This is also confirmed by other answers mentioned in the Rust at Work section later below.</p><p>Rust expertise is also continually increasing amongst our respondents! 20% of respondents can write (only) simple programs in Rust (a decrease of 3pp from 2023), while 53% consider themselves productive using Rust ‚Äî up from 47% in 2023. While the survey is just one tool to measure the changes in Rust expertise overall, these numbers are heartening as they represent knowledge growth for many Rustaceans returning to the survey year over year.</p><p>Unsurprisingly, the most popular version of Rust is , either the most recent one or whichever comes with the users' Linux distribution. Almost a third of users also use the latest nightly release, due to various reasons (see below). However, it seems that the beta toolchain is not used much, which is a bit unfortunate. We would like to encourage Rust users to use the beta toolchain more (e.g. in CI environments) to help test soon-to-be stabilized versions of Rust.</p><p>People that use the nightly toolchain mostly do it to gain access to specific unstable language features. Several users have also mentioned that rustfmt works better for them on nightly or that they use the nightly compiler because of faster compilation times.</p><p>To use Rust, programmers first have to learn it, so we are always interested in finding out how do they approach that. Based on the survey results, it seems that most users learn from Rust documentation and also from <a href=\"https://doc.rust-lang.org/book/\">The Rust Programming Language</a> book, which has been a favourite learning resource of new Rustaceans for a long time. Many people also seem to learn by reading the source code of Rust crates. The fact that both the documentation and source code of tens of thousands of Rust crates is available on <a href=\"https://docs.rs\">docs.rs</a> and GitHub makes this easier.</p><p>In terms of answers belonging to the \"Other\" category, they can be clustered into three categories: people using LLM (large language model) assistants (Copilot, ChatGPT, Claude, etc.), reading the official Rust forums (Discord, <a href=\"https://users.rust-lang.org/\">URLO</a>) or being mentored while contributing to Rust projects. We would like to extend a big thank you to those making our spaces friendly and welcoming for newcomers, as it is important work and it pays off. Interestingly, a non-trivial number of people \"learned by doing\" and used rustc error messages and clippy as a guide, which is a good indicator of the quality of Rust diagnostics.</p><p>In terms of formal education, it seems that Rust has not yet penetrated university curriculums, as this is typically a very slowly moving area. Only a very small number of respondents (around 3%) have taken a university Rust course or used university learning materials.</p><p>In terms of operating systems used by Rustaceans, Linux was the most popular choice, and it seems that it is getting increasingly popular year after year. It is followed by macOS and Windows, which have a very similar share of usage.</p><blockquote><p>As you can see in the <a href=\"https://blog.rust-lang.org/images/2025-02-13-rust-survey-2024/which-os-do-you-use-wordcloud.png\">wordcloud</a>, there are also a few users that prefer Arch, btw.</p></blockquote><p>Rust programmers target a diverse set of platforms with their Rust programs. We saw a slight uptick in users targeting embedded and mobile platforms, but otherwise the distribution of platforms stayed mostly the same as last year. Since the WebAssembly target is quite diverse, we have split it into two separate categories this time. Based on the results it is clear that when using WebAssembly, it is mostly in the context of browsers (23%) rather than other use-cases (7%).</p><p>We cannot of course forget the favourite topic of many programmers: which IDE (developer environment) they use. Although Visual Studio Code still remains the most popular option, its share has dropped by 5pp this year. On the other hand, the Zed editor seems to have gained considerable traction recently. The small percentage of those who selected \"Other\" are using a wide range of different tools: from CursorAI to classics like Kate or Notepad++. Special mention to the 3 people using \"ed\", that's quite an achievement.</p><blockquote><p>You can also take a look at the linked <a href=\"https://blog.rust-lang.org/images/2025-02-13-rust-survey-2024/what-ide-do-you-use-wordcloud.png\">wordcloud</a> that summarizes open answers to this question (the \"Other\" category), to see what other editors are also popular.</p></blockquote><p>We were excited to see that more and more people use Rust at work for the majority of their coding, 38% vs 34% from last year. There is a clear upward trend in this metric over the past few years.</p><p>The usage of Rust within companies also seems to be rising, as 45% of respondents answered that their organisation makes non-trivial use of Rust, which is a 7pp increase from 2023.</p><p>Once again, the top reason employers of our survey respondents invested in Rust was the ability to build relatively correct and bug-free software. The second most popular reason was Rust‚Äôs performance characteristics. 21% of respondents that use Rust at work do so because they already know it, and it's thus their default choice, an uptick of 5pp from 2023. This seems to suggest that Rust is becoming one of the baseline languages of choice for more and more companies.</p><p>Similarly to the previous year, a large percentage of respondents (82%) report that Rust helped their company achieve its goals. In general, it seems that programmers and companies are quite happy with their usage of Rust, which is great!</p><p>In terms of technology domains, the situation is quite similar to the previous year. Rust seems to be especially popular for creating server backends, web and networking services and cloud technologies. It also seems to be gaining more traction for embedded use-cases.</p><blockquote><p>You can scroll the chart to the right to see more domains. Note that the Automotive domain was not offered as a closed answer in the 2023 survey (it was merely entered through open answers), which might explain the large jump.</p></blockquote><p>It is exciting to see the continued growth of professional Rust usage and the confidence so many users feel in its performance, control, security and safety, enjoyability, and more!</p><p>As always, one of the main goals of the State of Rust survey is to shed light on challenges, concerns, and priorities on Rustaceans‚Äô minds over the past year.</p><p>We have asked our users about aspects of Rust that limit their productivity. Perhaps unsurprisingly, slow compilation was at the top of the list, as it seems to be a perennial concern of Rust users. As always, there are efforts underway to improve the speed of the compiler, such as enabling the <a href=\"https://blog.rust-lang.org/2023/11/09/parallel-rustc.html\">parallel frontend</a> or switching to a <a href=\"https://blog.rust-lang.org/2024/05/17/enabling-rust-lld-on-linux.html\">faster linker by default</a>. We invite you to test these improvements and let us know if you encounter any issues.</p><p>Other challenges included subpar support for debugging Rust and high disk usage of Rust compiler artifacts. On the other hand, most Rust users seem to be very happy with its runtime performance, the correctness and stability of the compiler and also Rust's documentation.</p><p>In terms of specific unstable (or missing) features that Rust users want to be stabilized (or implemented), the most desired ones were async closures and if/let while chains. Well, we have good news! Async closures will be stabilized in the next version of Rust (1.85), and if/let while chains will hopefully follow <a href=\"https://github.com/rust-lang/rust/pull/132833\">soon after</a>, once Edition 2024 is released (which will also happen in Rust 1.85).</p><p>Other coveted features are generators (both sync and async) and more powerful generic const expressions. You can follow the <a href=\"https://rust-lang.github.io/rust-project-goals/2025h1/goals.html\">Rust Project Goals</a> to track the progress of these (and other) features.</p><p>In the open answers to this question, people were really helpful and tried hard to describe the most notable issues limiting their productivity. We have seen mentions of struggles with async programming (an all-time favourite), debuggability of errors (which people generally love, but they are not perfect for everyone) or Rust tooling being slow or resource intensive (rust-analyzer and rustfmt). Some users also want a better IDE story and improved interoperability with other languages.</p><p>This year, we have also included a new question about the speed of Rust's evolution. While most people seem to be content with the status quo, more than a quarter of people who responded to this question would like Rust to stabilize and/or add features more quickly, and only 7% of respondents would prefer Rust to slow down or completely stop adding new features.</p><p>Interestingly, when we asked respondents about their main worries for the future of Rust, one of the top answers remained the worry that Rust will become too complex. This seems to be in contrast with the answers to the previous question. Perhaps Rust users still seem to consider the complexity of Rust to be manageable, but they worry that one day it might become too much.</p><p>We are happy to see that the amount of respondents concerned about Rust Project governance and lacking support of the Rust Foundation has dropped by about 6pp from 2023.</p><p>Each year, the results of the State of Rust survey help reveal the areas that need improvement in many areas across the Rust Project and ecosystem, as well as the aspects that are working well for our community.</p><p>If you have any suggestions for the Rust Annual survey, please <a href=\"https://github.com/rust-lang/surveys/issues\">let us know</a>!</p><p>We are immensely grateful to those who participated in the 2024 State of Rust Survey and facilitated its creation. While there are always challenges associated with developing and maintaining a programming language, this year we were pleased to see a high level of survey participation and candid feedback that will truly help us make Rust work better for everyone.</p><p>If you‚Äôd like to dig into more details, we recommend you to browse through the full <a href=\"https://raw.githubusercontent.com/rust-lang/surveys/main/surveys/2024-annual-survey/report/annual-survey-2024-report.pdf\">survey report</a>.</p>","contentLength":14399,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"This Week in Rust 586","url":"https://this-week-in-rust.org/blog/2025/02/12/this-week-in-rust-586/","date":1739336400,"author":"TWiR Contributors","guid":466,"unread":true,"content":"<p>This week's crate is <a href=\"https://github.com/virust-ai/esp32-mender-client\">esp32-mender-client</a>, a client for ESP32 to execute firmware updates and remote commands.</p><p>Thanks to <a href=\"https://users.rust-lang.org/t/crate-of-the-week/2704/1399\">Kelvin</a> for the self-suggestion!</p><p>An important step for RFC implementation is for people to experiment with the\nimplementation and give feedback, especially before stabilization.  The following\nRFCs would benefit from user testing before moving forward:</p><ul><li><em>No calls for testing were issued this week.</em></li></ul><ul><li><em>No calls for testing were issued this week.</em></li></ul><ul><li><em>No calls for testing were issued this week.</em></li></ul><p>If you are a feature implementer and would like your RFC to appear on the above list, add the new \nlabel to your RFC along with a comment providing testing instructions and/or guidance on which aspect(s) of the feature\nneed testing.</p><p>Always wanted to contribute to open-source projects but did not know where to start?\nEvery week we highlight some tasks from the Rust community for you to pick and get started!</p><p>Some of these tasks may also have mentors available, visit the task page for more information.</p><p><em>No Calls for participation were submitted this week.</em></p><p>Are you a new or experienced speaker looking for a place to share something cool? This section highlights events that are being planned and are accepting submissions to join their event as a speaker.</p><p><em>No Calls for papers or presentations were submitted this week.</em></p><p>A relatively neutral week, with lots of real changes but most small in\nmagnitude. Most significant change is rustdoc's move of JS/CSS minification to\nbuild time which cut doc generation times on most benchmarks fairly\nsignificantly.</p><p>3 Regressions, 5 Improvements, 1 Mixed; 2 of them in rollups\n32 artifact comparisons made in total</p><ul><li><em>No RFCs were approved this week.</em></li></ul><p>Every week, <a href=\"https://www.rust-lang.org/team.html\">the team</a> announces the 'final comment period' for RFCs and key PRs\nwhich are reaching a decision. Express your opinions now.</p><ul><li><em>No Cargo Tracking Issues or PRs entered Final Comment Period this week.</em></li></ul><ul><li><em>No Language Team Proposals entered Final Comment Period this week.</em></li></ul><ul><li><em>No Language Reference RFCs entered Final Comment Period this week.</em></li></ul><ul><li><em>No Unsafe Code Guideline Tracking Issues or PRs entered Final Comment Period this week.</em></li></ul><p>Rusty Events between 2025-02-12 - 2025-03-12 ü¶Ä</p><p>If you are running a Rust event please add it to the <a href=\"https://www.google.com/calendar/embed?src=apd9vmbc22egenmtu5l6c5jbfc%40group.calendar.google.com\">calendar</a> to get\nit mentioned here. Please remember to add a link to the event too.\nEmail the <a href=\"mailto:community-team@rust-lang.org\">Rust Community Team</a> for access.</p><blockquote><p>Just because things are useful doesn't mean they are magically sound.</p></blockquote>","contentLength":2396,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"The case for sans-io","url":"https://fasterthanli.me/articles/the-case-for-sans-io","date":1738954381,"author":"Amos Wenger","guid":18,"unread":true,"content":"<p data-bo=\"208\">The most popular option to decompress ZIP files from the Rust programming\nlanguage is a crate simply named <a href=\"https://lib.rs/crates/zip\">zip</a> ‚Äî At the time of this writing, it has 48\nmillion downloads. It‚Äôs fully-featured, supporting various compression methods,\nencryption, and even supports writing zip files.</p><p data-bo=\"528\">However, that‚Äôs not the crate  uses to read ZIP files. Some\napplications benefit from using asynchronous I/O, especially if they decompress\narchives that they download from the network.</p><a href=\"https://fasterthanli.me/articles/the-case-for-sans-io#character-encoding-differences\"></a><a href=\"https://fasterthanli.me/articles/the-case-for-sans-io#platform-differences\"></a><a href=\"https://fasterthanli.me/articles/the-case-for-sans-io#the-end-of-central-directory-record\"></a><a href=\"https://fasterthanli.me/articles/the-case-for-sans-io#boundary-confusion\"></a><a href=\"https://fasterthanli.me/articles/the-case-for-sans-io#not-doing-any-i-o-at-all\"></a><a href=\"https://fasterthanli.me/articles/the-case-for-sans-io#the-structure-of-rc-zip\"></a><a href=\"https://fasterthanli.me/articles/the-case-for-sans-io#bringing-io-uring-into-it\"></a><a href=\"https://fasterthanli.me/articles/the-case-for-sans-io#plugging-rc-zip-into-monoio\"></a><a href=\"https://fasterthanli.me/articles/the-case-for-sans-io#closing-words\"></a>","contentLength":471,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"This Week in Rust 585","url":"https://this-week-in-rust.org/blog/2025/02/05/this-week-in-rust-585/","date":1738731600,"author":"TWiR Contributors","guid":465,"unread":true,"content":"<p>This week's crate is <a href=\"https://github.com/orhun/ratzilla\">ratzilla</a>, a library for building terminal-themed web applications with Rust and WebAssembly.</p><p>An important step for RFC implementation is for people to experiment with the\nimplementation and give feedback, especially before stabilization.  The following\nRFCs would benefit from user testing before moving forward:</p><ul><li><em>No calls for testing were issued this week.</em></li></ul><ul><li><em>No calls for testing were issued this week.</em></li></ul><ul><li><em>No calls for testing were issued this week.</em></li></ul><p>If you are a feature implementer and would like your RFC to appear on the above list, add the new \nlabel to your RFC along with a comment providing testing instructions and/or guidance on which aspect(s) of the feature\nneed testing.</p><p>Always wanted to contribute to open-source projects but did not know where to start?\nEvery week we highlight some tasks from the Rust community for you to pick and get started!</p><p>Some of these tasks may also have mentors available, visit the task page for more information.</p><p>Are you a new or experienced speaker looking for a place to share something cool? This section highlights events that are being planned and are accepting submissions to join their event as a speaker.</p><p><em>No Calls for papers or presentations were submitted this week.</em></p><p>A very quiet week with performance of primary benchmarks showing no change over all.</p><table><thead><tr></tr></thead><tbody><tr></tr><tr></tr><tr></tr><tr><td align=\"center\">Improvements ‚úÖ  (secondary)</td></tr><tr></tr></tbody></table><p>5 Regressions, 2 Improvements, 5 Mixed; 6 of them in rollups\n49 artifact comparisons made in total</p><ul><li><em>No RFCs were approved this week.</em></li></ul><p>Every week, <a href=\"https://www.rust-lang.org/team.html\">the team</a> announces the 'final comment period' for RFCs and key PRs\nwhich are reaching a decision. Express your opinions now.</p><ul><li><em>No RFCs entered Final Comment Period this week.</em></li></ul><ul><li><em>No Cargo Tracking Issues or PRs entered Final Comment Period this week.</em></li></ul><ul><li><em>No Language Team Proposals entered Final Comment Period this week.</em></li></ul><ul><li><em>No Language Reference RFCs entered Final Comment Period this week.</em></li></ul><ul><li><em>No Unsafe Code Guideline Tracking Issues or PRs entered Final Comment Period this week.</em></li></ul><p>Rusty Events between 2025-02-05 - 2025-03-05 ü¶Ä</p><p>If you are running a Rust event please add it to the <a href=\"https://www.google.com/calendar/embed?src=apd9vmbc22egenmtu5l6c5jbfc%40group.calendar.google.com\">calendar</a> to get\nit mentioned here. Please remember to add a link to the event too.\nEmail the <a href=\"mailto:community-team@rust-lang.org\">Rust Community Team</a> for access.</p><blockquote><p>If your rust code compiles and you don't use \"unsafe\", that is a pretty good certification.</p></blockquote><p>Thanks to <a href=\"https://users.rust-lang.org/t/twir-quote-of-the-week/328/1657\">ZiCog</a> for the suggestion!</p>","contentLength":2292,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"crates.io: development update","url":"https://blog.rust-lang.org/2025/02/05/crates-io-development-update.html","date":1738713600,"author":"Tobias Bieniek","guid":315,"unread":true,"content":"<p>Back in July 2024, we published a <a href=\"https://blog.rust-lang.org/2024/07/29/crates-io-development-update.html\">blog post</a> about the ongoing development of crates.io. Since then, we have made a lot of progress and shipped a few new features. In this blog post, we want to give you an update on the latest changes that we have made to crates.io.</p><p>In <a href=\"https://rust-lang.github.io/rfcs/3660-crates-io-crate-deletions.html\">RFC #3660</a> we proposed a new feature that allows crate owners to delete their crates from crates.io under certain conditions. This can be useful if you have published a crate by mistake or if you want to remove a crate that is no longer maintained. After the RFC was accepted by all team members at the end of August, we began implementing the feature.</p><p>We created a new API endpoint <code>DELETE /api/v1/crates/:name</code> that allows crate owners to delete their crates and then created the corresponding user interface. If you are the owner of a crate, you can now go to the crate page, open the \"Settings\" tab, and find the \"Delete this crate\" button at the bottom. Clicking this button will lead you to a confirmation page telling you about the potential impact of the deletion and requirements that need to be met in order to delete the crate:</p><p>As you can see from the screenshot above, a crate can only be deleted if either: the crate has been published for less than 72 hours or the crate only has a single owner, and the crate has been downloaded less than 500 times for each month it has been published, and the crate is not depended upon by any other crate on crates.io.</p><p>These requirements were put in place to prevent abuse of the deletion feature and to ensure that crates that are widely used by the community are not deleted accidentally. If you have any feedback on this feature, please let us know!</p><p>Around the holiday season we started experimenting with generating an <a href=\"https://www.openapis.org/\">OpenAPI</a> description for the crates.io API. This was a long-standing request from the community, and we are happy to announce that we now have an experimental OpenAPI description available at <a href=\"https://crates.io/api/openapi.json\">https://crates.io/api/openapi.json</a>!</p><p>Please note that this is still considered work-in-progress and e.g. the stability guarantees for the endpoints are not written down and the response schemas are also not fully documented yet.</p><p>You can view the OpenAPI description in e.g. a Swagger UI at <a href=\"https://petstore.swagger.io/\">https://petstore.swagger.io/</a> by putting <code>https://crates.io/api/openapi.json</code> in the top input field. We decided to not ship a viewer ourselves for now due to security concerns with running it on the same domain as crates.io itself. We may reconsider whether to offer it on a dedicated subdomain in the future if there is enough interest.</p><p>The OpenAPI description is generated by the <a href=\"https://github.com/juhaku/utoipa\">utoipa</a> crate, which is a tool that can be integrated with the <a href=\"https://github.com/tokio-rs/axum\">axum</a> web framework to automatically generate OpenAPI descriptions for all of your endpoints. We would like to thank <a href=\"https://github.com/juhaku\">Juha Kukkonen</a> for his great work on this tool!</p><h2><a href=\"https://blog.rust-lang.org/2025/02/05/crates-io-development-update.html#support-form-and-report-crate-button\" aria-hidden=\"true\"></a>Support form and \"Report Crate\" button</h2><p>Since the crates.io team is small and mostly consists of volunteers, we do not have the capacity to manually monitor all publishes. Instead, we rely on you, the Rust community, to help us catch malicious crates and users. To make it easier for you to report suspicious crates, we added a \"Report Crate\" button to all the crate pages. If you come across a crate that you think is malicious or violates the <a href=\"https://www.rust-lang.org/policies/code-of-conduct\">code of conduct</a> or our <a href=\"https://crates.io/policies\">usage policy</a>, you can now click the \"Report Crate\" button and fill out the form that appears. This will send an email to the crates.io team, who will then review the crate and take appropriate action if necessary. Thank you to crates.io team member <a href=\"https://github.com/eth3lbert\">@eth3lbert</a> who worked on the majority of this.</p><p>If you have any issues with the support form or the \"Report Crate\" button, please let us know. You can also always email us directly at <a href=\"mailto:help@crates.io\">help@crates.io</a> if you prefer not to use the form.</p><p>We have added a new feature that allows you to receive email notifications when a new version of your crate is published. This can be useful in detecting unauthorized publishes of your crate or simply to keep track of publishes from other members of your team.</p><p>This feature was another <a href=\"https://github.com/rust-lang/crates.io/issues/815\">long-standing feature request</a> from our community, and we were happy to finally implement it. If you'd prefer not to receive publish notifications, then you can go to your account settings on crates.io and disable these notifications.</p><p>These were some of the more visible changes to crates.io over the past couple of months, but a lot has happened \"under the hood\" as well.</p><ul><li><p><a href=\"https://rust-lang.github.io/rfcs/3691-trusted-publishing-cratesio.html\">RFC #3691</a> was opened and accepted to implement \"Trusted Publishing\" support on crates.io, similar to other ecosystems that adopted it. This will allow you to specify on crates.io which repository/system is allowed to publish new releases of your crate, allowing you to publish crates from CI systems without having to deal with API tokens anymore.</p></li><li><p>Slightly related to the above: API tokens created on crates.io now expire after 90 days by default. It is still possible to disable the expiry or choose other expiry durations though.</p></li><li><p>The crates.io team was one of the first projects to use the <a href=\"https://diesel.rs/\">diesel</a> database access library, but since that only supported synchronous execution it was sometimes a little awkward to use in our codebase, which was increasingly moving into an async direction after our migration to <a href=\"https://github.com/tokio-rs/axum\">axum</a> a while ago. The maintainer of diesel, <a href=\"https://github.com/weiznich\">Georg Semmler</a>, did a lot of work to make it possible to use diesel in an async way, resulting in the <a href=\"https://github.com/weiznich/diesel_async\">diesel-async</a> library. Over the past couple of months we incrementally ported crates.io over to  queries, which now allows us to take advantage of the internal query pipelining in  that resulted in some of our API endpoints getting a 10-15% performance boost. Thank you, Georg, for your work on these crates!</p></li><li><p>Whenever you publish a new version or yank/unyank existing versions a couple of things need to be updated. Our internal database is immediately updated, and then we synchronize the sparse and git index in background worker jobs. Previously, yanking and unyanking a high number of versions would each queue up another synchronization background job. We have now implemented automatic deduplication of redundant background jobs, making our background worker a bit more efficient.</p></li><li><p>The final big, internal change that was just merged last week is related to the testing of our frontend code. In the past we used a tool called <a href=\"https://miragejs.com/\">Mirage</a> to implement a mock version of our API, which allowed us to run our frontend test suite without having to spin up a full backend server. Unfortunately, the maintenance situation around Mirage had lately forced us to look into alternatives, and we are happy to report that we have now fully migrated to the \"Industry standard API mocking\" package <a href=\"https://mswjs.io/\">msw</a>. If you want to know more, you can find the details in the \"small\" <a href=\"https://github.com/rust-lang/crates.io/pull/10393\">migration pull request</a>.</p></li></ul><p>We hope you enjoyed this update on the development of crates.io. If you have any feedback or questions, please let us know on <a href=\"https://rust-lang.zulipchat.com/#narrow/stream/318791-t-crates-io\">Zulip</a> or <a href=\"https://github.com/rust-lang/crates.io/discussions\">GitHub</a>. We are always happy to hear from you and are looking forward to your feedback!</p>","contentLength":6967,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Announcing Rust 1.84.1","url":"https://blog.rust-lang.org/2025/01/30/Rust-1.84.1.html","date":1738195200,"author":"The Rust Release Team","guid":314,"unread":true,"content":"<p>The Rust team has published a new point release of Rust, 1.84.1. Rust is a\nprogramming language that is empowering everyone to build reliable and\nefficient software.</p><p>If you have a previous version of Rust installed via rustup, getting Rust\n1.84.1 is as easy as:</p><p>If you don't have it already, you can <a href=\"https://www.rust-lang.org/install.html\">get </a> from the\nappropriate page on our website.</p><p>1.84.1 resolves a few regressions introduced in 1.84.0:</p><p>It also includes several fixes for those building Rust from source:</p><p>Many people came together to create Rust 1.84.1. We couldn't have done it\nwithout all of you. <a href=\"https://thanks.rust-lang.org/rust/1.84.1/\">Thanks!</a></p>","contentLength":567,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"This Week in Rust 584","url":"https://this-week-in-rust.org/blog/2025/01/29/this-week-in-rust-584/","date":1738126800,"author":"TWiR Contributors","guid":464,"unread":true,"content":"<p>This week's crate is <a href=\"https://github.com/riberk/embed_it\">embed_it</a>, a crate that helps you to embed assets into your binary and generates structs / trait implementations for each file or directory.</p><p>Thanks to <a href=\"https://users.rust-lang.org/t/crate-of-the-week/2704/1390\">Riberk</a> for the self-suggestion!</p><p>An important step for RFC implementation is for people to experiment with the\nimplementation and give feedback, especially before stabilization.  The following\nRFCs would benefit from user testing before moving forward:</p><ul><li><em>No calls for testing were issued this week.</em></li></ul><ul><li><em>No calls for testing were issued this week.</em></li></ul><ul><li><em>No calls for testing were issued this week.</em></li></ul><p>If you are a feature implementer and would like your RFC to appear on the above list, add the new \nlabel to your RFC along with a comment providing testing instructions and/or guidance on which aspect(s) of the feature\nneed testing.</p><p>If you are a feature implementer and would like your RFC to appear on the above list, add the new \nlabel to your RFC along with a comment providing testing instructions and/or guidance on which aspect(s) of the feature\nneed testing.</p><p>Always wanted to contribute to open-source projects but did not know where to start?\nEvery week we highlight some tasks from the Rust community for you to pick and get started!</p><p>Some of these tasks may also have mentors available, visit the task page for more information.</p><p>Are you a new or experienced speaker looking for a place to share something cool? This section highlights events that are being planned and are accepting submissions to join their event as a speaker.</p><p>Relatively quiet week, with one large-ish regression that will be reverted.\n<a href=\"https://github.com/rust-lang/rust/pull/132666\">#132666</a> produced a nice perf. win, by skipping\nunnecessary work. This PR actually reversed a regression caused by a <a href=\"https://github.com/rust-lang/rust/pull/131984\">previous PR</a>.</p><table><thead><tr></tr></thead><tbody><tr></tr><tr></tr><tr></tr><tr><td align=\"center\">Improvements ‚úÖ  (secondary)</td></tr><tr></tr></tbody></table><p>2 Regressions, 3 Improvements, 2 Mixed; 4 of them in rollups\n45 artifact comparisons made in total</p><ul><li><em>No RFCs were approved this week.</em></li></ul><p>Every week, <a href=\"https://www.rust-lang.org/team.html\">the team</a> announces the 'final comment period' for RFCs and key PRs\nwhich are reaching a decision. Express your opinions now.</p><ul><li><em>No RFCs entered Final Comment Period this week.</em></li></ul><ul><li><em>No Cargo Tracking Issues or PRs entered Final Comment Period this week.</em></li></ul><ul><li><em>No Language Team Proposals entered Final Comment Period this week.</em></li></ul><ul><li><em>No Language Reference RFCs entered Final Comment Period this week.</em></li></ul><ul><li><em>No Unsafe Code Guideline Tracking Issues or PRs entered Final Comment Period this week.</em></li></ul><ul><li><em>No New or Updated RFCs were created this week.</em></li></ul><p>Rusty Events between 2025-01-29 - 2025-02-26 ü¶Ä</p><p>If you are running a Rust event please add it to the <a href=\"https://www.google.com/calendar/embed?src=apd9vmbc22egenmtu5l6c5jbfc%40group.calendar.google.com\">calendar</a> to get\nit mentioned here. Please remember to add a link to the event too.\nEmail the <a href=\"mailto:community-team@rust-lang.org\">Rust Community Team</a> for access.</p><blockquote><p>I have experience in multiple styles of MMA gained from fighting the borrow checker, if that counts.</p></blockquote>","contentLength":2690,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"December Project Goals Update","url":"https://blog.rust-lang.org/2025/01/23/Project-Goals-Dec-Update.html","date":1737590400,"author":"David Wood and Niko Matsakis","guid":313,"unread":true,"content":"<p>Our big goal for this period was async closures, and we are excited to announce that work there is done! Stable support for async closures <a href=\"https://github.com/rust-lang/rust/pull/132706#issuecomment-2540470500\">landed on nightly on Dec 12</a> and it will be included in Rust 1.85, which ships on Feb 20. Big kudos to <a href=\"https://github.com/compiler-errors\">compiler-errors</a> for driving that.</p><p>For our other goals, we made progress, but there remains work to be done:</p><ul><li><strong>Return Type Notation (RTN)</strong> is implemented and we had a <a href=\"https://blog.rust-lang.org/inside-rust/2024/09/26/rtn-call-for-testing.html\">call for experimentation</a> but it has not yet reached stable. This will be done as part of our 2025H1 goal.</li><li>Async Functions in Traits (and Return Position Impl Trait in Trait) are currently not consided  compatible. We would eventually like to have first-class  support, but as an intermediate step we created a procedural macro crate <a href=\"https://crates.io/crates/dynosaur\"></a> that can create wrappers that enable . We are planning a comprehensive blog post in 2025H1 that shows how to use this crate and lays out the overall plan for async functions in traits.</li><li>Work was done to prototype an <strong>implementation for async drop</strong> but we didn't account for reviewing bandwidth. <a href=\"https://github.com/nikomatsakis\">nikomatsakis</a> has done initial reads and is working with PR author to get this done in 2025H1. To be clear though the scope of this is an experiment with the goal of uncovering implementation hurdles. There remains significant language design work before this feature would be considered for stabilization (we don't even have an RFC, and there are lots of unknowns remaining).</li><li>We have had fruitful discussions about the trait for  but do not have widespread consensus, that's on the docket for 2025H1.</li></ul><p>We largely completed our goal to stabilize the language features used by the Rust for Linux project. In some cases a small amount of work remains. Over the last six months, we...</p><ul><li>stabilized the  macro to get the offset of fields;</li><li> stabilization PR and reference updates are up, excluding the \"output\" feature.</li><li>completed the majority of the work for arbitrary self types, which is being used by RfL and just needs documentation before stabilisation</li></ul><p>We also began work on compiler flag stabilization with <a href=\"https://github.com/rust-lang/rfcs/pull/3716\">RFC 3716</a>, which outlines a scheme for stabilizing flags that modify the target ABI.</p><p>The final release of Rust 2024 is confirmed for February 20, 2025 as part of Rust 1.85. Rust 1.85 is currently in beta. Feedback from the nightly beta and crater runs has been actively addressed, with adjustments to migrations and documentation to enhance user experience.</p><p>Big shout-outs to <a href=\"https://github.com/traviscross\">TC</a> and  <a href=\"https://github.com/ehuss/\">Eric Huss</a> for their hard work driving this program forward.</p><p>Over the last six months a number of internal refactorings have taken place that are necessary to support a  prototype.</p><p>One refactoring is that we have changed how we represent const arguments in the compiler to allow for adding a separate representation for the kinds of const arguments that  will add.</p><p>Another big refactoring is that we have changed the API surface for our representation of const arguments in the type system layer, there is no longer a way to evaluate a const argument without going through our general purpose type system logic. This was necessary to ensure that we correctly handle equality of the kinds of const arguments that  will support.</p><p>With all of these pre-requisite refactorings completed, a feature gate has been added to the compiler (<code>feature(min_generic_const_args)</code>) that uses the new internal representation of const arguments. We are now beginning to implement the actual language changes under this feature gate.</p><p>Over the course of the last six months...</p><ul><li>cargo semver-checks began to include generic parameters and bounds in its schema, allowing for more precise lints;</li><li>cargo manifest linting was implemented and merged, allowing for lints that look at the cargo manifest;</li><li>building on cargo manifest linting, the  lint was added, which identifies breakage caused by the removal of a package feature.</li></ul><p>In addition, we fleshed out a design sketch for the changes in rustdoc's JSON support that are needed to support cross-crate item linting. This in turn requires compiler extensions to supply that information to rustdoc.</p><ul><li>Progress was made on adding const traits and implementation in the compiler, with improvements being carefully considered.  was constified in <a href=\"https://github.com/rust-lang/rust/pull/133237\">rust#133237</a> and / in <a href=\"https://github.com/rust-lang/rust/pull/133260\">rust#133260</a>.</li></ul><ul><li>Over the last six months, we created a lang-team experiment devoted to this issue and <a href=\"https://github.com/spastorino\">spastorino</a> began work on an experimental implementation. <a href=\"https://github.com/joshtriplett\">joshtriplett</a> authored <a href=\"https://github.com/rust-lang/rfcs/pull/3680\">RFC 3680</a>, which has received substantial feedback. The current work is focused on identifying \"cheaply cloneable\" types and making it easy to create closures that clone them instead of moving them.</li></ul><ul><li>Alternatives to sandboxed build scripts are going to be investigated instead of continuing this project goal into 2025h1 - namely, declaratively configuring system dependencies with <a href=\"https://crates.io/crates/system-deps\"></a>, using an approach similar to code-checker <a href=\"https://crates.io/crates/cargo-acl\">Cackle</a> and its sandbox environment <a href=\"https://github.com/containers/bubblewrap\">Bubblewrap</a>, or fully-sandboxed build environments like Docker or Nix.</li></ul><ul><li>Significant speedups have been achieved, reducing the slowest crate resolution time from over 120 seconds to 11 seconds, and decreasing the time to check all crates from 178 minutes to 71.42 minutes.</li><li>Performance improvements have been made to both the existing resolver and the new implementation, with the lock file verification time for all crates reduced from 44.90 minutes to 32.77 minutes (excluding some of the hardest cases).</li></ul><ul><li>Our pull request adding example searches and adding a search button has been added to the agenda for the rustdoc team next meeting.</li></ul><ul><li>The  stabilization is now stable in version 1.84, with a new update blogpost published.</li><li>Significant progress was made on bootstrap with . We're now able to compile rustc and cargo, enabling try-builds and perf runs.</li></ul><ul><li>An optimisation for the  lint is open, benchmarked, and currently under review.</li><li>Help is needed on any issue marked with , especially on issue #13714.</li></ul><ul><li>Over the course of this goal, Nadrieril wrote and posted the never patterns RFC as an attempt to make progress without figuring out the whole picture, and the general feedback was \"we want to see the whole picture\". Next step will be to write up an RFC that includes a clear proposal for which empty patterns can and cannot be omitted. This is 100% bottlenecked on my own writing bandwidth (reach out if you want to help!). Work will continue but the goal won't be resubmitted for 2025h1.</li></ul><ul><li><a href=\"https://github.com/amandasystems\">Amanda</a> has made progress on removing placeholders, focusing on lazy constraints and early error reporting, as well as investigating issues with rewriting type tests; a few tests are still failing, and it seems error reporting and diagnostics will be hard to keep exactly as today.</li><li><a href=\"https://github.com/lqd\">@lqd</a> has opened PRs to land the prototype of the location-sensitive analysis. It's working well enough that it's worthwhile to land; there is still a lot of work left to do, but it's a major milestone, which we hoped to achieve with this project goal.</li></ul><ul><li>A fix stopping cargo-script from overriding the release profile was posted and merged.</li><li>Help is wanted for writing frontmatter support in rustc, as rustfmt folks are requesting it to be represented in the AST.</li></ul><ul><li>RFC is done, waiting for all rustdoc team members to take a look before implementation can start.</li></ul><ul><li><a href=\"https://github.com/SparrowLii\">SparrowLii</a> proposed a 2025H1 project goal to continue stabilizing the parallel front end, focusing on solving reproducible deadlock issues and improving parallel compilation performance.</li><li>The team discussed solutions to avoid potential deadlocks, finding that disabling work-stealing in rayon's subloops is effective, and will incorporate related modifications in a PR.</li></ul><ul><li>Progress on  continued despite a busy schedule, with a focus on improving suggestions and addressing architectural challenges.</li><li>A new API was designed in collaboration with <a href=\"https://github.com/epage\">epage</a>, aiming to align  more closely with  for easier contribution and integration.</li></ul><ul><li>The project goal slate for 2025h1 has been posted <a href=\"https://github.com/rust-lang/rfcs/pull/3764#issuecomment-2593395122\">as an RFC</a> and is waiting on approval from project team leads.</li></ul><ul><li>Another pull request was merged with only one remaining until a working MVP is available on nightly.</li><li>Some features were removed to simplify upstreaming and will be added back as single PRs.</li><li>Will start work on  feature of LLVM/Enzyme which allows Array of Struct and Struct of Array vectorisation.</li><li>There's been a push to add a AMD GPU target to the compiler which would have been needed for the LLVM offload project.</li></ul><ul><li>We have written and verified around 220 safety contracts in the verify-rust-std fork.</li><li>3 out of 14 challenges have been solved.</li><li>We have successfully integrated Kani in the repository CI, and we are working on the integration of 2 other verification tools: VeriFast and Goto-transcoder (ESBMC)</li></ul><ul><li>There wasn't any progress on this goal, but building a community around a-mir-formality is still a goal and future plans are coming.</li></ul><p>The following goals have not received updates in the last month:</p>","contentLength":8756,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"This Week in Rust 583","url":"https://this-week-in-rust.org/blog/2025/01/22/this-week-in-rust-583/","date":1737522000,"author":"TWiR Contributors","guid":463,"unread":true,"content":"<p>This week's crate is <a href=\"https://crates.io/crates/resvg\">resvg</a>, an SVG rendering library.</p><p>An important step for RFC implementation is for people to experiment with the\nimplementation and give feedback, especially before stabilization.  The following\nRFCs would benefit from user testing before moving forward:</p><ul><li><em>No calls for testing were issued this week.</em></li></ul><ul><li><em>No calls for testing were issued this week.</em></li></ul><ul><li><em>No calls for testing were issued this week.</em></li></ul><p>If you are a feature implementer and would like your RFC to appear on the above list, add the new \nlabel to your RFC along with a comment providing testing instructions and/or guidance on which aspect(s) of the feature\nneed testing.</p><p>Always wanted to contribute to open-source projects but did not know where to start?\nEvery week we highlight some tasks from the Rust community for you to pick and get started!</p><p>Some of these tasks may also have mentors available, visit the task page for more information.</p><p>Are you a new or experienced speaker looking for a place to share something cool? This section highlights events that are being planned and are accepting submissions to join their event as a speaker.</p><p>A very quiet week for performance, with small improvements essentially on all benchmarks.</p><p>0 Regression, 1 Improvement, 2 Mixed; 0 of them in rollups\n40 artifact comparisons made in total</p><p>Every week, <a href=\"https://www.rust-lang.org/team.html\">the team</a> announces the 'final comment period' for RFCs and key PRs\nwhich are reaching a decision. Express your opinions now.</p><ul><li><em>No Cargo Tracking Issues or PRs entered Final Comment Period this week.</em></li></ul><ul><li><em>No Language Team Proposals entered Final Comment Period this week.</em></li></ul><ul><li><em>No Language Reference RFCs entered Final Comment Period this week.</em></li></ul><ul><li><em>No Unsafe Code Guideline Tracking Issues or PRs entered Final Comment Period this week.</em></li></ul><p>Rusty Events between 2025-01-22 - 2025-02-19 ü¶Ä</p><p>If you are running a Rust event please add it to the <a href=\"https://www.google.com/calendar/embed?src=apd9vmbc22egenmtu5l6c5jbfc%40group.calendar.google.com\">calendar</a> to get\nit mentioned here. Please remember to add a link to the event too.\nEmail the <a href=\"mailto:community-team@rust-lang.org\">Rust Community Team</a> for access.</p><blockquote><p>Memory safety issues mean you can‚Äôt trust what you‚Äôre seeing in your source code anymore.</p></blockquote>","contentLength":2032,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Rust 2024 in beta channel","url":"https://blog.rust-lang.org/2025/01/22/rust-2024-beta.html","date":1737504000,"author":"TC & Eric Huss","guid":312,"unread":true,"content":"<p>The next edition, Rust 2024, has entered the beta channel.  It will live there until 2025-02-20, when Rust 1.85 and Rust 2024 will be released as stable.</p><p>We're really happy with how Rust 2024 has turned out, and we're looking forward to putting it in your hands.</p><p>You can get a head start in preparing your code for the new edition, and simultaneously help us with final testing of Rust 2024, by following these steps within a project:</p><ol><li>Run <code>cargo +beta fix --edition</code>.</li><li>Set  and, if needed, , in .</li><li>Run , address any remaining warnings, and then run other tests.</li></ol><p>More details on how to migrate can be found <a href=\"https://doc.rust-lang.org/nightly/edition-guide/editions/transitioning-an-existing-project-to-a-new-edition.html\">here</a> and within each of the <a href=\"https://doc.rust-lang.org/nightly/edition-guide/rust-2024/\">chapters</a> describing the changes in Rust 2024.  For more on the changes themselves, see the <a href=\"https://doc.rust-lang.org/nightly/edition-guide/\">Edition Guide</a>.</p><p>If you encounter any problems or see areas where we could make the experience better, tell us about it by <a href=\"https://github.com/rust-lang/rust/issues/new/choose\">filing an issue</a>.</p>","contentLength":851,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Pre-RFC - Rename annotations","url":"https://poignardazur.github.io//2025/01/22/rename-annotations/","date":1737504000,"author":"Olivier Faure","guid":743,"unread":true,"content":"<p>Let‚Äôs imagine you‚Äôre writing a crate.</p><p>Your crate has a single  file, with two modules and an arbitrary number of items:</p><div><div><pre><code></code></pre></div></div><p>After a while, you decide that Foobar should really be exported from the  module. It‚Äôs a breaking change, but you‚Äôre fine with releasing a new major version:</p><div><div><pre><code></code></pre></div></div><p>Any user previously importing from your crate will get this error when they bump the version number:</p><div><div><pre><code>error[E0432]: unresolved import `best_crate::bar::Foobar`\n  --&gt; src/lib.rs:12:5\n   |\n12 | use best_crate::bar::Foobar;\n   |     ^^^^^^^^^^^^^^^^^^^^^^^ no `Foobar` in `best_crate::bar`\n   |\nhelp: consider importing this struct instead\n   |\n12 | use best_crate::foo::Foobar;\n   |     ~~~~~~~~~~~~~~~~~~~~~~~~\n</code></pre></div></div><p>This isn‚Äôt ideal, but at least there‚Äôs the ‚Äúconsider importing this instead‚Äù message giving these users an easy way to fix this.</p><p>But now let‚Äôs say you decide that ‚ÄúFoobar‚Äù is a terrible name, and your struct should really be named ‚ÄúFoofoo‚Äù instead for consistency:</p><div><div><pre><code></code></pre></div></div><p>Now your users will get this message:</p><div><div><pre><code>error[E0432]: unresolved import `best_crate::bar::Foobar`\n  --&gt; src/lib.rs:12:5\n   |\n12 | use best_crate::bar::Foobar;\n   |     ^^^^^^^^^^^^^^^^^^^^^^^ no `Foobar` in `best_crate::bar`\n</code></pre></div></div><p>No message to help them figure out what to use instead.</p><p>Rust should have an attribute to inform the compiler that an item previously existed, but has been moved and/or renamed:</p><div><div><pre><code></code></pre></div></div><p>You might want to put the attribute on the ‚Äúnew‚Äù item instead, in which case the syntax would be:</p><div><div><pre><code></code></pre></div></div><p>You‚Äôd probably want both, for cases where either the module of origin is removed, or the destination is no longer in the same crate (e.g. because you‚Äôve split your crate into sub-crates).</p><p>This diagnostic could help the compiler give more helpful error messages:</p><div><div><pre><code>error[E0432]: unresolved import `best_crate::bar::Foobar`\n  --&gt; src/lib.rs:12:5\n   |\n12 | use best_crate::bar::Foobar;\n   |     ^^^^^^^^^^^^^^^^^^^^^^^ no `Foobar` in `best_crate::bar`\n   |\nhelp: this item has been renamed to `best_crate::foo::Foofoo`\n   |\n12 | use best_crate::foo::Foofoo;\n   |     ~~~~~~~~~~~~~~~~~~~~~~~~\n</code></pre></div></div><p>Because the compiler is  that this is the correct move and not just guessing based on name similarity,  and similar tools would be able to automatically apply the rename.</p><p>Rename annotations would be helpful as a ‚Äúgrace period‚Äù after a crate‚Äôs major version change, but they would also be useful for purely internal refactors, using  to change  directives throughout your codebase.</p><p>All in all, this feels like a pretty useful feature which, thanks to the  namespace‚Äôs relaxed constraints, could be implemented relatively swiftly in the Rust toolchain.</p>","contentLength":2615,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Patterns of use of Vello crate","url":"https://poignardazur.github.io//2025/01/18/vello-analysis/","date":1737158400,"author":"Olivier Faure","guid":742,"unread":true,"content":"<p>This document tries to establish patterns among a list of crates and Github projects using the <a href=\"https://github.com/linebender/vello/\">Vello</a> renderer.</p><p>The crate list isn‚Äôt meant to be exhaustive, but it‚Äôs pretty large: I‚Äôve sifted through maybe 40 or so reverse dependencies of the Vello repository, up to the point where most of the READMEs I read were along the lines of ‚ÄúWIP: quick experiment paint shapes with Vello‚Äù.</p><p>Don‚Äôt expect anything groundbreaking. My main focus is on common patterns among people using Vello‚Äôs <a href=\"https://docs.rs/vello/latest/vello/struct.Scene.html\"></a> API; most of this is going to be pretty dry.</p><p>I‚Äôve mostly noticed two types of projects with Vello as a direct dependency:</p><ul><li> bridging Vello with some other format or framework, or providing wrapper functions for Vello‚Äôs API. Ex: , , etc.</li><li> that renders specific things with Vello.</li></ul><p>(Though in practice, a few blurred the lines, and a lot of projects that I put in one category or the other mostly ended up using Vello for example code or for very basic painting.)</p><p>The numbers (18 engine projects, 13 app-like projects) aren‚Äôt too surprising if you‚Äôre familiar with the ‚ÄúRust has 50 game engines and 3 games‚Äù stereotype. They also match my ‚Äúgut feeling‚Äù reading the code, where it feels like a lot more projects use Vello in a very systematized way, as some kind of middleware or optional backend than as a plug-and-play dependency to paint a bunch of shapes.</p><p>For instance, I saw almost no project calling the  function more than five times.</p><p>This is confounded by the fact that I only looked for direct dependents of Vello; I might have found more app projects looking for dependents of Masonry or bevy_vello. Maybe the painting-privitive-heavy code is in the dependents of one of those engine code projects I cited.</p><p>Graphite, for example, is a primitive-heavy 2D editor, but its use of Vello is bottlenecked through a middleware layer with its own internal representation.</p><p>In general, though, my impression is that the stereotype is mostly true.</p><p>Another interesting pattern is that code actually using Vello to paint things was often in amateur stub projects, which is good for our purposes: it tells us how people who have little experience with Vello end up using it.</p><h3>Fill and stroke arguments</h3><p> and  are the most used methods by a very wide margin.</p><p>As a reminder, their prototype is:</p><div><div><pre><code></code></pre></div></div><p>A lot code calling them looks like this:</p><div><div><pre><code></code></pre></div></div><p>Note the heavy usage of default values:</p><ul><li> is the default fill setting for most paint APIs.</li><li> creates a stroke with rount joins and caps, no dashes, and the given width.</li><li> is set to  for both methods.</li><li> is set to  for both methods.</li></ul><p>These patterns can be found throughout the projects I‚Äôve linked. In total, I‚Äôve counted:</p><ul><li>16 projects using  with ,  and .</li><li>10 projects using  with ,  and .</li><li>7 projects using  with , a transform and .</li><li>3 projects using  with , a transform and .</li></ul><p>Projects that used all the arguments of  or  were rare, and were generally written as middleware code passing these arguments from another source. For example:</p><div><div><pre><code></code></pre></div></div><p>These projects tended to have one instance code calling each Scene method in the entire repository.</p><p>Most of the projects I‚Äôve looked at used the  and  API exclusively.\nFew of them used , , , etc.</p><p>In total, I‚Äôve counted about a dozen projects using any of these APIs.</p><p>Those that did tended to be the ‚Äúrender any arbitrary SVG‚Äù kinds of projects.</p><p>Based on the above, I‚Äôd recommend having Vello export the following API:</p><div><div><pre><code></code></pre></div></div><ul><li> and  use the minimum number of arguments.</li><li> and  use an additional  argument.</li><li> and  use the full API.</li></ul><p>With this API, the  code I quoted would look like this:</p><div><div><pre><code></code></pre></div></div><p>This would also let us remove most of the helpers in  in Masonry.</p>","contentLength":3583,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["rust"]}