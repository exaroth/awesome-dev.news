{"id":"EfcLDDAkyqguXw9Vbtcae7fRhxCsY1chPUNLpwbK9oHS42b4dGEMeGvA2hWHB2j3LFSAo7qhibLNgPBcA5djbGp95Jk5T","title":"top scoring links : programming","displayTitle":"Reddit - Programming","url":"https://www.reddit.com/r/programming/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/programming/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"Why OOP & FP are the Two Main Paradigms","url":"https://www.youtube.com/watch?v=l_3AGwVwP_k","date":1739624173,"author":"/u/OkMemeTranslator","guid":592,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1iq0rlf/why_oop_fp_are_the_two_main_paradigms/"},{"title":"Lessons from David Lynch: A Software Developer's Perspective","url":"https://lackofimagination.org/2025/02/lessons-from-david-lynch-a-software-developers-perspective/","date":1739612430,"author":"/u/aijan1","guid":594,"unread":true,"content":"<p>David Lynch passed away in January 2025, shortly after being evacuated from his Los Angeles home due to the Southern California wildfires. He’s perhaps best known for the groundbreaking TV series <a href=\"https://en.wikipedia.org/wiki/Twin_Peaks\">Twin Peaks</a>, which inspired countless shows, including The X-Files, The Sopranos, and Lost.</p><p>Lynch was genuinely a good human being who cared deeply for his actors and crew. He discovered extraordinary talent like Naomi Watts, who had struggled to land a major role in a Hollywood movie after 10 years of auditioning. From the interviews he gave, it quickly becomes apparent that he respected people of all kinds and never put anyone down – even those who truly deserved it.</p><p>Lynch is famous for refusing to explain his movies. Although not a fan of his previous work, the great film critic Roger Ebert once wrote that <a href=\"https://en.wikipedia.org/wiki/Mulholland_Drive_(film)\">Mulholland Drive</a> remained compulsively watchable while refusing to yield to interpretation.</p><p>While Lynch offered very little in terms of what his movies meant, he was generous in sharing his views on creativity, work, and life in general. As a tribute to Lynch, I’d like to share my perspective on his life lessons from a software developer’s viewpoint.</p><blockquote><p>Ideas are like fish. If you want to catch little fish, you can stay in the shallow water. But if you want to catch the big fish, you’ve got to go deeper.</p></blockquote><p>We’ve all got hundreds or even thousands of ideas floating around in our brains. But the really big ones are few and far between. Once you catch a good one –because they’re so rare– write it down immediately, says Lynch. From there, ideas attract other ideas and start to grow from their initial seed state. The final job is to translate those ideas into a medium, whether it’s a film, a painting, or software.</p><blockquote><p>The idea is the whole thing. If you stay true to the idea, it tells you everything you need to know, really. You just keep working to make it look like that idea looked, feel like it felt, sound like it sounded, and be the way it was.</p></blockquote><p>Software development is part art, part engineering. We don’t build the same software over and over again – virtually all software is crafted by hand, sometimes with help from AI. If you ask two developers to create a non-trivial program, it’s very likely that the programs they produce will be different, even if the functionality is the same. Under the hood, the programming language, data structures, and overall architecture may be completely different. And on the surface, the user interfaces may look nothing alike.</p><p>It’s a good habit to listen to what users have to say, but they often can only describe their problems – they rarely come up with good ideas to solve them. And that’s OK. It’s our job to find the right ideas, implement them well, and solve tricky problems in a way we, and hopefully the users, will love.</p><blockquote><p>My friend Bushnell Keeler, who was really responsible for me wanting to be a painter, said you need four hours of uninterrupted time to get one hour of good painting in, and that is really true.</p></blockquote><p>Like other creative fields, writing code requires deep concentration. We need to hold complex structures in our minds while working through problems. Switching between coding and other tasks disrupts  – that magical state of mind where we lose track of time and produce code effortlessly. That’s why many developers hate meetings – they are toxic to our productivity.</p><blockquote><p>I believe you need technical knowledge. And also, it’s really, really great to learn by doing. So, you should make a film.</p></blockquote><p>Software development is one of those rare fields where a college degree isn’t required to succeed. Yes, we should all know the basics, but in my experience, new college graduates often lack the practical knowledge to be effective developers.</p><p>The real learning happens through hands-on experience: building real projects, debugging tricky problems, collaborating with teams, and maintaining code over time. It’s crucial to never stop learning, experimenting, and iterating on our craft.</p><blockquote><p>Happy accidents are real gifts, and they can open the door to a future that didn’t even exist.</p></blockquote><p>Tim Berners-Lee invented the web in 1989, while working at CERN, the European Organization for Nuclear Research. Originally conceived to meet the demand for information sharing between scientists around the world, the web went mainstream within just a few years.</p><p>Linus Torvalds created Git due to a licensing dispute over BitKeeper, the original version control system used for Linux development. The need for a new tool led to Git becoming the most widely used version control system today.</p><blockquote><p>I feel that a set should be like a happy family. Almost like Thanksgiving every day, happily going down the road together.</p></blockquote><p>Be kind to your teammates, don’t embarrass them. They may not be perfect, but accept them for who they are. The most important trait of an effective software development team is psychological safety –that is, team members feel safe to take risks and be vulnerable in front of each other, as corroborated by <a href=\"https://rework.withgoogle.com/en/guides/understanding-team-effectiveness\">Google’s research</a> on the subject.</p><p>It’s OK to make mistakes, as long as you learn from them. Knowing that your team has your back when things go south is a wonderful feeling.</p><blockquote><p>Most of Hollywood is about making money - and I love money, but I don’t make the films thinking about money.</p></blockquote><p>Just like Lynch prioritizes creativity over financial gain, some of the most impactful software projects started with an open source model, and they literally changed the world, such as Linux, PostgreSQL, and Node.js, just to name a few.</p><p>What makes these projects remarkable is that they didn’t emerge from corporate boardrooms – they were built by communities of passionate developers, collaborating across the world.</p><p>Money is just a means to an end. Unfortunately, many get this confused.</p><p>David, thank you for making the world a better place!</p>","contentLength":5845,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ipy01t/lessons_from_david_lynch_a_software_developers/"},{"title":"Kafka Delay Queue: When Messages Need a Nap Before They Work","url":"https://beyondthesyntax.substack.com/p/kafka-delay-queue-when-messages-need","date":1739596108,"author":"/u/Sushant098123","guid":596,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ipu9n3/kafka_delay_queue_when_messages_need_a_nap_before/"},{"title":"Modern Java Deep Dive","url":"https://www.youtube.com/watch?v=z4qsidg261E","date":1739591964,"author":"/u/BlueGoliath","guid":591,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ipt4pe/modern_java_deep_dive/"},{"title":"Siren Call of SQLite on the Server","url":"https://pid1.dev/posts/siren-call-of-sqlite-on-the-server/","date":1739551579,"author":"/u/sausagefeet","guid":593,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ipevoh/siren_call_of_sqlite_on_the_server/"},{"title":"Switching on Strings in Zig","url":"https://www.openmymind.net/Switching-On-Strings-In-Zig/","date":1739542983,"author":"/u/simon_o","guid":595,"unread":true,"content":"<p>Newcomers to Zig will quickly learn that you can't switch on a string (i.e. ). The following code gives us the unambiguous error message :</p><pre><code>color</code></pre><p>I've seen two explanations for why this isn't supported. The first is that there's ambiguity around string identity. Are two strings only considered equal if they point to the same address? Is a null-terminated string the same as its non-null-terminated counterpart? The other reason is that users of  [apparently] expect <a href=\"https://en.wikipedia.org/wiki/Branch_table\">certain optimizations</a> which are not possible with strings (although, presumably, these same users would know that such optimizations aren't possible with string).</p><p>Instead, in Zig, there are two common methods for comparing strings.</p><p>The most common way to compare strings is using  with :</p><pre><code>stdmem colorstdmem colorstdmem colorstdmem color</code></pre><p>The implementation for  depends on what's being compared. Specifically, it has an optimized code path when comparing strings. Although that's what we're interested in, let's look at the non-optimized version:</p><pre><code> T a balen  blenalen  aptr  bptra ba_elem b_elema_elem  b_elem</code></pre><p>Whether we're dealing with slices of bytes or some other type, if they're of different length, they can't be equal. Once we know that they're the same length, if they point to the same memory, then they must be equal. I'm not a fan of this second check; it might be cheap, but I think it's quite uncommon. Once those initial checks are done, we compare each element (each byte of our string) one at a time.</p><p>The optimized version, which  used for strings, is <a href=\"https://github.com/ziglang/zig/blob/5b9b5e45cb710ddaad1a97813d1619755eb35a98/lib/std/mem.zig#L720\">much more involved</a>. But it's fundamentally the same as the above with <a href=\"https://www.openmymind.net/SIMD-With-Zig/\">SIMD</a> to compare multiple bytes at once.</p><p>The nature of string comparison means that real-world performance is dependent on the values being compared. We know that if we have 100  branches then, at the worse case, we'll need to call  100 times. But comparing strings of different lengths or strings which differ early will be significantly faster. For example, consider these three cases:</p><pre><code> str1  10_000  str2  10_000 \n    _  stdmem str1 str2 str1  a\"  10_000 str2  a\"  10_000\n    _  stdmem str1 str2 str1  999_999 str2  1_000_000\n    _  stdmem str1 str2</code></pre><p>For me, the first comparison takes ~270ns, whereas the other two take ~20ns - despite the last one involving much larger strings. The second case is faster because the difference is early in the string allowing the  loop to return after only one comparison. The third case is faster because the strings are of a different length:  is returned by the initial  check.</p><p>The  takes an enum type and a string value and returns the corresponding enum value or null. This code prints \"you picked: blue\"</p><pre><code> std \n    red\n    blue\n    green\n    pink color  stdmetaColorInvalidChoicecolorred  stddebugblue  stddebuggreen  stddebugpink  stddebug</code></pre><p>If you don't need the enum type (i.e. ) beyond this check, you can leverage Zig's anonymous types. This is equivalent:</p><pre><code> std  color  stdmeta\n        red\n        blue\n        green\n        pinkInvalidChoicecolorred  stddebugblue  stddebuggreen  stddebugpink  stddebug</code></pre><p>It's  obvious how this should perform versus the straightforward  approach. Yes, we now have a  statement that the compiler can [hopefully] optimize, but  still has convert our input, , into an enum.</p><p>The implementation of  depends on the number of possible values, i.e. the number of enum values. Currently, if there are more than 100 values, it'll fallback to using the same  that we explored above. Thus, with more than 100 values it does the  check PLUS the switch. This should <a href=\"https://github.com/ziglang/zig/issues/3863\">improve in the future</a>.</p><p>However, with 100 or fewer values,  creates a comptime  which can then be used to lookup the value.  isn't something we've looked at before. It's a specialized map that buckets keys by their length. Its advantage over Zig's <a href=\"https://www.openmymind.net/Zigs-HashMap-Part-1/\">other hash maps</a> is that it can be constructed at compile-time. For our  enum, the internal state of a  would look something like:</p><pre><code>// keys are ordered by length\nkeys:     [\"red\", \"blue\", \"pink\", \"green\"];\n\n// values[N] corresponds to keys[N]\nvalues:   [.red, .blue, .pink, .green];\n\n// What's this though?\nindexes:  [0, 0, 0, 0, 1, 3];</code></pre><p>It might not be obvious how  is used. Let's write our own  implementation, simulating the above  state:</p><pre><code>str keys  values redbluepinkgreen indexes strlen  indexeslen index  indexesstrlenindex  keyslen key  keysindexkeylen  strlenstdmem key str valuesindex\n        index </code></pre><p>Take note that  are ordered by length. As a naive implementation, we could iterate through the keys until we either find a match or find a key with a longer length. Once we find a key with a longer length, we can stop searching, as all remaining candidates won't match - they'll all be too long.  goes a step further and records the index within  where entries of a specific length begin.  tells us where to start looking for keys with a length of 3 (at index 0).  tells us where to start looking for keys with a length of 5 (at index 3).</p><p>Above, we fallback to using  for any key which is the same length as our target string.  uses its own \"optimized\" version:</p><pre><code>a baptr  bptra ba_elem b_elema_elem  b_elem</code></pre><p>This is the same as the simple  implementation, minus the length check. This is done because the  within our  loop is only ever called for values with matching length. On the flip side, 's  doesn't use SIMD, so it would be slower for large strings.</p><p>In my own benchmarks, in general, I've seen little difference between the two approaches. It does seem like  is generally as fast or faster. It also results in more concise code and is ideal if the resulting enum is useful beyond the comparison.</p><p>You usually don't have long enum values, so the lack of SIMD-optimization isn't a concern. However, if you're considering building your own  at compile time with long keys, you should benchmark with a custom  function based on .</p><p>We could manually bucket those  branches ourselves, similar to what the  does. Something like:</p><pre><code>colorlenstdmem colorstdmem colorstdmem colorstdmem color</code></pre><p>Ughhh. This highlights the convenience of using  to generate similar code. Also, do remember that  quickly discards strings of different lengths, which helps to explain why both approaches generally perform similarly.</p>","contentLength":6154,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ipbna2/switching_on_strings_in_zig/"}],"tags":["dev","reddit"]}