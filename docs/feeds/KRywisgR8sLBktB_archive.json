{"id":"KRywisgR8sLBktB","title":"JS/Frontend","displayTitle":"JS/Frontend","url":"","feedLink":"","isQuery":true,"isEmpty":false,"isHidden":false,"itemCount":9,"items":[{"title":"3D Layered Text: Interactivity and Dynamicism","url":"https://css-tricks.com/3d-layered-text-interactivity-and-dynamism/","date":1755868471,"author":"Amit Sheen","guid":236913,"unread":true,"content":"<p>In the previous two chapters, we built a layered 3D text effect, added depth and color, and then brought it to life with motion. We explored static structure, animated variations, and even some clever decoration tricks. But everything so far has been hard-coded.</p><p>This time, we’re going dynamic.</p><p>In this final chapter, we’re stepping into the world of interactivity by adding JavaScript into the mix. We’ll start by generating the layers programmatically, giving us more flexibility and cleaner code (and we’ll never have to copy-paste divs again). Then, we’ll add some interaction. Starting with a simple  effect, and ending with a fully responsive bulging text that follows your mouse in real time. Let’s go.</p><p>Before we jump into JavaScript, let us clean things up a bit. We will pause the animations for now and go back to the static example we wrapped up with in the first chapter. No need to touch the CSS just yet. Let us start with the HTML.</p><p>We will strip it down to the bare essentials. All we really need is one element with the text. The class stays. It is still the right one for the job.</p><pre rel=\"HTML\" data-line=\"\"><code markup=\"tt\">&lt;div class=\"layeredText\"&gt;Lorem Ipsum&lt;/div&gt;</code></pre><p>It is time. Let us start adding some JavaScript. Don’t worry, the impact on performance will be minimal. We’re only using JavaScript to set up the layers and define a few CSS variables. That’s it. All the actual style calculations still happen off the main thread, maintain high frames per second, and don’t stress the browser.</p><p>We will begin with a simple function called . This is where all the magic of layer generation will happen. To work its magic, the function will receive the element we want to use as the container for the layers.</p><pre rel=\"JavaScript\" data-line=\"\"><code markup=\"tt\">function generateLayers(element) {\n  // magic goes here\n}</code></pre><p>To trigger the function, we will first create a small variable that holds all the elements with the  class. And yes, we can have more than one on the page, as we will see later. Then, we will pass each of these elements into the  function to generate the layers.</p><pre rel=\"JavaScript\" data-line=\"\"><code markup=\"tt\">const layeredElements = document.querySelectorAll('.layeredText');\n\nlayeredElements.forEach(generateLayers);</code></pre><p>Now let us dive into the  function itself and start with a small fail safe mechanism. There are situations, especially when working with frameworks or libraries that manage your DOM, where a component might get rendered more than once or a function might run multiple times. It should not happen, but we want to be ready just in case.</p><p>So, before we do anything, we will check if the element already contains a  with the  class. If it does, we will simply exit the function and do nothing:</p><pre rel=\"JavaScript\" data-line=\"\"><code markup=\"tt\">function generateLayers(element) {\n  if (element.querySelector('.layers')) return;\n  \n  // rest of the logic goes here\n}</code></pre><p> In the real world, I would treat this as a chance to catch a rendering bug. Instead of silently returning, I would probably send a message back to the dev team with the relevant data and expect the issue to be fixed.</p><p>One last thing we need to cover before we start building the layers is the number of layers. If you remember, we have a CSS variable called , but that will not help us here. Besides, we want this to be more dynamic than a single hardcoded value.</p><p>Here is what we will do. We will define a constant in our JavaScript called . As the name suggests, this will be our default value. But we will also allow each element to override it by using an attribute like .</p><p>Then we will take that number and push it back into the CSS using  on the parent element, since we rely on that variable in the styles.</p><pre rel=\"JavaScript\" data-line=\"\"><code markup=\"tt\">const DEFAULT_LAYERS_COUNT = 24;\n\nfunction generateLayers(element) {  \n  if (element.querySelector('.layers')) return;\n  \n  const layersCount = element.dataset.layers || DEFAULT_LAYERS_COUNT;\n  element.style.setProperty('--layers-count', layersCount);\n}</code></pre><p>Now we have everything we need, and we can finally generate the layers. We will store the original text content in a variable. Then we will build the markup, setting the  of the parent element to match the structure we used in all the previous examples. That means a  with the original content, followed by a  with the  class.</p><p>Inside that , we will run a loop based on the number of layers, adding a new layer in each iteration:</p><pre rel=\"JavaScript\" data-line=\"\"><code markup=\"tt\">function generateLayers(element) {\n\n  // previous code\n\n  const content = element.textContent;\n\n  element.innerHTML = `\n    &lt;span&gt;${content}&lt;/span&gt;\n    &lt;div class=\"layers\" aria-hidden=\"true\"&gt;\n      ${Array.from({ length: layersCount}, (_, i) =&gt;\n        `&lt;div class=\"layer\" style=\"--i: ${i + 1};\"&gt;${content}&lt;/div&gt;`\n      ).join('')}\n    &lt;/div&gt;\n  `;\n}</code></pre><p>And that is it. Our 3D text is ready, and all the layers are now built entirely through JavaScript. Try playing around with it. Change the text inside the  element. Add your name, your project name, your brand. Let me know how it looks.</p><p> I also removed the  variable from the CSS, since it is now set dynamically with JavaScript. While I was at it, I moved the font settings out of the  element, since they should be applied globally or to a more appropriate wrapper. Just a bit of housekeeping to keep things clean.</p><p>Since we already added a way to set the number of layers dynamically, let us take advantage of it.</p><p>Here is an example with three different  elements, each using a different number of layers. The first one (A) has 8 layers, the second (B) has 16, and the third (C) has 24.</p><p>You can clearly see the difference in height between the letters, since the total height depends on the number of layers. When it comes to color though, we used the normalized value (remember that?), so the gradient looks consistent regardless of height or layer count.</p><p>We can just as easily normalize the total height of the layers. All we need to do is replace the  variable with a new one called . Instead of setting the distance between each layer, we define the total height for the full stack. That lets us multiply the normalized value by , and get a consistent size no matter how many layers we have.</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.layeredText {\n  --text-height: 36px;\n\n  .layer {\n    --n: calc(var(--i) / var(--layers-count));\n\n    transform: translateZ(calc(var(--n) * var(--text-height)));\n    color: hsl(200 30% calc(var(--n) * 100%));\n  }\n}</code></pre><p>We are ready to start reacting to user input. But before we do anything, we need to think about the things we do  want to interact with, and that means the extra layers.</p><p>We already handled them for screen readers using , but even with regular mouse interactions, these layers can get in the way. In some cases, they might block access to clickable elements underneath.</p><p>To avoid all of that, we will add  to the  element. This makes the layers completely ‘transparent’ to mouse clicks and hover effects.</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.layers {\n  pointer-events: none;\n}</code></pre><p>Now we can finally start responding to user input and adding a bit of interaction. Let’s say I want to use this 3D effect on links, as a hover effect. It might be a little over the top, but we are here to have fun.</p><p>We will start with this simple markup, just a paragraph of Lorem ipsum, but with two links inside. Each link has the  class. Right now, those links will already have depth and layers applied, but that is not what we want. We want the 3D effect to appear only on hover.</p><p>To make that happen, we will define a new  block in  and move all the 3D related styles into it. That includes the color and shadow of the , the color and  of each , and to make it look even better, we will also animate the <a href=\"https://css-tricks.com/almanac/properties/o/opacity/\"></a> of the layers.</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.layeredText {\n  &amp;:hover {\n    span {\n      color: black;\n      text-shadow: 0 0 0.1em #003;\n    }\n\n    .layer {\n      color: hsl(200 30% calc(var(--n) * 100%));\n      transform: translateZ(calc(var(--i) * var(--layer-offset) + 0.5em));\n      opacity: 1;\n    }\n  }\n}</code></pre><p>Now we need to define the base appearance, the styles that apply when there is no hover. We will give the  and the layers a soft bluish color, apply a simple , and set the layers to be fully transparent by default.</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.layeredText {\n  display: inline-block;\n\n  span, .layer {\n    color: hsl(200 100% 75%);\n    transition: all 0.5s;\n  }\n\n  .layer {\n    opacity: 0;\n  }\n}</code></pre><p>Also, I added  to the  element. This helps prevent unwanted line breaks and allows us to apply transforms to the element, if needed. The result is a hover effect that literally makes each word pop right off the page:</p><p>Of course, if you are using this as a hover effect but you also have some elements that should always appear with full depth, you can easily define that in your CSS.</p><p>For example, let us say we have both a heading and a link with the  class, but we want the heading to always show the full 3D effect. In this case, we can update the hover block selector to target both:</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.layeredText {\n  &amp;:is(h1, :hover) {\n    /* full 3D styles here */\n  }\n}</code></pre><p>This way, links will only show the effect on hover, while the heading stays bold and dimensional all the time.</p><p>Now we can start working with the mouse position in JavaScript. To do that, we need two things: the position of the mouse on the page, and the position of each element on the page.</p><p>We will start with the mouse position, since that part is easy. All we need to do is add a  listener, and inside it, define two CSS variables on the :  for the horizontal mouse position, and  for the vertical position.</p><pre rel=\"JavaScript\" data-line=\"\"><code markup=\"tt\">window.addEventListener('mousemove', e =&gt; {\n  document.body.style.setProperty('--mx', e.pageX);\n  document.body.style.setProperty('--my', e.pageY);\n});</code></pre><p>Notice that I am using  and , not  and . That is because I want the mouse position relative to the entire page, not just the viewport. This way it works correctly even when the page is scrolled.</p><p>Now we need to get the position of each element, specifically the  and  values. We will define a function called  that loops through all , finds their position using a  function, and sets it to a couple of CSS custom properties.</p><pre rel=\"JavaScript\" data-line=\"\"><code markup=\"tt\">function setRects() {\n  layeredElements.forEach(element =&gt; {\n    const rect = element.getBoundingClientRect();\n    element.style.setProperty('--top', rect.top + window.scrollY);\n    element.style.setProperty('--left', rect.left + window.scrollX);\n  });\n}</code></pre><p>Once again, I am using  and  to get the position relative to the entire page, not just the viewport.</p><p>Keep in mind that reading layout values from the DOM can be expensive in terms of performance, so we want to do it as little as possible. We will run this function once after all the layers are in place, and again only when the page is resized, since that could change the position of the elements.</p><pre rel=\"JavaScript\" data-line=\"\"><code markup=\"tt\">setRects();\nwindow.addEventListener('resize', setRects);</code></pre><p>That is it. We are officially done writing JavaScript for this article. At this point, we have the mouse position and the position of every element stored as CSS values.</p><p>Great. So, what do we do with them?</p><p>Remember the examples from the previous chapter where we used <a href=\"https://css-tricks.com/almanac/properties/b/background-image/\"></a>? That is the key. Let us take that same idea and use a simple radial gradient, from red to white.</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.layer {\n  background-clip: text;\n  color: transparent;\n  background-image: radial-gradient(circle at center, red 24px, white 0);\n}</code></pre><p>But instead of placing the center of the circle in the middle of the element, we will shift it based on the mouse position. To calculate the position of the mouse relative to the element, we simply subtract the element’s position from the mouse position. Then we multiply by , since the value must be in pixels, and plug it into the  part of the gradient.</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.layer {\n  background-image:\n    radial-gradient(\n      circle at calc((var(--mx) - var(--left)) * 1px)\n                calc((var(--my) - var(--top)) * 1px),\n      red 24px,\n      white 0\n    );\n}</code></pre><p>The result is text with depth and a small red dot that follows the movement of your mouse.</p><p>Okay, a small red dot is not exactly mind blowing. But remember, you are not limited to that. Once you have the mouse position, you can use it to drive all sorts of dynamic effects. In just a bit, we will start building the bulging effect that kicked off this entire series, but in other cases, depending on your needs, you might want to normalize the mouse values first.</p><h3>Normalizing Mouse Position</h3><p>Just like we normalized the index of each layer earlier, we can normalize the mouse position by dividing it by the total width or height of the body. This gives us a value between  and .</p><pre rel=\"JavaScript\" data-line=\"\"><code markup=\"tt\">document.body.style.setProperty('--nx', e.pageX / document.body.clientWidth);\ndocument.body.style.setProperty('--ny', e.pageY / document.body.clientHeight);</code></pre><p>Normalizing the mouse values lets us work with relative positioning that is independent of screen size. This is perfect for things like adding a responsive tilt to the text based on the mouse position.</p><p>Now we are finally ready to build the last example. The idea is very similar to the red dot example, but instead of applying the  only to the top layer, we will apply it across all the layers. The color is stored in a custom variable and used to paint the gradient.</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.layer {\n  --color: hsl(200 30% calc(var(--n) * 100%));\n\n  color: transparent;\n  background-clip: text;\n  background-image:\n    radial-gradient(\n      circle at calc((var(--mx) - var(--left)) * 1px)\n                calc((var(--my) - var(--top)) * 1px),\n                var(--color) 24px,\n                transparent 0\n    );\n}</code></pre><p>Now we get something similar to the red dot we saw earlier, but this time the effect spreads across all the layers.</p><p>We are almost there. Before we go any further with the layers, I want to make the base text look a bit weaker when the hover effect is not active. That way, we create a stronger contrast when the full effect kicks in.</p><p>So, we will make the  text transparent and increase the opacity of its shadow:</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">span {\n  color: transparent;\n  text-shadow: 0 0 0.1em #0004;\n}</code></pre><p>Keep in mind, this makes the text nearly unreadable when the hover effect is not active. That is why it is important to use a proper media query to detect whether the device supports hover. Apply this styling only when it does, and adjust it for devices that do not.</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">@media (hover: hover) {\n  /* when hover is supported */\n}</code></pre><p>This is it. The only thing left is to fine tune the size of the gradient for each layer. And we are done. But I do not want the bulge to have a linear shape. Using the normalized value alone will give me evenly spaced steps across all layers. That results in a shape with straight edges, like a cone.</p><p>To get a more convex appearance, we can take advantage of the new trigonometric functions available in CSS. We will take the normalized value, multiply it by 90 degrees, and pass it through a <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/cos\" rel=\"noopener\"></a> function. Just like the normalized value, the cosine will return a number between  and , but with a very different distribution. The spacing between values is non-linear, which gives us that smooth convex curve.</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">--cos: calc(cos(var(--n) * 90deg));</code></pre><p>Now we can use this variable inside the gradient. Instead of giving the color a fixed radius, we will multiply  by whatever size we want the effect to be. I also added an absolute value to the calculation, so that even when  is very low (close to zero), the gradient still has a minimum visible size.</p><p>And, of course, we do not want sharp, distracting edges. We want a smooth fade. So, instead of giving the  a hard stop point, we will give it a larger value. The difference between the  and the  values will control how soft the transition is.</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">background-image:\n  radial-gradient(\n    circle at calc((var(--mx) - var(--left)) * 1px)\n              calc((var(--my) - var(--top)) * 1px),\n              var(--color) calc(var(--cos) * 36px + 24px),\n              transparent calc(var(--cos) * 72px)\n  );</code></pre><p>And just like that, we get an interactive effect that follows the mouse and gives the impression of bulging 3D text:</p><p>At this point, our 3D layered text has gone from a static stack of HTML elements to a fully interactive, mouse-responsive effect. We built dynamic layers with JavaScript, normalized depth and scale, added responsive hover effects, and used live input to shape gradients and create a bulging illusion that tracks the user’s every move.</p><p>But more than anything, this chapter was about control. Controlling structure through code. Controlling behavior through input. And controlling perception through light, color, and movement. And we did it all with native web technologies.</p><p>This is just the beginning. You can keep going with noise patterns, lighting, reflections, physics, or more advanced motion behaviors. Now you have the tools to explore them, and to create bold, animated, expressive typography that jumps right off the screen.</p><p>Now go make something that moves.</p>","contentLength":16487,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"We still love jQuery","url":"https://javascriptweekly.com/issues/749","date":1755820800,"author":"","guid":236915,"unread":true,"content":"<p> — Lee, formerly of Vercel and widely recognized for his influence on Next.js and React, shares candid reflections on the React community, digging into the rise of React Server Components, the tension between commercial and non-commercial priorities, the toll of burnout, and a reminder that, above all, this is still a community of&nbsp;</p>","contentLength":336,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"3D Layered Text: Motion and Variations","url":"https://css-tricks.com/3d-layered-text-motion-and-variations/","date":1755698092,"author":"Amit Sheen","guid":234544,"unread":true,"content":"<p>In the previous chapter, we built a basic 3D layered text effect using nothing but HTML and CSS. It looks great and has a solid visual presence, but it’s completely static. That is about to change.</p><p>In this chapter, we will explore ways to animate the effect, add transitions, and play with different variations. We will look at how motion can enhance depth, and how subtle tweaks can create a whole new vibe.</p><p> This article contains multiple animated examples that may include flashing or fast moving visuals. If you are sensitive to motion, please proceed with caution.</p><p>Let’s start things off with a quick animation tip that pairs perfectly with layered 3D text. Sometimes, we want to rotate the element without actually changing the orientation of the text so it stays readable. The trick here is to combine multiple rotations across two axes. First, rotate the text on the z-axis. Then, add a tilt on the x-axis. Finally, rotate the text back on the z-axis.</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">@keyframes wobble {\n  from { transform: rotate(0deg) rotateX(20deg) rotate(360deg); }\n  to { transform: rotate(360deg) rotateX(20deg) rotate(0deg); }\n}</code></pre><p>Since we rotate on the z-axis and then reverse that rotation, the text keeps its original orientation. But because we add a tilt on the x-axis in the middle, and the x-axis itself keeps rotating, the angle of the tilt changes as well. This creates a kind of  effect that shows off the text from every angle and emphasizes the sense of depth.</p><p>If we want to take this a few steps further, we can combine the wobble with a  effect. We will animate the  slightly along the z-axis:</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.layers {\n  animation: hover 2s infinite ease-in-out alternate;\n}\n\n@keyframes hover {\n  from { transform: translateZ(0.3em); }\n  to { transform: translateZ(0.6em); }\n}</code></pre><p>To really sell the effect, we will leave the original span in place — like a shadowed anchor — change its color to transparent, and animate the blur factor of its <a href=\"https://css-tricks.com/almanac/properties/t/text-shadow/\"></a>:</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">span {\n  color: transparent;\n  animation: shadow 2s infinite ease-in-out alternate;\n}\n\n@keyframes shadow {\n  from { text-shadow: 0 0 0.1em #000; }\n  to { text-shadow: 0 0 0.2em #000; }\n}</code></pre><p>Syncing those two animations together gives the whole thing a more realistic feel:</p><p>OK, this is starting to look a lot better now that things are moving. But the whole word is still moving as one. Can we make each letter move independently? The answer, as usual, is “yes, but…”</p><p>It is absolutely possible to split each word into a separate letters and animate them individually. But it also means a lot more elements moving on the screen, and that can lead to performance issues. If you go this route, try not to animate too many letters at once, and consider reducing the number of layers.</p><p>In the next example, for instance, I reduced the layer count to sixteen. There are five letters, and to place them side by side, I gave the  a , then added a small delay to each letter using <a href=\"https://css-tricks.com/almanac/pseudo-selectors/n/nth-child/\"></a>:</p><p>Until now, we have only been moving the text along the z-axis, but we can definitely take it further. Each layer can be moved or rotated in any direction you like, and if we base those transformations on the  variable, we can create all sorts of interesting effects. Here are a few I played with, just to give you some ideas.</p><p>In the first one, I am animating the  to create a  effect:</p><p>In the others, I am adding a bit of rotation. The first one is applied to the y-axis for the  effect:</p><p>This next example applies rotation on the x-axis for the :</p><p>And, finally, we can apply it on the z-axis for a  example:</p><p>Working with separate layers does not just let us tweak the animation for each one; it also lets us adjust the  for every layer individually, which can lead to some really interesting effects. Let us take this  example:</p><p>Right now, the animation is applied to the  element itself, and I am simply changing its scale:</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.layeredText {\n  animation: pulsing 2s infinite ease-out;\n}\n\n@keyframes pulsing {\n  0%, 100% { scale: 1; }\n  20% { scale: 1.2; }\n}</code></pre><p>But we can apply the animation to each layer separately and give each one a slight delay. Note that the  is part of the stack. It is a layer, too, and sometimes you will want to include it in the animation:</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.layer {\n  --delay: calc(var(--n) * 0.3s);\n}\n\n:is(span, .layer) {\n  animation: pulsing 2s var(--delay, 0s) infinite ease-out;\n}</code></pre><p>Here I am using the <a href=\"https://css-tricks.com/almanac/pseudo-selectors/i/is/\"></a> selector to target both the individual layers and the  itself with the same animation. The result is a much more lively and engaging effect:</p><p>In the previous chapter, I mentioned that I usually prefer to save pseudo elements for decorative purposes. This is definitely a technique worth using. We can give each layer one or two pseudo elements, add some content, position them however we like, and the 3D effect will already be there.</p><p>It can be anything from simple outlines to more playful shapes. Like , for example:</p><p>Notice that I am using the  selector to include the  here, too, but sometimes we will not want to target all the layers — only a specific portion of them. In that case, we can use  to select just part of the stack. For example, if I want to target only the bottom twelve layers (out of twenty four total), the decoration only covers half the height of the text. I can do something like  , and the full selector would be:</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">:is(span, .layer:nth-child(-n + 12))::before {\n  /* pseudo style */\n}</code></pre><p>This is especially useful when the decoration overlaps with the text, and you do not want to cover it or make it hard to read.</p><p>Of course, you can animate these pseudo elements too. So how about a 3D “” text with a built-in spinner?</p><p>I made a few changes to pull this off. First, I selected twelve layers from the middle of the stack using a slightly more advanced selector: <code>.layer:nth-child(n + 6):nth-child(-n + 18)</code>. This targets the layers from number six to eighteen.</p><p>Second, to fake the shadow, I added a blur filter to the ‘s pseudo element. This creates a nice soft effect, but it can cause performance issues in some cases, so use it with care.</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">:is(span, .layer:nth-child(n + 6):nth-child(-n + 18))::before {\n  /* spinner style */\n}\n\nspan {\n  /* span style */\n\n  &amp;::before {\n    filter: blur(0.1em);\n  }\n}</code></pre><p>But you don’t have to use pseudo elements to add some visual interest. You can also style any text with a custom pattern using . Just select the top layer with the  selector, set its text color to  so the background shows through, and use .</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.layer {\n  /* layer style */\n    \n  &amp;:last-child {\n    color: transparent;\n    background-clip: text;\n    background-image: ... /* use your imagination */\n  }\n}</code></pre><p>Here is a small demo using striped  with <code>repeating-linear-gradient</code>, and  made with <code>repeating-radial-gradient</code>:</p><p>And, yes, you can absolutely use an  too:</p><p>Let us take the previous idea a couple of steps further. Instead of applying a pattern just to the top layer, we will apply it to all the layers, creating a full 3D pattern effect. Then we will animate it.</p><p>We’ll start with the colors. First, we give all the layers a  text color. The color we used before will now be stored in a custom property called , which we will use in just a moment.</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.layer {\n  --n: calc(var(--i) / var(--layers-count));\n  --color: hsl(200 30% calc(var(--n) * 100%));\n\n  color: transparent;\n}</code></pre><p>Now let’s define the background, and we’ll say we want a moving  pattern. We can create it using  with two colors. The first will be our  variable, and the second could be . But in this case, I think black with very low opacity works better.</p><p>We just need to set the <a href=\"https://css-tricks.com/almanac/properties/b/background-size/\"></a> to control the pattern scale, and of course, make sure to apply  here too:</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.layer {\n  --n: calc(var(--i) / var(--layers-count));\n  --color: hsl(200 30% calc(var(--n) * 100%));\n\n  color: transparent;\n  background-image:\n    repeating-conic-gradient(var(--color) 0 90deg, hsl(0 0% 0% / 5%) 0 180deg);\n  background-size: 0.2em 0.2em;\n  background-clip: text;\n  transform: translateZ(calc(var(--i) * var(--layer-offset)));\n  animation: checkers 24s infinite linear;\n}\n\n@keyframes checkers {\n  to { background-position: 1em 0.4em; }\n}</code></pre><p>As you can see, I have already added the <a href=\"https://css-tricks.com/almanac/properties/a/animation/\"></a> property. In this case, it is very simple to animate the pattern. Just slowly move the <a href=\"https://css-tricks.com/almanac/properties/b/background-position/\"></a>, and that is it. Now we have text with a moving 3D pattern:</p><p>So far, we have been using a single font, and as I mentioned earlier, font choice is mostly a matter of taste or brand guidelines. But since we are already working with layered text, we absolutely have to try it with <a href=\"https://css-tricks.com/one-file-many-options-using-variable-fonts-web/\">variable fonts</a>. The idea behind variable fonts is that each one includes axes you can manipulate to change its appearance. These can include width, weight, slant, or just about anything else.</p><p>Here are a few examples I really like. The first one uses the <a href=\"https://fonts.google.com/specimen/Climate+Crisis\" rel=\"noopener\"></a> font, which has a  axis that ranges from 1979 to 2025. With each year, the letters melt slightly and shrink a bit. It is a powerful ecological statement, and when you stack the text in layers, you can actually see the changes and get a pretty striking 3D effect:</p><p>Another great option is <a href=\"https://fonts.google.com/specimen/Bitcount\" rel=\"noopener\"></a>, a variable font with a classic weight axis ranging from 100 to 900. By changing the weight based on the layer index, you get a layered effect that looks like peaks rising across the text:</p><p>And here is an example that might give your browser a bit of a workout. The font <a href=\"https://fonts.google.com/specimen/Kablammo\" rel=\"noopener\"></a> includes a  axis, and adjusting it completely changes the shape of each letter. So, I figured it would be fun to animate that axis (yes,  is animatable), and add a short delay between the layers, like we saw earlier, to give the animation a more dynamic and lively feel.</p><p>Before we wrap up this second chapter, I want to show you one more animation. By now you have probably noticed that there is always more than one way to do things, and sometimes it is just a matter of finding the right approach. Even the positioning of the layers, which we have been handling statically with , can be done a little differently.</p><p>If we animate the layers to move along the z-axis, from zero to the full height of the text, and add an equal delay between each one, we end up with the same visual 3D effect, only in motion.</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.layer {\n  --n: calc(var(--i) / var(--layers-count));\n  --delay: calc(var(--n) * -3s);\n\n  animation: layer 3s var(--delay) infinite ease-in-out;\n}\n\n@keyframes layer {\n  from { transform: translateZ(0); }\n  to { transform: translateZ(calc(var(--layers-count) * var(--layer-offset))); }\n}</code></pre><p>This is a more advanced technique, suited for more complex animations. It is not something you need for every use case, but for certain effects, it can look very cool.</p><p>So far, we have brought the layered text effect to life with movement, variation, and creative styling. We also saw how even small changes can have a huge visual impact when applied across layers.</p><p>But everything we have done so far has been pre defined and self contained. In the next chapter, we are going to add a layer of interactivity. Literally. From simple  transitions to using JavaScript to track the mouse position, we will apply real-time transformations and build a fully responsive bulging effect.</p>","contentLength":10957,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Learning web development: Booleans, comparisons and if statements","url":"https://2ality.com/2025/08/javascript-booleans-comparisons-if.html","date":1755648000,"author":"Dr. Axel Rauschmayer","guid":234654,"unread":true,"content":"<p>In this chapter, we learn about tools for only running a piece of code if a condition is met: truth values (booleans), comparisons and  statements.</p>","contentLength":147,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"This Week In React #246: Next.js, React Router, TanStack, StyleX, MUI, Storybook | FlashList 2, RN 0.81, Expo, Radon, Gesture Handler, Audio, Skia, Nitro, Strict DOM | TC39, Node, TypeScript, Astro, BIDC, Surveys","url":"https://thisweekinreact.com/newsletter/246","date":1755648000,"author":"","guid":234626,"unread":true,"content":"<p>After a short summer break, we’re happy to say we’re back! I think we could open a public swimming pool because we’re drowning in the amount of content this week.</p><p>This week was full of big releases: Vercel released Next.js 15.5, React Native 0.81 was launched, and last but not least, we finally have the long-awaited FlashList 2 with great performance and cool features.</p><p>As always, thanks for supporting us on your favorite platform:</p><p>Your data grid should do more than just render rows. Performance matters, but <strong>UX is where the real wins happen</strong>. When picking a React Data Grid, consider how users interact with it and what features will help them get things done. <a href=\"https://www.infragistics.com/products/ignite-ui-react?utm_source=this-week-in-react&amp;utm_medium=referral&amp;utm_campaign=ignite-ui-react&amp;utm_term=newsletter-sponsorship&amp;utm_content=top-5-react-grid-features\" target=\"_blank\" rel=\"noopener noreferrer\">Ignite UI for React</a> goes beyond the basics. It provides everything you need to build high-performance web apps with must-haves like:</p><ul><li>🔍 Advanced Filtering – Complex queries with AND/OR logic, no code required.</li><li>💾 State Persistence – Save grid layouts, filters &amp; sort state across sessions.</li><li>⌨️ Keyboard Navigation – Faster workflows + built-in accessibility.</li><li>📤 Export to Excel – Share filtered data in a click.</li><li>📊 Pivot Grid – Analyze data without leaving your app.</li></ul><p>See how you can utilize these features and maximize the potential of your next React app.</p><p>The new minor version of Next.js brings exciting improvements across many areas of the framework including:</p><ul><li> in middleware now marked as stable</li><li>Turbopack for production builds in beta</li><li>Typed Routes for type-safe navigation</li><li>Deprecation of  in order to provide Biome as a fast alternative to ESLint</li><li>Next.js 16 deprecation warnings</li></ul><p>Discover a new perspective on building full-stack web applications with  and . A hands-on course that teaches you how to build real-world SaaS applications, including payment gateways, message queues, database inspectors, and email servers.</p><p>Learn a cutting-edge stack with  and  from bestselling book author and blogger .</p><p>FlashList v2 is a complete rewrite that eliminates the need for developers to provide item size estimates, a major limitation of v1. Thanks to React Native's New Architecture, which enables synchronous layout measurements, FlashList v2 can precisely calculate and correct item positions before they are painted on the screen. This new approach removes the need for native code and delivers pixel-perfect scrolling, improves performance with an adaptive rendering algorithm, and enables advanced features like automatic scroll position maintenance. Also, FlashList v2 comes with masonry layout support built-in.</p><p>React Native version 0.81 introduces support for the new Android 16, which enforces  display requirements. A major new experimental feature is precompiled builds for iOS, promising significantly faster compilation times. Since this version the built-in  component is deprecated and they moved JSC runtime support out to a community-maintained package.</p>","contentLength":2842,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Launching MDN's new front end","url":"https://developer.mozilla.org/en-US/blog/launching-new-front-end/","date":1755561600,"author":"mdn-team","guid":233431,"unread":true,"content":"<article>MDN is getting a facelift 🎉. Discover what's changed, what's improved, and how navigating the site just got smoother.\n</article>","contentLength":121,"flags":null,"enclosureUrl":"https://developer.mozilla.org/en-US/blog/launching-new-front-end/featured.png","enclosureMime":"","commentsUrl":null},{"title":"3D Layered Text: The Basics","url":"https://css-tricks.com/3d-layered-text-the-basics/","date":1755524760,"author":"Amit Sheen","guid":231616,"unread":true,"content":"<p>Recently, a client asked me to create a bulging text effect. These are exactly the kinds of creative challenges I live for. I explored several directions, JavaScript solutions, SVG filters, but then I remembered the concept of 3D layered text. With a bit of cleverness and some advanced CSS, I managed to get a result I’m genuinely proud of.</p><p>Visually, it’s striking, and it’s also a perfect project to learn all sorts of valuable CSS animation techniques. From the fundamentals of layering, through element indexing, to advanced background-image tricks. And yes, we’ll use a touch of JavaScript, but don’t worry about it right now.</p><p>There is a lot to explore here, so this article is actually the first of a three part series. In this chapter, we will focus on the core technique. You will learn how to build the layered 3D text effect from scratch using HTML and CSS. We will cover structure, stacking, indexing, perspective, and how to make it all come together visually.</p><p>In chapter two, we will add movement. Animations, transitions, and clever visual variations that bring the layers to life.</p><p>In chapter three, we will introduce JavaScript to follow the mouse position and build a fully interactive version of the effect. This will be the complete bulging text example that inspired the entire series.</p><p>Before we dive into the text, let’s talk about 3D. CSS actually allows you to create some wild three-dimensional effects. Trust me, I’ve done it. It’s pretty straightforward to move and position elements in a 3D space, and have full control over perspective. But there’s one thing CSS doesn’t give us: depth.</p><p>If I want to build a cube, I can’t just give an element a , a , and a . There is no , it doesn’t work that way. To build a cube or any other 3D structure in CSS, we have two main approaches: constructive and layered.</p><p>The constructive method is very powerful, but can feel a bit fiddly, with plenty of transforms and careful attention to perspective. You take a bunch of flat elements and assemble them together, somewhere between digital Lego bricks and origami. Each side of the shape gets its own element, positioned and rotated precisely in the 3D space. Suddenly, you have a cube, a pyramid, or any other structure you want to create.</p><p>And the results can be super satisfying. There’s something unique about assembling 3D objects piece by piece, watching flat elements transform into something with real presence. The constructive method opens up a world where you can experiment, improvise, and invent new forms. You could even, for example, build a cute robot bouncing on a pogo stick.</p><p>But here we’re going to focus on the layered method. This approach isn’t about building a 3D object out of sides or polygons. Instead, it’s all about stacking multiple layers, sometimes dozens of them, and using subtle shifts in position and color to create the illusion of depth. You’re tricking the eye into seeing volume and bulges where there’s really just a clever pile of flat elements.</p><p>This technique is super flexible. Think of a cube of sticky memo papers, but instead of squares, the papers are cut to shape your design. It’s perfect for text, 3D shapes, and UI elements, especially with round edges, and you can push it as far as your creativity (and patience) will take you.</p><p> Keep in mind that this method can easily become a nightmare for screen reader users, especially when applied to text. Make sure to wrap all additional and decorative layers with . That way, your creative effects won’t interfere with accessibility and ensure that people using assistive technologies can still have a good experience.</p><h3>Creating a 3D Layered Text</h3><p>Let’s kick things off with a basic static example, using “lorem ipsum” as a placeholder (feel free to use any text you want). We’ll start with a simple container element with a class of . Inside, we’ll put the original text in a  (it will help later when we want to style this text separately from the layered copies), and another div with a class of “layers” where we’ll soon add the individual layers. (And don’t forget the .)</p><pre rel=\"HTML\" data-line=\"\"><code markup=\"tt\">&lt;div class=\"text\"&gt;\n  &lt;span&gt;Lorem ipsum&lt;/span&gt;\n  &lt;div class=\"layers\" aria-hidden=\"true\"&gt;&lt;/div&gt;\n&lt;/div&gt;</code></pre><p>Now that we have our wrapper in place, we can start building out the layers themselves. In chapter three, we will see how to build the layers dynamically with JavaScript, but you can generate them easily with a simple loop in your preprocessor (if you are using one), or just add them manually in the code. Check out the  below for a quick way to do that. The important thing is that we end up with something that looks like this.</p><pre rel=\"HTML\" data-line=\"\"><code markup=\"tt\">&lt;div class=\"layers\" aria-hidden=\"true\"&gt;\n  &lt;div class=\"layer\"&gt;&lt;/div&gt;\n  &lt;div class=\"layer\"&gt;&lt;/div&gt;\n  &lt;div class=\"layer\"&gt;&lt;/div&gt;\n  &lt;!-- ...More layers --&gt;\n&lt;/div&gt;</code></pre><p>Great, now we have our layers, but they are still empty. Before we add any content, let’s quickly cover how to assign their indexes.</p><p>Indexing simply means assigning each layer a variable (let’s call it ) that holds its index. So, the first layer gets , the second gets , and so on. We’ll use these numbers later on as values for calculating each layer’s position and appearance.</p><p>There are a couple of ways to add these variables to your layers. You can define the value for each layer using  in CSS, (again, a simple loop in your preprocessor, if you’re using one), or you can do it inline, giving each layer element a  attribute with the right  value.</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.layer {\n  &amp;:nth-child(1): { --i: 1; }\n  &amp;:nth-child(2): { --i: 2; }\n  &amp;:nth-child(3): { --i: 3; }\n  /* ... More layers */\n}</code></pre><pre rel=\"HTML\" data-line=\"\"><code markup=\"tt\">&lt;div class=\"layers\" aria-hidden=\"true\"&gt;\n  &lt;div class=\"layer\" style=\"--i: 1;\"&gt;&lt;/div&gt;\n  &lt;div class=\"layer\" style=\"--i: 2;\"&gt;&lt;/div&gt;\n  &lt;div class=\"layer\" style=\"--i: 3;\"&gt;&lt;/div&gt;\n  &lt;!-- ...More layers --&gt;\n&lt;/div&gt;</code></pre><p>In this example, we will go with the inline approach. It gives us full control, keeps things easy to understand, and avoids dependency between the markup and the stylesheet. It also makes the examples copy friendly, which is great if you want to try things out quickly or tweak the markup directly.</p><p> If you’re working in an IDE with Emmet support, you can generate all your layers at once by typing <code>.layer*24[style=\"--i: $;\"]</code> and pressing . The  is your class,  is the number of elements, attributes go in square brackets , and  is the incrementing number. But, If you’re reading this in the not-so-distant future, you might be able to use <a href=\"https://css-tricks.com/almanac/functions/s/sibling-index/\"></a> and not even need these tricks. In that case, you won’t need to add variables to your elements at all, just swap out  for  in the next code examples.</p><p>Now let us talk about adding content to the layers. Each layer needs to contain the original text. There are a few ways to do this. In the next chapter, we will see how to handle this with JavaScript, but if you are looking for a CSS-only dynamic solution, you can add the text as the content of one of the layer’s pseudo elements. This way, you only need to define the text in a single variable, which makes it a great fit for titles, short labels, or anything that might change dynamically.</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.layer {\n  --text: \"Lorem ipsum\";\n  \n  &amp;::before {\n    content: var(--text);\n  }\n}</code></pre><p>The downside, of course, is that we are creating extra elements, and I personally prefer to save pseudo elements for decorative purposes, like the border effect we saw earlier. We will look at more examples of that in the next chapter.</p><p>A better, more straightforward approach is to simply place the text inside each layer. The downside to this method is that if you want to change the text, you will have to update it in every single layer. But since in this case the example is static and I do not plan on changing the text, we will simply use Emmet, putting the text inside curly braces .</p><p>So, we will type <code>.layers*24[style=\"--i: $;\"]{Lorem ipsum}</code> and press  to generate the layers.</p><pre rel=\"HTML\" data-line=\"\"><code markup=\"tt\">&lt;div class=\"text\"&gt;\n  Lorem ipsum\n  &lt;div class=\"layers\" aria-hidden=\"true\"&gt;\n    &lt;div class=\"layer\" style=\"--i: 1;\"&gt;Lorem ipsum&lt;/div&gt;\n    &lt;div class=\"layer\" style=\"--i: 2;\"&gt;Lorem ipsum&lt;/div&gt;\n    &lt;div class=\"layer\" style=\"--i: 3;\"&gt;Lorem ipsum&lt;/div&gt;\n    &lt;!-- ...More layers --&gt;\n  &lt;/div&gt;\n&lt;/div&gt;</code></pre><p>Now we can start working on the styling and positioning. The first thing we need to do is make sure all the layers are stacked in the same place. There are a few ways to do this as well , but I think the easiest approach is to use  with  on the  and on each , making sure every layer matches the container’s size exactly. Of course, we’ll set the container to  so that all the layers are positioned relative to it.</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.text {\n  position: relative;\n\n  .layers, .layer {\n    position: absolute;\n    inset: 0;\n  }\n}</code></pre><p>Now comes the part that trips some people up, adding perspective. To give the text some depth, we’re going to move each layer along the z-axis, and to actually see this effect, we need to add a bit of perspective.</p><p>As with everything so far, there are a few ways to do this. You could give perspective to each layer individually using the  function, but my recommendation is always to apply perspective at the parent level. Just wrap the element (or elements) you want to bring into the 3D world inside a wrapper div (here I’m using ) and apply the perspective to that wrapper.</p><p>After setting the perspective on the parent, you’ll also need to use <code>transform-style: preserve-3d;</code> on each child of the . Without this, browsers flatten all transformed children into a single plane, causing any z-axis movement to be ignored and everything to look flat. Setting  ensures that each layer’s 3D position is maintained inside the parent’s 3D context, which is crucial for the depth effect to come through.</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.scene {\n  perspective: 400px;\n  \n  * {\n    transform-style: preserve-3d;\n  }\n}</code></pre><p>In this example, I’m using a fairly low value for the <a href=\"https://css-tricks.com/almanac/properties/p/perspective/\"></a>, but you should definitely play around with it to suit your own design. This value represents the distance between the viewer and the object, which directly affects how much depth we see in the transformed layers. A smaller value creates a stronger, more exaggerated 3D effect, while a larger value makes the scene appear flatter. This property is what lets us actually see the z-axis movement in action.</p><p>Now we can move the layers along the z-axis, and this is where we start using the index values we defined earlier. Let’s start by defining two custom properties that we’ll use in a moment: , which holds the number of layers, and , which is the spacing between each layer.</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.text {\n  --layers-count: 24;\n  --layer-offset: 1px;\n}</code></pre><p>Now let’s set the  value for each layer. We already have the layer’s index and the spacing between layers, so all we need to do is multiply them together inside the <a href=\"https://css-tricks.com/almanac/properties/t/transform/\"></a> property.</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.layer {  \n  transform: translateZ(calc(var(--i) * var(--layer-offset)));\n}</code></pre><p>This feels like a good moment to stop and look at what we have so far. We created the layers, stacked them on top of each other, added some content, and moved them along the z-axis to give them depth. And this is where we’re at:</p><p>If you really try, and focus hard enough, you might see something that kind of looks like 3D. But let’s be honest, it does not look good. To create a real sense of depth, we need to bring in some color, add a bit of shadow, and maybe rotate things a bit for a more dynamic perspective.</p><p>Sometimes we might want (or need) to use the value of  as is, like in the last snippet, but for some calculations, it’s often better to  the value. This means dividing the index by the total number of layers, so we end up with a value that ranges from  to . By normalizing, we keep our calculations flexible and proportional, so the effect remains balanced even if the number of layers changes.</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.layer {\n  --n: calc(var(--i) / var(--layers-count));\n}</code></pre><p>Now we can adjust the color for each layer, or more precisely, the brightness of the color. We’ll use the normalized value on the ‘light’ of a simple HSL function, and add a touch of saturation with a bluish hue.</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.layer {\n  color: hsl(200 30% calc(var(--n) * 100%));\n}</code></pre><p>Gradually changing the brightness between layers helps create a stronger sense of depth in the text. And without it, you risk losing some of the finer details</p><p>Second, remember that we wrapped the original text in a  so we could style it? Now is the time to use it. Since this text sits on the bottom layer, we want to give it a darker color than the rest. Black works well here, and in most cases, although in the next chapter we will look at examples where it actually needs to be .</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">span {\n  color: black;\n  text-shadow: 0 0 0.1em #003;\n}</code></pre><p>Before we wrap this up, let us change the font. This is of course a matter of personal taste or brand guidelines. In my case, I am going with a bold, chunky font that works well for most of the examples. You should feel free to use whatever font fits your style.</p><p>Let us also add a slight rotation to the text, maybe on the x-axis, so the lettering appears at a better angle:</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.text {\n  font-family: Montserrat, sans-serif;\n  font-weight: 900;\n  transform: rotateX(30deg);\n}</code></pre><p>And there you have it, combining all the elements we’ve covered so far: the layers, indexes, content, perspective, positioning, and lighting. The result is a beautiful, three-dimensional text effect. It may be static for now, but we’ll take care of that soon.</p><p>At this point, we have a solid 3D text effect built entirely with HTML and CSS. We covered everything from structure and indexing to layering, depth, and color. It may still be static, but the foundation is strong and ready for more.</p><p>In the next chapters, we are going to turn things up. We will add motion, introduce transitions, and explore creative ways to push this effect further. This is where it really starts to come alive.</p>","contentLength":13719,"flags":null,"enclosureUrl":"https://css-tricks.com/wp-content/uploads/2025/07/Bulging-Text.mp4","enclosureMime":"","commentsUrl":null},{"title":"Learning web development: Arrays in JavaScript","url":"https://2ality.com/2025/08/javascript-arrays.html","date":1755475200,"author":"Dr. Axel Rauschmayer","guid":231709,"unread":true,"content":"<p>In this chapter we look at one way of storing more than one value in a variable: .</p>","contentLength":82,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Learning web development: Strings and methods in JavaScript","url":"https://2ality.com/2025/08/javascript-strings-methods.html","date":1755388800,"author":"Dr. Axel Rauschmayer","guid":230591,"unread":true,"content":"<p>In the last chapter, we worked with numbers. In this chapter, we’ll work with text and write our first applications.</p>","contentLength":118,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["frontend"]}