{"id":"6SJ","title":"Go","displayTitle":"Go","url":"","feedLink":"","isQuery":true,"isEmpty":false,"isHidden":false,"itemCount":38,"items":[{"title":"Scaling multi-tenant Go applications: Choosing the right database partitioning approach","url":"https://dev.to/abhirockzz/scaling-multi-tenant-go-applications-choosing-the-right-database-partitioning-approach-2amd","date":1751547689,"author":"Abhishek Gupta","guid":183144,"unread":true,"content":"<p>Multi-tenant applications face a fundamental challenge: how to efficiently store and query data for tenants of vastly different sizes? Consider the typical scenario where your platform serves both enterprise clients with hundreds of thousands of users, as well as small businesses with just a handful. With traditional database partitioning strategies you are likely to run into these common issues:</p><ul><li>: Large tenants create oversized partitions while small tenants waste allocated resources</li><li>: High-activity tenants overwhelm individual database partitions, creating performance bottlenecks</li><li>: User-specific lookups require scanning entire tenant datasets</li><li>: Mixed workloads compete for the same database resources</li></ul><p>Azure Cosmos DB has been a go-to solution for <a href=\"https://learn.microsoft.com/en-us/azure/architecture/guide/multitenant/service/cosmos-db\" rel=\"noopener noreferrer\">multi-tenant applications</a> due to its global distribution, automatic scaling, and flexible data models. Its partition-based architecture naturally aligns with tenant isolation requirements, making it attractive for SaaS platforms, IoT applications, and content management systems.</p><p>However, even with these capabilities, the fundamental multi-tenant partitioning challenges persist. Let's examine how these issues manifest specifically in a Cosmos DB context.</p><p>This blog post explores an approach to solving multi-tenant scaling challenges in Go applications using Azure Cosmos DB. You'll learn how to implement this using the <a href=\"https://learn.microsoft.com/en-us/azure/cosmos-db/nosql/sdk-go\" rel=\"noopener noreferrer\">Go SDK for Azure Cosmos DB</a>, focusing on how to achieve efficient data distribution and query performance.</p><h2>\n  \n  \n  Challenges with a multi-tenant SaaS solution\n</h2><p>Imagine you're building a multi-tenant SaaS platform that manages user sessions and activities across different organizations using Cosmos DB. In such a setup, tenant variability is a significant challenge. Enterprise clients may have over 50,000 users generating millions of session events, while small businesses might only have 10 to 50 users with minimal activity. Mid-market companies typically fall in between, with 500 to 5,000 users and moderate usage. This wide range of tenant sizes and activity levels creates unique challenges for data partitioning and resource allocation in the database.</p><p>This is how you might define your user session data model using a single partition key:</p><div><pre><code></code></pre></div><p>This approach has several challenges. First, partition size imbalance occurs as enterprise tenants generate massive 20GB+ partitions, while small tenants use minimal storage, resulting in uneven resource utilization across physical partitions. Second, hot partition bottlenecks can develop when large tenants reach the <a href=\"https://learn.microsoft.com/en-us/azure/cosmos-db/partitioning-overview#physical-partitions\" rel=\"noopener noreferrer\">10,000 RU/s physical partition limit</a> during peak usage periods. Third, user queries become inefficient because looking up individual user sessions requires scanning entire tenant partitions, which consumes unnecessary Request Units. Cross-tenant analytics also suffer, as queries spanning multiple tenants become expensive cross-partition operations.</p><h2>\n  \n  \n  Hierarchical Partition Keys to the rescue\n</h2><p>Hierarchical partition keys (HPKs) help implement subpartitioning that allows you to define up to three levels of partition key hierarchy. This leads to better data distribution and query routing compared to traditional single-level partitioning. Instead of forcing all tenant data into a single partition boundary, you are able to create logical subdivisions that align with your actual access patterns.</p><p>Mapping this to the the multi-tenant solution challenges, hierarchical partition keys allow you to define a three-level partitioning scheme:</p><ul><li>: Primary partition key (e.g., ) - provides tenant isolation</li><li>: Secondary partition key (e.g., ) - distributes data within tenants\n</li><li>: Tertiary partition key (e.g., ) - provides fine-grained distribution</li></ul><p>This creates a logical partition path like instead of just . Large tenants can be subdivided by user and session, eliminating hot partitions. Instead of one massive \"Enterprise-Corp\" partition, you get manageable partitions like: <code>[\"Enterprise-Corp\", \"user-1001\", \"session-abc123\"]</code>, <code>[\"Enterprise-Corp\", \"user-1002\", \"session-def456\"]</code>, etc.</p><p>Now, we can refactor the user session data model as such:</p><div><pre><code></code></pre></div><p>Your queries can now be efficiently routed to only the subset of physical partitions that contain the relevant data. Specifying the full or partial subpartitioned partition key path effectively avoids a cross-partition query across all the parititions, which is a common problem with single partition keys.</p><ul><li>: <code>WHERE tenantId = 'Enterprise-Corp' AND userId = 'user-1001' AND sessionId = 'session-abc123'</code> provides single-partition access</li><li>: <code>WHERE tenantId = 'Enterprise-Corp' AND userId = 'user-1001'</code> pinpoints exact data location</li><li>: <code>WHERE tenantId = 'Enterprise-Corp'</code> only targets relevant partitions</li></ul><p>Each logical partition (tenant-user-session combination) can scale independently, allowing tenant data to exceed the traditional 20GB limit and maintain optimal performance. Targeted queries consume fewer Request Units by avoiding unnecessary cross-partition scans, directly reducing operational expenses.</p><h2>\n  \n  \n  Hierarchical Partition Keys in action with the Go SDK for Azure Cosmos DB\n</h2><p>To explore the concepts, we will use <a href=\"https://github.com/abhirockzz/cosmosdb-go-hierarchical-partition-keys\" rel=\"noopener noreferrer\">a Go application</a> that loads sample user session data into Azure Cosmos DB and queries it using the hierarchical partition keys.</p><p>Run the loader to populate the database with sample data that uses hierarchical partition keys. Its a <a href=\"https://github.com/abhirockzz/cosmosdb-go-hierarchical-partition-keys/blob/main/load/main.go\" rel=\"noopener noreferrer\">CLI application</a> that generates user session data for users in different tenant types (Enterprise, Mid-market, Small business) and inserts it into the Cosmos DB container.</p><p>Clone the repository and change into the  directory:</p><div><pre><code>git clone https://github.com/abhirockzz/cosmosdb-go-hierarchical-partition-keys\ncosmosdb-go-hierarchical-partition-keys/load\n</code></pre></div><p>Build the data loader application and run it. The database and container will be created automatically if they do not exist.</p><div><pre><code>go build  data-loader main.go\n\n./data-loader  100  &lt;insert database name&gt;  &lt;insert container name&gt; </code></pre></div><p>Here is how the container is created with hierarchical partition keys:</p><div><pre><code></code></pre></div><p>... and this is how sample data is added:</p><div><pre><code></code></pre></div><p>Lets dive into the queries that demonstrate how to retrieve data using hierarchical partition keys.</p><p>Let's examine how different query patterns perform with hierarchical partition keys. To execute these examples, you can comment out the relevant sections in the  function of the <a href=\"https://github.com/abhirockzz/cosmosdb-go-hierarchical-partition-keys/blob/main/query/main.go\" rel=\"noopener noreferrer\">query/main.go</a> file, set the required environment variables, and run the application.</p><div><pre><code>https://your-account.documents.azure.com:443/\n&lt;insert database name&gt;\n&lt;insert container name&gt;\n\ncosmosdb-go-hierarchical-partition-keys/query\ngo run main.go\n</code></pre></div><h4>\n  \n  \n  1. Point Read (Most Efficient)\n</h4><p>This is the most efficient query type, where you retrieve a single item using its unique ID and full partition key path. This avoids any cross-partition overhead.</p><p>Take a look at the  function that performs a point read operation:</p><div><pre><code></code></pre></div><p>This is routed to the single logical and physical partition that contains the data for the specified values of , , and .</p><div><pre><code></code></pre></div><h4>\n  \n  \n  3. User-Specific Data (Targeted Cross-Partition)\n</h4><p>This query is a targeted cross-partition query that returns data for a specific user in the tenant and routed to specific subset of logical and physical partition(s) that contain data for the specified values of  and .</p><div><pre><code></code></pre></div><h4>\n  \n  \n  4. Tenant-Wide Data (Efficient Cross-Partition)\n</h4><p>This query is a targeted cross-partition query that returns data for all users in a tenant and routed to a specific subset of logical and physical partition(s) that contain data for the specified value of .</p><p>The <code>queryWithSinglePKParameter</code> is a function that lets you query with a single partition key parameter - this can be either , , or .</p><div><pre><code></code></pre></div><h4>\n  \n  \n  5. User or Session Across All Tenants (Fan-Out)\n</h4><p>Both types of queries will be routed to all physical partitions, resulting in a fan-out cross-partition query.</p><div><pre><code></code></pre></div><blockquote><p>This type of query is not efficient and should be avoided in production scenarios. It is included here for completeness, but you should design your application to avoid such queries whenever possible.</p></blockquote><p>Multi-tenant applications face inherent scaling challenges with traditional single-level partitioning: tenant size variability, hot partitions, and inefficient query patterns that impact both performance and cost. Hierarchical partition keys in Azure Cosmos DB address these issues by enabling intelligent data distribution across multiple partition levels, maintaining tenant isolation while achieving better resource utilization. By aligning your partition strategy with actual access patterns, you can build applications that scale naturally with tenant growth while maintaining predictable performance characteristics.</p>","contentLength":8571,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Domain Driven Design Microservice","url":"https://dev.to/subpxl/domain-driven-design-microservice-pd4","date":1751539113,"author":"shubham panchal","guid":183047,"unread":true,"content":"<ol><li>What is Domain Driven Design</li></ol><p>\nA microservice is a independent compoent of a<p>\nbusiness logic. mostly is a breakdown of a</p>\nmonolith application into individual componetns<p>\nthat can scale and make the service fault tolerant</p>\nThere are many advantages of microservces<p>\nand they cater to different business needs as per</p>\ndesign an architecture.\nEvent driven\nwith webworker</p><p><strong>What is Domain Driven Design</strong>\nDomain Drivern Design is a software design pattern that saperates businesss logic from language infrastruture and other technical components. it has businss logic domain at its core and all other things<p>\nthat changes are wrapped like onion onto it.</p>\nIt is important as the core business logic never changes but the outlying technologies changes but doesnot affect the business logic, It is like a port and adapter pattern where technologies like databases or message queues can be replaced easily without affecting anything.</p><p>\nThe main business layer of the application that contains business models , methods, events and their working.<p>\nThese are independent of any database or message queue or router and they mostly dont change.They have classes or structs that defines objects</p>\nor models and their methods and their interface signatures.</p><p><a href=\"https://media2.dev.to/dynamic/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fpwwex7xdxyk5i61bowcx.PNG\"><img src=\"https://media2.dev.to/dynamic/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fpwwex7xdxyk5i61bowcx.PNG\" alt=\"Image description\" width=\"395\" height=\"347\"></a>\nApplication Layer is the layer that connects interface layer to the domain layer.Here there are many usecases of business present that may use more that one domain method for its working.Along with that it is responsible for authentication and transaction processing . sending notifications or<p>\ntriggering events. when interface later recieves a resuqest it sends to</p>\nappropriate usecase method in application layer that may contain multiple domain methods and triggers events accordingly.</p><p><a href=\"https://media2.dev.to/dynamic/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fgsyubdoqc1t07oq2yjtf.PNG\"><img src=\"https://media2.dev.to/dynamic/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fgsyubdoqc1t07oq2yjtf.PNG\" alt=\"Image description\" width=\"360\" height=\"325\"></a>\nInterface layer is the outer layer from where the applicaiton is accessed.<p>\nIt can be a cli , a rest api or a grpc endpoint. even all three in one application. This takes the appropriate input and sends to the application layer usecase for further processing and sends response back.</p></p><p><a href=\"https://media2.dev.to/dynamic/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fs3vk5ois46ugvpsd1bej.PNG\"><img src=\"https://media2.dev.to/dynamic/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fs3vk5ois46ugvpsd1bej.PNG\" alt=\"Image description\" width=\"245\" height=\"469\"></a>\nInfrastructure layer is where all interfaces are implemented concrete. It has all the technologies in it such as database, message queue, external apis and other relevent external things that are required by the<p>\napplication. It should implements domain interface methods to work and this infra related technologies are injected into the repository</p>\nor other related objects in the main setup. This process is called wiring.</p>","contentLength":2418,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Smoke Alarm Batteries: Hogwarts’ Silent Protectors Against Fiendfyre & Forgotten Spells","url":"https://dev.to/ersajay/smoke-alarm-batteries-hogwarts-silent-protectors-against-fiendfyre-forgotten-spells-3iae","date":1751524350,"author":"ersajay","guid":182774,"unread":true,"content":"<p>The Leaky Cauldron’s Safety Secret\nOn a rainy afternoon in Hogsmeade, I ducked into Zonko’s Joke Shop—not for Weasley’s Wizard Wheezes, but for a chat with Mr. Filch, the Hogwarts caretaker (and accidental safety guru).<p>\n“You’re here for the batteries, aren’t you?” he grumbled, polishing a Duster 3000. “Not as fun as Pygmy Puffs, but just as vital. Ever seen a smoke alarm fail? It’s worse than a Descendo charm gone wrong—chaos, and no one to blame but a lousy battery.”</p>\nIntrigued, I leaned in. This wasn’t just about magic—it was about smoke alarm batteries—the unsung heroes of wizarding (and muggle) safety. Let’s unmask their magic.</p><ol><li>What Powers Your Smoke Alarm? (Spells, or Just… Batteries?)\nSmoke alarms rely on batteries that are more than metal and chemicals—they’re life-or-death spells in a case. Here’s the lineup:</li></ol><p>9V Lithium: A 10-year marvel, built to survive -40°C (Arctic attics) to +85°C (kitchen ceilings). Think of it as a Fidelius Charm for your home—secret, sturdy, and unbreakable.<a href=\"https://www.ersaelectronics.com/p/ultralife-cr123a-31147917\" rel=\"noopener noreferrer\">CR123A</a> Lithium: Slim, coin-shaped cells for detectors like the First Alert SCO500. Imagine a Pocket Sneakoscope—small enough to fit anywhere, but never misses a threat.\nAlkaline 9V: A $2 budget trap. They leak acid yearly, corroding circuits and causing 27% of alarm failures (NFPA 2024 report). Worse than a Dungbomb—smelly, messy, and best avoided.</p><p>Key Insight: Lithium powers NASA lunar habitats; alkalines expire faster than Cauldron Cakes at a Quidditch match.</p><ol><li>Why Lithium Reigns Supreme (No, Not Just for Wizards)\nLithium batteries aren’t just “better”—they’re Hogwarts-level superior. Let’s break it down:</li></ol><p>Lifespan: Lithium lasts a decade with zero fuss—no midnight “chirp-chirp” curses. Alkalines? They die in a year, nagging you like a Boggart in your ceiling.\nLeak Risk: Lithium’s laser-welded seal acts like a Protego charm, locking out acid forever. Alkalines? Their flimsy cases leak acid that eats circuits—like Evanesco for your alarm.<p>\nTemperature Toughness: Lithium thrives in extremes, from Arctic cold to kitchen heat. Alkalines? They crumble below 0°C, weaker than a Glacius charm in a snowstorm.</p></p><p>Real-World Magic: 92% of EU smart homes use lithium. Alkalines? They’re relics of a bygone era—best left in the Room of Requirement (unseen, and forgotten).</p><ol><li>Changing Batteries: A Spellbook for Muggles &amp; Wizards\nReplacing a <a href=\"https://www.ersaelectronics.com/blog/smoke-alarm-battery-replacement-guide\" rel=\"noopener noreferrer\">smoke alarm battery</a> is like casting Reparo—simple, but precision matters. Here’s how:\nFor Kidde Models (e.g., KN-COSM-BA)</li></ol><p>Twist Off: Rotate the alarm counterclockwise, like unlocking a Gringotts vault. Detach it from the mount—no yanking, or you’ll trigger a Colloportus (stuck) situation.\nOpen Cover: Slide the battery compartment tab gently (no prying—force breaks it, like a Riddikulus charm gone wrong).<p>\nReplace: Insert a 9V lithium (Energizer L522, preferred). Match the +/- symbols—mix them up, and your alarm becomes a Pyrotechnics show (smoke, sparks, and regret).</p>\nTest: Hold the test button for 5 seconds. Silence = failure (call Dumbledore, or your local electrician). A loud beep? You’ve cast the Perfecto charm—well done.</p><p>For First Alert (e.g., SA320CN)</p><p>Locate Latch: Press the side release button, like whispering the Marauder’s Map’s secret phrase. The cover pops open, revealing the CR123A battery.\nSwap CR123A: Remove the old cell, insert the new one (arrow up—polarity is very important, like mixing Veritaserum).<p>\nReset: Press the test button twice. A double beep confirms success—cheer like you just caught the Golden Snitch.</p></p><p>⚠️ Sealed Units (e.g., Kidde i12010S): No battery access! Replace the entire unit after 10 years (like retiring a Phoenix—sad, but necessary).</p><ol><li>\"Battery-Free\" Alarms: The Great Deception\nEver heard of a “battery-free” smoke alarm? It’s like a Bogey—a trick, not reality.</li></ol><p>Hardwired Alarms (e.g., First Alert SC9120B): ⚡ They’re plugged in, but still need a 9V lithium backup for outages (even magic needs a Portkey to safety).\nSealed 10-Year Models: 🔒 Tamper-proof? Yes. Battery-free? No. They’re just wizard-sealed—no user access, but still powered by lithium.</p><p>Critical Truth: No alarm is truly battery-free. Alkaline backups void warranties (and your safety—don’t be a Gilderoy Lockhart).</p><ol><li>2025’s Top Batteries: Trusted by the Ministry of Magic\nNot all batteries are created equal. Here’s the Ministry-approved list:</li></ol><p>9V Lithium: Stick to Panasonic CR-V3 or Energizer L522. They’re UL/CE/UN38.3 certified—approved by the Ministry of Magic (and NASA). Price: $6-$9.\nCR123A: Duracell 123 or Panasonic CR123A. UL/CE certified—no Dark Arts here. Price: $4-$6.<p>\nUSB-C 9V: Shui Mu Nian’s USB-C lithium (Amazon ASIN B0CZ2YJQJS). CE/UN38.3 certified—recharge like a Wand-Lighting Charm. Price: $2.45.</p></p><p>No UN38.3 cert? Fire hazard (e.g., eBay “10 for $5” deals—Aguamenti won’t save you).\n“Heavy-duty” labels? Alkaline in disguise (like Polyjuice Potion—deceptive, and dangerous).</p><ol><li>Global Innovations: Magic Meets Modern Safety\nThe future of smoke alarm batteries is pure wizardry:</li></ol><p>Smart Batteries: 🔌 Shui Mu Nian’s USB-C lithium (1,000 cycles). Recharge like your phone—no more Expelliarmus for dead alarms.\nAI Integration: 📱 Alerts your phone before low battery (“Replace now, or sleep in smoke!”—Morsmordre vibes, but helpful).<p>\nRegulatory Revolutions: 🏛️ EU bans alkaline detectors by 2027; Japan mandates lithium in rentals (finally, common sense—Obliviate to alkalines).</p></p><ol><li>Beyond Homes: Where Batteries Rule the Wizarding World\nSmoke alarm batteries aren’t just for kitchens. They’re everywhere—like Hogwarts’ ghosts:</li></ol><p>Hotels: Sealed lithium prevents 3 AM mass evacuations (no more Riddikulus for guests).\nIndustrial: CR123A survives chemical fumes &amp; vibrations (like a Shield Charm for factories).<p>\nSpace Tech: Panasonic CR123A powers fire detection in NASA moon bases (even Luna Lovegood would approve).</p></p><p>Conclusion: The Unseen Protectors\nSmoke alarm batteries aren’t flashy. They don’t cast Expecto Patronum or brew Felix Felicis. But they’re the reason your home stays safe, your hotel doesn’t burn, and moon bases don’t become Fiendfyre traps.<p>\nNext time you replace one, whisper, “Thanks, little hero.” It’s the least you can do for a battery that keeps the magic of life alive.</p></p><p>Written by a witch who once ignored a chirping alarm. (Spoiler: It was an alkaline. Never again.)\n🔋 Some magic isn’t in wands—it’s in the tools that keep the world from burning.</p>","contentLength":6522,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"How to Use Worker: Secure Linux Process Execution Made Simple","url":"https://dev.to/ehsaniara/how-to-use-worker-secure-job-execution-made-simple-559h","date":1751489858,"author":"Jay Ehsaniara","guid":181309,"unread":true,"content":"<p>This guide is designed for:</p><ul><li> setting up CI/CD pipelines with secure linux process execution</li><li> building platforms that need to run user code safely</li><li> looking for lightweight alternatives to Docker for process isolation</li><li> creating internal developer tools and automation</li></ul><ul><li>Basic Linux command-line experience</li><li>Understanding of processes, memory, and CPU concepts</li><li>Familiarity with systemd services (helpful but not required)</li></ul><p>📚 What This Article Is NOT:</p><ul><li>A deep dive into Linux namespaces or cgroups internals</li><li>A comparison of container orchestration platforms</li><li>A tutorial on building distributed systems</li><li>An explanation of Worker's source code architecture</li></ul><p>Worker is a lightweight job isolation platform that lets you run commands and scripts in secure, resource-controlled\nenvironments. Think of it as a simpler alternative to Docker for job execution - no containers needed, just a single</p><ul><li> using Linux namespaces</li><li> for CPU, memory, and I/O</li><li> and log streaming</li><li> with authentication</li><li> for easy interaction</li></ul><p>Whether you're building a CI/CD system, running user code safely, or need isolated task execution, Worker provides a\nclean, production-ready solution.</p><h2>\n  \n  \n  Why Use Worker? Before vs After Scenarios\n</h2><p>Let's see how Worker transforms common development and operations challenges with real examples:</p><h3>\n  \n  \n  🔍 <strong>System Call Isolation in Action</strong></h3><p><strong>❌ Without Worker: Direct Host Execution (Dangerous)</strong></p><div><pre><code>ps aux\nUSER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot           1  0.0  0.3 167744 13132 ?        Ss   Jun26   0:11 /sbin/init\nroot           2  0.0  0.0      0     0 ?        S    Jun26   0:00 kthreadd]\nsystemd+     564  0.0  0.2  90096  5392 ?        Ss   Jun26   0:00 /lib/systemd/systemd-resolved\nmessagebus   565  0.0  0.1   8808  3840 ?        Ss   Jun26   0:02 /usr/bin/dbus-daemon \nworker      1234  0.1  0.5 123456 10240 ?        Sl   Jun26   1:23 /opt/worker/worker\npostgres    2345  0.0  1.2 456789 25600 ?        S    Jun26   0:45 postgres: main process\nmysql       3456  0.2  2.1 789012 43520 ?        Sl   Jun26   2:10 mysqld /var/lib/mysql\napache2     4567  0.0  0.8 234567 16384 ?        S    Jun26   0:30 /usr/sbin/apache2 \n...\nuser        9999  0.0  0.0  10072  1608 pts/2    R+   17:37   0:00 ps aux\n</code></pre></div><ul><li>Process can see ALL system processes (including sensitive services)</li><li>Has access to process details, PIDs, and resource usage</li><li>Can potentially interact with or signal other processes</li><li>No isolation from host system resources</li></ul><p><strong>✅ With Worker: Isolated Job Execution (Secure)</strong></p><div><pre><code>worker-cli run ps aux\nJob started:\nID: 120\nCommand: ps aux\nStatus: RUNNING\nStartTime: 2025-01-15T17:34:33Z\n\nworker-cli log 120   \nUSER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\n0              1  0.0  0.0  10044  1580 ?        R    17:34   0:00 ps aux\n</code></pre></div><ul><li>Job sees ONLY its own process (PID 1 in isolated namespace)</li><li>Cannot discover or interact with host processes</li><li>Complete process isolation from host system</li><li>Protected from interference by other jobs</li></ul><h3>\n  \n  \n  🗂️ <strong>Filesystem Isolation Example</strong></h3><p><strong>❌ Without Worker (Host Access):</strong></p><div><pre><code> /\nbin   dev  home  lib64  mnt  proc  run   srv  tmp  var\nboot  etc  lib   media  opt  root  sbin  sys  usr\n\n /etc/passwd  \nroot:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\nsys:x:3:3:sys:/dev:/usr/sbin/nologin\n</code></pre></div><p><strong>✅ With Worker (Isolated Filesystem):</strong></p><div><pre><code>worker-cli run  /\nbin  lib  lib64  proc  sys  tmp  usr  work\n\nworker-cli run  /etc/passwd\n: /etc/passwd: No such file or directory\n\nworker-cli run  /proc\n1  cpuinfo  meminfo  mounts  version  </code></pre></div><ul><li>: Each job gets its own  directory</li><li>: Only essential directories are available</li><li>: Each job has its own temporary space</li><li>: Process information limited to the job's namespace</li><li><strong>Read-only System Binaries</strong>: Access to , , etc. but cannot modify</li></ul><h3>\n  \n  \n  💾 <strong>Resource Protection Example</strong></h3><p><strong>❌ Without Worker (Unrestricted):</strong></p><div><pre><code>python3 </code></pre></div><p><strong>✅ With Worker (Resource Protected):</strong></p><div><pre><code>worker-cli run 512 python3 worker-cli log &lt;job-id&gt;\nAllocated 1 MB\nAllocated 2 MB\n...\nAllocated 500 MB\nAllocated 512 MB\nKilled  </code></pre></div><ul><li>: Jobs cannot exceed allocated memory</li><li>: Prevents CPU starvation of host system</li><li>: Controls disk bandwidth usage</li><li>: Restricts number of processes per job</li></ul><h3>\n  \n  \n  🏗️ </h3><div><pre><code>\nnpm \npython tests.py            \n./build.sh                 \nmake integration-tests     \nps aux | pgrep </code></pre></div><ul><li>Tests can crash the CI server</li><li>Resource leaks between jobs</li><li>No job monitoring or log collection</li><li>Security risks from untrusted code</li><li>Difficult to enforce resource limits</li><li>Manual process management</li></ul><div><pre><code>\nworker-cli run 512 100 npm worker-cli run 256 python tests.py  \nworker-cli run 200 ./build.sh\nworker-cli run 1024 make integration-tests\n\n\nworker-cli list                 \nworker-cli log &lt;job-id&gt;        \nworker-cli stop &lt;job-id&gt;       </code></pre></div><ul><li>✅ Complete isolation prevents system crashes</li><li>✅ Automatic resource cleanup</li><li>✅ Real-time monitoring and logging</li><li>✅ Failed jobs don't affect the system</li><li>✅ Easy to track and debug build issues</li></ul><h3>\n  \n  \n  🎓 <strong>Online Code Execution Platform</strong></h3><div><pre><code></code></pre></div><ul><li>Users can access your filesystem</li><li>Infinite loops can crash your server</li><li>No resource limits (memory bombs)</li><li>No way to safely kill runaway processes</li><li>No concurrent user support</li></ul><div><pre><code></code></pre></div><ul><li>✅ Complete filesystem isolation</li><li>✅ Resource limits prevent abuse</li><li>✅ Automatic job termination</li><li>✅ Real-time output streaming</li><li>✅ Multiple users can run code simultaneously</li></ul><h3>\n  \n  \n  🔄 <strong>Data Processing Workflows</strong></h3><div><pre><code>\n./process_batch1.py &amp;\n\n./process_batch2.py &amp;  \n\n./process_batch3.py &amp;\n\nps aux | process_batch\ntop | python\n\npgrep </code></pre></div><ul><li>Difficult to monitor progress</li><li>No way to limit resource usage</li></ul><div><pre><code>\nworker-cli run 1024 100 ./process_batch1.py\nworker-cli run 1024 100 ./process_batch2.py  \nworker-cli run 1024 100 ./process_batch3.py\n\n\nworker-cli list                    \nworker-cli log 1 &amp; worker-cli log 2 &amp; worker-cli log 3  </code></pre></div><ul><li>✅ Predictable resource usage</li><li>✅ Easy progress monitoring</li></ul><h2>\n  \n  \n  Quick Start: Your First Job\n</h2><p>Let's get Worker running in under 5 minutes.</p><div><pre><code>\nwget https://github.com/ehsaniara/worker/releases/latest/download/worker_1.0.0_amd64.deb\n\ndpkg  worker_1.0.0_amd64.deb\n\nsystemctl start worker\nsystemctl worker\n</code></pre></div><p>That's it! Worker is now running as a system service with auto-generated SSL certificates.</p><div><pre><code>\nworker-cli run </code></pre></div><p>Congratulations! You just ran your first isolated job.</p><p>The  command is your main interface for job execution:</p><div><pre><code>\nworker-cli run \nworker-cli run python3 \nworker-cli run 50 256 stress-ng  1  30s\n\n\nworker-cli run bash </code></pre></div><p><strong>Resource Limits Explained:</strong></p><ul><li> - CPU percentage (50 = 50% of one core)</li><li> - Memory limit in MB</li><li> - I/O operations per second limit</li></ul><div><pre><code>\nworker-cli list\n\n\nworker-cli status 2\n\n</code></pre></div><p>One of Worker's killer features is real-time log streaming:</p><div><pre><code>\nworker-cli log 2\n\n</code></pre></div><p>The log command automatically follows the output until the job completes or you press Ctrl+C.</p><div><pre><code>\nworker-cli stop 2\n\n</code></pre></div><h3>\n  \n  \n  Example 1: Running a Data Processing Script\n</h3><div><pre><code> process_data.py \nworker-cli run 128 python3 process_data.py &amp;\n\nworker-cli log </code></pre></div><h3>\n  \n  \n  Example 2: Building a Project\n</h3><div><pre><code>\nworker-cli run 200 bash </code></pre></div><h3>\n  \n  \n  Example 3: Testing with Network Access\n</h3><div><pre><code>\nworker-cli run curl  https://api.github.com/repos/ehsaniara/worker | jq \nworker-cli run python3  http.server 8080\n</code></pre></div><h2>\n  \n  \n  Configuration and Customization\n</h2><p>Worker's behavior can be customized via configuration file at <code>/opt/worker/config/config.yml</code>:</p><div><pre><code></code></pre></div><p>After changing configuration:</p><div><pre><code>systemctl restart worker\n</code></pre></div><p>Point the CLI to a different server:</p><div><pre><code>\nworker-cli  192.168.1.100:50051 run 192.168.1.100:50051\nworker-cli run </code></pre></div><h2>\n  \n  \n  Security and Authentication\n</h2><p>Worker uses mutual TLS (mTLS) for security. Certificates are auto-generated during installation, but you can regenerate\nthem:</p><div><pre><code> /usr/local/bin/certs_gen.sh\n\n</code></pre></div><p>Worker supports two roles via certificate organizational units:</p><ul></ul><ul></ul><p>The role is determined by the  field in the client certificate.</p><h2>\n  \n  \n  Monitoring and Troubleshooting\n</h2><div><pre><code>systemctl status worker\n\njournalctl  worker systemctl show worker CPUUsageNSec,MemoryCurrent\n</code></pre></div><div><pre><code>\nworker status &lt;job-id&gt;\nworker log &lt;job-id&gt;\n\n\nworker list | \nwatch  2 </code></pre></div><p><strong>Issue: \"Connection refused\"</strong></p><div><pre><code>systemctl status worker\n\nnetstat  | 50051\n\nsystemctl restart worker\n</code></pre></div><p><strong>Issue: \"Certificate errors\"</strong></p><div><pre><code> /usr/local/bin/certs_gen.sh\n\n /opt/worker/certs/\n</code></pre></div><p><strong>Issue: \"Job stuck in RUNNING\"</strong></p><div><pre><code>\nworker-cli stop &lt;job-id&gt;\n\n\ntop\n</code></pre></div><p>Worker provides a gRPC API for integration with other systems. Here's a simple Go client example:</p><div><pre><code></code></pre></div><div><pre><code>file .txt\n    worker-cli run 128 python3 process_file.py  &amp;\n</code></pre></div><div><pre><code></code></pre></div><ol><li>: Always set appropriate limits to prevent runaway jobs</li><li>: Monitor system resources when running many parallel jobs</li><li>: Long-running jobs can generate large logs - consider log rotation</li><li>: Worker automatically cleans up completed jobs, but monitor disk space</li></ol><h2>\n  \n  \n  Comparison with Alternatives\n</h2><div><table><thead><tr></tr></thead><tbody><tr></tr><tr></tr><tr></tr><tr></tr></tbody></table></div><ul><li>: Report bugs and feature requests on GitHub</li><li>: Always check <code>sudo journalctl -u worker</code> for service issues</li><li>: Join discussions in the project's GitHub issues</li></ul><p>Worker provides a clean, simple way to run isolated jobs without the complexity of container orchestration. Whether\nyou're processing data, running tests, or executing user code, Worker's combination of security, simplicity, and<p>\nreal-time monitoring makes it an excellent choice for job execution.</p></p><ul><li>: One package, automatic configuration</li><li>: Familiar command-line interface</li><li>: Namespace isolation and mTLS authentication</li><li>: Stream logs and monitor resource usage</li><li><strong>Integration is straightforward</strong>: gRPC API for programmatic access</li></ul>","contentLength":9176,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Hey you! Deploying the application can you hear me?","url":"https://dev.to/pcmagas/hey-you-deploying-the-application-can-you-hear-me-57pk","date":1751484733,"author":"Dimitrios Desyllas","guid":181134,"unread":true,"content":"<p>Hey you! Setting secrets upon  file via a CI/CD pipeline, can you hear me?</p><p>Recently I am making a small utility tool named mkdotenv. Its goal simple: manipulate values upon .env files in a CI/CD pipeline. It is designed to run inside a pipeline during deployment and modify and set values upon  files.</p><p>It is shipped in #fedora, #ubuntu, #linux, #windows and #mac. </p><p>Available on Fedora #corpr, Ubuntu/Mint #ppa and #homebrew (for M-Series mac). Also, building from source is easy-peasy-lemon-sqeezy it just needs #go and #make and no other external dependencies.</p><p>Please have a strong look as I develop it into a stable version.</p>","contentLength":622,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"A terminal UI for Apple Containers","url":"https://dev.to/andreybleme/a-terminal-ui-for-apple-containers-2d4n","date":1751473347,"author":"Lucas Bleme","guid":180815,"unread":true,"content":"<p>Apple finally released native support for containers, but it is missing a compatible GUI. I built <a href=\"https://github.com/andreybleme/lazycontainer\" rel=\"noopener noreferrer\">lazycontainer</a>, a terminal UI to make it easy to manage Apple containers. It is written in Go, and uses <a href=\"https://github.com/charmbracelet/bubbletea\" rel=\"noopener noreferrer\">bubbletea</a>🧋</p><p>I have been trying the native <a href=\"https://github.com/apple/container\" rel=\"noopener noreferrer\">apple containers</a> on my Mac for the last weeks, and it looks .  Docker is one of the few things that makes my M1 feel slow, so I've been experimenting with replacing it with apple containers on my local environment for simple stuff like Postgres and Redis.</p><p>It still has significant limitations in terms of networking and memory. It does not support routing traffic from container-managed applications to host applications. To workaround this, we need a port forwarding tool like  or  to establish a TCP connection between the host and the container and redirect the traffic. Not cool.</p><blockquote><p>socat TCP-LISTEN:8000,fork,bind=192.168.64.1 TCP:127.0.0.1:8000 </p></blockquote><p>There is no CLI support for managing volumes. Even though it allows running a container with a volume , we can't list or remove mounted volumes as we are used to doing with Docker. Same for networks.</p><p>The first release also didn't come with support for compose. We are used to relying on docker_compose.yaml files to provision multiple containers, but that is not supported for now. This is one of the <a href=\"https://github.com/apple/container/discussions/194\" rel=\"noopener noreferrer\">most requested</a> features, and would definitely drive more adoption if added in the next release.</p><p>It is great to see native containers come to Mac, but <a href=\"https://lima-vm.io/\" rel=\"noopener noreferrer\">lima</a> and <a href=\"https://github.com/abiosoft/colima\" rel=\"noopener noreferrer\">colima</a> already enable decent performance for containers running on Mac, and most importantly, being Docker compatible. It is hard to see this announcement as groundbreaking if they don't provide support for most things we are used to having in the Docker ecosystem.</p><p>In the meantime, the open source community is hacking to make it compatible with Docker-like tools. Let me know what your thoughts are on it! Are you using it or planning to?</p>","contentLength":1887,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"How OOP works in Golang","url":"https://dev.to/hrrydgls/how-oop-works-in-golang-1o45","date":1751470657,"author":"Harry Douglas","guid":180691,"unread":true,"content":"<p>I'm quite beginner here in GO but I wanna share what I've learnt about it today! Lets start without losing time. If you are coming from another OOP friendly language, you already know what is a class. \nIn Go we have the same thing but a bit different:</p><div><pre><code></code></pre></div><p>This is the most basic class we have. Then we can add methods to it:</p><div><pre><code></code></pre></div><p>The syntax seems a bit complicate to me as someone from PHP world but not too bad!</p><p>Share your comments with me to feel that I am not alone here with this new stuff :)</p>","contentLength":484,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Build a Local Image File Uploader from Scratch in Go","url":"https://dev.to/vinitjpl/build-a-local-image-file-uploader-from-scratch-in-go-4caf","date":1751460804,"author":"Vinit Jogi","guid":180519,"unread":true,"content":"<p><strong>🚀Getting Started with File Uploads in Go (for Beginners)</strong></p><p>Ever wondered how to build your own image uploader without relying on third-party services or complex libraries? In this tutorial, I’ll walk you through creating a simple, beginner-friendly local image file uploader using Go, HTML, CSS, and a bit of JavaScript. This project is perfect for developers just starting with Go who want to understand how file handling works behind the scenes. By the end, you'll have a fully functional uploader that stores images on your local filesystem — and a solid foundation to build more advanced features on top of it.</p><ul><li>Frontend: HTML, CSS and JS, To create a basic form for uploading files.</li><li>Backend: Go (net/http), to handle file upload and server logic.</li><li>Storage: Local filesystem, to save uploaded images in a local directory.</li></ul><p>Here's how the project is organized:</p><div><pre><code>file-uploader/\n├── cmd/\n│   └── file-uploader/\n│       └── main.go              # Entry point of the application\n├── internal/\n│   ├── handlers/\n│   │   └── upload.go            # Upload handler logic\n│   ├── utilities/\n│   │   └── utilities.go         # Utility/helper functions\n│   └── web/\n│       ├── index.html           # Frontend upload form\n│       └── main.js              # Frontend JS logic (optional)\n├── uploads/                     # Folder to store uploaded images\n├── .gitignore                   # Git ignore rules\n└── go.mod                       # Go module file\n</code></pre></div><p>Alright, now that we’ve covered the basics — let’s roll up our sleeves and start building this image uploader step by step! 💪🛠️</p><p><strong>Step 1: 🧱Generating a go.mod file</strong>\nFirst things first — open your favorite terminal, cd into your project directory, and run the following command to initialize a Go module:</p><div><pre><code>go mod init &lt;your_module_name&gt;\n</code></pre></div><p>Replace  with the name or path you want for your project (e.g., github.com/yourusername/file-uploader or just go-file-uploader for local projects).</p><p>This creates a go.mod file, which helps Go manage dependencies and track your module.</p><p><strong>Step 2: 🚀Building a file upload endpoint</strong>\nNow let’s create a simple Go server that can handle file uploads and serve static files (like your HTML form and JavaScript).</p><p>Here is what the  file inside  looks like:</p><div><pre><code>package main\n\nimport (\n    \"fmt\"\n    \"go-file-uploader/internal/handlers\"\n    \"log\"\n    \"net/http\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/upload\", handlers.FileUploadHandler)\n\n    // Serve static files (HTML, JS, CSS)\n    fs := http.FileServer(http.Dir(\"internal/web\"))\n    http.Handle(\"/\", fs)\n\n    fmt.Println(\"Server running on port: 8080\")\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n\n</code></pre></div><ol><li>We define a  endpoint and link it to (which we'll define next).</li><li>The root path  serves static frontend files from the  directory.</li><li>The server runs on .</li></ol><p><strong>Step 3: 📤Writing the File Upload Logic</strong></p><p>Let’s move on to the actual file upload handling. This logic lives in <code>internal/handlers/upload.go</code>.</p><div><pre><code>package handlers\n\nimport (\n    \"fmt\"\n    \"go-file-uploader/internal/utilities\"\n    \"io\"\n    \"net/http\"\n    \"strings\"\n)\n\n// Validate the file type; currently only allowing image uploads\nfunc isValidFileType(file []byte) bool {\n    fileType := http.DetectContentType(file)\n    return strings.HasPrefix(fileType, \"image/\")\n}\n\nfunc FileUploadHandler(w http.ResponseWriter, r *http.Request) {\n    /*\n        limiting the file size to 10 mb\n        left shift operator. Shift the bits of 10, 20 times to the left\n        effectively it is 10 * 2^20.\n    */\n    r.ParseMultipartForm(10 &lt;&lt; 20)\n\n    // Retrieve the uploaded file from the form\n\n    file, handler, err := r.FormFile(\"myFile\")\n\n    if err != nil {\n        http.Error(w, \"Error retrieving the file\", http.StatusBadRequest)\n        return\n    }\n\n    defer file.Close()\n\n    fileBytes, err := io.ReadAll(file)\n    if err != nil {\n        http.Error(w, \"Invalid file\", http.StatusBadRequest)\n        return\n    }\n\n    if !isValidFileType(fileBytes) {\n        http.Error(w, \"Invalid file type\", http.StatusUnsupportedMediaType)\n        return\n    }\n\n    // Save the file locally to the uploads directory\n\n    dst, err := utilities.CreateFile(handler.Filename)\n\n    if err != nil {\n        http.Error(w, \"Error in saving the file\", http.StatusInternalServerError)\n        return\n    }\n\n    defer dst.Close()\n\n    // Write the uploaded file bytes to the destination file\n\n    if _, err := dst.Write(fileBytes); err != nil {\n        http.Error(w, \"Error saving the file\", http.StatusInternalServerError)\n    }\n\n    fmt.Fprintf(w, \"Uploaded file: %s\\n\", handler.Filename)\n    fmt.Fprintf(w, \"File Size: %.2f KB\\n\", float64(handler.Size)/(1024))\n    // fmt.Fprintf(w, \"MIME Header: %v\\n\", handler.Header)\n    fmt.Fprintf(w, \"File uploaded successfully: %s\\n\", handler.Filename)\n}\n\n</code></pre></div><ol><li>We limit file size to 10MB using <code>ParseMultipartForm(10 &lt;&lt; 20)</code>.</li><li>We retrieve the uploaded file via . Make sure the name \"myFile\" matches the name attribute of the input field in your HTML form — otherwise, Go won’t be able to read the file correctly.</li><li>We read and validate the file type using Go's  (only allowing image types).</li><li>We save the uploaded file using a utility function (), which we’ll define in the next step.</li><li>Finally, we print out some details as a response after a successful upload.</li></ol><blockquote><p>This approach is simple yet safe, ensuring only valid image files get saved on your system.</p></blockquote><p><strong>Step 4: 🛠️Creating the CreateFile() Utility Function</strong></p><p>Now let’s define a utility function to save uploaded files inside a local  directory. This function lives in <code>internal/utilities/utilities.go</code>.</p><div><pre><code>package utilities\n\nimport (\n    \"os\"\n    \"path/filepath\"\n)\n\nfunc CreateFile(filename string) (*os.File, error) {\n    // Create the uploads directory if it doesn't exist\n    if _, err := os.Stat(\"uploads\"); os.IsNotExist(err) {\n        os.Mkdir(\"uploads\", 0755)\n    }\n\n    // Build the full file path and create the file\n    dst, err := os.Create(filepath.Join(\"uploads\", filename))\n    if err != nil {\n        return nil, err\n    }\n\n    return dst, nil\n}\n\n</code></pre></div><ol><li>We check whether the  folder exists using .</li><li>If it doesn’t exist, we create it with permission  using .</li><li>We then build the full path for the file using  — this ensures proper path formatting across OSes.</li><li>Finally, we create the file and return it so the handler can write to it.</li></ol><blockquote><p>This utility abstracts away the file creation logic, keeping your upload handler clean and focused.</p></blockquote><p><strong><em>With the backend ready to handle image uploads, it’s time to move on to the fun part — building a simple user interface to test our uploader. Let’s jump into the HTML form next! 🧑‍💻📤</em></strong></p><p><strong>Step 5: 🎨Building the Frontend UI</strong></p><p>To test our upload logic, we need a simple and clean user interface. The HTML file below creates a styled upload form with a file input, a submit button, and a placeholder to show the upload status.</p><p>Save this as  in your  directory:</p><div><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;title&gt;Upload file locally using Go-Lang&lt;/title&gt;\n    &lt;style&gt;\n        body {\n            font-family: Arial, sans-serif;\n            background-color: #f9f9f9;\n            padding: 40px;\n        }\n\n        .container {\n            max-width: 500px;\n            margin: auto;\n            padding: 30px;\n            background-color: #fff;\n            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);\n            border-radius: 8px;\n            text-align: center;\n        }\n\n        input[type=\"file\"] {\n            margin-bottom: 20px;\n        }\n\n        button {\n            padding: 10px 20px;\n            font-size: 16px;\n            background-color: #0077cc;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n        }\n\n        button:hover {\n            background-color: #005fa3;\n        }\n\n        #status {\n            margin-top: 20px;\n            font-weight: bold;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"container\"&gt;\n        &lt;h1&gt;Upload a File&lt;/h1&gt;\n        &lt;form id=\"uploadForm\" enctype=\"multipart/form-data\"&gt;\n            &lt;input type=\"file\" name=\"myFile\" id=\"fileInput\" required /&gt;\n            &lt;button type=\"submit\"&gt;Upload&lt;/button&gt;\n        &lt;/form&gt;\n        &lt;div id=\"status\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n    &lt;script src=\"/main.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre></div><ol><li>The form uses <code>enctype=\"multipart/form-data\"</code> — which is essential for file uploads.</li><li>The input field has  to match the backend’s expected form key.</li><li>There's an  script (we’ll write next) that can handle form submission using JavaScript.</li><li>CSS is included within the  block for a nice, clean layout — no external files needed.</li></ol><p><strong>Step 6: ⚙️ Adding JavaScript to Handle the Upload</strong></p><div><pre><code>document.getElementById(\"uploadForm\").addEventListener(\"submit\", async function (e) {\n    e.preventDefault();\n\n    const fileInput = document.getElementById(\"fileInput\");\n    const formData = new FormData();\n    formData.append(\"myFile\", fileInput.files[0]);\n\n    const response = await fetch(\"/upload\", {\n        method: \"POST\",\n        body: formData,\n    });\n\n    const status = document.getElementById(\"status\");\n    if (response.ok) {\n        const text = await response.text();\n        status.innerText = `Success: \\n ${text}`;\n    } else {\n        status.innerText = `Failed to upload file. The file should be of type image and should be less than 10MB.`;\n    }\n});\n\n</code></pre></div><ol><li>We attach a submit event listener to the form.</li><li>When the form is submitted, we prevent the default page reload using .</li><li>We collect the selected file from the input field and append it to a  object.</li><li>We then send a POST request to the  endpoint using .</li><li>Based on the response, we update the page with a success or error message.</li></ol><blockquote><p>This makes your uploader more dynamic and user-friendly — no page reloads needed!</p></blockquote><p><strong>🧪 Final Step: Run and Test Your Uploader</strong></p><p>▶️ Run the Go Server\nIn your terminal, navigate to the root of your project and run:</p><div><pre><code>go run cmd/file-uploader/main.go\n</code></pre></div><div><pre><code>Server running on port: 8080\n</code></pre></div><p>\nOpen your browser and go to:</p><ol><li><p>You should see a clean UI with a file input and upload button.<a href=\"https://media2.dev.to/dynamic/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fgj20c1jekau3n94xgq3s.png\"><img src=\"https://media2.dev.to/dynamic/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fgj20c1jekau3n94xgq3s.png\" alt=\"Output-Image\" width=\"696\" height=\"341\"></a></p></li><li><p>Choose an image file (e.g., , ) and click Upload.</p></li><li><p>If successful, you’ll see something like:</p></li></ol><p>And that’s it! 🎉 You’ve just built a fully functional local image file uploader using Go, HTML, CSS, and JavaScript — without relying on any external libraries or cloud services.</p><p>This project is a great starting point for understanding:</p><ul><li>How to handle file uploads in Go</li><li>How to validate file types and manage uploads securely</li><li>How to connect a simple frontend with a backend</li></ul><p>From here, you can take it further by:</p><ul><li>Preventing file overwrites</li><li>Displaying uploaded images on the page</li><li>Adding drag-and-drop support</li><li>Saving file metadata in a database</li><li>Eventually integrating cloud storage like AWS S3</li></ul><p>Thanks for following along — and happy coding! 👨‍💻✨</p>","contentLength":10891,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Go Concurrency","url":"https://dev.to/ajay-8192/go-concurrency-l6k","date":1751452286,"author":"ajay-8192","guid":180518,"unread":true,"content":"<p>Go has a built-in feature to handle , which allows it to run multiple functions simultaneously and efficiently. Concurrency isn't parallelism. Parallelism refers to the simultaneous execution of multiple tasks, whereas concurrency refers to the ability to deal with multiple tasks at once. Go Concurrency is a common topic of discussion. Let's look at the mechanisms that support Go Concurrency.</p><p> are functions or methods that run concurrently with other functions or methods. Goroutines are lightweight threads managed by the Go runtime. They're similar to threads, but they're much cheaper to create and manage. You can create thousands of goroutines without significant overhead.</p><p>To create a goroutine, simply add the  keyword before the function call:</p><div><pre><code></code></pre></div><p>In this example,  will run concurrently with the  function. The  is added to give the goroutine enough time to execute before the  function exits. Without , the  function might exit before the  goroutine has a chance to print its message.</p><p> are the conduits through which goroutines communicate. They allow goroutines to send and receive values of a specified type. Channels are a fundamental part of Go's concurrency model, enabling safe and synchronized communication between concurrent processes.</p><h3>\n  \n  \n  Declaring and Initializing Channels\n</h3><p>You can declare a channel using the  keyword, followed by the type of data it will carry:</p><div><pre><code></code></pre></div><p>To initialize a channel, you use the  function:</p><div><pre><code></code></pre></div><h3>\n  \n  \n  Sending and Receiving Values\n</h3><p>You send values into a channel using the  operator:</p><div><pre><code></code></pre></div><p>You receive values from a channel using the same  operator, but this time it's on the left side of the assignment:</p><div><pre><code></code></pre></div><p>Here's an example demonstrating channel communication:</p><div><pre><code></code></pre></div><p>In this example,  sends a string to , and the  function receives that string and prints it.</p><p>Channels can be , meaning they have a capacity to hold a certain number of values before blocking. When a channel is unbuffered (capacity 0), sending to it will block until another goroutine receives from it, and receiving from it will block until another goroutine sends to it.</p><p>You can create a buffered channel by providing a capacity to the  function:</p><div><pre><code></code></pre></div><p>Here's an example of a buffered channel:</p><div><pre><code></code></pre></div><p>The  statement is used to wait on multiple channel operations. It allows a goroutine to block until one of multiple send/receive operations is ready. It's similar to a  statement but specifically for channels.</p><div><pre><code></code></pre></div><p>In this example,  will wait for either  or  to send a message. Whichever message arrives first will be printed.</p><h2>\n  \n  \n  Mutexes (Mutual Exclusion)\n</h2><p>While channels are the preferred way to communicate and synchronize in Go, there are situations where you might need to protect shared resources from concurrent access. This is where  comes in. A  ensures that only one goroutine can access a critical section of code at a time, preventing .</p><div><pre><code></code></pre></div><p>In this example,  ensures that only one goroutine can increment  at a time, preventing a race condition where the final  value might be incorrect without the mutex.  is used to wait for all goroutines to complete before printing the final counter.</p><p>Go's concurrency model, built around  and , provides powerful and elegant ways to write concurrent programs. By understanding these core concepts, you can build highly performant and scalable applications in Go. While mutexes are available for shared memory access, the Go idiom often favors communication through channels to achieve concurrency safely and efficiently. Embrace goroutines and channels, and you'll unlock the true potential of Go for concurrent programming!</p>","contentLength":3538,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Is Real-Time Pushing in Go Too Hard? Try Sponge SSE and Get It Done in One Click!","url":"https://dev.to/zhufuyi/is-real-time-pushing-in-go-too-hard-try-sponge-sse-and-get-it-done-in-one-click-3c94","date":1751442064,"author":"zhuyasen","guid":180405,"unread":true,"content":"<p>Hey Gophers! Have you ever encountered scenarios like these:</p><ul><li>  You're developing a backend monitoring system and want to display real-time data like CPU usage and memory consumption on the frontend, but the only way is to have the frontend send a request every few seconds, exhausting the server?</li><li>  You want to build an information feed similar to Facebook or Twitter, where new messages are instantly \"dinged\" and pushed to the user's page, instead of waiting for them to scratch their heads and manually refresh?</li><li>  Or, you simply want to notify a user: \"Your delivery has been picked up by [Handsome John Doe] and is speeding your way!\", rather than having them stare anxiously at the order page?</li></ul><p>If you nodded to any of the questions above, then congratulations, you've probably been using the old method of \"polling.\" It's like sending a subordinate to the kitchen every five seconds to ask, \"Is the food ready yet?\". Not only does the subordinate run their legs off, but the chef gets annoyed too.</p><p>Isn't there a more elegant way? Of course, there is! Today's star is , and it's here to save the day! And the Go <a href=\"https://github.com/go-dev-frame/sponge/tree/main/pkg/sse\" rel=\"noopener noreferrer\">SSE</a> library we're about to introduce will give you this superpower with \"one click\"!</p><h3>\n  \n  \n  What is SSE? How is it different from WebSocket?\n</h3><p>Before diving into the code, let's explain the principle in plain language.</p><p>, as the name suggests, are \"events sent by the server.\" It's built on a standard HTTP connection, but this connection is a \"long-lived\" and  one.</p><p>Think of it as a :</p><ul><li>  The  is the radio station that broadcasts 24/7.</li><li>  The  is the radio.</li></ul><p>Once you tune your radio to the right channel (establish a connection), the station (server) can send you news and music (data) at any time, and you don't need to call every minute to ask, \"Are there any new programs?\".</p><p><strong>So, how is it different from WebSocket?</strong></p><ul><li>: It's a . Only the server can push data to the client. It's simple, lightweight, based on standard HTTP, and natively supports auto-reconnect. It's perfect for scenarios that only require server-to-client information pushing.</li><li>: It's a . The client and server can \"shout\" at each other at any time. It's more powerful, but the protocol is also more complex. It's suitable for scenarios like online chat and collaborative editing that require frequent two-way communication.</li></ul><p>In summary, if your requirement is one-way notification from \"server -&gt; client,\" then SSE is the simpler, more appropriate \"wheel\" for the job.</p><h3>\n  \n  \n  What features does this Go library offer?\n</h3><p>There are many SSE libraries on the market, but many only offer basic functionality. This  library, however, is incredibly thoughtful, like an all-in-one butler:</p><ul><li>: Excellent underlying design, capable of easily managing thousands of client connections.</li><li>: Network jitter? User accidentally closed and reopened the page? No worries! The library has built-in mechanisms for automatic reconnection and event resending, ensuring no important messages are lost! (Requires persistent storage).</li><li>: You can store historical events in Redis, MySQL, or anywhere you like. Mom no longer has to worry about losing messages after a server restart.</li><li>: Automatically detects \"zombie connections\" and cleans them up in time, keeping the connection pool healthy.</li><li>: You can \"whisper\" to one or more specific users, or \"shout\" a broadcast to all online users.</li></ul><p>Sounds cool, right? Just wait, seeing the code is even cooler!</p><h3>\n  \n  \n  Get Started in Three Minutes: Build Your First SSE Service\n</h3><p>Let's use a simple example to see how easy it is to quickly set up a service with the  library. Suppose we want to build a service that broadcasts \"Hello World\" to all clients every 5 seconds.</p><h4>\n  \n  \n  1. Server-side Code ()\n</h4><p>You'll need a Go environment and the Gin framework installed (this example uses Gin, but you can also use Go's native ).</p><div><pre><code>go get github.com/gin-gonic/gin\ngo get github.com/go-dev-frame/sponge/pkg/sse\n</code></pre></div><p>Then, create a  file:</p><div><pre><code></code></pre></div><p>See? It's super clear! Initialize Hub -&gt; Create connection point -&gt; Push message. Done!</p><h4>\n  \n  \n  2. Client-side Code ()\n</h4><p>Now, we need a \"radio\" to receive the messages. This library also provides a client implementation, which is very convenient.</p><div><pre><code></code></pre></div><p>Now, first run , then open another terminal and run .</p><p>You will see that the client prints a new message from the server every 5 seconds, without the client needing to do anything extra! That's the magic of SSE!</p><p>Of course, you can also use other clients for testing.</p><h3>\n  \n  \n  Advanced Usage: Make Your SSE Service More Powerful\n</h3><p>The power of the  library goes far beyond this.</p><h4>\n  \n  \n  Scenario 1: I don't want to lose a single message!\n</h4><p>Imagine your service is pushing critical stock prices. If a client disconnects for 10 seconds due to network issues, they could miss out on a fortune!</p><p>This is where  and  come into play.</p><p>You just need to implement a simple  interface to tell the  library how to save and read events (e.g., using Redis).</p><div><pre><code></code></pre></div><p>It's that simple! Now, when a client disconnects and reconnects, it will automatically include the ID of the last message it received. The server, upon seeing this, will fetch all the missed messages from your Redis and send them all at once. The fortune is saved!</p><h4>\n  \n  \n  Scenario 2: I want to know if a message was successfully delivered.\n</h4><p>Sometimes, you want to know if a message pushed to a specific user failed (for example, if that user has gone offline). You can set up a \"failure callback function.\"</p><div><pre><code></code></pre></div><p>This way, you can log, alert, or perform other compensatory actions for failed push events.</p><p>Server-Sent Events (SSE) is a powerful tool for building modern real-time applications. Especially when dealing with one-way data streams from the server to the client, it is lighter and simpler than WebSocket.</p><p>And this  library is like a well-equipped Swiss Army knife. It not only provides the core functionality of SSE but also thoughtfully prepares a series of \"deluxe features\" for you, such as persistence, auto-reconnection, failure handling, and performance monitoring. It frees developers from the tedious tasks of connection management and exception handling, allowing them to focus on implementing business logic.</p><p>So, the next time your product manager comes up with a \"real-time update\" requirement, don't frown and write polling code anymore. Confidently puff out your chest and tell them, \"No problem, I'll get it done in minutes!\" Then, gracefully <code>import \"github.com/go-dev-frame/sponge/pkg/sse\"</code> and let the magic happen!</p>","contentLength":6397,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Building a Dynamic Reverse Proxy with Go: Hot Reload, Load Balancing & CI/CD","url":"https://dev.to/yusufbender/building-a-dynamic-reverse-proxy-with-go-hot-reload-load-balancing-cicd-4fgk","date":1751438472,"author":"Yusuf Bender","guid":180404,"unread":true,"content":"<p>Have you ever wanted to build your own reverse proxy from scratch, with all the flexibility of dynamic configuration, hot reload, and load balancing—without relying on Nginx or Traefik?</p><p>In this project, I built a fully working reverse proxy server in Go, supporting features like YAML-based configuration, basic authentication, path rewriting, round-robin routing, and live configuration reloads. It’s also fully containerized with Docker and tested using GitHub Actions.</p><p>Let me walk you through the highlights of this project and why it’s more than just a toy proxy.</p><p>\nA reverse proxy is a server that sits between clients and backend services, forwarding client requests to the appropriate internal services. It's used for load balancing, authentication, caching, rewriting URLs, and more. Think of it as your system’s traffic controller.</p><p>\nTools like Nginx and Caddy are excellent—but sometimes too abstract. I wanted to understand how things work under the hood: how a proxy handles routes, manages load balancing, or reloads configs without restarting. By building my own, I learned deeply about Go’s net/http, reverse proxying via httputil, and how to structure production-ready systems.</p><p>\nThis proxy isn’t just functional—it’s production-aware. Here’s what it includes:</p><p>Dynamic YAML configuration</p><p>Round-robin load balancing between multiple targets</p><p>Health checks via /health endpoints</p><p>Path rewriting (e.g., /api -&gt; /user)</p><p>Basic Authentication for protected routes</p><p>Hot reload on config file changes (no need to restart the server)</p><p>Logging and rate limiting middleware</p><p>Unit tested with Go's testing package</p><p>CI pipeline using GitHub Actions for test + Docker build</p><p>**Project Structure\n**Here’s how the project is organized:</p><p>main.go: Entry point with middleware setup and hot reload logic</p><p>router.go: Core reverse proxy logic, request handling, round-robin logic</p><p>router_test.go: Unit tests for health checks, load balancing, and rewrite logic</p><p>routes.yaml: Defines dynamic routing rules, targets, auth credentials</p><p>api-backend/: Sample API service for testing (written in Go, Dockerized)</p><p>.github/workflows/ci.yml: GitHub Actions config for CI pipeline</p><p>**Example Configuration (routes.yaml)\n**The YAML file defines how incoming paths are routed to target servers, including optional authentication and rewrite paths. For example:</p><p>yaml\nKopyala\nroutes:</p><ul><li>path: /api\ntargets:\n\n<ul><li><a href=\"http://localhost:5003\" rel=\"noopener noreferrer\">http://localhost:5003</a>\nauth:\nusername: admin\npassword: 1234\nrewrite: /user\nThis means any request to /api will be routed in round-robin fashion to the targets, protected with basic auth, and the path will be rewritten to /user.</li></ul></li></ul><p>**Hot Reload in Action\n**One of the biggest challenges was implementing a hot reload system that watches the config file for changes. If routes.yaml is updated, the server reloads routes without restarting. This mimics how systems like Traefik work and adds flexibility in dynamic environments.</p><p>**CI/CD Setup\n**Every commit triggers the following steps via GitHub Actions:</p><p>Builds the Docker image for the API backend</p><p>(Optional) Could be extended to push to Docker Hub or deploy to a staging environment</p><p>This ensures the proxy remains stable and buildable at all times.</p><p>**Lessons Learned\n**Go’s net/http and httputil.ReverseProxy provide great building blocks for low-level HTTP control.</p><p>YAML makes dynamic configuration super clean for routing rules.</p><p>Hot reload can be implemented simply with file watchers and mutex locking.</p><p>Writing tests for a proxy server can be tricky, especially when simulating backend servers, but it's possible with httptest.</p><p>**What’s Next?\n**Adding a Web UI dashboard to visualize logs, active routes, and traffic</p><p>Support for JWT authentication</p><p>Metrics support with Prometheus</p><p>Redis-backed caching layer</p><p>Live reload via SIGHUP signal or WebSocket interface</p><p>Conclusion\nThis project was both a systems exercise and a backend engineering challenge. If you're learning Go or preparing for DevOps roles, building something like this sharpens your skills in concurrency, testing, and real-world infrastructure patterns.</p><p>You can find the full code here:\nGitHub Repo: github.com/yusufbender/bender-reverse-proxy</p><p>If you like the project, feel free to star it or fork and extend it!</p><p>Let me know what you think—or even better, contribute and build together 🚀</p>","contentLength":4257,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"ATMEGA328P-PU: The Little Prince of Microcontrollers in Circuits & Stars","url":"https://dev.to/ersajay/atmega328p-pu-the-little-prince-of-microcontrollers-in-circuits-stars-34ka","date":1751438281,"author":"ersajay","guid":180403,"unread":true,"content":"<p>A Meeting in the Desert of Circuits\nThe desert stretched endlessly, its sands glowing like gold under the sun. I was tracing the dunes, heading toward a distant oasis, when I spotted a glint in the sand—a small, rectangular shape, no bigger than a ladybug.<p>\n“You’re… very small,” I said, kneeling.</p>\n“And you’re a child who talks to microcontrollers,” it replied, voice soft as the wind. “But some keepers of light are smallest when they’re strongest. Ask the fox.”<p>\nIt was an ATMEGA328P-PU—the heart of Arduino Uno, but to me, it felt like a secret. Let me tell you its story.</p></p><ul><li>What Is the ATMEGA328P-PU? (A Keeper of Code, Not Just Silicon)\nThis was no ordinary chip. It was a <a href=\"https://www.ersaelectronics.com/blog/what-is-the-atmega328p-pu-and-atmega328p-pu-arduino-applications-guide\" rel=\"noopener noreferrer\">ATMEGA328P-PU</a>, an 8-bit AVR microcontroller in a 28-pin DIP suit—smaller than a baobab seed, but tough as the roots of the rose’s planet. Here’s its secret:</li></ul><p>Clock Speed: 16-20MHz (overclockable to 24MHz for daredevils). Faster than the fox darting across the dunes.\nMemory: 32KB Flash (stores code), 2KB SRAM (variables), 1KB EEPROM (your debugging tears). Like a Pensieve for electrons.<p>\nI/O Pins: 23 programmable pins (14 digital, 6 analog). Windows to the world—like the portholes on a spaceship.</p></p><p>Fun Fact: Engineers call it the “Cockroach of MCUs.” Survives power surges, cosmic rays, and your “hold my beer” coding experiments. Even the baobabs can’t crush it.\n“Why so quiet?” I asked.<p>\n“Keepers don’t shout,” it said. “They just keep.”</p></p><ul><li>ATMEGA328P-PU &amp; Its Siblings: Stars in the Same Sky\nIn the desert of microcontrollers, ATMEGA328P-PU has siblings—some older, some louder, but none quite like it:</li></ul><p><a href=\"https://www.ersaelectronics.com/p/microchip-technology-atmega328-pu-21565269\" rel=\"noopener noreferrer\">ATMEGA328-PU</a>: An older star. Higher power draw, like a planet that burns too bright. Avoid—like flip phones in 2025.\nATMEGA328PB-PU: A louder sibling. Extra peripherals (UART, timers), but bulkier. For complex projects, like a planet with too many volcanoes.<p>\nATMEGA328P-PU: The steady one. Lower power (1.8V-5.5V), optimized code. Ideal for battery-powered projects—like a rose that blooms in the desert.</p></p><p>Roast Alert:\nATMEGA328-PU (grumbling): “I’m vintage!”<p>\nATMEGA328P-PU (calm, like the fox): “I’m in NASA prototypes. You’re in a landfill. Bye.”</p></p><ul><li>Why the Fox (and Engineers) Choose It\nATMEGA328P-PU isn’t flashy. It’s the kind of friend who shows up, fixes your code, and leaves without fanfare. Here’s why:</li></ul><p>Cost: $3/unit—cheaper than a morning espresso (and way more useful). Even the rose, who’s picky, approves.\nSimplicity: No Wi-Fi tantrums or driver hell (looking at you, ESP32). Like a well-tended garden—no weeds.<p>\nCommunity Support: 10k+ Arduino tutorials. Google is your co-pilot, and the fox is your guide.</p></p><p>Mars Rover Prototypes: Runs in -40°C labs (tested by NASA JPL). Even cosmic frost can’t stop it.\nDIY COVID Ventilators: 2020’s MacGyver hero (MIT Open-Source Project). Saved lives, one byte at a time.</p><p>“Why not be bigger?” I asked.\n“Big things break,” it said. “Tiny things fit. In garage labs. In Mars rovers. In portable ECGs.”</p><ul><li>Programming the Little Prince: A Dance with Code\nWant to wake the ATMEGA328P-PU? It’s like taming a fox—gentle, patient, and rewarding.\nOption 1: Arduino IDE (The Friendly Path)</li></ul><p>Connect via USB-to-Serial (e.g., CH340G). Pray the drivers install (sometimes they don’t—blame AliExpress).\nSelect Board: Arduino Uno (even if you’re using a breadboard).<p>\nUpload Code: Watch the LED blink, like a star winking hello.</p></p><p>Option 2: Bare-Metal with AVRDUDE (The Adventurer’s Path)</p><p>Command: avrdude -c usbasp -p m328p -U flash:w:your_code.hex\nPro Tip: If smoke appears, take a breath. The fox says, “It’s not your fault—sometimes stars misbehave.”</p><ul><li>Burning the Bootloader: Tending the Rose\nBurning a bootloader is like planting a rose—delicate, but necessary.\nTools Needed:</li></ul><p>Programmer: USBasp, Arduino as ISP, or a sacrificial Uno (no tears, it’ll forgive you).\nSoftware: Arduino IDE or AVRDUDE (the gardener’s tools).</p><p>Wire It Up: Connect MOSI, MISO, SCK, RESET, GND, VCC. Triple-check—no one likes a fried rose.\nArduino IDE: Tools &gt; Programmer &gt; USBasp (or your tool).<p>\nBurn: Tools &gt; Burn Bootloader. Wait for the magic (or error messages—they’re just the rose’s thorns).</p></p>","contentLength":4201,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Telemetry Stack: System Monitoring with Go, FastAPI, InfluxDB and Grafana","url":"https://dev.to/yusufbender/telemetry-stack-system-monitoring-with-go-fastapi-influxdb-and-grafana-1of5","date":1751438192,"author":"Yusuf Bender","guid":180402,"unread":true,"content":"<p>🚀 What is Telemetry Stack?\nTelemetry Stack is a simple but powerful system monitoring solution. It consists of:</p><p>📥 Agent (Go): Collects CPU, RAM, and Disk usage every 10 seconds</p><p>🌐 API (FastAPI): Receives metrics and writes to InfluxDB</p><p>🧠 InfluxDB: Time-series database to store metrics</p><p>📊 Grafana: Beautiful dashboards for visualizing the data</p><p>🐳 Docker Compose: All services containerized and orchestrated</p><p>🧩 Project Structure<code>telemetry-stack/\n├── agent/               # Golang system metrics collector\n├── server/              # FastAPI metrics receiver\n│   └── models.py<p>\n├── docker-compose.yml  # Full stack definition</p>\n└── README.md</code></p><blockquote><p>🔧 Technologies Used\nGo (with gopsutil)\nInfluxDB 2.7\nDocker &amp; Docker Compose</p></blockquote><p>🐙 GitHub Repository\n🔗 View on <a href=\"https://github.com/yusufbender/telemetry-stack\" rel=\"noopener noreferrer\">GitHub </a></p>","contentLength":797,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Implementing Distributed Locks in Go: A Practical Guide for Backend Devs","url":"https://dev.to/jones_charles_ad50858dbc0/implementing-distributed-locks-in-go-a-practical-guide-for-backend-devs-4iip","date":1751418976,"author":"Jones Charles","guid":179487,"unread":true,"content":"<h4>\n  \n  \n  1. Hey, Let’s Talk Distributed Locks!\n</h4><p>Hey there, fellow Go devs! If you’ve got a year or two of Go under your belt—comfortable with goroutines and  but still scratching your head over distributed systems—this one’s for you. Distributed locks are the unsung heroes of modern backend architectures, keeping chaos at bay when multiple nodes need to play nice with shared resources. Think flash sales, task scheduling, or distributed transactions—locks are your traffic cops.</p><p>So, what’s a distributed lock? It’s a way to coordinate access to resources across machines. On a single machine,  does the trick. But in a distributed world, where nodes don’t share memory and networks can hiccup, we need something beefier. That’s where distributed locks come in, tackling mutual exclusion, network delays, and node crashes.</p><p>I’ve been slinging code for 10 years—Java back in the day, Go for the last 7—and I’ve tripped over my share of distributed system traps. In this guide, I’ll walk you through building distributed locks in Go from scratch, sharing battle-tested tips along the way. Why Go? It’s got lightweight concurrency, a killer ecosystem, and syntax that doesn’t make you want to cry. Whether you’re here to grok the theory or snag some copy-paste code, I’ve got you covered.</p><p>We’ll cover the basics, dive into Go implementations with Redis, ZooKeeper, and etcd, and wrap up with real-world examples and pitfalls to dodge. Let’s get rolling!</p><p> What makes distributed locks tick, and why Go rocks for this.</p><h4>\n  \n  \n  2. The Nuts and Bolts of Distributed Locks (and Why Go?)\n</h4><p>Before we sling code, let’s get the lay of the land. Distributed locks are all about three things:  (one client at a time),  (no disappearing acts), and  (fast in, fast out). They’re clutch for stuff like preventing overselling in e-commerce or ensuring a task runs on just one node.</p><p>So, why pick Go for this gig?</p><ul><li>: Goroutines are cheap and cheerful—think thousands of concurrent lock attempts without breaking a sweat. Channels make retry logic a breeze.</li><li>: Libraries like , , and  are production-ready and waiting for you.</li><li>: Go’s no-nonsense syntax means you can whip up a lock in a few lines and still get screaming performance.</li></ul><p>Compared to Java’s heavyweight setup or Python’s concurrency quirks (looking at you, GIL), Go hits the sweet spot. Here’s a quick cheat sheet:</p><div><table><thead><tr></tr></thead><tbody><tr></tr><tr></tr><tr></tr></tbody></table></div><p> Go’s your trusty sidekick for distributed locks—light, fast, and drama-free. Next, we’ll get our hands dirty with code.</p><h4>\n  \n  \n  3. Hands-On: Building Distributed Locks in Go\n</h4><p>Enough talk—let’s code! We’ll implement distributed locks using Redis, ZooKeeper, and etcd, three heavy hitters in the game. Each has its flavor, and I’ll drop full Go snippets you can run or tweak. Let’s do this!</p><h5>\n  \n  \n  3.1 Redis: Fast and Furious\n</h5><p> Redis uses  (set if not exists) to grab a lock, with a TTL to avoid deadlocks. It’s like snagging the last slice of pizza—if you’re first, it’s yours, but you’ve got a timer.</p><div><pre><code></code></pre></div><p> The Lua script ensures only the lock owner can release it—avoids someone else swiping your pizza.</p><p> High-speed scenarios like flash sales where consistency can flex a bit.</p><h5>\n  \n  \n  3.2 ZooKeeper: Rock-Solid Consistency\n</h5><p> ZooKeeper uses temporary sequential nodes. You create a node, check if you’re the lowest number, and wait your turn if not—like a polite queue at the DMV.</p><div><pre><code></code></pre></div><p> When you need bulletproof consistency, like financial systems or critical scheduling.</p><h5>\n  \n  \n  3.3 etcd: The Cloud-Native Champ\n</h5><p> etcd uses leases and key competition. You grab a lease, set a key, and hold it ‘til the lease is up—like renting a coworking desk.</p><div><pre><code></code></pre></div><p> Cloud-native apps or anything in the Kubernetes orbit—etcd’s a natural fit.</p><div><table><thead><tr></tr></thead><tbody><tr></tr><tr></tr><tr></tr></tbody></table></div><h4>\n  \n  \n  4. Level Up: Best Practices and Pitfalls to Avoid\n</h4><p>Code’s in the bag, but distributed locks are tricky beasts in the wild. Think of them as a relay baton—drop it, and your system’s toast. With a decade of backend scars, I’ve got some hard-won tips and traps to share. Let’s make your locks bulletproof.</p><p> I once locked an entire e-commerce inventory with one key. Peak traffic hit, contention spiked, and QPS tanked to the hundreds. Oof.</p><p> Lock by specific IDs (like product IDs) to keep things granular and contention low.</p><div><pre><code></code></pre></div><h6>\n  \n  \n  Timeouts and Retries Done Right\n</h6><p> A task scheduler I built had a tiny TTL. One slow job later, the lock expired, another node jumped in, and chaos ensued—duplicate tasks everywhere.</p><p> Use  for timeouts and exponential backoff for retries. Less fighting, more winning.</p><div><pre><code></code></pre></div><p> Locks can bottleneck your app silently. Log acquire/release times and track contention with tools like Prometheus.</p><div><pre><code></code></pre></div><h6>\n  \n  \n  The “Whoops, I Deleted Your Lock” Trap\n</h6><p> Client A’s lock expires, B grabs it, then A wipes it out by mistake. Concurrency goes poof.</p><p> Use unique IDs and a Lua script (see Redis example) to ensure only the owner releases it.</p><h6>\n  \n  \n  ZooKeeper’s Network Hiccups\n</h6><p> In a payment system, network jitter dropped ZooKeeper connections, killing locks and duplicating orders.</p><p> Reconnect and double-check your lock:</p><div><pre><code></code></pre></div><h6>\n  \n  \n  etcd’s High-Concurrency Lag\n</h6><p> Under heavy load, etcd’s lease requests piled up, slowing lock grabs to a crawl.</p><p> Pre-allocate leases and reuse them:</p><div><pre><code></code></pre></div><p> Locks need finesse—keep them tight, resilient, and visible.</p><h4>\n  \n  \n  5. Locks in Action: Real-World Scenarios\n</h4><p>Time to take our locks for a spin! We’ll tackle two classics: an e-commerce flash sale and a distributed task scheduler. Code’s ready, lessons are baked in—let’s roll.</p><h5>\n  \n  \n  5.1 Flash Sale: No Overselling Allowed\n</h5><p> 100 product units, 100,000 users, zero oversells. Redis to the rescue.</p><div><pre><code></code></pre></div><p> Redis locks keep stock checks atomic. Pipeline it for even more speed.</p><h5>\n  \n  \n  5.2 Task Scheduler: One Node, One Job\n</h5><p> Clean logs at midnight on one node only. etcd’s got this.</p><div><pre><code></code></pre></div><p> etcd’s leases ensure one winner, and state sticks around for recovery.</p><ul><li> Cut lock time with async logging— showed ~5k QPS.\n</li><li> Shard tasks by ID for scale.</li></ul><h4>\n  \n  \n  6. Wrapping Up: Key Takeaways and What’s Next\n</h4><p>We’ve made it! From the nuts and bolts of distributed locks to Go-powered implementations and real-world wins, we’ve covered a lot of ground. Think of this as your crash course in taming distributed chaos. Let’s recap, drop some final tips, and peek at what’s ahead for Go in this space.</p><p>Distributed locks boil down to <strong>mutual exclusion, reliability, and speed</strong>, and Go’s a champ at delivering them. Here’s the rundown:  </p><ul><li>: Your go-to for blazing-fast, high-concurrency gigs like flash sales.\n</li><li>: The rock-solid choice for consistency-first jobs like scheduling.\n</li><li>: The balanced, Go-native pick for cloud setups and Kubernetes fans.\n</li></ul><p>We’ve coded them up, dodged pitfalls like lock misdeletion and network jitter, and seen them shine in e-commerce and task scheduling. The secret sauce? Fine-tune granularity, handle timeouts like a pro, and monitor everything.</p><h5>\n  \n  \n  Practical Tips from the Trenches\n</h5><p>After 10 years of backend battles, here’s my cheat sheet for rocking distributed locks:  </p><ol><li>: Kick off with Redis—it’s easy and fast. Scale to ZooKeeper or etcd when you need more.\n</li><li>: Keep lock hold times tiny—shard locks or go async for big wins.\n</li><li>: Network blips happen. Retry smartly and check lock state.\n</li><li>: No metrics, no clue. Log and track contention from day one.\n</li></ol><p>Go’s star is rising in distributed systems, and it’s no fluke. With Kubernetes, Istio, and etcd all in its orbit, Go’s concurrency and simplicity are a perfect match for cloud-native chaos. What’s next? I’d bet on frameworks that bake in service discovery and auto-renewing leases—less boilerplate, more focus on your app. Distributed locks in Go feel like driving a tuned-up sports car: fast, stable, and fun to code.</p><p>So, grab the snippets, tweak them for your projects, and let me know how it goes—I’d love to hear your war stories! Distributed locks don’t have to be a headache, and with Go, they’re downright approachable.</p><p> Locks are tools, not magic. Pick the right one, wield it well, and your system will thank you. Happy coding!</p>","contentLength":8081,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"1 million chess boards and 10,000+ Go binaries","url":"https://golangweekly.com/issues/560","date":1751414400,"author":"","guid":180796,"unread":true,"content":"<a href=\"https://golangweekly.com/link/171236/rss\"><img src=\"https://res.cloudinary.com/cpress/image/upload/c_limit,w_480,h_480,q_auto/copm/9fcfc468.png\" width=\"146\" height=\"110\"></a><p> — AppSignal gives Go developers the tools they need to fix bugs, track performance issues, and ship with confidence. Easy to set up, a joy to use, and built for teams that care about their code.  Start your free trial today, no credit card&nbsp;required.</p>","contentLength":253,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Advanced Golang Concurrency Patterns: Building Million-Events-Per-Second Data Pipelines with Intelligent Resource Management","url":"https://dev.to/aaravjoshi/advanced-golang-concurrency-patterns-building-million-events-per-second-data-pipelines-with-2i02","date":1751394696,"author":"Aarav Joshi","guid":179197,"unread":true,"content":"<blockquote><p>As a best-selling author, I invite you to explore my books on <a href=\"https://www.amazon.com/stores/Aarav-Joshi/author/B0DQYNVXZ7?ref=ap_rdr&amp;isDramIntegrated=true&amp;shoppingPortalEnabled=true&amp;ccs_id=738636bd-0ca1-4d7b-8efa-481bfc222571\" rel=\"noopener noreferrer\">Amazon</a>. Don't forget to follow me on <a href=\"https://medium.com/@aarav-joshi\" rel=\"noopener noreferrer\">Medium</a> and show your support. Thank you! Your support means the world! </p></blockquote><h2>\n  \n  \n  Advanced Concurrency Patterns for High-Throughput Data Pipelines in Golang\n</h2><p>Building high-performance data pipelines requires moving beyond basic worker pools. I've spent years optimizing Go systems processing millions of events per second. The real challenge lies in balancing throughput with priority handling while preventing resource exhaustion. Let me share patterns that transformed our production systems.  </p><p>Concurrency isn't just about goroutines. It's about intelligent resource management. Consider priority handling first. Dedicated channels for critical items prevent queue starvation. In our implementation, high-priority items bypass batching entirely:</p><div><pre><code></code></pre></div><p>This simple separation reduced our P99 latency by 40%. Unexpectedly, it also improved regular throughput by eliminating head-of-line blocking.  </p><p>Backpressure must be explicit. Many systems fail when queues overflow silently. We return submission statuses:</p><div><pre><code></code></pre></div><p>In production, we couple this with exponential backoff and circuit breakers. Clients respect backpressure signals, preventing cascading failures.  </p><p>Batching requires careful tuning. Fixed batch intervals cause latency spikes. Fixed sizes waste resources. Our solution combines both:</p><div><pre><code></code></pre></div><p>This dual-trigger approach maintains consistent latency while adapting to load variations.  </p><p>Work stealing solves imbalance problems. Traditional approaches introduce significant overhead. Our probabilistic stealing minimizes locks:</p><div><pre><code></code></pre></div><p>We lock only during item transfer, not during queue inspection. This reduced steal overhead by 70% in benchmarks.  </p><p>Telemetry is non-negotiable. We track:  </p><ul><li>Per-shard load distribution\n</li><li>Batch processing times (exponential moving average)\n</li></ul><div><pre><code></code></pre></div><p>These metrics feed our auto-scaling systems. Sudden queue depth increases trigger horizontal scaling.  </p><p>I learned hard lessons about resource exhaustion. Our pipeline now includes these safeguards:</p><div><pre><code></code></pre></div><p>We maintain a strict priority queue ratio. When priority items exceed 10% of capacity, clients must throttle. This prevents priority floods from starving regular items.  </p><p>Production enhancements matter. We added:  </p><ul><li>Circuit breakers that skip shards during downstream failures\n</li><li>A dead-letter queue for unprocessable items\n</li><li>Dynamic batch sizing based on queue depth\n</li><li>Prometheus metrics endpoint\n</li></ul><div><pre><code></code></pre></div><p>These adjustments happen during maintenance windows. We avoid runtime mutations that could cause races.  </p><p>Performance characteristics surprised us. On 8-core servers:  </p><ul><li>Sustained throughput: 780K ops/second\n</li><li>Priority latency: &lt;2ms P99\n</li><li>Resource utilization: 70% CPU at peak\n</li><li>Zero drops at 10x load spikes\n</li></ul><p>The key was minimizing synchronization. Our work stealing uses brief, targeted locks. Batch processing avoids shared state. Each shard maintains independent buffers.  </p><p>Shutdown handling is often overlooked. We use context cancellation:</p><div><pre><code></code></pre></div><p>This prevents data loss during deployments. In-flight items complete processing while new submissions stop immediately.  </p><p>Through trial and error, I discovered critical insights. First, backpressure must propagate to clients. Second, metrics should drive scaling decisions. Third, priority systems need strict quotas. Most importantly, simplicity beats cleverness. Each component does one thing well.  </p><h2>\n  \n  \n  These patterns now power our real-time analytics pipeline. They process 14 billion events daily with predictable performance. The system self-regulates during traffic spikes. Failures remain isolated. That reliability transformed how we design data systems.\n</h2><p>📘 , , , and  to the channel!</p><p> is an AI-driven publishing company co-founded by author . By leveraging advanced AI technology, we keep our publishing costs incredibly low—some books are priced as low as —making quality knowledge accessible to everyone.</p><p>Stay tuned for updates and exciting news. When shopping for books, search for  to find more of our titles. Use the provided link to enjoy !</p><p>Be sure to check out our creations:</p>","contentLength":4061,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Golang Context Package: A Guide to One of the Most Used Packages in Go","url":"https://dev.to/pedro-silva-dev/golang-context-package-a-guide-to-one-of-the-most-used-packages-in-go-a3g","date":1751376687,"author":"Pedro Silva","guid":178938,"unread":true,"content":"<p>So, you're writing some Go code and you keep seeing context.Context pop up everywhere, right? Especially if you're building network servers or anything that juggles multiple tasks at once. This package was added way back in Go version 1.7, and it's super important for writing good, solid code. But what does it actually do? And why should you care? Let's dive in and figure it out!</p><p>The \"Why\": The Problem Context Solves\nPicture this: you have a web server that handles requests. For each request, your server might need to make a database query and a call to an external API. Now, think about two scenarios:</p><p>The user cancels the request: The user just closes their browser tab. Your server, not knowing this, carries on with the database query and the API call, wasting CPU, memory, and network resources on a result that no one is ever going to see.</p><p>An operation is too slow: The external API is taking forever to respond. You don't want your server to hang forever, tying up resources. You need a way to set a time limit.</p><p>These scenarios show a classic challenge in concurrent programming: managing an operation's lifecycle. That's exactly the problem the context package was made to solve. It gives us a standard, super-powerful way to handle deadlines, timeouts, cancellation signals, and to carry request-specific data around.</p><p>The Context Lifecycle: A Tree of Operations\nThe most important concept to get about context is that it creates a tree of operations. Each new request or background job kicks off a new tree.</p><p>The Root: Every context tree starts with a root. You'll typically create this using . This base context is never canceled, has no values, and no deadline.</p><p>Child Contexts: When you want to change a context—like adding a timeout or making it cancelable—you create a child context from a parent.\nctx, cancel := (parentCtx, 2*time.Second)</p><p>Propagation: This parent-child relationship is the key to the context's power.</p><p>Cancellation flows downwards: When a parent context is canceled, all of its children and their children's children are immediately canceled, too.</p><p>Values are inherited: A child context inherits all the values from its parent.</p><p>This tree structure lets you create a scope for a specific operation. If the main operation gets canceled (like the user's HTTP request is terminated), all the sub-operations (database queries, API calls) <em>tied to its context automatically get the signal to stop</em>.</p><p>The \"What\": The  Interface\nAt its heart, the package gives us the context.Context interface, which is surprisingly simple:</p><div><pre><code>type Context interface {\n    // Done returns a channel that's closed when work done on behalf of this\n    // context should be canceled.\n    Done() &lt;-chan struct{}\n\n    // Err returns a non-nil error if Done is closed.\n    // It will be context.Canceled or context.DeadlineExceeded.\n    Err() error\n\n    // Deadline returns the time when work done on behalf of this\n    // context should be canceled.\n    Deadline() (deadline time.Time, ok bool)\n\n    // Value returns the value associated with this context for a key,\n    // or nil if no value is associated with the key.\n    Value(key interface{}) interface{}\n}\n\n</code></pre></div><p>You'll rarely implement this interface yourself. Instead, you'll use the functions the context package already gives you to create and manage contexts.</p><p>The \"How\": Creating and Using Contexts\nLet's see how to build and use the context tree in practice.</p><p> and context.TODO(): Like we said, this is your starting point—the root of your context tree. You'll usually use it in main() or at the top level of a request handler.</p><p>: This function also returns an empty context. You should use it when you're not sure which context to use or when a function should be updated to accept a context but isn't yet. It works like a \"to-do\" note for the future.</p><p>: Propagating Cancellation\nThis is the most direct way to make an operation cancelable. It returns a child context and a CancelFunc. It's basically a \"stop\" button!</p><div><pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n)\n\nfunc worker(ctx context.Context, id int) {\n    for {\n        select {\n        case &lt;-ctx.Done():\n            // The context was canceled, so we stop working.\n            fmt.Printf(\"Worker %d: stopping. Reason: %v\\n\", id, ctx.Err())\n            return\n        default:\n            fmt.Printf(\"Worker %d: doing work.\\n\", id)\n            time.Sleep(500 * time.Millisecond)\n        }\n    }\n}\n\nfunc main() {\n    // Create a base context for our operation.\n    // It's good practice to call the cancel function to free up resources,\n    // so we use defer here.\n    ctx, cancel := context.WithCancel(context.Background())\n    defer cancel() \n\n    // Start a few workers, all using the same cancelable context.\n    go worker(ctx, 1)\n    go worker(ctx, 2)\n\n    // Let them run for a couple of seconds.\n    time.Sleep(2 * time.Second)\n\n    // Now, cancel the whole operation.\n    fmt.Println(\"Main: canceling all workers.\")\n    cancel() // This closes the ctx.Done() channel for all workers.\n\n    // Wait a moment to see the workers' shutdown messages.\n    time.Sleep(1 * time.Second)\n    fmt.Println(\"Main: finished.\")\n}\n</code></pre></div><p>When  is called, the  channel of ctx is closed, and both goroutines get the signal to terminate.</p><p>context.WithTimeout &amp; context.WithDeadline: Time-based Cancellation\nThese are specialized and very common versions of WithCancel. It's like putting a stopwatch on your operation.</p><p>WithTimeout: Cancels the context after a certain amount of time.</p><p>WithDeadline: Cancels the context at a specific time.</p><div><pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n)\n\nfunc slowOperation(ctx context.Context) {\n    fmt.Println(\"Starting slow operation...\")\n    select {\n    case &lt;-time.After(5 * time.Second):\n        // This won't be reached if the context times out first.\n        fmt.Println(\"Operation completed successfully.\")\n    case &lt;-ctx.Done():\n        // The context's deadline was exceeded.\n        fmt.Println(\"The operation timed out:\", ctx.Err())\n    }\n}\n\nfunc main() {\n    // Create a context that will be canceled after 3 seconds.\n    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)\n    // It's a good practice to always call cancel, even on a timeout context,\n    // to release resources if the operation finishes early.\n    defer cancel()\n\n    slowOperation(ctx)\n}\n\n</code></pre></div><p>: Passing Request Data\nWithValue lets you attach data to a context. This is great for passing info that's relevant to a whole request chain, like a tracing ID or an authenticated user's identity.</p><p>Heads up: Use WithValue sparingly! Don't use it to pass essential parameters to functions; those should be explicit function arguments. Think of it more like a sticky note you attach to the request, not a suitcase.</p><p>To avoid key conflicts, always define a custom, unexported type for your context keys.</p><div><pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n)\n\n// Use a custom unexported type for the context key.\ntype key string\n\nconst traceIDKey key = \"traceID\"\n\nfunc process(ctx context.Context) {\n    // Retrieve the value.\n    id, ok := ctx.Value(traceIDKey).(string)\n    if ok {\n        fmt.Println(\"Processing with Trace ID:\", id)\n    } else {\n        fmt.Println(\"No Trace ID found.\")\n    }\n}\n\nfunc main() {\n    // Create a context with a value.\n    ctx := context.WithValue(context.Background(), traceIDKey, \"abc-123-xyz\")\n\n    process(ctx)\n}\n\n</code></pre></div><p><strong>Best Practices and Pitfalls</strong>\nAlways pass Context as the first argument to a function: func DoSomething(, ...). It's just good Go etiquette!</p><p>Always call the cancel function returned by WithCancel, WithTimeout, and WithDeadline to clean up resources.  is your best friend.</p><p>Never store a Context inside a struct. Pass it explicitly.</p><p>Never pass a nil Context. If you're not sure, use .</p><p>context.Background() should only be used at the highest level of a program (e.g., in main or at the start of a request handler) as the root of a context tree. Avoid passing it directly to other functions.</p><p>A Context is immutable. Functions like WithCancel or WithValue return a new child context; they don't modify the one you pass in.</p><p>Conclusion\nAnd that's it! The context package isn't so scary after all, is it? It's a tool to keep your concurrent code from becoming a mess. By thinking in terms of these \"context trees,\" you can handle timeouts and cancellations now. The next time you see context.Context in some code, you'll know it's the secret sauce that holds the whole operation together. Follow for more content!</p>","contentLength":8460,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"TicTacToe. Go Duel. AI vs Fate.","url":"https://dev.to/andrey_matveyev/tictactoe-go-duel-ai-vs-fate-5g9a","date":1751365377,"author":"Andrey Matveyev","guid":178846,"unread":true,"content":"<h3>\n  \n  \n  Neural Network vs Random Number Generator\n</h3><blockquote><p>\"Knowledge itself is power\" (с) -Francis Bacon</p></blockquote><p>Creating a network is easy. Training it correctly is not an easy task. The result often does not match expectations. In reality, there is no magic here. The network does exactly what it is told to do. If the result is not what was intended, then the error is either in the training or in the interpretation of the results obtained. The creator's thoughts cannot yet be guessed by the network.</p><p>In our previous article, we delved into the fundamentals of neural networks, building a simple model in Golang and successfully solving the classic XOR problem. Now it's time to move on to a more exciting and complex area — Reinforcement Learning — and apply this knowledge to create an intelligent agent capable of playing Tic-Tac-Toe.</p><p>Unlike the XOR problem, where the network immediately received the \"correct answer\" and could adjust its weights, in games like Tic-Tac-Toe, a key difficulty arises: delayed reward. The agent makes moves, but the outcome of its actions (win, loss, or draw) is only known at the end of the game. This means we cannot immediately point out an \"error\" or \"success\" for each individual move to the network. The agent needs to learn to associate intermediate actions with future outcomes.</p><p>It is precisely to solve such problems that the Deep Q-Learning (DQN) algorithm was developed, which we will discuss in detail in this article. We will describe the game logic, the DQN agent's architecture, and analyze its training process as both the first and second player. The article is written in an accessible, popular style and will not delve deeply into the mathematical foundations, as there are many excellent resources on this topic available online (e.g., <a href=\"https://www.anyscale.com/blog?author=misha-laskin\" rel=\"noopener noreferrer\">mathematics of reinforcement learning (RL)</a> or <a href=\"https://www.youtube.com/playlist?list=PLZjXXN70PH5itkSPe6LTS-yPyl5soOovc\" rel=\"noopener noreferrer\">video about DeepLearning</a>).</p><p>Tic-Tac-Toe is a simple deterministic game for two players on a 3x3 board. Players take turns placing their symbols (X and O) into empty cells. The goal of the game is to be the first to get three of your symbols in a row horizontally, vertically, or diagonally. If all cells are filled and no winner is determined, the game ends in a draw.</p><ul><li><p>: Determined by the arrangement of X and O symbols on the board.</p></li><li><p>: Choosing an empty cell to place your symbol.</p></li><li><p>: A win for one of the players or a draw.</p></li><li><p>: In Tic-Tac-Toe, the first player has a strategic advantage. With optimal play from both players, the game always ends in a draw or a win for the first player. According to my estimates, and confirmed by experiment (when the agent initially plays like a random opponent), the probability of winning for the player who makes the first move to the center is about 60% (600 out of 1000 games), a loss is about 30%, and a draw is 10%.</p></li></ul><p><strong>Board Representation and State Vector</strong></p><p>The game  is represented by a Board struct, and its state is converted into a numerical vector for the neural network using the  method.</p><div><pre><code></code></pre></div><h3>\n  \n  \n  Deep Q-Learning Agent (DQN)\n</h3><p>Our agent is based on the  architecture, which combines Q-learning with deep neural networks. This is evident in how the action for the next state is selected using the main Q-network, and then its Q-value is evaluated using the target network. This helps to reduce the overestimation of Q-values characteristic of classic DQN.</p><p>The board state is converted into a numerical vector that is fed into the neural network. For each of the 9 board cells:</p><ul><li><p>, if the cell is occupied by the agent's symbol.</p></li><li><p>, if the cell is occupied by the opponent's symbol.</p></li><li><p>, if the cell is empty.</p></li></ul><p><strong>Neural Network Architecture</strong></p><p>The agent uses a fully connected neural network.</p><ul><li><p>: 9 neurons (corresponding to the 9 board cells).</p></li><li><p>: One hidden layer with 27 (or 45/72) neurons with a Tanh activation function. The minimum number of neurons in the hidden layer that yielded satisfactory results was 9.</p></li><li><p>: 9 neurons (corresponding to 9 possible actions/cells), also with a Tanh activation function.</p></li></ul><p>The agent learns by interacting with the environment (the Tic-Tac-Toe game) and receiving rewards.</p><p>The  stores the agent's experiences, allowing for efficient training by sampling past interactions.</p><div><pre><code></code></pre></div><p><strong>DQNAgent Structure and Action Selection</strong></p><p>The  struct holds the Q-network, target network, replay buffer, and training parameters. The  method implements the epsilon-greedy strategy.</p><div><pre><code></code></pre></div><p>The  method implements the core Double DQN update rule, using the replay buffer and target network.</p><div><pre><code></code></pre></div><p>Note the Bellman equation:</p><div><pre><code></code></pre></div><p>Using this mechanism, the \"reward\" gradually \"propagates\" from the end of the game to its beginning.</p><p>The  function defines the reward structure for the agent:</p><div><pre><code></code></pre></div><h3>\n  \n  \n  Training Process and Results\n</h3><p>So, we are all set for testing.\nLet's briefly summarize what we have:</p><ul><li>A  with a 9:27:9 architecture that knows nothing.</li><li>A  and implementation of game logic (start, rule adherence, and end detector (win/loss/draw)).</li><li>An  who can make moves into free cells randomly. And that's all.</li><li>An  that, from the start, plays like its opponent but has the ability to learn. It knows when the game ends. And it knows whether it finished the game well or poorly.</li></ul><p>What can we observe and by what criteria can we determine the learning progress?</p><ul><li>Firstly, it's the agent's win percentage (expected to increase).</li><li>Secondly, we can observe the decrease in Epsilon to understand what is happening – whether the agent is exploring (making random moves) or utilizing its accumulated experience.</li><li>Thirdly, we can look at the weight vector on the output layer to understand how the agent decides to make its first move on an empty board (it is expected that the center will have the largest weight, then the corners, and then the sides as the least promising).</li><li>And finally, we can track the maximum number of wins achieved throughout the entire experiment.</li></ul><p>Let's see what came of this and whether our agent will show growth in its competence.</p><p><strong>Training the Agent as the First Player</strong></p><p>In this scenario, the agent (Player X) always makes the first move in the game. To accelerate convergence and ensure the learning of an optimal starting strategy, we can experimented with forcing the first move to the center of the board (default without this).</p><p>These are the settings that can be changed when conducting an experiment.\n'Knobs' that can be 'turned' for fine-tuning.<p>\nThe network implemented here usually forgives even gross errors.</p>\nThe most you risk is falling into a local minimum instead of a global one.<p>\nFeel free to try it yourself.</p></p><div><pre><code></code></pre></div><div><pre><code>PS D:\\go\\go-sample-tictactoe&gt; go run .\nStarting DQN agent training (X) against a random opponent (O) for Tic-Tac-Toe...\nEpisode: 1000, Wins X: 571 (571), Losses X: 307, Draws: 122, Epsilon X: 0.9876, Q(start): 0.4501|0.5164|0.4117  0.5863[0.5449]0.4485  0.3473|0.4411|0.4166\nEpisode: 2000, Wins X: 590 (590), Losses X: 284, Draws: 126, Epsilon X: 0.9715, Q(start): 0.3683|0.4917|0.3963  0.2354[0.6179]0.3571  0.2806|0.3732|0.3737\nEpisode: 3000, Wins X: 585 (590), Losses X: 294, Draws: 121, Epsilon X: 0.9558, Q(start): 0.2797|0.4310|0.3559  0.1067[0.4802]0.2719  0.1742|0.2720|0.2669\nEpisode: 4000, Wins X: 588 (590), Losses X: 285, Draws: 127, Epsilon X: 0.9402, Q(start): 0.2361|0.4065|0.3263  0.1037[0.3945]0.2356  0.1445|0.2771|0.2186\n...\nEpisode: 297000, Wins X: 952 (969), Losses X: 43, Draws: 5, Epsilon X: 0.0156, Q(start): 0.5193|0.3906|0.2095  0.5050[0.3286]0.4332  0.1040|0.3630|0.2807\nEpisode: 298000, Wins X: 957 (969), Losses X: 40, Draws: 3, Epsilon X: 0.0154, Q(start): 0.5189|0.3942|0.1822  0.4883[0.3528]0.4347  0.1214|0.3698|0.2528\nEpisode: 299000, Wins X: 977 (977), Losses X: 20, Draws: 3, Epsilon X: 0.0152, Q(start): 0.5201|0.4159|0.1651  0.4708[0.3775]0.4352  0.1291|0.3870|0.2078\n--- Target network updated at step 1050000 (Epsilon: 0.0151) ---\nEpisode: 300000, Wins X: 968 (977), Losses X: 23, Draws: 9, Epsilon X: 0.0150, Q(start): 0.4733|0.4222|0.1718  0.4519[0.4072]0.4743  0.1526|0.4102|0.1889\n...\nEpisode: 497000, Wins X: 952 (990), Losses X: 43, Draws: 5, Epsilon X: 0.0011, Q(start): 0.3910|-0.3152|-0.2335  -0.2994[0.4932]0.0485  0.0135|-0.4090|-0.2174\n--- Target network updated at step 1700000 (Epsilon: 0.0011) ---\nEpisode: 498000, Wins X: 942 (990), Losses X: 55, Draws: 3, Epsilon X: 0.0011, Q(start): 0.3798|-0.3127|-0.2245  -0.3118[0.4557]0.0439  0.0072|-0.4120|-0.2115\nEpisode: 499000, Wins X: 936 (990), Losses X: 56, Draws: 8, Epsilon X: 0.0011, Q(start): 0.3651|-0.3107|-0.2292  -0.3250[0.3711]0.0254  -0.0033|-0.4216|-0.1881\nEpisode: 500000, Wins X: 954 (990), Losses X: 41, Draws: 5, Epsilon X: 0.0011, Q(start): 0.3561|-0.3119|-0.2014  -0.3267[0.3711]0.0196  -0.0191|-0.4155|-0.1827\n\nTraining complete.\nTesting the agent (X against random O)...\n\nTest Results (1000 games, Agent X vs random O):\nAgent X Wins: 956\nAgent X Losses (Random O Wins): 39\nDraws: 5\n</code></pre></div><p>When the agent was to make the first move to the center, it demonstrated outstanding results, achieving up to 992 wins out of 1000 (in some cases) test games against a random opponent, with a minimal number of losses and draws. This confirms that the agent successfully learned an optimal strategy for the first player.</p><p>\"Win Growth (agent moves first)\" graph:</p><p><strong>Training the Agent as the Second Player</strong></p><p>In this scenario, the opponent (Player O) always makes the first move randomly, and our agent (Player X) always responds second. This puts the agent in a less advantageous position, as the first move in Tic-Tac-Toe provides a strategic advantage. The goal of this experiment is to test how well the agent can adapt to the role of the second player and minimize the opponent's advantage.</p><ul><li><p>The same hyperparameters as for the first scenario were used.</p></li><li><p>The only change is that the opponent always makes the first move.</p></li></ul><div><pre><code></code></pre></div><div><pre><code>PS D:\\go\\go-sample-tictactoe&gt; go run .\nStarting DQN agent training (X) against a random opponent (O) for Tic-Tac-Toe...\nEpisode: 1000, Wins X: 296 (296), Losses X: 587, Draws: 117, Epsilon X: 0.9902, Q(start): 0.2536|0.3091|0.2323  0.3227[0.3963]0.3577  0.4702|0.4281|0.2465\nEpisode: 2000, Wins X: 298 (298), Losses X: 590, Draws: 112, Epsilon X: 0.9766, Q(start): 0.1909|0.3386|0.2124  0.3879[0.3856]0.3629  0.5409|0.4653|0.2537\nEpisode: 3000, Wins X: 295 (298), Losses X: 598, Draws: 107, Epsilon X: 0.9633, Q(start): 0.0990|0.3089|0.1477  0.3343[0.3218]0.2929  0.5055|0.4229|0.2093\nEpisode: 4000, Wins X: 261 (298), Losses X: 601, Draws: 138, Epsilon X: 0.9501, Q(start): 0.0718|0.2712|0.0945  0.3015[0.2998]0.2637  0.4218|0.3067|0.1649\n...\nEpisode: 69000, Wins X: 610 (610), Losses X: 342, Draws: 48, Epsilon X: 0.3986, Q(start): 0.5987|0.5451|0.5798  0.5912[0.6872]0.5793  0.6331|0.5710|0.5508\nEpisode: 70000, Wins X: 610 (610), Losses X: 359, Draws: 31, Epsilon X: 0.3935, Q(start): 0.5962|0.5428|0.5695  0.5917[0.6848]0.5758  0.6282|0.5837|0.5531\nEpisode: 71000, Wins X: 606 (610), Losses X: 365, Draws: 29, Epsilon X: 0.3885, Q(start): 0.5914|0.5330|0.5650  0.5899[0.6844]0.5742  0.6268|0.5863|0.5423\nEpisode: 72000, Wins X: 570 (610), Losses X: 407, Draws: 23, Epsilon X: 0.3835, Q(start): 0.5867|0.5349|0.5650  0.5872[0.6871]0.5795  0.6202|0.5833|0.5385\nEpisode: 73000, Wins X: 564 (610), Losses X: 405, Draws: 31, Epsilon X: 0.3786, Q(start): 0.5912|0.5303|0.5606  0.5833[0.6815]0.5811  0.6198|0.5832|0.5418\nEpisode: 74000, Wins X: 612 (612), Losses X: 353, Draws: 35, Epsilon X: 0.3737, Q(start): 0.5958|0.5287|0.5575  0.5840[0.6816]0.5730  0.6146|0.5765|0.5359\n--- Target network updated at step 250000 (Epsilon: 0.3694) ---\nEpisode: 75000, Wins X: 588 (612), Losses X: 373, Draws: 39, Epsilon X: 0.3689, Q(start): 0.6005|0.5305|0.5658  0.5903[0.6910]0.5730  0.6132|0.5845|0.5456\nEpisode: 76000, Wins X: 650 (650), Losses X: 311, Draws: 39, Epsilon X: 0.3642, Q(start): 0.6314|0.5703|0.5932  0.6218[0.7187]0.6036  0.6409|0.6085|0.5756\n...\nEpisode: 497000, Wins X: 792 (822), Losses X: 185, Draws: 23, Epsilon X: 0.0020, Q(start): 0.5345|0.3504|0.2066  0.2787[0.5258]0.4991  0.1034|0.5461|0.5410\nEpisode: 498000, Wins X: 804 (822), Losses X: 168, Draws: 28, Epsilon X: 0.0020, Q(start): 0.5329|0.3472|0.2169  0.2769[0.5331]0.4969  0.1012|0.5451|0.5428\nEpisode: 499000, Wins X: 782 (822), Losses X: 180, Draws: 38, Epsilon X: 0.0019, Q(start): 0.5315|0.3456|0.2200  0.2724[0.5288]0.4962  0.1074|0.5430|0.5417\nEpisode: 500000, Wins X: 780 (822), Losses X: 188, Draws: 32, Epsilon X: 0.0019, Q(start): 0.5310|0.3443|0.2219  0.2718[0.5285]0.4971  0.1044|0.5442|0.5446\n\nTraining complete.\nTesting the agent (X against random O)...\n\nTest Results (1000 games, Agent X vs random O):\nAgent X Wins: 783\nAgent X Losses (Random O Wins): 191\nDraws: 26\n</code></pre></div><p>In the initial stages of training, the agent, as expected, showed a lower win percentage and a higher number of losses/draws due to the opponent's first-move advantage. However, as training progressed, the agent significantly improved its performance.</p><p><strong>Example game after training:</strong></p><div><pre><code>Example game after training (X vs random O):\n-------------\n|   |   |   |\n-------------\n|   |   |   |\n-------------\n| O |   |   |\n-------------\nX's Turn:\n-------------\n|   |   |   |\n-------------\n|   |   | X |\n-------------\n| O |   |   |\n-------------\nO's Turn:\n-------------\n|   |   |   |\n-------------\n| O |   | X |\n-------------\n| O |   |   |\n-------------\nX's Turn:\n-------------\n|   |   |   |\n-------------\n| O |   | X |\n-------------\n| O |   | X |\n-------------\nO's Turn:\n-------------\n|   |   |   |\n-------------\n| O |   | X |\n-------------\n| O | O | X |\n-------------\nX's Turn:\n-------------\n|   |   | X |\n-------------\n| O |   | X |\n-------------\n| O | O | X |\n-------------\nGame Over! Player X won!\n</code></pre></div><p>\"Win Growth (agent moves second)\" graph:</p><p>These results show that the agent successfully learned to optimally respond to various first moves by the opponent, significantly increasing its win rate despite the strategic disadvantage of moving second. The \"first move selection\" problem for the agent disappeared, as it focused on reactive tactics.</p><p>The project on training a DQN agent for Tic-Tac-Toe successfully demonstrated the effectiveness of deep reinforcement learning algorithms even for simple deterministic games. We saw how the agent can adapt to different roles (first/second player) and achieve near-optimal performance against a random opponent.</p><p>The most guaranteed way to make the agent learn \"human\" optimality (center, corners) is to train it against a stronger, strategic opponent (e.g., Minimax AI) or in self-play mode. These opponents will punish any suboptimal move, forcing the agent towards true optimality.</p><p>Write in the comments if you are interested, and I will arrange a battle (a real fight) between two agents. For now, my immediate plans include a final \"move\" to Linux and writing a small backend (e.g., a REST API) for a simple client to try playing with what has been developed.</p>","contentLength":14687,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Revisiting My Old Neural Network Project in Go","url":"https://dev.to/harun_alrasyid_d6c9f599c/revisiting-my-old-neural-network-project-in-go-37ep","date":1751357835,"author":"Harun Al Rasyid","guid":178770,"unread":true,"content":"<p>It was messy, naïve, and mostly forgotten in my GitHub. The goal was to better understand the internals of forward and backpropagation by implementing everything manually, without relying on external ML libraries. The code worked, but it was very basic and lacked in performance.</p><p>Now, I’m revisiting this project to refactor the code and improve the overall design. Here’s a summary of what I’ve improved:</p><p>The codebase already had a good separation of concerns: activation functions, loss, optimizers, and network logic were neatly organized into their own modules. This made it relatively easy to extend the library with new features.</p><h2>\n  \n  \n  The Improvement : Parallel Training\n</h2><p>To improve training efficiency, I implemented . </p><ul><li>Training data is split into multiple batches, each processed in a separate goroutine using .</li><li>I used  to safely collect training errors and weight deltas from all batches.</li><li>After all batches are processed, the deltas are merged using a custom  function and applied once at the end of the epoch.</li></ul><p>. Initial versions caused data races when multiple goroutines accessed or modified shared weight structures.: Delay all updates until after parallel computation finishes.</p><p><strong>Locking Can Kill Parallelism</strong>. Putting locks around weight updates inside each batch makes the process sequential. It removes the benefit of parallelism.: Do all mutation  goroutines have joined.</p><p><strong>Unstable Training Without Averaging</strong>. Summing raw deltas led to unstable error gradient.: Add delta average in  to stabilize learning.</p><ul><li>Training speed increased (especially for datasets like Iris).</li></ul>","contentLength":1581,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Make C++ a better place #4: Go as an alternative","url":"https://dev.to/pikotutorial/make-c-a-better-place-4-go-as-an-alternative-57ip","date":1751356680,"author":"pikoTutorial","guid":178745,"unread":true,"content":"<p>The Go programming language brings simplicity and a clear design philosophy that make it attractive for developers who are tired of the complexity of C++. In this article, we will explore the most interesting features of the Go language that distinguish it from C++.</p><h2>\n  \n  \n  Producer/consumer implementation with Go\n</h2><p>If you didn't see <a href=\"https://pikotutorial.com/make-c-a-better-place-0-introduction/\" rel=\"noopener noreferrer\">the first article of this series</a>, please read it because I explained there what are the things I want to check about each C++ alternative and how I'm going to do that.</p><p>Below you case see the implementation of the <a href=\"https://github.com/pasparsw/make_cpp_a_better_place/blob/main/languages_comparison/cpp/producer_consumer.cpp\" rel=\"noopener noreferrer\">reference producer/consumer application</a> written in Go. I really wanted this implementation to be based on channels (more on them at the end of the article) because it's a very interesting feature of Go, but because channels are by design meant to be used for one-to-one communication, they are not suitable for this use case.</p><div><pre><code></code></pre></div><p>So accordingly to the list of checks that I'm interested in, Go gives us the following statistics:</p><ul><li> - this code is 106 lines long (124 lines for C++)</li><li> - it takes 91ms to build this application (2149ms for C++) with command:\n</li></ul><div><pre><code>/usr/local/go/bin/go build  producer_consumer.go\n</code></pre></div><ul><li> - it takes 2172ms to run it (597ms for C++)</li><li> - 1.4MB (105kB for C++)</li></ul><h3>\n  \n  \n  What I like about this code?\n</h3><p>In Go you don't need to specify size of the fixed-size array if you provide its elements during initialization. This is a very nice feature because whenever you want to change the content of the array, you just add or remove an element from the initialization list, without having to additionally change the size of the array.</p><p>I love the fact that Go doesn't force me to create a thread, specify its worker, start it, wait for every thread to join separately etc. - if you have a function that you want to run asynchronously, you just call  and that's it.</p><p>Go fails to build the program if a certain variable is not used. It's not a warning or a suggestion - you just won't get any executable binary out of such source code.</p><p>Go allows to provide all the imports in form of a list, so I didn't need to repeat \"import...\" for every required element.</p><h3>\n  \n  \n  What I don't like about this code?\n</h3><h4>\n  \n  \n  Consts not applicable to all types\n</h4><p>I was not able to create e.g. a constant array because Go doesn't allow for that.</p><p>It's not visible directly in the example, but Go's encapsulation relies on the naming convention - if something starts with a upper-case letter, it's public (available outside of the package) and if something starts with a lower-case letter, it's private (not visible form outside of the package). Although it solves the problem of having special keywords like ,  etc., I think it can sometimes be a pain in the ass because I imagine a situation in which I want to just change the visibility of the function to private and suddenly I need to change the name of the function in all places where it has been already used within the package.</p><p>In the Producer/Consumer example code I use a variadic template to provide the constructor's arguments to  function depending on what worker type I am currently creating (Producer vs Consumer). Unfortunately, Go doesn't have that. I thought that I'll workaround that just by making some arguments having default values, so that I can provide only the ones which are relevant during creation of a specific worker. To my surprise, it turned out that Go doesn't allow function's argument to have a default value.</p><p>Moreover, there's not even a built-in enum type which forces user to define enums in a pretty weird way, not fitting into the general simplicity of the Go language.</p><h2>\n  \n  \n  Using Go to write C++ code for the existing code bases\n</h2><p>Go compiles directly to the machine code, so there's no out-of-the-box way to generate C++ code out of it.</p><h2>\n  \n  \n  Using existing C++ code in Go\n</h2><p>Go does not allow to use C++ code within Go programs. There is Cgo, but it requires to wrap all the C++ functions in a C interface, so effectively it does not allow for usage of all C++ features. For example, our <a href=\"https://github.com/pasparsw/make_cpp_a_better_place/blob/main/languages_comparison/cpp/lib_user.cpp\" rel=\"noopener noreferrer\">our reference C++ library user</a> uses templates which are not supported in C. So for me, the final conclusion is that I just can't use the existing C++ code writing programs in Go.</p><h2>\n  \n  \n  Other interesting Go features\n</h2><h3>\n  \n  \n  Concurrency - Go's main achievement\n</h3><p>Every programming language has something what its developers put at the center of its philosophy. For Go, concurrency may be considered as such thing. It has a very interesting approach to concurrency and thread-safety summarized by the sentence:</p><blockquote><p>Do not communicate by sharing memory; instead, share memory by communicating. </p></blockquote><p>Go implements it by usage of channels which are Go's attempt to assure thread-safety by design and not by usage of synchronization primitives like mutexes. Channels may be considered shared resources (a channel may be as simple as a single integer value) which can be accessed only by one goroutine at a time. If you're a C++ programmer, you can see the channel as a combination of ,  and . Below you can find the code showing channels in action (notice also how simple it is to spin up a new thread-like execution flow just by adding  before the function call):</p><div><pre><code></code></pre></div><p>Channels have their own -like statement which is called  in Go. It allows to react upon incoming data from multiple channels:</p><div><pre><code></code></pre></div><p>I wondered if this point shouldn’t actually be at the top of the list because the situation with implicit conversions in C++ is so bad and so confusing for the beginners that I recently started to consider it as one of the most important features of the programming language. It's mainly because C++ claims to be a strongly typed language, which lets your guard down, but in reality you come across multiple situations in which the language behaves as if it doesn't care about the types. Here is an (abstract, but vivid example - I don't want to repeat boring examples with assigning  to a ) example of what I mean - this is a valid and working code in C++:</p><div><pre><code></code></pre></div><p>Someone will say <em>\"hey, just add an  before the constructor and the compilation will fail\"</em> and it's true, but then I can ask what if something like this slips through the review:</p><div><pre><code></code></pre></div><p>It compiles again. Now I hear voice saying (because I already heard such argument) that <em>\"it is not a bug because you see  type name explicitly written on the left of the  which is being initialized with , so it is basically a language feature and no implicit conversion here\"</em>. Ok, let's then add a simple function to this code and tell me where do you see the  type name during the function call:</p><div><pre><code></code></pre></div><p>The answer is: you don't. And remember that  class from the example can be arbitrarily complex type or can start some resource management directly in the constructor, so maybe you've just constructed a heavy communication proxy or a database connection broker directly out of an integer literal.</p><p>My point is that there's just so many ways in C++ to trigger an implicit conversion that you must never forget about it. In Go the situation is simple - if you have any custom type definition, even a type which is basically an alias, like below:</p><p>you must convert everything explicitly to that type.</p><h3>\n  \n  \n  Uniform formatting with Gofmt\n</h3><p>One of Go's standout features is its commitment to uniformity of code formatting. The language comes with a built-in formatter  that imposes a consistent style across all Go codebases. Unlike C++, where formatting styles can vary greatly from one team to another, Go enforces a common standard. This means that Go developers spend less time debating style guidelines and more time focusing on solving real problems.</p><p>However, Go's formatting solution isn't perfect. For instance, it doesn't care much about line length or whitespaces, which means that two developers using  may still produce different source code.</p><p>Go has only one way to write scope curly brackets after ,  etc. The opening curly bracket must be placed in the same line because otherwise the Go lexer may insert a semicolon after the statement changing its meaning, for example:</p><p>In fact, the latter version won't even compile because the compiler will complain about an unexpected newline.</p><p>One of Go’s interesting features is named return values, which allow you to name return variables directly in the function signature:</p><div><pre><code></code></pre></div><p>By doing so, you can use  directly inside the function without explicitly declaring it again. This reduces boilerplate code and helps the code to be self-documented. The downside is that these named return values are zero-initalized to their default values, so it also allows to return value which was not modified during the function flow (so was not explicitly initialized to any particular value).</p><p>However, I admit that this may be a concern brought from other programming languages, a concern that is not applicable to Go. Go actually encourages to design types accordingly to  rule meaning that the memory initialized with zeros translates to some valid state of the object (for example, a zeroed mutex translates to an unlocked mutex). That brings us to the next interesting concept in Go.</p><h3>\n  \n  \n  Memory allocation:  vs. </h3><p>In Go, there are two ways to allocate memory:  and . These functions differ significantly from their similarly-sounding counterparts in C++ (, , ).</p><p>The  function allocates memory for an object, but does not initialize it. I must admit that at the beginning for me, as a person used to C++, it was pretty confusing because in C++ you can't write the following code if  doesn't have a default constructor :</p><p>The behavior of Go's  behaves more like such code:</p><div><pre><code></code></pre></div><ul><li>allocate memory for the object</li><li>get a pointer to such an allocated and initialized object</li></ul><p>you use composite literals (Go's constructors) like on the code snippet bellow:</p><div><pre><code></code></pre></div><p>The  function is a totally different story, starting with the fact that it doesn't even return a pointer. If you come from outside of C++ world, you could ask , but if you're a C++ insider you see that the connection is obvious. Its usage is also limited to slices, maps and channels. All these types happen to carry a reference to a data structure that must be initialized before use what  is responsible for.</p><h3>\n  \n  \n  Resource management with defer\n</h3><p>Go gives the ability to defer a statement until the end of functions scope (similar as <a href=\"https://pikotutorial.com/make-c-a-better-place-3-d-as-an-alternative\" rel=\"noopener noreferrer\">the scope guard statements in D</a>). The deferred statements are deferred in form of a stack, so their execution order is reversed. It's helpful and definitely better then writing the same functions at the end of the scope, but as I mentioned in the article about D, I'm not a big fan of defer-like mechanisms because although it helps to not forget about releasing certain resource (e.g. after adding a new path to the function), it still must be manually typed in by the programmer who is responsible for remembering it, so we can be sure that sooner or later someone will forget about it anyway.</p><p>Go differentiates between two types of errors: recoverable and unrecoverable. Recoverable error handling relies on multivalue returns because a function may return 2 values - the actual returned value and the associated error which can be checked by the caller before using the value. </p><p>In contrast, unrecoverable errors, such as accessing out-of-bounds slices, trigger a , which immediately stops normal execution and begins stack unwinding. However, Go provides the  function (in my opinion, not the best name choice for the \"unrecoverable\" type of error handling) to regain control during the unwinding process. Because the only code that is able to run during stack unwinding is inside the deferred functions,  must be used inside of a deferred function as well.</p><div><pre><code></code></pre></div><p>If the section  panics, the control flow will be regained by the  and error will be printed.</p>","contentLength":11650,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"🕵️‍♂️ Stop guessing why your Go service is slow.","url":"https://dev.to/aleksei_aleinikov/stop-guessing-why-your-go-service-is-slow-514h","date":1751354852,"author":"Aleksei Aleinikov","guid":178744,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"⚡ Upgrade Your Go APIs to HTTP/2 in 2025 — Why You’re (Probably) Late","url":"https://dev.to/aleksei_aleinikov/upgrade-your-go-apis-to-http2-in-2025-why-youre-probably-late-5dgc","date":1751354514,"author":"Aleksei Aleinikov","guid":178743,"unread":true,"content":"<p>Browsers switched years ago. Your CDN speaks h2. But… your Go backend? Still whispering HTTP/1.1 like it’s 2010.</p><p>What you’re missing out on:\n✅ Multiplexed requests — no more Head-of-Line blocking<p>\n✅ Fewer connections — lower TLS handshake and socket overhead</p>\n✅ Automatic header compression — smaller packets, faster responses<p>\n✅ Happier users and lower cloud bills</p></p><p>🧑‍💻 The upgrade? Usually just one line plus TLS.\n🚀 The gain? Snappier APIs, smoother streams, leaner infra.</p><p>👉 Check out a minimal working Go example (and see why a single </p>","contentLength":565,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"⏰🐹 Parallel Tasks in Go 2025: Tame Your Timeouts & Tickers Like a Pro","url":"https://dev.to/aleksei_aleinikov/parallel-tasks-in-go-2025-tame-your-timeouts-tickers-like-a-pro-17i2","date":1751354182,"author":"Aleksei Aleinikov","guid":178742,"unread":true,"content":"<p>Spawning 1,000 goroutines is easy. Managing them without chaos?</p><p>That’s mastery.\n✅ Semaphore channels cap concurrency cleanly<p>\n✅ Back-pressure lets you fail fast (no more silent queue pileups)</p>\n✅ time.After() for one-liner timeouts — no stuck clients<p>\n✅ time.NewTicker() keeps heartbeats flowing safely</p>\n✅ Reuse timers to save GC and stay lean under load</p><ul><li>Protect APIs from flooding in milliseconds</li><li>Stop ghost pings with smart cancels</li><li>Run watchdogs without memory leaks</li></ul>","contentLength":473,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"⚡🐹 Optimizing Go in 2025: Slices, Strings & sync.Pool Mastery","url":"https://dev.to/aleksei_aleinikov/optimizing-go-in-2025-slices-strings-syncpool-mastery-3plj","date":1751354129,"author":"Aleksei Aleinikov","guid":178741,"unread":true,"content":"<p>Slices and strings in Go look simple — until they eat your RAM and GC pauses.</p><p>✅ Pre-allocate with make([]T, 0, N) to skip hidden copies\n✅ Use strings.Builder for clean, fast string joins<p>\n✅ sync.Pool = free GC breaks during traffic spikes</p>\n✅ Reuse buffers, reset with care, avoid race bugs</p><ul><li>Filter slices in place: filtered := events[:0] — no new allocs</li><li>One static HTML builder instead of 20 tiny buffers</li><li>Reuse JSON encoders to slash latency under load</li></ul><p>Takeaway:\nKnow how slices grow, pick the right string concat method, and treat pools like sharp knives — powerful but dangerous.</p>","contentLength":587,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"2N3904 Transistor: Hogwarts’ Unyielding Wand for Circuits & Cosmic Spells","url":"https://dev.to/ersajay/2n3904-transistor-hogwarts-unyielding-wand-for-circuits-cosmic-spells-12ck","date":1751353469,"author":"ersajay","guid":178740,"unread":true,"content":"<p>The Leaky Cauldron’s Hidden Tool\nOn a drizzly afternoon in Diagon Alley, I ducked into Quality Wands &amp; Oddments—a shop that sold more than just wands. Behind the display of Felix Felicis and Pensieves, the owner, Mr. Fizzlewick, held up a small, cylindrical device, no bigger than a Bertie Bott’s Every Flavor Bean.<p>\n“That’s a 2N3904 transistor,” he said, grinning. “Not flashy like a Lumos charm, but it’s the Ollivander’s wand of electronics—trusted by hobbyists, engineers, even NASA. Powers everything from LED strips to Mars rovers. Unyielding. Ubiquitous. Wizarding.”</p>\nIntrigued, I leaned in. This wasn’t just metal and silicon—it was a 2N3904, the unsung hero of circuits. Let’s unmask its magic.</p><ul><li>What Is a 2N3904? (A Workhorse, Not a Show Pony)\nThe 2N3904 is Hogwarts’ “NPN bipolar junction transistor” 🔧—a TO-92 package (think: a tiny, cylindrical wand core) built for general-purpose amplification and switching. Here’s its spellbook (specs):</li></ul><p>Voltage: 40V collector-emitter (VCEO)—unfazed by voltage storms (unlike Tarantallegra—messy, and unwanted).\nCurrent: 200mA collector current (IC)—sips power like a Butterbeer sip, not a Firewhiskey chug.<p>\nSpeed: 300MHz transition frequency (fT)—faster than a Knight Bus in reverse.</p></p><p>Real-World Magic: Survives garage lab mishaps and Martian simulations. It’s the Disillusionment Charm of transistors: invisible, but essential.</p><ul><li>2N3904 Pinout: The Three Spells of a Wand\nThe TO-92 package has three pins—think of them as the “spells” that make it work:</li></ul><p>Emitter (E): The exit for electrons—where magic leaves the wand.\nBase (B): The control gate—a flick of your wrist (or a small current) to start the flow.<p>\nCollector (C): The entry for electrons—where magic begins.</p></p><p>Pro Tip: Face the flat side, and pins are E-B-C left to right. Mix them up, and your circuit becomes a Pyrotechnics spell gone wrong (smoke, sparks, and a “Oops”).</p><ul><li>The Datasheet: The 2N3904’s Magic Manual\nEvery wizard needs a Advanced Potion-Making book—for <a href=\"https://www.ersaelectronics.com/blog/what-is-a-2n3904-and-2n3904-transistor-applications-guide\" rel=\"noopener noreferrer\">2N3904</a>, it’s the datasheet (grabbed from ON Semiconductor or STMicroelectronics). Key takeaways:</li></ul><p>Absolute Max Ratings: 40V, 200mA—exceed these, and it’s Finite Incantatem (game over).\nDC Current Gain (hFE): 100-300—amplifies signals like Sonorus for electrons.<p>\nThermal Limits: 200°C/W—don’t let it cozy up to power resistors (they’re Furnunculus-hot).</p></p><p>Fun Fact: The “Typical Applications” section is a Marauder’s Map for hobbyists—plots paths from LED strips to insulin pumps.</p><ul><li>Why Wizards (Engineers) Swear by 2N3904\n2N3904 isn’t a Elder Wand—it’s the Hedwig of transistors: reliable, affordable, and everywhere.</li></ul><p>Cost: $0.02/unit—cheaper than a Pumpkin Pastie (and way more useful).\nAvailability: Sold at Digi-Key, Amazon, even your local electronics shop—like Fizzing Whizbees in a candy store.<p>\nVersatility: Powers LED strips (keeping your dorm lit), insulin pumps (saving lives), and Tesla key fobs (stopping parking-lot tantrums).</p></p><p>NASA Rovers: Survives -55°C Mars simulations (Duracell? Expelliarmus).\nYour Garage Lab: Handles your DIY “I’ll fix it!” projects (even when you fry it).</p><ul><li>Swapping Spells: Can You Replace It?\nNot all <a href=\"https://www.ersaelectronics.com/search/transistors\" rel=\"noopener noreferrer\">transistors</a> are Unforgivable Curses—some are just different. Here’s who plays well with 2N3904:</li></ul><p>2N2222/2N2222A: Upgraded wands. Higher current (600mA) or voltage (75V)—great for muscle.\nBC547: Weaker cousin. Lower current (100mA)—like a Wingardium Leviosa that fizzles.<p>\n2N3906: PNP polarity—reverse magic. Like a wand that casts Muffliato when you want Lumos.</p>\n2N7000 (MOSFET): Different magic type. Not a BJT—like using a broom for Apparition.</p><p>Golden Rule: Match polarity (NPN/PNP) first—like matching wand cores. Then check specs.</p><ul><li>Wielding 2N3904 Like a Pro (No Burned Fingers)\nWant to cast 2N3904 spells without chaos? Follow these steps:\nStep 1: Calculate the Base Resistor (RB)\nFormula: RB = (VCC - VBE) / IB\nThink of it as measuring Polyjuice Potion—precision matters.\nStep 2: Solder Carefully\nNo third-degree burns allowed. Use a steady hand, like repairing a Time-Turner.\nStep 3: Test (and Pray)\nIf smoke appears, blame the datasheet (or your shaky soldering).\nPro Tip: For SMD designs, use MMBT3904—its pocket-sized twin (perfect for tiny spells).</li></ul><ul><li>Where to Buy (Avoid Knockturn Alley Fakes)\nIn 2025, shop like a Gryffindor—no dodgy Knockturn Alley fakes:</li></ul><p>Trusted Sources: Digi-Key, Ersaelectronics—reliable as Madam Pomfrey.\nRed Flags: eBay listings with stock photos and “100% Genuine!!” claims—they’re Gilderoy Lockhart in disguise.</p><p>Price Range: $0.02/unit retail; cheaper in bulk (AliExpress, but verify suppliers!).</p><ul><li>The Future: 2N3904 in 2030 &amp; Beyond\nWhat’s next for our tiny wand?</li></ul><p>AI Gadgets: Powers AR glasses that don’t melt your face (no Incendio mid-meeting).\nSmart Home Tech: Keeps your coffee maker from burning breakfast (no Fiendfyre at 7 AM).<p>\nMic Drop: Hoard these now. Future retro gamers will trade Golden Snitches for your stash.</p></p><p>Conclusion: The Unseen Guardian of Magic\n2N3904 isn’t flashy. It doesn’t cast Expecto Patronum or brew Polyjuice Potion. But it’s the reason your LED strips glow, your insulin pump works, and Mars rovers send back photos.<p>\nNext time you hold one, whisper, “Thanks, little wand.” It’s the least you can do for a transistor that keeps the magic of modern life alive.</p></p><p>Written by a witch who once fried a 2N3904 trying to power a toy broom. (Spoiler: It worked. Eventually.)\n🔧 Some magic isn’t in wands—it’s in the tools that keep the world turning.</p>","contentLength":5546,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Your Servers Deserve Better: Meet Minexus, a Smart Admin Agent System in Go","url":"https://dev.to/arhuman/your-server-deserves-better-meet-minexus-a-smart-admin-agent-system-in-go-41gn","date":1751330910,"author":"arhuman","guid":177036,"unread":true,"content":"<h2>\n  \n  \n  Meet Minexus — A Modular, Distributed Admin System in Go\n</h2><p>I was tired of managing my servers with brittle scripts, ad hoc SSH sessions, and clunky monitoring tools. So I built <a href=\"https://github.com/arhuman/minexus\" rel=\"noopener noreferrer\">Minexus</a>, a modular platform to monitor and control servers via secure agents, with Go and gRPC under the hood.</p><ul><li>To send a command to 50 machines and get results back fast</li><li>To build your own admin plugins with Go</li><li>To manage your servers like a well-oiled, distributed system</li></ul><p>Then this might be up your alley.</p><p><a href=\"https://github.com/arhuman/minexus\" rel=\"noopener noreferrer\">Minexus</a> is made of 3 main components:</p><p> — the central server, connected to a PostgreSQL DB</p><p> — lightweight agents running on your hosts, communicating with the Nexus via gRPC + mTLS</p><p> — an admin UI and command interface, also talking to the Nexus</p><p>Minions register periodically. Commands go through the Nexus, and results are logged/stored. Want a new command? Just write a command.</p><p>It’s simple, extensible, and built for sysadmins/devops/devs who want control without vendor lock-in.</p><ul><li>Remote command execution (with return capture)</li><li>Service restarts across hosts</li><li>Health checks / monitoring plugins</li><li>Security scans (CVE lookup, etc.)</li></ul><p>Anything you can plug into a Go module...</p><p>Want to send restart-service nginx to all your production servers and get clean results in seconds? Minexus can do that.</p><p>It's early days, but it’s usable and growing. Contributors welcome — the command system (soon a plugin system) makes it a playground for Go devs.</p><p>You're not a coder, it's not a problem: I’d love 🙏 </p><ul><li>Feedback on the architecture</li><li>Suggestions for useful commands/plugins</li><li>Help testing on non-Linux environments</li><li>Ideas to make this your go-to internal admin framework</li></ul><h2>\n  \n  \n  Let’s Build This Together\n</h2><p>I believe sysadmin/devops tooling should be:</p><ul></ul><p>If you agree, give Minexus a spin, drop a comment, or open an issue.</p>","contentLength":1785,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Go for JavaScripters: Why You Should Learn Golang","url":"https://dev.to/brailyguzman/go-for-javascripters-why-you-should-learn-golang-1poo","date":1751322462,"author":"Braily Guzman","guid":176958,"unread":true,"content":"<ul><li>\nGo for JavaScripters: Why You Should Learn Golang\n\n<ul><li>Go vs JavaScript: Quick Comparison</li><li>\nData Types\n\n<ul></ul></li><li>Structs, Types, Methods, and Interfaces</li><li>\n\nStrings, Bytes, and Runes\n\n<ul><li>Strings (Immutable UTF-8)</li><li>Runes (Unicode Code Points)</li><li>Quick Comparison: JavaScript vs Go</li></ul></li><li>\n\nFunctions and Control Flow\n\n<ul><li>Returning Multiple Values</li></ul></li><li>Working with the strings Package</li><li>Concurrency in Go: Goroutines, Channels, WaitGroups, and Mutexes</li><li>Concurrency vs Parallelism</li><li>Common Gotchas for JS Devs</li><li>Mini Project: Word Counter CLI</li><li>Go Modules &amp; Project Structure</li><li>Simple HTTP Server Example</li><li>JavaScript to Go: Quick Reference Cheat Sheet</li></ul></li></ul><p>Are you a JavaScript developer looking to expand your backend skills, or just curious about a language that powers Docker, Kubernetes, and much of the modern cloud? Meet  (aka Golang): a language created at Google by Ken Thompson, Rob Pike, and Robert Griesemer to make software development fast, fun, and scalable.</p><p>Go is designed for simplicity, speed, and reliability. It compiles to a single binary, has a powerful standard library, and makes concurrency (doing many things at once) a breeze. If you love JavaScript's flexibility but crave more performance and predictability, Go is a perfect next step.</p><ul><li>How Go compares to JavaScript in syntax and philosophy</li><li>Go's type system, variables, and data structures</li><li>How to handle strings, bytes, and runes (Unicode!)</li><li>Using Go's  package for text manipulation</li><li>Go's powerful concurrency model (goroutines, channels, and more)</li><li>Common pitfalls for JS devs switching to Go</li><li>How to build and run Go code</li></ul><p>If you're a JavaScript developer looking to level up with a fast, modern language built for performance and scalability, it's time to meet Go.</p><p> is a middle-level programming language created at Google in 2007 by engineers who were tired of waiting around for their code to compile and dealing with overly complex systems. The result? A language that combines the performance of C (low-level) with the simplicity and readability of Python (high-level).</p><h2>\n  \n  \n  Go vs JavaScript: Quick Comparison\n</h2><div><table><tbody><tr></tr><tr></tr><tr></tr><tr></tr><tr><td>APIs, infra, CLI, servers</td></tr></tbody></table></div><p>Go shines when it comes to building fast, scalable backend systems. It's a top choice for writing APIs, web servers, CLI tools, and infrastructure-level software. Tools like , , and  are all written in Go, which says a lot about its speed and reliability.</p><p>One of Go's biggest superpowers is , the ability to run multiple tasks at the same time. In JavaScript, we use  and the event loop to handle asynchronous operations. In Go, we use goroutines, lightweight threads that are easy to spawn and manage.</p><p>Go also makes deployment a breeze. While Node.js apps often require npm install, package.json, and a dozen dependencies, Go compiles everything into a single binary file you can just drop on a server and run.</p><blockquote><ul><li>Front-end/browser-based development</li><li>Rapid prototyping with lots of UI</li><li>Projects needing generics-heavy data structures (though Go 1.18+ now supports generics, it's not as flexible as TypeScript)</li></ul></blockquote><p><strong>Go might not be ideal for:</strong></p><ul><li>Projects that require a lot of dynamic typing or runtime type changes (Go is statically typed and not as flexible as JavaScript or Python for dynamic data structures).</li><li>Codebases that rely heavily on advanced generics or metaprogramming (Go's generics are intentionally simple and less expressive than those in TypeScript, Rust, or C++).</li><li>Rapid prototyping where developer speed and a huge ecosystem of libraries (like npm for JS or PyPI for Python) are critical. Go's ecosystem is strong but not as broad for every domain.</li><li>Projects where you need mature, specialized libraries for things like data science, machine learning, or scientific computing (Go's ecosystem is growing, but not as deep as Python's in these areas).</li><li>Teams that require hot-reloading, scripting, or embedding code at runtime (Go is compiled and not designed for scripting or live code changes).</li></ul><div><pre><code></code></pre></div><div><pre><code></code></pre></div><div><pre><code></code></pre></div><div><pre><code></code></pre></div><p>Go is statically typed, so once a variable has a type, it can't be reassigned to something else, no switching  from a number to a string like in JS.</p><p>Unlike JavaScript, which uses a single  type for all integers, Go provides several distinct integer types. Each type has its own range and memory usage, allowing you to choose the most appropriate one for your needs.</p><div><table><thead><tr></tr></thead><tbody><tr></tr><tr><td>-2.1 billion to 2.1 billion</td></tr><tr></tr><tr><td>-9 quintillion to 9 quintillion</td></tr><tr></tr><tr><td>platform dependent (usually 32 or 64 bits)</td></tr><tr><td>platform dependent (unsigned version of int)</td></tr></tbody></table></div><p>For example, if you need to store an RGB (Red, Green, Blue) value ranging from 0 to 255, the best choice is  (an unsigned 8-bit integer), since it efficiently covers exactly that range. If you need to store larger values, simply choose an integer type with a bigger bit size, such as , , or , depending on your requirements.</p><ul><li> will default to 32 or 64 bits depending on your system.</li><li> types don't allow negative numbers but give you more room for positive values.</li><li>Go will catch integer overflows at compile time, not at runtime.\n</li></ul><div><pre><code></code></pre></div><p>This compiles but causes weird behavior:</p><div><pre><code></code></pre></div><div><table><tbody><tr><td>7 digits (single precision)</td></tr><tr><td>15 digits (double precision — default)</td></tr></tbody></table></div><div><pre><code></code></pre></div><p>Warning: Precision loss can happen with  when dealing with very large or very small decimal values.</p><p>In Go, arrays have  and contain elements of a single type.</p><div><pre><code></code></pre></div><p>You can also let Go infer the length:</p><div><pre><code></code></pre></div><ul><li>Arrays are . Assigning or passing them copies the whole array.</li><li>Their size is part of their type ( != )</li></ul><p>Slices are more flexible and commonly used than arrays.</p><div><pre><code></code></pre></div><p>You can create a slice from an array:</p><div><pre><code></code></pre></div><p>You can also use  to create a slice with a given length and capacity:</p><div><pre><code></code></pre></div><p>Slices are , so modifying one will affect the original array:</p><div><pre><code></code></pre></div><div><pre><code></code></pre></div><h3>\n  \n  \n  Structs, Types, Methods, and Interfaces\n</h3><p>Go uses structs to group related data together, similar to objects in JavaScript. You can also define methods on types (including structs) to add behavior.</p><div><pre><code></code></pre></div><div><pre><code></code></pre></div><p>Interfaces in Go define a set of method signatures (behavior) that a type must implement. Any type that provides those methods \"satisfies\" the interface, even if it doesn't explicitly declare that it does. This allows you to write flexible and decoupled code, because functions can accept interfaces rather than concrete types. Interfaces are a key part of Go's approach to polymorphism and code reuse.</p><p>Duck typing is a concept where the type or class of an object is determined by its behavior (methods and properties), not by explicit inheritance or declaration. The phrase comes from \"If it walks like a duck and quacks like a duck, it's a duck.\" In Go, any type that implements the methods required by an interface is considered to satisfy that interface, even if it doesn't explicitly declare it. This is similar to how JavaScript objects can be passed to functions as long as they have the expected methods or properties.</p><p><strong>Interfaces Example (Multiple Types):</strong></p><div><pre><code></code></pre></div><p>\nJavaScript doesn't have interfaces, but you can use objects with the same method signatures (duck typing):</p><div><pre><code></code></pre></div><h3>\n  \n  \n  Strings, Bytes, and Runes\n</h3><p>In , strings are sequences of UTF-16 code units. This usually feels like characters but isn't always, especially with emojis or characters from other languages.</p><p>In , strings are <strong>UTF-8 encoded immutable slices of bytes</strong>. That means:</p><ul><li>A string is a sequence of bytes.</li><li>Characters can take up multiple bytes.</li><li>Indexing directly gives you a , not a character.</li></ul><h4>\n  \n  \n  Strings (Immutable UTF-8)\n</h4><div><pre><code></code></pre></div><ul><li>Each character in  might take 1-3 bytes.</li><li>Strings are immutable. You  change characters via indexing.</li></ul><p><strong>Accessing bytes (not characters)</strong>:</p><div><pre><code></code></pre></div><ul><li>A  is an alias for , just a number from 0-255.</li><li> lets you inspect or manipulate the underlying raw data of a string.\n</li></ul><div><pre><code></code></pre></div><div><pre><code></code></pre></div><h4>\n  \n  \n  Runes (Unicode Code Points)\n</h4><p>A  in Go is an  representing a full Unicode character, even emojis and symbols from non-Latin scripts.</p><ul><li>Useful when dealing with , not bytes.</li><li>Can handle multi-byte characters like emoji properly.\n</li></ul><div><pre><code></code></pre></div><p>Use a  to  properly:</p><div><pre><code></code></pre></div><div><pre><code></code></pre></div><h4>\n  \n  \n  Quick Comparison: JavaScript vs Go\n</h4><div><table><tbody><tr></tr><tr><td> → 4</td></tr><tr></tr><tr></tr></tbody></table></div><div><table><thead><tr></tr></thead><tbody><tr></tr><tr><td><code>utf8.RuneCountInString(str)</code></td></tr><tr></tr></tbody></table></div><h3>\n  \n  \n  Functions and Control Flow\n</h3><div><pre><code></code></pre></div><div><pre><code></code></pre></div><p>In Go, you must declare the type of each parameter and the return value. The function block is enclosed by  just like JS.</p><h4>\n  \n  \n  Returning Multiple Values\n</h4><p>Go functions can return more than one value, which is commonly used for returning a result and an error.</p><div><pre><code></code></pre></div><p>In JavaScript, you might return an object or array to simulate multiple return values:</p><div><pre><code></code></pre></div><p>Go uses familiar  logic but requires the conditions to evaluate to a , no more truthy/falsy magic like in JS.</p><div><pre><code></code></pre></div><p>Go uses pointers to reference memory locations, similar to C, but without pointer arithmetic. Pointers are useful for modifying values in place and for efficient memory usage.</p><div><pre><code></code></pre></div><ul><li> means \"pointer to an int\".</li><li> gets the address of .</li><li> dereferences the pointer to access the value.</li></ul><p>\nJavaScript does not have pointers, but objects and arrays are passed by reference:</p><div><pre><code></code></pre></div><p>Go has only one loop keyword: .</p><div><pre><code></code></pre></div><p>You can also use it like a  loop:</p><div><pre><code></code></pre></div><p>The  keyword is used to iterate over elements in a variety of data structures, including arrays, slices, maps, and strings. When iterating over a string,  yields the index and the Unicode code point (rune) at each position.</p><p><strong>Example: Iterating over runes in a string</strong></p><div><pre><code></code></pre></div><p><em>This will print each Unicode character (rune) in the string, including multi-byte characters like emojis.</em></p><h2>\n  \n  \n  Working with the strings Package\n</h2><p>Go's standard library includes the powerful  package for manipulating text. Here are some common tasks:</p><div><pre><code></code></pre></div><div><pre><code></code></pre></div><h2>\n  \n  \n  Concurrency in Go: Goroutines, Channels, WaitGroups, and Mutexes\n</h2><p>Go's concurrency model is one of its superpowers. Unlike JavaScript's single-threaded event loop, Go lets you run multiple tasks at the same time using goroutines and channels.</p><h3>\n  \n  \n  Concurrency vs Parallelism\n</h3><ul><li> is about dealing with lots of things at once (structuring your program to handle multiple tasks that may not actually run at the same time).</li><li> is about doing lots of things at the same time (actually running on multiple CPU cores).</li></ul><p>Go makes it easy to write concurrent code, and if your machine has multiple cores, Go can run goroutines in parallel too.</p><p>A goroutine is a lightweight thread managed by the Go runtime. Just add  before a function call to run it concurrently:</p><div><pre><code></code></pre></div><p>Channels let goroutines communicate safely:</p><div><pre><code></code></pre></div><ul><li> sends a value into the channel.</li><li> receives a value from the channel.</li></ul><p>A  lets you wait for a group of goroutines to finish:</p><div><pre><code></code></pre></div><p>A  is used to safely share data between goroutines:</p><div><pre><code></code></pre></div><p> Without it, multiple goroutines could try to update  at the same time, causing race conditions.</p><p>The  keyword in Go schedules a function call to run after the function completes, just before it returns. This is especially useful for cleanup tasks like closing files, unlocking mutexes, or printing final messages.</p><div><pre><code></code></pre></div><p>If you use multiple  statements, they run in LIFO (last-in, first-out) order:</p><div><pre><code></code></pre></div><ul><li>Closing files or network connections</li><li>Logging or printing final messages</li></ul><p>\nJavaScript doesn't have a direct equivalent, but you might use  in a  block for similar cleanup:</p><div><pre><code></code></pre></div><h2>\n  \n  \n  Common Gotchas for JS Devs\n</h2><ul><li><strong>No implicit type coercion:</strong> Go won't convert types for you.  is an error, not .</li><li> Uninitialized variables have a default value (e.g.,  for int,  for string,  for pointers/slices/maps).</li><li> Go uses explicit error returns, not try/catch.</li><li> All variables must be declared before use.</li><li><strong>No unused imports or variables:</strong> The compiler will error if you import a package or declare a variable and don't use it.</li><li> Use structs and interfaces instead.</li><li><strong>No method overloading or default parameters.</strong></li></ul><h2>\n  \n  \n  Mini Project: Word Counter CLI\n</h2><p>Let's build a simple CLI tool that reads a line of text from the user, counts the number of words and unique words, and prints word frequencies. This demonstrates string manipulation, maps, and user input.</p><div><pre><code></code></pre></div><p><strong>Why not use  for user input?</strong></p><ul><li> is best for simple, space-separated input (e.g., numbers or single words), but for names or sentences,  is preferred because it reads the whole line, including spaces.  will only read up to the first space.</li></ul><h2>\n  \n  \n  Go Modules &amp; Project Structure\n</h2><p>Go uses modules to manage dependencies. To start a new project:</p><div><pre><code>go mod init github.com/yourusername/yourproject\n</code></pre></div><p>Typical Go project structure:</p><div><pre><code>myproject/\n  go.mod\n  main.go\n  pkg/      # reusable packages\n  internal/ # private packages\n</code></pre></div><p>Go does not use exceptions. Instead, functions that can fail return an  as a second return value:</p><div><pre><code></code></pre></div><h2>\n  \n  \n  Simple HTTP Server Example\n</h2><p>Go makes it easy to spin up a web server:</p><div><pre><code></code></pre></div><h2>\n  \n  \n  JavaScript to Go: Quick Reference Cheat Sheet\n</h2><div><table><thead><tr></tr></thead><tbody><tr></tr><tr></tr><tr><td>Multiple return values + </td></tr><tr></tr><tr></tr><tr></tr></tbody></table></div><p>Go is a modern, efficient, and fun language that empowers JavaScript developers to build fast, scalable, and reliable backend systems. With its simple syntax, powerful concurrency model, and robust standard library, Go is a fantastic next step for anyone looking to level up their programming skills.</p><p>If you’re comfortable in JavaScript, you’re more ready for Go than you think. The syntax is different, but the logic and problem-solving skills you’ve built in JS will serve you well.</p><p>Ready to try Go? Dive into the resources above, experiment with the examples, and start building something awesome. Happy coding! 🚀</p><p><em>Have questions or feedback? Feel free to reach out or leave a comment!</em></p>","contentLength":12899,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"You Don't Know iota","url":"https://dev.to/leapcell/you-dont-know-iota-2c9b","date":1751305337,"author":"Leapcell","guid":176829,"unread":true,"content":"<p>When you delve into official libraries, open-source libraries, or any Go project, you’ll find the magical identifier  everywhere. It plays an important role, making code more concise and clear, while improving readability and maintainability. Its applications are wide-ranging, from enumerated types to bit operations, and even complex constant expression calculations—it can do it all.</p><p>In this article, I will take you on an in-depth exploration of the magical power of , including an introduction to , its use cases, practical tips, and important considerations.</p><blockquote><p>Within a constant declaration, the predeclared identifier iota represents successive untyped integer constants. Its value is the index of the respective ConstSpec in that constant declaration, starting at zero.</p></blockquote><p>The above quote is from the official documentation. In short, by using , we can automatically create a series of consecutive integers in constant declarations, starting from zero, without manually specifying the value for each constant.</p><h3>\n  \n  \n  Automatically Generating Incrementing Constant Values\n</h3><p>With , it’s easy to generate incrementing constant values. The first constant using  in a constant declaration is initialized to 0, and subsequent constants automatically increment, making it unnecessary to specify the value of each constant manually when defining a series of incrementing constants. This improves code readability and maintainability. For example:</p><div><pre><code></code></pre></div><h3>\n  \n  \n  Defining Enumerated Type Constants\n</h3><p>By using , you can easily define a series of related enumerated values without having to manually specify the number for each value. This makes the enumeration type definitions more concise and easier to extend or modify. For example:</p><div><pre><code></code></pre></div><p>By using  within constant declarations, you can create complex expressions and adjust the value of  as needed in each constant declaration. This allows you to easily generate a set of constants that follow a specific pattern. For example:</p><div><pre><code></code></pre></div><p>By combining the left shift operator () with , you can conveniently generate a set of constants for bitwise operations. For example:</p><div><pre><code></code></pre></div><h2>\n  \n  \n  Tips and Considerations When Using iota\n</h2><p>We can use the underscore () to ignore certain values, for example:</p><div><pre><code></code></pre></div><h3>\n  \n  \n  iota Is Independent in Different Constant Blocks\n</h3><p>The scope of  is the entire constant block. The  in different constant blocks is independent, and the value of the first  in each block is always 0.</p><div><pre><code></code></pre></div><p>This article provided a detailed introduction to . By fully leveraging the features of  in your code, you can make your code more concise and clear, while also improving readability and maintainability.</p><p><a href=\"https://leapcell.io/?lc_t=d_goiota\" rel=\"noopener noreferrer\">Leapcell</a> is the Next-Gen Serverless Platform for Web Hosting, Async Tasks, and Redis:</p><ul><li>Develop with Node.js, Python, Go, or Rust.</li></ul><p><strong>Deploy unlimited projects for free</strong></p><ul><li>pay only for usage — no requests, no charges.</li></ul><p><strong>Unbeatable Cost Efficiency</strong></p><ul><li>Pay-as-you-go with no idle charges.</li><li>Example: $25 supports 6.94M requests at a 60ms average response time.</li></ul><p><strong>Streamlined Developer Experience</strong></p><ul><li>Intuitive UI for effortless setup.</li><li>Fully automated CI/CD pipelines and GitOps integration.</li><li>Real-time metrics and logging for actionable insights.</li></ul><p><strong>Effortless Scalability and High Performance</strong></p><ul><li>Auto-scaling to handle high concurrency with ease.</li><li>Zero operational overhead — just focus on building.</li></ul>","contentLength":3274,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Golang","url":"https://dev.to/weiming77/golang-2bli","date":1751286800,"author":"weiming77","guid":176626,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Go CLI Mastery: Crafting Developer Tools That Don't Suck","url":"https://dev.to/tavernetech/go-cli-mastery-crafting-developer-tools-that-dont-suck-3p53","date":1751279851,"author":"Taverne Tech","guid":176546,"unread":true,"content":"<ol><li>The Foundation: Setting Up Your CLI Architecture</li><li>Building Your CLI Masterpiece: Subcommands and Advanced Features</li><li>Pro Tips &amp; Distribution: Making Your CLI Tool Production-Ready\n</li></ol><p>Picture this: You're a developer, and your terminal is your kingdom. You've got 47 different CLI tools installed, but somehow, half of them feel like they were designed by someone who's never actually used a command line. The flags make no sense, the help text is either non-existent or a novel, and don't even get me started on the error messages! 😤</p><p>But here's the thing – <strong>Go has quietly become the undisputed champion of CLI tool development</strong>. Docker, Kubernetes kubectl, Hugo, and countless other tools that make our dev lives easier are all built with Go. Why? Because Go combines the performance of compiled languages with the simplicity that makes developers actually want to use your tools.</p><p>Today, we're diving deep into the art and science of building CLI tools that developers will not only use but actually  using. Buckle up, gophers! 🐹</p><h2>\n  \n  \n  1. 🏗️ The Foundation: Setting Up Your CLI Architecture\n</h2><p>Let's start with a confession: building CLI tools used to be like assembling IKEA furniture blindfolded. You'd spend more time parsing flags than actually solving problems. Thankfully, the Go ecosystem has evolved, and we now have tools that make CLI development feel less like archaeology and more like actual engineering.</p><p> – the dynamic duo of Go CLI development. Here's a lesser-known fact: <strong>Cobra was originally created by Steve Francia (spf13), the same genius behind Hugo</strong>. The framework powers some of the most popular CLI tools in existence, and there's a good reason for that.</p><div><pre><code></code></pre></div><p>: Notice how we're using both short () and long () flags? This isn't just good practice – it's <strong>respecting your users' muscle memory</strong>. Some folks are  people, others prefer . Why force them to choose sides in the CLI wars?</p><p>The beautiful thing about this setup is that <strong>Viper automatically handles environment variables, config files, and command flags in order of precedence</strong>. Your users can configure your tool however they want, and you don't have to write a single line of additional parsing code. It's like having a personal assistant for configuration management! 🎩</p><h2>\n  \n  \n  2. 🛠️ Building Your CLI Masterpiece: Subcommands and Advanced Features\n</h2><p>Now that we've got our foundation, let's build something that would make even the most jaded senior developer nod in approval. CLI tools are like Swiss Army knives – <strong>everyone needs one, but half the features remain mysterious unless you design them intuitively</strong>.</p><p>Here's where most CLI tools fail: they treat subcommands like an afterthought. But in Go with Cobra, subcommands are first-class citizens. Let's build a practical example – a developer productivity tool:</p><div><pre><code></code></pre></div><p>Here's a : The  package we're using was inspired by the realization that <strong>68% of developers spend more time reading CLI output than writing code</strong>. Good visual feedback isn't just pretty – it's a productivity multiplier!</p><p> in this example is the combination of:</p><ul><li> (Git is enabled by default because, come on, it's 2025)</li><li> (no more cryptic \"error: invalid input\" nonsense)</li><li> with colors and emojis</li><li> that actually explains what went wrong\n</li></ul><div><pre><code></code></pre></div><p>The magic here is  – your CLI starts simple but grows with your users' expertise. Beginners can use  and get something that works. Power users can dive into <code>project create myapp --lang rust --ci --template microservice</code> when they're ready.</p><h2>\n  \n  \n  3. 🚀 Pro Tips &amp; Distribution: Making Your CLI Tool Production-Ready\n</h2><p>Alright, you've built an awesome CLI tool. It works on your machine (famous last words, right?). Now comes the real challenge: <strong>making it work everywhere and making it easy for people to actually get their hands on it</strong>.</p><p>Here's a lesser-known fact that'll blow your mind: <strong>Go's static compilation means your CLI tool can run on systems where the user has never even heard of Go</strong>. This is huge! While Python developers are explaining virtual environments and Node.js folks are debugging npm conflicts, you just hand someone a binary and say \"run this.\"</p><div><pre><code></code></pre></div><p><strong>Testing CLI apps is like teaching your pet to fetch</strong> – lots of repetition, but when it works, it's magical. The key is testing both the happy path and the \"what happens when users inevitably do something unexpected\" path.</p><p>Now, let's talk about  – because the best CLI tool in the world is useless if nobody can install it:</p><div><pre><code></code></pre></div><p>But here's the : Use GitHub Actions to automate this process and create releases automatically:</p><div><pre><code></code></pre></div><p> Set up Homebrew distribution for macOS users:</p><div><pre><code></code></pre></div><p>The irony? You'll spend more time setting up the distribution pipeline than building the actual CLI tool. But that's the price of making software that people can actually use without a PhD in dependency management! 😂</p><p>We've journeyed from the basics of Cobra and Viper to building production-ready CLI tools that developers will actually want to use. The key takeaways? <strong>Respect your users' intelligence, provide sensible defaults, give helpful feedback, and make installation painless</strong>.</p><p>The Go ecosystem has matured to the point where building professional CLI tools is no longer the domain of systems programming wizards. With the right frameworks and practices, you can create tools that feel as polished as the best commercial software.</p><p>Here's the thing: <strong>every great developer tool started as someone's side project to solve their own problem</strong>. Docker began as a deployment tool for dotCloud. Kubernetes started as Google's internal orchestration system. Your next CLI tool might just be the one that changes how developers work.</p><p>So, what CLI tool will you build next? Will it be the project generator that finally makes sense? The deployment tool that doesn't require a manual? The debugging assistant that actually assists? <strong>The terminal is your canvas, and Go is your brush</strong> 🎨</p><p>Share your Go CLI creations in the comments – I'd love to see what the community builds with these techniques! And remember, the best CLI tool is the one that makes other developers' lives just a little bit easier.</p>","contentLength":6054,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Stop Wrestling with Config Files: A DevOps Guide to Sanity with Konfigo","url":"https://dev.to/bogdan_bododumitrescu_/stop-wrestling-with-config-files-a-devops-guide-to-sanity-with-konfigo-1hh3","date":1751270037,"author":"Bogdan “Bodo” Dumitrescu","guid":176410,"unread":true,"content":"<p>As a DevOps engineer, you've probably felt the pain of managing configuration files. You've got JSON, YAML, TOML,  files, and maybe even some custom formats you'd rather not talk about. You're juggling configs for different environments (dev, staging, prod), and trying to keep everything in sync is a nightmare. What if I told you there's a better way?</p><p>Enter Konfigo, a powerful command-line tool that's about to become your new best friend.</p><p>Konfigo is a versatile configuration management tool that helps you streamline your entire configuration workflow. It reads various configuration file formats, merges them intelligently, and processes the combined data against a user-defined schema for validation, transformation, and even batch output generation.</p><p>Think of it as a Swiss Army knife for your configuration files. 🇨🇭</p><p>Here are some of the key features that make Konfigo a game-changer for DevOps:</p><ul><li> JSON, YAML, TOML, and  files are all supported. No more converting files by hand!</li><li> Intelligently merges multiple configuration sources, respecting order and immutability rules.</li><li><strong>Powerful Schema Processing:</strong><ul><li> Inject dynamic values from environment variables, dedicated variable files, or schema defaults.</li><li> Create new configuration values (e.g., , , , ).</li><li> Modify keys and values (e.g., , , , , , , , ).</li><li> Enforce rules (, , , , , , ).</li></ul></li><li> Use the  directive in a variables file to generate multiple tailored configuration outputs from a single schema and run.</li><li><strong>Environment Variable Integration:</strong> Override any configuration value directly using environment variables.</li></ul><h2>\n  \n  \n  Why Should a DevOps Person Care? 🤷‍♀️\n</h2><p>Okay, so Konfigo has a lot of features. But how does it actually make your life easier?</p><h3>\n  \n  \n  Tame the Multi-Headed Hydra of Configuration Formats\n</h3><p>Let's say you have a base configuration in YAML, but your production environment requires some overrides from a  file. With Konfigo, you can merge them with a single command:</p><div><pre><code>konfigo  base.yaml,prod.env </code></pre></div><p>No more writing custom scripts to parse and merge different formats. Konfigo handles it all for you.</p><h3>\n  \n  \n  Automate Your Configuration Workflow\n</h3><p>You can integrate Konfigo into your CI/CD pipelines to generate environment-specific configurations on the fly. For example, you can have a base configuration and then apply environment-specific overrides from different files.</p><p>Here's a conceptual example of how you might use Konfigo in a CI/CD pipeline:</p><div><pre><code></code></pre></div><h3>\n  \n  \n  Prevent Configuration Drift\n</h3><p>Configuration drift is a major source of headaches in any infrastructure. With Konfigo's schema validation, you can enforce a consistent structure and set of rules for your configurations.</p><p>For example, you can create a schema that requires a specific key to be present, or that a value must be a number within a certain range. If a configuration doesn't match the schema, Konfigo will throw an error, and you can catch the problem before it ever reaches production.</p><h3>\n  \n  \n  Dynamic Configurations are Your Friend\n</h3><p>Stop hardcoding values in your configuration files! With Konfigo, you can use variables and data generation to create dynamic configurations.</p><p>For example, you can use an environment variable to set the database host, or you can use the  generator to add a build timestamp to your configuration.</p><div><pre><code>konfigo  config.json  schema.yml  staging-vars.yml  staging_config.json\n</code></pre></div><p>If you're managing configurations for a microservices architecture or a multi-tenant application, you know how complex it can get. Konfigo's batch processing feature can help you simplify this.</p><p>You can create a template configuration and then use a variables file to generate multiple tailored configurations for each service or tenant.</p><p>Let's look at a simple example of how Konfigo can be used to validate and transform a configuration file.</p><div><pre><code></code></pre></div><div><pre><code></code></pre></div><div><pre><code>konfigo  config.json  schema.yaml </code></pre></div><div><pre><code></code></pre></div><p>In this example, Konfigo does two things:</p><ol><li> the input to ensure that  is at least 1024.</li><li> the input by adding the prefix  to the  key.</li></ol><h2>\n  \n  \n  Ready to Give it a Try? 🚀\n</h2><p>I've only scratched the surface of what Konfigo can do. If you're tired of wrestling with configuration files, I highly recommend giving it a try.</p><p>Let me know what you think in the comments below! 👇</p>","contentLength":4166,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"BC847 Transistor: The Tiny Star-Keeper of Our Tech Planets","url":"https://dev.to/ersajay/bc847-transistor-the-tiny-star-keeper-of-our-tech-planets-31p4","date":1751264592,"author":"ersajay","guid":176375,"unread":true,"content":"<p>A Meeting in the Circuit Desert\nThe desert stretched endlessly, its sands glowing like gold under the sun. I was tracing the dunes, heading toward a distant oasis, when I spotted a glint in the sand—a small, silver shape, no bigger than a ladybug.<p>\n“You’re… very small,” I said, kneeling.</p>\n“And you’re a child who talks to transistors,” it replied, voice steady as the wind. “But some keepers of light are smallest when they’re strongest. Ask the fox.”<p>\nIt was a BC847—an NPN bipolar junction transistor, but to me, it felt like a secret. Let me tell you its story.</p></p><ul><li>What Is a BC847? (Not Just Metal—A Keeper of Light)\nThis was no ordinary silicon. It was a BC847, a tiny hero in a SOT-23-3 suit—smaller than a ladybug, but tough as a baobab’s roots. Here’s its secret:</li></ul><p>Voltage: 45V collector-emitter (VCEO), 5V base-emitter (VBE). It’s like a windbreak for circuits—sturdy against storms of static.\nCurrent: 100mA collector current (<a href=\"https://www.ersaelectronics.com/\" rel=\"noopener noreferrer\">IC</a>), 5mA base current (IB). Sips power like a hummingbird, not a thirsty camel.\nSpeed: 100MHz transition frequency (fT). Faster than the fox darting across the dunes.</p><p>Real-World Magic: Powers LED drivers in Philips Hue bulbs (keeping your roses lit) and Tesla’s battery sensors (guiding spaceships on Earth).\n“Why so quiet?” I asked.<p>\n“Keepers don’t shout,” it said. “They just keep.”</p></p><ul><li>BC847 &amp; Its Neighbors: Brothers, Not Twins\nIn the desert of transistors, <a href=\"https://www.ersaelectronics.com/blog/what-is-a-bc847-and-bc847-equivalents\" rel=\"noopener noreferrer\">BC847</a> has cousins—some taller, some faster, but none quite like it:</li></ul><p>BC846: A stronger brother. Handles 65V (vs. BC847’s 45V) but same current. Like a cactus that grows taller, not wider.\nBC547: An old friend. Cheaper, but bulkier (TO-92 vs. SOT-23). Like a postman with a big bag—reliable, but takes up space.<p>\n2N3904: A flashy neighbor. Faster, but panics at voltage spikes. Like a sprinter who trips at the finish line.</p></p><p>Roast Alert:\n2N3904 (boasting): “I’m cheaper!”<p>\nBC847 (calm, like the fox): “I’m in Tesla’s BMS. You’re in a kid’s science kit. Bye.”</p></p><ul><li>Why BC847 Shines Brighter Than Most\nBC847 isn’t just a transistor—it’s a star in the circuit sky. Here’s why:</li></ul><p>Tiny, But Tenacious: SOT-23-3 fits wearables and IoT sensors, like a key in a tiny lock. Even the fox couldn’t squeeze into spaces this small.\nSpeed of Light: 100MHz fT processes signals faster than your Wi-Fi rage-quits. The fox? He’s impressed.<p>\nCheap, But Charming: $0.02/unit—cheaper than your morning espresso. Even the rose, who’s picky, approves.</p></p><p>“Why not be bigger?” I asked.\n“Big things break,” it said. “Tiny things fit. In smartwatches. In Mars rovers. In insulin pumps.”</p><ul><li>BC847: Keeper of a Thousand Stars\nFrom your wrist to the cosmos, BC847 guards:</li></ul><p>Medical (The Healer’s Planet):\nPowers portable ECG monitors, amplifying weak heart signals (no “404 Error: Heartbeat”). Keeps insulin pumps precise—because roses (and diabetics) need gentle care.</p><p>Automotive &amp; Aerospace (The Cosmic Planets):\nMonitors Tesla’s battery cells (no TikTok fire memes—phew!). Survives cosmic radiation in satellites (Earth drama is overrated, anyway).</p><p>Consumer Tech (Your Daily Planet):\nPowers smartwatch sensors, outlasting your gym motivation. Keeps wireless earbuds jamming—because even foxes need their Hotline Bling.</p><p>“Do you get lonely?” I asked.\n“No,” it said. “I’m everywhere. In your watch, in your car, in the stars. Loneliness is for roses that forget they’re loved.”</p><ul><li>Brand Battle: The Guardians of the Desert\nNot all keepers are made equal. Let’s meet the ones worth trusting:</li></ul><p>Nexperia: The geographer of transistors. Makes high-speed BC847W variants—pricier ($0.05/unit), but worth it for precision.\nON Semiconductor: The cactus of the bunch. Works from -40°C (Arctic) to +150°C (Sahara). Bulk orders only, but tough as nails.<p>\nGuangzhou Guangxin: The friendly merchant. Budget-friendly ($0.02/unit), but skip if you need fancy datasheets.</p></p><p>Pro Tip: For Mars rovers, stick to ON Semi’s BC847HR (-55°C rated). Even the stars trust it.</p><ul><li>How to Find Your BC847 (Avoid the Baobabs of Fakes)\nIn 2025, shop like a wanderer—no baobab-sized fakes:</li></ul><p>Retailers: Digi-Key, Ersaelectronic. Search “BC847 SOT-23”—they’ll guide you like the desert’s wind.\nBulk Orders: Alibaba, with verified suppliers like Guangzhou Guangxin. Bargain like a merchant, but check for laser-etched logos (stickers = baobabs).</p><p>Price Range: $0.02–$0.10/unit retail; $0.015/unit for 1k+ (AliExpress).</p><p>The Secret of the Tiny Keeper\nBC847 isn’t flashy. It doesn’t need a name in lights or a viral meme. It’s the kind of friend you remember when your smartwatch works, your Tesla doesn’t catch fire, or a Mars rover sends back photos.<p>\n“What makes you special?” I asked, as I left.</p>\nIt didn’t answer. It just sat there, quiet as the desert, as the stars, as time itself.<p>\nAnd I realized—some keepers don’t need to be big. They just need to shine.</p></p><p>Written by a wanderer who once mistook a BC847 for a ladybug. (Spoiler: It didn’t fly, but it powered a toy robot. Close enough.)\n🌵 You become responsible, forever, for the stars you once overlooked.</p>","contentLength":5108,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"การสร้าง Docker Image สำหรับ Go ให้เหมาะกับ Production","url":"https://dev.to/somprasongd/kaarsraang-docker-image-samhrab-go-aihehmaaakab-production-529b","date":1751256550,"author":"Somprasong Damyos","guid":176281,"unread":true,"content":"<blockquote><p>แนวทางสร้าง Go container image ที่ เล็ก ปลอดภัย deploy ง่าย และ maintain ได้ระยะยาว</p></blockquote><p>เมื่อพัฒนาแอปพลิเคชันด้วยภาษา Go หนึ่งในจุดเด่นที่สำคัญคือการสร้างไฟล์ไบนารีแบบ static ทำให้เหมาะอย่างยิ่งสำหรับนำไปบรรจุใน Docker container ที่มีขนาดเล็กและปลอดภัย ซึ่ง Alpine Linux เป็นฐานที่คนนิยมใช้เพราะขนาดเล็กและมีแพ็กเกจพื้นฐานเพียงพอสำหรับงานส่วนใหญ่</p><p>แต่การจะทำให้ container ขนาดเล็กและพร้อมใช้จริงใน production ต้องเข้าใจประเด็นสำคัญทั้งในแง่ของ build, dependency, และการจัดการ image ให้มีความเสถียรและปลอดภัย</p><h3>\n  \n  \n  ปิด cgo (CGO_ENABLED=0) เพื่อสร้าง static binary\n</h3><p>โดยปกติ Go จะเปิดใช้ cgo เป็นค่าเริ่มต้นหากโค้ดมีการเรียกไลบรารี C หรือใช้ฟังก์ชันมาตรฐานบางส่วนที่อ้างอิง libc ซึ่งอาจทำให้ไฟล์ไบนารีต้องพึ่งพา shared library ภายนอก เช่น glibc หรือ musl</p><p>เมื่อใช้ Alpine ซึ่งใช้ musl libc แทน glibc ปัญหาที่พบบ่อยคือไฟล์ไบนารีที่พึ่ง glibc จะรันไม่สำเร็จ หากต้องการความแน่นอนว่ารันได้ทุกที่บน Linux base image ควรตั้ง  เพื่อให้ Go สร้างไฟล์ไบนารีที่ลิงก์แบบ static ทั้งหมด ลดปัญหา dependency ภายนอก</p><h3>\n  \n  \n  ลดขนาดไฟล์ด้วย ldflags \"-s -w\"\n</h3><p>ตัวเลือก  เป็นอีกเทคนิคที่ใช้กันทั่วไปเพื่อลดขนาดไฟล์ที่ได้จาก </p><ul><li> จะตัด symbol table ซึ่งไม่จำเป็นต่อการรันจริง</li><li> จะตัดข้อมูลสำหรับการ debug (DWARF)</li></ul><p>ผลคือขนาดไฟล์จะลดลงได้หลาย MB แต่ข้อควรระวังคือ หากต้องใช้เครื่องมือ debug เช่น Delve ข้อมูลเหล่านี้จะหายไป ทำให้ debug ได้ลำบากขึ้น เทคนิคนี้จึงเหมาะสำหรับ build ไบนารีที่ใช้จริงใน production เท่านั้น</p><h3>\n  \n  \n  ทำไมไม่ควรใช้ alpine:latest\n</h3><p>หลายคนมักเขียน Dockerfile ว่า  เพราะง่าย แต่ในทางปฏิบัติ นี่เป็นสิ่งที่ควรหลีกเลี่ยง เนื่องจาก tag  ไม่ได้ผูกกับ version ใด ๆ แบบตายตัว ภายใน repository อาจอัปเดตเมื่อใดก็ได้โดยไม่ประกาศล่วงหน้า ซึ่งทำให้ build ครั้งถัดไปอาจได้ base image ที่ไม่เหมือนเดิมและอาจเกิดปัญหาใหม่โดยไม่รู้ตัว</p><p>แนวทางที่ควรทำคือระบุเวอร์ชันให้ชัดเจน เช่น  เพื่อให้แน่ใจว่าผลลัพธ์ reproducible และ rollback ได้ง่ายหากเกิดปัญหา</p><h3>\n  \n  \n  ใช้ Multi-Stage Build เพื่อลดขนาดและจัดการได้ง่าย\n</h3><p>Dockerfile สำหรับ Go ที่ดีควรแยกขั้นตอน build ออกจากขั้นตอน runtime โดยใช้ multi-stage build ขั้นแรกใช้ image  สำหรับ compile โค้ด ขั้นถัดไปใช้  หรือแม้แต่  เพื่อลดขนาด image</p><div><pre><code>go mod download\ngo build  /app/app ./cmd/api/main.go\n\napk add  ca-certificates tzdata  addgroup  appgroup  adduser  appuser  appgroup\n\n</code></pre></div><p>อีกหนึ่งจุดที่หลายคนมองข้ามคือ user ที่ container ใช้รันโปรเซส เริ่มต้น container จะรันด้วย root ซึ่งถ้าเกิดช่องโหว่ ผู้โจมตีอาจใช้สิทธิ root ภายใน container เพื่อโจมตีต่อได้ง่าย</p><p>วิธีแก้คือสร้าง user สิทธิจำกัด แล้วสั่งให้ container รันด้วย user นี้แทน การเพิ่มบรรทัด  และ  ใน Dockerfile เป็นวิธีปฏิบัติมาตรฐานที่ช่วยปิดความเสี่ยงนี้ได้ดี</p><p>หลายคนสับสนระหว่าง  และ  ว่าควรใช้แบบไหน ต่างกันอย่างไร</p><ul><li> ใช้กำหนด  ที่ container ต้องรันเสมอ ไม่ว่าผู้ใช้จะสั่ง  พร้อม argument อะไร คำสั่งนี้จะถูกเรียกเสมอ โดย argument ที่ตามมาจะถูกต่อท้าย</li><li> ใช้กำหนด  ถ้า  ไม่ได้ระบุ argument ใหม่ ระบบจะใช้ค่าใน  แทน แต่ถ้าผู้ใช้ระบุ argument ใหม่ทั้งหมด  จะถูกแทนที่ทันที</li></ul><div><pre><code></code></pre></div><p>กรณีนี้ หากรัน  จะได้  ถ้ารัน  จะได้ </p><p>การใช้  แบบ exec form () ยังช่วยให้โปรเซสของเราทำงานเป็น PID 1 โดยตรง ทำให้จัดการ signal ได้ถูกต้อง โดยเฉพาะ SIGTERM ซึ่งสำคัญต่อการทำ graceful shutdown ใน production</p><h2>\n  \n  \n  สรุปแนวทาง Production Docker Image สำหรับ Go\n</h2><ul><li>ปิด cgo () เพื่อสร้างไฟล์ static</li><li>ใช้  เพื่อลดขนาดไฟล์</li><li>ระบุ base image version ชัดเจน เช่น  อย่าใช้ </li><li>แยกขั้น build ออกจากขั้น runtime ด้วย multi-stage build</li><li>สร้าง non-root user เพื่อลดความเสี่ยง</li><li>ใช้  เพื่อกำหนด command หลัก และ  เพื่อกำหนด default arguments</li></ul><p>แนวทางทั้งหมดนี้จะช่วยให้ได้ Docker Image ที่ขนาดเล็ก เสถียร ปลอดภัย และจัดการได้ง่ายจริงในงาน production</p>","contentLength":7879,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Mastering Timeout Control in Go with Goroutines","url":"https://dev.to/jones_charles_ad50858dbc0/mastering-timeout-control-in-go-with-goroutines-27bh","date":1751244482,"author":"Jones Charles","guid":175465,"unread":true,"content":"<h2>\n  \n  \n  Hey, Let’s Talk Timeouts!\n</h2><p>If you’ve built backend systems, you’ve hit the timeout wall. External APIs, database queries, or distributed tasks—without a timeout, your app can hang like a sloth on a branch. Think of timeouts as your app’s \"eject button\"—they keep things moving and save resources when the chef’s taking too long with your metaphorical pizza.</p><p>Go’s concurrency toolkit—goroutines and channels—is a game-changer here. Forget clunky threads or callback nightmares; Go’s approach is like snapping together LEGO bricks. This post is for devs with a year or two of Go under their belt—folks who’ve spun up goroutines but want to wield timeouts like a pro. We’ll go from basics to battle-tested designs, sprinkled with real-world wins and facepalms. Why goroutines? They’re light, fast, and pair perfectly with channels for clean timeout magic. Buckle up—we’re diving in!</p><h2>\n  \n  \n  Timeout Control : Why Goroutines Shine\n</h2><h3>\n  \n  \n  What’s a Timeout, Anyway?\n</h3><p>A timeout caps how long a task gets to run. Finish on time? Cool. Too slow? Sorry, you’re cut off. It’s everywhere in backend land—waiting on an API, querying a database, or juggling distributed jobs. No timeout means angry users or a crashed server.</p><div><table><thead><tr></tr></thead><tbody><tr></tr><tr></tr><tr></tr></tbody></table></div><h3>\n  \n  \n  Goroutines: The Timeout Superpower\n</h3><p>Goroutines aren’t just threads lite—they’re timeout ninjas. Here’s why:</p><ol><li>: Starting at 2KB, they scale to thousands without breaking a sweat—try that with Java threads!</li><li>: Channels sync tasks and timeouts effortlessly, no lock juggling required.</li><li>: With , timeouts snap into place like LEGO—no bloated configs needed.</li></ol><p>Compare that to Java’s thread pools or C++ timers—Go’s leaner and meaner.</p><div><table><thead><tr></tr></thead><tbody><tr></tr><tr></tr></tbody></table></div><p>Plus, tricks like  and  make timeouts dynamic and leak-proof. Ready to code? Let’s roll!</p><h2>\n  \n  \n  Getting Hands-On: Simple Timeout with Goroutines\n</h2><p>Time to code! Let’s build a basic timeout setup with goroutines and channels. It’s like learning to ride a bike—start simple, then trick it out later. We’ll simulate an API call with a 5-second deadline. Here’s the game plan: launch a goroutine, use a channel for results, and race it against a timeout.</p><div><pre><code></code></pre></div><ol><li>: Runs the task async—main thread stays chill.</li><li>:  grabs the output, buffered so the goroutine doesn’t block.</li><li>: Listens for the result or —first one wins.</li></ol><p>Run it, and the 6-second \"API\" loses to the 5-second timeout. Boom—.</p><ul><li>Dead simple—under 20 lines!\n</li><li>Lightweight—goroutines sip resources.</li></ul><ul><li>: Timeout triggers, but the goroutine keeps chugging. In this case, that  finishes anyway—wasted cycles.\n</li><li>: Fine for one task, messy for a dozen.</li></ul><p>This is your timeout starter kit—great for quick wins, but it’s not ready for the big leagues. Next, we’ll swap  for  to level up control and kill those leaks.</p><h2>\n  \n  \n  Level Up: Timeout Control with Context\n</h2><p>Our basic setup was cool, but it’s like a bike without brakes—leaky and hard to stop. Enter Go’s  package: the timeout boss that cancels tasks and cleans up messes. Let’s ditch  and make a database query that stops on a 1-second dime.</p><p>Since Go 1.7,  has been the concurrency MVP. It’s not just timeouts—it’s cancellation, propagation, and resource smarts in one. Here’s the pitch:</p><ul><li>: Set deadlines or kill tasks manually.</li><li>: Share control across functions—no repeat code.</li><li>: Tell goroutines to quit via .</li></ul><div><pre><code></code></pre></div><ol><li>: Spawns a context with a 1-second fuse.</li><li>: Frees resources, timeout or not.</li><li>: Signals the goroutine to quit—no lingering zombies.</li><li>: Spills the beans on what went wrong.</li></ol><p>Run it, and the 2-second query gets axed at 1 second—clean and efficient.</p><ul><li>:  is your safety net.</li><li>: Pass  as the first arg—it’s the Go way.</li><li>: Chain contexts for deep call stacks.</li></ul><ul><li>: I once skipped —goroutines piled up ‘til the server cried. Check  to spot stragglers.</li><li>: A 500ms cap killed legit database calls. Use P95 latency (e.g., 1.5x) to set sane limits.</li></ul><p>This is timeout control with brains—scalable and leak-free. Next, we’ll hit real-world chaos with distributed systems and high-concurrency tricks!</p><h2>\n  \n  \n  Real-World Timeout Kung Fu\n</h2><p>Theory’s nice, but projects are where timeouts get real. With a decade of scars to prove it, I’ll walk you through two battle-tested scenarios—distributed task scheduling and high-concurrency APIs. Code, wins, and facepalms incoming!</p><h3>\n  \n  \n  Scenario 1: Taming Distributed Systems\n</h3><p>Picture an e-commerce order flow: inventory, payment, logistics—all separate services. One lags, and the whole chain stalls. We need per-task timeouts  a global kill switch, plus partial results if things go south.</p><p>Nested  with goroutines, plus  for wrangling parallel calls. Here’s a 5-second timeout across three services:</p><div><pre><code></code></pre></div><ol><li>: Runs services in parallel, ties them to , and grabs errors.</li><li>: \"Payment\" times out, but others succeed—user gets .</li><li>: 5 seconds caps the chaos.</li></ol><ul><li>: Track each service’s time—saved my bacon debugging timeouts.</li><li>: Don’t ditch everything for one failure.</li></ul><h3>\n  \n  \n  Scenario 2: High-Concurrency API Chaos\n</h3><p>An API gateway slamming downstream services with requests. Unchecked goroutines could spiral into a memory apocalypse. We need timeouts  a lid on concurrency.</p><p>A worker pool with —three goroutines max, 3-second timeout:</p><div><pre><code></code></pre></div><ol><li>: Three workers keep goroutines in check.</li><li>: 3 seconds cuts off laggards.</li><li>: Tasks flow in, results flow out—smooth as butter.</li></ol><ul><li>: Base it on load— is a solid start.</li><li>: Add a token bucket to chill downstream pressure.</li></ul><ul><li>: I’ve seen goroutines hog CPU post-timeout—check  religiously.</li><li>: Task IDs + durations = debug gold.</li></ul><h2>\n  \n  \n  Wrapping Up: Timeout Mastery Unlocked\n</h2><p>We’ve gone from timeout newbie to goroutine ninja! <strong>Goroutines + channels/context</strong> are your Go timeout dream team—light, fast, and slick. Whether it’s a quick API call or a sprawling distributed system, you’ve got the tools: basic  for simplicity,  for control, and  for chaos. Pitfalls? Sure—leaky goroutines and tight timeouts bit me hard—but now you know the fixes.</p><h3>\n  \n  \n  Where It Shines (and Where It Doesn’t)\n</h3><p>This stuff kills it for high-concurrency backends—think microservices or task queues. Need millisecond precision for trading apps?  might lag a hair—try  instead.</p><ul><li>: Go 1.23 buffs —finer cancellation’s coming. Dig in!</li><li>: Pair timeouts with gRPC tracing or Kafka queues—it’s the future.</li><li>:  is a task’s heartbeat—master it, and your code sings.</li></ul><p>: Spin up  to spy on goroutines, log timeout stats, and tweak away. This is your launchpad—go build something epic!</p>","contentLength":6446,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Working with Scheduled Tasks in Go: Timer and Ticker","url":"https://dev.to/leapcell/working-with-scheduled-tasks-in-go-timer-and-ticker-8jb","date":1751223698,"author":"Leapcell","guid":175346,"unread":true,"content":"<p>In daily development, we may encounter situations where we need to delay the execution of some tasks or execute them periodically. At this point, we need to use timers in Go.</p><p>In Go, there are two types of timers:  (one-shot timer) and  (periodic timer). This article will introduce both types of timers.</p><p>A Timer is a one-shot timer used to perform an operation once at a specific time in the future.</p><p>There are two ways to create a Timer:</p><ul><li><code>NewTimer(d Duration) *Timer</code>: This function accepts a parameter  of type  (the time interval), which indicates how long the timer should wait before expiring.  returns a new Timer, which internally maintains a channel . When the timer fires, the current time is sent to channel .</li><li><code>AfterFunc(d Duration, f func()) *Timer</code>: Accepts a specified time interval  and a callback function . This function returns a new Timer, and when the timer expires, it directly calls  instead of sending a signal through channel . Calling the Timer's  method can stop the timer and cancel the execution of .</li></ul><p>The following code demonstrates how to use  and  to create timers and their basic usage:</p><div><pre><code></code></pre></div><p>The output of the above code is as follows:</p><div><pre><code>timer fired!\ntimer2 fired!\n</code></pre></div><p>Here is a step-by-step explanation of the code:</p><ol><li>Use  to create a timer, then listen to its  property in a new goroutine to wait for the timer to fire.</li><li>Use  to create another timer, specifying a callback function to handle the timer expiration event.</li><li>The main goroutine waits long enough to ensure the timer's firing information can be printed.</li></ol><p>: This method is used to reset the expiration time of a Timer, essentially reactivating it. It accepts a parameter  of type , representing how long the timer should wait before expiring.</p><p>In addition, this method returns a  value:</p><ul><li>If the timer is active, it returns .</li><li>If the timer has already expired or been stopped, it returns  (note:  does not mean the reset failed, it only indicates the current state of the timer).</li></ul><div><pre><code></code></pre></div><p>The output of the code is as follows:</p><p>Step-by-step explanation:</p><ol><li>Create a timer set to expire after 5 seconds.</li><li>Call the  method immediately to set it to expire in 1 second. Since the timer is still active (not expired),  returns .</li><li>The  statement waits for the timer to expire and prints the actual seconds passed (about 1 second).</li><li>The timer is reset again, this time to expire in 2 seconds. Since the timer has already expired,  returns .</li><li>The  statement again waits for the timer to expire and prints the seconds passed (about 2 seconds).</li></ol><p>: This method is used to stop the timer. If the timer is successfully stopped, it returns . If the timer has already expired or been stopped, it returns . Note: the  operation does not close channel .</p><div><pre><code></code></pre></div><p>The output is as follows:</p><p>Step-by-step explanation:</p><ol><li>Create a timer set to fire after 3 seconds.</li><li>Immediately call the  method to stop the timer. Since the timer has not yet fired,  returns .</li><li>Call  again to try to stop the same timer. Since it is already stopped, this time  returns .</li></ol><p>A Ticker is a periodic timer used to execute tasks repeatedly at fixed intervals. At every interval, it sends the current time to its channel.</p><p>We can use the  function to create a new Ticker object. This function accepts a  parameter  (the interval).</p><div><pre><code></code></pre></div><p>The output of the code is as follows:</p><div><pre><code>ticker fired!\nticker fired!\nticker fired!\nticker fired!\nticker fired!\n</code></pre></div><p>Step-by-step explanation:</p><ol><li>Create a timer that fires every second. To ensure the timer is cleaned up at the end of the function, we use .</li><li>Create a context that times out after 5 seconds.  is used to clean up the context before exiting.</li><li>In a new goroutine, a  statement listens to two channels: the timer's channel () and the context's done channel (). When the timer fires each second, it prints a message. When the context times out (after 5 seconds), it prints a timeout message and returns, ending the goroutine.</li><li>The main goroutine uses <code>time.Sleep(time.Second * 7)</code> to wait 7 seconds, ensuring that both the timer firing and timeout events can be observed.</li></ol><p>In addition to listening to  with , you can also use a  loop:</p><p>Note: Even if you stop a Ticker with the  method, its channel  will not be closed. This means, whether you use  or  to listen to , you need another mechanism to exit the loop, such as using a context.</p><p>The  method is used to stop the ticker and reset its period to the specified duration. The next tick will occur after the new period has elapsed. It accepts a parameter  of type , which represents the new interval. This parameter must be greater than zero; otherwise, the  method will panic internally.</p><div><pre><code></code></pre></div><p>The output of the code is as follows:</p><p>Step-by-step explanation:</p><ol><li>Create a time.Ticker that fires every 5 seconds.</li><li>Use the  method to change the interval from 5 seconds to 1 second.</li><li>In a single loop, print out the interval. The expected result is 1 second.</li></ol><p>The  method is used to stop the ticker. After calling , no more ticks will be sent to channel .  the  operation does not close the channel .</p><div><pre><code></code></pre></div><p>The output is as follows:</p><div><pre><code>Ticker fired!\nTicker fired!\nTicker fired!\nGoroutine stopped!\nTicker stopped!\n</code></pre></div><ol><li>Create a time.Ticker object that fires every second. At the same time, a quit channel of type  is introduced, which is used to send a stop signal to the running goroutine.</li><li>Start a new goroutine. In this goroutine, a for-select loop listens to two events: ticker firing () and the quit signal (). Each time the ticker fires, it prints a message. If it receives the quit signal, it prints a message and exits the loop.</li><li>In the main goroutine, <code>time.Sleep(time.Second * 3)</code> simulates a waiting time of 3 seconds, during which the ticker will fire a few times.</li><li>The main goroutine stops the ticker by calling , then closes the quit channel. The goroutine receives the quit signal, prints a message, and exits the loop.</li></ol><p>The  method does  close channel , so we need to use other means (such as a quit signal) to clean up resources.</p><h2>\n  \n  \n  Main Differences Between Timer and Ticker\n</h2><ul><li> is used for tasks that are executed after a single delay.</li><li> is used for tasks that need to be executed repeatedly.</li></ul><h3>\n  \n  \n  Behavioral Characteristics:\n</h3><ul><li> fires once after the specified delay, sending a single time value to its channel.</li><li> fires periodically at the specified interval, sending repeated time values to its channel.</li></ul><ul><li> can be reset ( method) and stopped ( method).  is used to change the firing time of the Timer.</li><li> can also be reset ( method) and stopped ( method).  is used to change the interval at which the Ticker fires.</li></ul><ul><li>The  method of  is used to prevent the Timer from firing. If the Timer has already fired,  does not remove the time value that has already been sent to its channel.</li><li>The  method of  is used to stop the periodic firing. Once stopped, no new values will be sent to its channel.</li></ul><ul><li>For both Timer and Ticker, calling the  method  close their  channels. If there are other goroutines listening on this channel, to avoid potential memory leaks, you need to manually terminate those goroutines. Usually, such resource cleanup can be handled by using a  or by a quit signal (implemented with channels).</li><li>After a Ticker has completed its task, you should call the  method to release the associated resources and prevent memory leaks. If you do not stop the Ticker in time, it may result in continuous resource occupation.</li></ul><p>This article has explored Go's Timer and Ticker in depth, introducing how to create them, their basic usage, and their related methods in detail. Additionally, the article summarizes the main differences between these two types of timers and emphasizes the considerations to keep in mind when using them.</p><p>When writing Go code, you should choose the appropriate timer according to the application scenario. At the same time, it's important to follow best practices—especially to release resources promptly after finishing with a timer—which is crucial for avoiding potential memory leaks.</p><p><a href=\"https://leapcell.io/?lc_t=d_gotimer\" rel=\"noopener noreferrer\">Leapcell</a> is the Next-Gen Serverless Platform for Web Hosting, Async Tasks, and Redis:</p><ul><li>Develop with Node.js, Python, Go, or Rust.</li></ul><p><strong>Deploy unlimited projects for free</strong></p><ul><li>pay only for usage — no requests, no charges.</li></ul><p><strong>Unbeatable Cost Efficiency</strong></p><ul><li>Pay-as-you-go with no idle charges.</li><li>Example: $25 supports 6.94M requests at a 60ms average response time.</li></ul><p><strong>Streamlined Developer Experience</strong></p><ul><li>Intuitive UI for effortless setup.</li><li>Fully automated CI/CD pipelines and GitOps integration.</li><li>Real-time metrics and logging for actionable insights.</li></ul><p><strong>Effortless Scalability and High Performance</strong></p><ul><li>Auto-scaling to handle high concurrency with ease.</li><li>Zero operational overhead — just focus on building.</li></ul>","contentLength":8454,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"From Migrations to Seed : Working with Fixtures in Nixopus","url":"https://dev.to/raghavyuva/from-migrations-to-seed-working-with-fixtures-in-nixopus-2e95","date":1751222512,"author":"Raghav","guid":175345,"unread":true,"content":"<p>Hey, we’re always up for exploring something cool at <a href=\"https://github.com/raghavyuva/nixopus\" rel=\"noopener noreferrer\">Nixopus</a>, and this time, we’re diving into fixtures. Now, the word  might sound a bit too technical and not immediately clear to many of our fellow developers so let’s break it down, and you’ll see exactly what we mean. Let’s dive in.</p><p>If you’ve worked with migrations before, you’ve probably come across the term  for databases. Even if you haven’t, let’s take a moment to understand what seeding data actually involves.</p><p>Usually, during development, things can get tricky over time, especially when you have contributors and developers working together on the same project. Everyone wants everything to be quick and hassle-free so development doesn’t slow down. As a project maintainer, it’s your responsibility to enable this smooth contribution roadmap for any user who wants to help out. That’s exactly what we’re working towards at Nixopus.</p><p>One major part of <a href=\"https://docs.nixopus.com/contributing\" rel=\"noopener noreferrer\">Contributing to Nixopus</a> is that after getting everything set up, Contributor still needs to do the following tasks :</p><ol><li>You realize you need  to log in and test admin features.</li><li>You also want to create  for that organization to test the role based access.</li><li>You might even want to enable specific features inside nixopus, and disable some!</li></ol><p>This is time consuming and error-prone, especially when you or your teammates need to do it over and over again on fresh databases. That’s exactly where data seeding comes into the picture.</p><p><em>The process of populating a database with an initial set of data.</em> Simple, isn’t it?</p><p>But how do we actually create one in Go using Bun ORM? This is what pushes us to explore how we can write a script to do exactly that.</p><p>We’ve divided our seed files into a modular folder structure. This way, everything stays organized and it’s much easier to load schema specific data when you need it.  </p><p>Below is an example of the file structure and the kind of data we’ll be loading into the database later in our <a href=\"https://github.com/raghavyuva/nixopus/blob/master/api/internal/fixtures/loader/fixture_loader.go\" rel=\"noopener noreferrer\">Codebase</a>:</p><div><pre><code></code></pre></div><p>First things first, we need to get input from the user. Let’s assume the user runs a command like:</p><p><code>go run internal/cmd/fixtures/main.go</code></p><p>Then we want to accept some arguments along with this command to determine what exactly the user is trying to do, we will get into what each flag does later, for now let's go forward</p><div><pre><code></code></pre></div><p>Now that we know what the user is actually trying to do, let’s create a Bun DSN URL which stands for , which is a connection string used to configure and connect to databases or services.</p><p>Here’s a raw example of what a Postgres DSN URL looks like: <code>postgres://username:password@localhost:5432/database_name?sslmode=disable</code></p><p>Since we don’t want to hardcode credentials, we need to load our secrets like passwords and other configs from environment variables. Here’s how we can do that in Go:</p><div><pre><code></code></pre></div><p>Once we have our DSN ready, we can check if our connection string is properly formatted and can be parsed without errors. The function we use for this is <a href=\"https://pkg.go.dev/github.com/jackc/pgx/v5#ParseConfig\" rel=\"noopener noreferrer\"></a>:</p><div><pre><code></code></pre></div><p>Now that we are ready to go, let's connect to our database and close the connection to database as our program ends</p><div><pre><code></code></pre></div><p>Now we need to load all our fixtures from the YAML files in our  folder.  Here’s a simple flowchart that shows how the loading process works, <a href=\"https://github.com/raghavyuva/nixopus/blob/master/api/internal/fixtures/loader/fixture_loader.go\" rel=\"noopener noreferrer\">Read The Code</a></p><p>After we have everything set up, we decide <strong>how we want to load the fixtures onto our database</strong>.  This block of code checks which option the user passed when they ran the command and performs the action accordingly:</p><div><pre><code></code></pre></div><h3>\n  \n  \n  Explanation of the Flags We Considered Earlier\n</h3><p>I know you must be waiting for the final touch, it's a lot of code to digest, right? So let’s take a moment to clearly understand the arguments we took earlier from the user:</p><ul><li>If you used , it , recreates them, and then loads your fixtures into fresh tables. This is helpful if you want to start from scratch every time.</li><li>If you used , it  but keeps the tables themselves (the structure stays intact), then loads your fixtures.</li><li>If you didn’t pass any of those flags, it simply <strong>inserts the fixture data as-is</strong>, without dropping or truncating anything.</li></ul><p>Do you think this could be done even better? Hmm that’s exactly why we’d love to have you join our <a href=\"https://discord.gg/skdcq39Wpv\" rel=\"noopener noreferrer\">Discord community</a>!   Want to see what we’re building and what we’ve accomplished so far? Take a look at our <a href=\"https://github.com/raghavyuva/nixopus/blob/master/CHANGELOG.md\" rel=\"noopener noreferrer\">CHANGELOG.md</a>.  </p>","contentLength":4258,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"**Building a Concurrent Caching System in Go: 500K+ Operations Per Second Performance**","url":"https://dev.to/aaravjoshi/building-a-concurrent-caching-system-in-go-500k-operations-per-second-performance-3gbl","date":1751221009,"author":"Aarav Joshi","guid":175344,"unread":true,"content":"<blockquote><p>As a best-selling author, I invite you to explore my books on <a href=\"https://www.amazon.com/stores/Aarav-Joshi/author/B0DQYNVXZ7?ref=ap_rdr&amp;isDramIntegrated=true&amp;shoppingPortalEnabled=true&amp;ccs_id=738636bd-0ca1-4d7b-8efa-481bfc222571\" rel=\"noopener noreferrer\">Amazon</a>. Don't forget to follow me on <a href=\"https://medium.com/@aarav-joshi\" rel=\"noopener noreferrer\">Medium</a> and show your support. Thank you! Your support means the world! </p></blockquote><p>Building high-performance applications often feels like solving a complex puzzle. When systems struggle under heavy data loads, I've found that intelligent caching becomes essential. My journey with Go led me to design a concurrent caching system that handles millions of operations efficiently. Let me share how this works and why it matters.</p><p>Caching isn't just about storing data. It's about making strategic decisions on what to keep and what to remove. In our implementation, we support three eviction strategies. Least Recently Used discards older items first. Least Frequently Used removes less-accessed entries. Adaptive Replacement Cache dynamically balances between recency and frequency patterns. Each approach serves different access scenarios.</p><p>Sharding is our secret weapon against contention. By splitting data across partitions, we minimize lock collisions. Here's how we distribute keys:</p><div><pre><code></code></pre></div><p>This FNV-1a hashing ensures even distribution across shards. Each shard operates independently, allowing concurrent access patterns that scale with CPU cores. </p><p>Memory management requires careful design. We use atomic operations for access tracking to avoid excessive locking. Notice how we handle entry updates:</p><div><pre><code></code></pre></div><p>These lightweight operations maintain accuracy without blocking other readers. For eviction, priority queues enable efficient removal. The LRU implementation uses a heap-based queue:</p><div><pre><code></code></pre></div><p>Time-based expiration is handled through a background cleaner. This routine periodically scans for stale entries:</p><div><pre><code></code></pre></div><p>Serialization demonstrates practical persistence. Our approach avoids marshaling expired entries:</p><div><pre><code></code></pre></div><p>Performance testing reveals impressive results. On a 32-core system, we consistently achieve over 500,000 operations per second. The sharded architecture reduces contention dramatically compared to single-lock implementations. Memory overhead stays low—about 30% less than standard map-based caches.</p><p>In production, I've applied this to several scenarios. Database query caching reduces backend load by 40% in read-heavy applications. Web session storage handles sudden traffic spikes gracefully. API response caching cuts latency from milliseconds to microseconds. For computational workflows, memoization reuse saves significant processing time.</p><p>Consider these enhancements for enterprise use. Add Prometheus metrics to track hit ratios and eviction rates. Implement size-based eviction for memory-bound systems. For distributed environments, integrate cluster coordination using gossip protocols. Always include cache warming mechanisms for cold starts.</p><p>The true value emerges in high-scale systems. When handling 50,000 operations across 100 goroutines, our implementation performs reliably:</p><div><pre><code></code></pre></div><h2>\n  \n  \n  This outputs results like: <code>Processed 50k ops in 92.4ms</code>. The numbers prove our design—minimal locking, smart eviction, and memory efficiency create a responsive caching layer. Whether building microservices or data pipelines, such caching becomes infrastructure bedrock.\n</h2><p>📘 , , , and  to the channel!</p><p> is an AI-driven publishing company co-founded by author . By leveraging advanced AI technology, we keep our publishing costs incredibly low—some books are priced as low as —making quality knowledge accessible to everyone.</p><p>Stay tuned for updates and exciting news. When shopping for books, search for  to find more of our titles. Use the provided link to enjoy !</p><p>Be sure to check out our creations:</p>","contentLength":3577,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"**Go Database Optimization: 5 Performance Patterns That Boost Application Speed by 700%**","url":"https://dev.to/aaravjoshi/go-database-optimization-5-performance-patterns-that-boost-application-speed-by-700-4148","date":1751220190,"author":"Aarav Joshi","guid":175326,"unread":true,"content":"<blockquote><p>As a best-selling author, I invite you to explore my books on <a href=\"https://www.amazon.com/stores/Aarav-Joshi/author/B0DQYNVXZ7?ref=ap_rdr&amp;isDramIntegrated=true&amp;shoppingPortalEnabled=true&amp;ccs_id=738636bd-0ca1-4d7b-8efa-481bfc222571\" rel=\"noopener noreferrer\">Amazon</a>. Don't forget to follow me on <a href=\"https://medium.com/@aarav-joshi\" rel=\"noopener noreferrer\">Medium</a> and show your support. Thank you! Your support means the world! </p></blockquote><p>Building high-performance applications in Go requires thoughtful database interaction design. When systems face heavy loads, inefficient data access becomes the primary bottleneck. I've seen applications crumble under pressure due to poorly optimized database patterns, leading to frustrated users and costly scaling. Let's explore practical techniques to prevent these issues.</p><p>Database connections are expensive resources. Creating new connections for every request wastes precious milliseconds. Connection pooling solves this by reusing existing connections. Here's how I configure it properly:</p><div><pre><code></code></pre></div><p>These numbers aren't arbitrary. After load testing various configurations, I found this ratio balances memory usage and connection wait times. Exceeding your database's actual connection limit causes queues that cascade through your application.</p><p>Batch processing revolutionized how I handle write operations. Instead of executing individual inserts, I group them:</p><div><pre><code></code></pre></div><p>The batch processor collects operations until reaching 100 requests or waiting 100ms, whichever comes first. This reduced database round trips by 92% in my last benchmark. The transaction block ensures atomic execution:</p><div><pre><code></code></pre></div><p>Caching requires careful strategy. I implement dual caching: prepared statements and query results. Statement caching avoids repeated SQL compilation:</p><div><pre><code></code></pre></div><p>Result caching works best for read-heavy operations. Serializing to JSON handles struct variability:</p><div><pre><code></code></pre></div><p>Context handling prevents resource leaks. Always propagate cancellation:</p><div><pre><code></code></pre></div><p>For production systems, add observability. I instrument these key metrics:</p><ul><li>Batch flush latency distribution</li><li>Pool utilization percentage</li></ul><p>Implement circuit breakers to avoid overwhelming databases during outages. This simple pattern prevents cascading failures:</p><div><pre><code></code></pre></div><p>Connection validation prevents stale pool issues. Before reuse, verify connectivity:</p><div><pre><code></code></pre></div><p>Tuning requires understanding your workload. For write-heavy systems, increase batch sizes to 500-1000 operations. For read-heavy applications, allocate more memory to caching. Always test with production-like data volumes.</p><p>These patterns delivered remarkable improvements in my projects. One API handling financial transactions increased throughput from 1,200 to 9,500 requests per second. Database CPU utilization dropped by 40% despite higher traffic. The implementation pays continuous dividends as systems scale.</p><h2>\n  \n  \n  Remember optimization isn't premature engineering. It's building responsive foundations. Start with connection pooling, add batching when write volumes grow, and introduce caching for frequent queries. Each layer compounds performance gains while keeping complexity manageable.\n</h2><p>📘 , , , and  to the channel!</p><p> is an AI-driven publishing company co-founded by author . By leveraging advanced AI technology, we keep our publishing costs incredibly low—some books are priced as low as —making quality knowledge accessible to everyone.</p><p>Stay tuned for updates and exciting news. When shopping for books, search for  to find more of our titles. Use the provided link to enjoy !</p><p>Be sure to check out our creations:</p>","contentLength":3242,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["go"]}