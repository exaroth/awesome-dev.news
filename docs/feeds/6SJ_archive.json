{"id":"6SJ","title":"Go","displayTitle":"Go","url":"","feedLink":"","isQuery":true,"isEmpty":false,"isHidden":false,"itemCount":13,"items":[{"title":"Go Nullable with Generics v2.0.0 - now supports omitzero","url":"https://github.com/LukaGiorgadze/gonull","date":1739617221,"author":"/u/Money-Relative-1184","guid":632,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1ipz22f/go_nullable_with_generics_v200_now_supports/"},{"title":"what do you use golang for?","url":"https://www.reddit.com/r/golang/comments/1ipykyd/what_do_you_use_golang_for/","date":1739615068,"author":"/u/Notalabel_4566","guid":636,"unread":true,"content":"<p>Is there any other major use than web development?</p>","contentLength":50,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Webassembly and go 2025","url":"https://www.reddit.com/r/golang/comments/1ipu4wd/webassembly_and_go_2025/","date":1739595637,"author":"/u/KosekiBoto","guid":635,"unread":true,"content":"<div><p>so I found <a href=\"https://www.youtube.com/watch?v=HShIpUgCPp4\">this video </a>and was thinking about doing something similar for my game as a means to implement modding, however I also stumbled upon a 3 y/o post when looking into it essentially stating that it's a bad idea and I wasn't able to really find anything on the state of go wasm, so can someone please enlighten me as to the current state of WASM and Go, thank you</p></div>   submitted by   <a href=\"https://www.reddit.com/user/KosekiBoto\"> /u/KosekiBoto </a>","contentLength":402,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"GOGC & GOMEMLIMIT ?","url":"https://www.reddit.com/r/golang/comments/1ipnxxk/gogc_gomemlimit/","date":1739575182,"author":"/u/mistyrouge","guid":633,"unread":true,"content":"<div><p>If the GC cost is fixed with regards to the amount of memory being freed up. Why would I not want to put  and  to say 70% of the memory I have available? Specially in an application that is known to be cpu bound.</p></div>   submitted by   <a href=\"https://www.reddit.com/user/mistyrouge\"> /u/mistyrouge </a>","contentLength":245,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"GitHub - Clivern/Peanut: üê∫ Deploy Databases and Services Easily for Development and Testing Pipelines.","url":"https://github.com/Clivern/Peanut","date":1739567268,"author":"/u/Clivern","guid":634,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1ipl12p/github_clivernpeanut_deploy_databases_and/"},{"title":"Shutdown Go server","url":"https://www.reddit.com/r/golang/comments/1ipj5zn/shutdown_go_server/","date":1739562402,"author":"/u/Kennedy-Vanilla","guid":637,"unread":true,"content":"<div><p>Hi, recently I saw that many people shutdown their servers like this or similar</p><pre><code>serverCtx, serverStopCtx serverCtx, serverStopCtx := context.WithCancel(context.Background()) sig := make(chan os.Signal, 1) signal.Notify(sig, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT) go func() { &lt;-sig shutdownCtx, cancelShutdown := context.WithTimeout(serverCtx, 30*time.Second) defer cancelShutdown() go func() { &lt;-shutdownCtx.Done() if shutdownCtx.Err() == context.DeadlineExceeded { log.Fatal(\"graceful shutdown timed out.. forcing exit.\") } }() err := server.Shutdown(shutdownCtx) if err != nil { log.Printf(\"error shutting down server: %v\", err) } serverStopCtx() }() log.Printf(\"Server starting on port %s...\\n\", port) err = server.ListenAndServe() if err != nil &amp;&amp; err != http.ErrServerClosed { log.Printf(\"error starting server: %v\", err) os.Exit(1) } &lt;-serverCtx.Done() log.Println(\"Server stopped\") } := context.WithCancel(context.Background()) sig := make(chan os.Signal, 1) signal.Notify(sig, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT) go func() { &lt;-sig shutdownCtx, cancelShutdown := context.WithTimeout(serverCtx, 30*time.Second) defer cancelShutdown() go func() { &lt;-shutdownCtx.Done() if shutdownCtx.Err() == context.DeadlineExceeded { log.Fatal(\"graceful shutdown timed out.. forcing exit.\") } }() err := server.Shutdown(shutdownCtx) if err != nil { log.Printf(\"error shutting down server: %v\", err) } serverStopCtx() }() log.Printf(\"Server starting on port %s...\\n\", port) err = server.ListenAndServe() if err != nil &amp;&amp; err != http.ErrServerClosed { log.Printf(\"error starting server: %v\", err) os.Exit(1) } &lt;-serverCtx.Done() log.Println(\"Server stopped\") </code></pre><p>Is it necessary? Like it's so many code for the simple operation</p></div>   submitted by   <a href=\"https://www.reddit.com/user/Kennedy-Vanilla\"> /u/Kennedy-Vanilla </a>","contentLength":1805,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Extensible Wasm Applications with Go","url":"https://go.dev/blog/wasmexport","date":1739404800,"author":"Cherry Mui","guid":264,"unread":true,"content":"<p>\n      Cherry Mui\n      13 February 2025\n      </p><p>Go 1.24 enhances its WebAssembly (Wasm) capabilities with the\naddition of the  directive and the ability to build a reactor\nfor WebAssembly System Interface (WASI).\nThese features enable Go developers to export Go functions to Wasm,\nfacilitating better integration with Wasm hosts and expanding the possibilities\nfor Go-based Wasm applications.</p><h2>WebAssembly and the WebAssembly System Interface</h2><p><a href=\"https://webassembly.org/\" rel=\"noreferrer\" target=\"_blank\">WebAssembly (Wasm)</a> is a binary instruction format\nthat was initially created for web browsers, providing the execution of\nhigh-performance, low-level code at speeds approaching native performance.\nSince then, Wasm‚Äôs utility has expanded, and it is now used in various\nenvironments beyond the browser.\nNotably, cloud providers offer services that directly execute Wasm\nexecutables, taking advantage of the\n<a href=\"https://wasi.dev/\" rel=\"noreferrer\" target=\"_blank\">WebAssembly System Interface (WASI)</a> system call API.\nWASI allows these executables to interact with system resources.</p><p>Go first added support for compiling to Wasm in the 1.11 release, through the\n port.\nGo 1.21 added a new port targeting the WASI preview 1 syscall API through the\nnew  port.</p><h2>Exporting Go Functions to Wasm with </h2><p>Go 1.24 introduces a new compiler directive, , which allows\ndevelopers to export Go functions to be called from outside of the\nWasm module, typically from a host application that runs the Wasm runtime.\nThis directive instructs the compiler to make the annotated function available\nas a Wasm <a href=\"https://webassembly.github.io/spec/core/valid/modules.html?highlight=export#exports\" rel=\"noreferrer\" target=\"_blank\">export</a>\nin the resulting Wasm binary.</p><p>To use the  directive, simply add it to a function definition:</p><pre><code>//go:wasmexport add\nfunc add(a, b int32) int32 { return a + b }\n</code></pre><p>With this, the Wasm module will have an exported function named  that\ncan be called from the host.</p><p>This is analogous to the <a href=\"https://go.dev/cmd/cgo#hdr-C_references_to_Go\">cgo  directive</a>,\nwhich makes the function available to be called from C,\nthough  uses a different, simpler mechanism.</p><p>A WASI reactor is a WebAssembly module that operates continuously, and\ncan be called upon multiple times to react on events or requests.\nUnlike a ‚Äúcommand‚Äù module, which terminates after its main function finishes,\na reactor instance remains live after initialization, and its exports remain\naccessible.</p><p>With Go 1.24, one can build a WASI reactor with the  build\nflag.</p><pre><code>$ GOOS=wasip1 GOARCH=wasm go build -buildmode=c-shared -o reactor.wasm\n</code></pre><p>The build flag signals to the linker not to generate the  function\n(the entry point for a command module), and instead generate an\n function, which performs runtime and package initialization,\nalong with any exported functions and their dependencies.\nThe  function must be called before any other exported functions.\nThe  function will not be automatically invoked.</p><p>To use a WASI reactor, the host application first initializes it by calling\n, then simply invoke the exported functions.\nHere is an example using <a href=\"https://wazero.io/\" rel=\"noreferrer\" target=\"_blank\">Wazero</a>, a Go-based Wasm runtime\nimplementation:</p><pre><code>// Create a Wasm runtime, set up WASI.\nr := wazero.NewRuntime(ctx)\ndefer r.Close(ctx)\nwasi_snapshot_preview1.MustInstantiate(ctx, r)\n\n// Configure the module to initialize the reactor.\nconfig := wazero.NewModuleConfig().WithStartFunctions(\"_initialize\")\n\n// Instantiate the module.\nwasmModule, _ := r.InstantiateWithConfig(ctx, wasmFile, config)\n\n// Call the exported function.\nfn := wasmModule.ExportedFunction(\"add\")\nvar a, b int32 = 1, 2\nres, _ := fn.Call(ctx, api.EncodeI32(a), api.EncodeI32(b))\nc := api.DecodeI32(res[0])\nfmt.Printf(\"add(%d, %d) = %d\\n\", a, b, c)\n\n// The instance is still alive. We can call the function again.\nres, _ = fn.Call(ctx, api.EncodeI32(b), api.EncodeI32(c))\nfmt.Printf(\"add(%d, %d) = %d\\n\", b, c, api.DecodeI32(res[0]))\n</code></pre><p>The  directive and the reactor build mode allow applications to\nbe extended by calling into Go-based Wasm code.\nThis is particularly valuable for applications that have adopted Wasm as a\nplugin or extension mechanism with well-defined interfaces.\nBy exporting Go functions, applications can leverage the Go Wasm modules to\nprovide functionality without needing to recompile the entire application.\nFurthermore, building as a reactor ensures that the exported functions can be\ncalled multiple times without requiring reinitialization, making it suitable\nfor long-running applications or services.</p><h2>Supporting rich types between the host and the client</h2><p>Go 1.24 also relaxes the constraints on types that can be used as input and\nresult parameters with  functions.\nFor example, one can pass a bool, a string, a pointer to an , or a\npointer to a struct which embeds  and contains supported\nfield types\n(see the <a href=\"https://go.dev/cmd/compile#hdr-WebAssembly_Directives\">documentation</a> for detail).\nThis allows Go Wasm applications to be written in a more natural and ergonomic\nway, and removes some unnecessary type conversions.</p><p>While Go 1.24 has made significant enhancements to its Wasm capabilities,\nthere are still some notable limitations.</p><p>Wasm is a single-threaded architecture with no parallelism.\nA  function can spawn new goroutines.\nBut if a function creates a background goroutine, it will not continue\nexecuting when the  function returns, until calling back into\nthe Go-based Wasm module.</p><p>While some type restrictions have been relaxed in Go 1.24, there are still\nlimitations on the types that can be used with  and\n functions.\nDue to the unfortunate mismatch between the 64-bit architecture of the client\nand the 32-bit architecture of the host, it is not possible to pass pointers in\nmemory.\nFor example, a  function cannot take a pointer to a struct that\ncontains a pointer-typed field.</p><p>The addition of the ability to build a WASI reactor and export Go functions to\nWasm in Go 1.24 represent a significant step forward for Go‚Äôs WebAssembly\ncapabilities.\nThese features empower developers to create more versatile and powerful Go-based\nWasm applications, opening up new possibilities for Go in the Wasm ecosystem.</p>","contentLength":5777,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Go 1.24 arrives","url":"https://golangweekly.com/issues/542","date":1739318400,"author":"","guid":616,"unread":true,"content":"<li><p><a href=\"https://golangweekly.com/link/165684/rss\">DB Fiddle</a> is a handy online database 'sandbox' for playing with various versions of MySQL, Postgres, and SQLite direct from the browser.</p></li>","contentLength":136,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Go 1.24 is released!","url":"https://go.dev/blog/go1.24","date":1739232000,"author":"Junyang Shao, on behalf of the Go team","guid":263,"unread":true,"content":"<div data-slug=\"/blog/go1.24\"><p>\n      Junyang Shao, on behalf of the Go team\n      11 February 2025\n      </p><p>Today the Go team is excited to release Go 1.24,\nwhich you can get by visiting the <a href=\"https://go.dev/dl/\">download page</a>.</p><p>Go 1.24 comes with many improvements over Go 1.23. Here are some of the notable\nchanges; for the full list, refer to the <a href=\"https://go.dev/doc/go1.24\">release notes</a>.</p><p>Several performance improvements in the runtime have decreased CPU overhead\nby 2‚Äì3% on average across a suite of representative benchmarks. These\nimprovements include a new builtin  implementation based on\n<a href=\"https://abseil.io/about/design/swisstables\" rel=\"noreferrer\" target=\"_blank\">Swiss Tables</a>, more efficient\nmemory allocation of small objects, and a new runtime-internal mutex\nimplementation.</p><ul><li>The  command now provides a mechanism for tracking tool dependencies for a\nmodule. Use  to add a  directive to the current module. Use\n to run the tools declared with the  directive.\nRead more on the <a href=\"https://go.dev/doc/go1.24#go-command\">go command</a> in the release notes.</li><li>The new  analyzer in  subcommand reports common mistakes in\ndeclarations of tests, fuzzers, benchmarks, and examples in test packages.\nRead more on <a href=\"https://go.dev/doc/go1.24#vet\">vet</a> in the release notes.</li></ul><h2>Standard library additions</h2><h2>Improved WebAssembly support</h2><p>Go 1.24 adds a new  directive for Go programs to export\nfunctions to the WebAssembly host, and supports building a Go program as a WASI\n<a href=\"https://github.com/WebAssembly/WASI/blob/63a46f61052a21bfab75a76558485cf097c0dbba/legacy/application-abi.md#current-unstable-abi\" rel=\"noreferrer\" target=\"_blank\">reactor/library</a>.\nRead more on <a href=\"https://go.dev/doc/go1.24#wasm\">WebAssembly</a> in the release notes.</p><p>Please read the <a href=\"https://go.dev/doc/go1.24\">Go 1.24 release notes</a> for the complete and\ndetailed information. Don‚Äôt forget to watch for follow-up blog posts that\nwill go in more depth on some of the topics mentioned here!</p><p>Thank you to everyone who contributed to this release by writing code and\ndocumentation, reporting bugs, sharing feedback, and testing the release\ncandidates. Your efforts helped to ensure that Go 1.24 is as stable as possible.\nAs always, if you notice any problems, please <a href=\"https://go.dev/issue/new\">file an issue</a>.</p></div>","contentLength":1768,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"sync/v2 and the 'v2'-ification of Go's standard library","url":"https://golangweekly.com/issues/541","date":1738713600,"author":"","guid":615,"unread":true,"content":"<p> ‚Äî It uses Linux-only network namespaces for now, but this is a Go-powered process-scoped HTTP tracer you can run  root privileges. It even decrypts TLS traffic by generating a CA on the fly. Handy for debugging or seeing if dependencies or apps are ‚Äòphoning&nbsp;home,‚Äô&nbsp;perhaps..</p><p>Monastic Academy for the Preservation of Life on Earth </p>","contentLength":338,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Slow, flaky, and failing","url":"https://bitfieldconsulting.com/posts/slow-flaky-failing","date":1738242900,"author":"John Arundel","guid":18,"unread":true,"content":"<blockquote><p><em>If you find yourself working on a project with quite a few broken\nwindows, it‚Äôs all too easy to slip into the mindset of ‚ÄúAll the rest of\nthis code is crap, I‚Äôll just follow suit.‚Äù</em>\n‚ÄîDavid Thomas &amp; Andrew Hunt, <a href=\"https://amzn.to/3yGUnhD\">‚ÄúThe\nPragmatic Programmer: Your Journey to Mastery‚Äù</a></p></blockquote><p>It‚Äôs one minute to ship time, and you hit ‚Äúpush‚Äù on the very last\ncommit. There it goes: the build is running. Every second counts now,\nand you watch the test output with increasing impatience. Why do the\ntests take so darned ?</p><p>And then, to your horror, the first red lights start to appear. ‚ÄúBut\nthese were passing before, and I haven‚Äôt touched that code!‚Äù you wail.\nIt‚Äôs no good: your co-workers are already giving you the stink eye for\nbreaking the build and holding them up.</p><p>You‚Äôre not going to ship today, for one simple reason: your tests are\nslow, flaky, and failing. So what the hell?</p><p>Flaky tests sometimes fail, sometimes pass, regardless of whether the\nsystem is correct. There are many reasons for flaky tests, so let‚Äôs look\nat a couple of them, with some possible solutions.</p><p> can be a source of flakiness, as you probably\nknow from experience. In particular, fixed sleeps in tests are a bad\nidea (see the next section for more about these). Eliminate these\nwherever possible and replace them with code that only waits as long as\nstrictly necessary.</p><p>When you need to  timing itself, use the shortest\npossible interval. For example, don‚Äôt test a timer function with a\none-second duration when one millisecond would work just as well.</p><p>In some tests, as crazy as it sounds, the  can\naffect the test. One way to eliminate this cause of flakiness is by\nturning , and if necessary injecting a fake\n function to return a canned time of day.</p><p>Flakiness can also sometimes arise from .\nSome data structures in Go are inherently unordered: maps, for example.\nComparing these needs special care.</p><p>For example, iterating over a map comparing its elements is not good\nenough: the iteration order of maps is unspecified in Go. Instead, we\ncan use the  function to compare maps regardless\nof iteration order:</p><pre><code></code></pre><p>On the other hand, slices  inherently ordered, and so\n requires this:</p><pre><code></code></pre><p>But sometimes we don‚Äôt actually care about the order. Maybe we get\nthese results from some concurrent computations, and we don‚Äôt know what\norder they will show up in. We just want to know that we \nthe right results.</p><p>To compare two slices for equal , then, regardless\nof order, we can use  to sort them before the\ncomparison:</p><pre><code></code></pre><p>Whatever the cause of a flaky test suite, it‚Äôs a serious problem.\nLeft untreated, it will continuously erode value from the tests, until\neventually they become useless and ignored by all. It should be a red\nflag to hear something like ‚ÄúOh yeah, that test just fails\nsometimes.‚Äù</p><p>As soon as you hear that, you know that the test has become useless.\nDelete it, if the flakiness really can‚Äôt be fixed. Thou shalt not suffer\na flaky test to live. As soon as it starts flaking, it stops being a\nuseful source of feedback, and bad tests are worse than no tests.</p><p>A  test is not the same thing as a flaky test: a\nbrittle test fails when you change something unrelated, whereas a flaky\ntest fails when it feels like it. Fixing brittle tests is usually a\nmatter of decoupling entangled components, or simply reducing the scope\n(and thus sharpening the focus) of the test.</p><p>On the other hand, flaky tests can require some time and effort to\nfind the underlying cause and address it. Only do this if the test is\nreally worth it; if not, just delete it.</p><p>What if some tests aren‚Äôt just flaky, but fail all the time, because\nbugs aren‚Äôt being fixed? This is a very dangerous situation, and without\nprompt action the tests will rapidly become completely useless.</p><p>Why? Because if tests are allowed to fail for a while without being\nfixed, people soon stop trusting them, or indeed paying \nattention to them: ‚ÄúOh yeah, that test always fails.‚Äù</p><p>We can never have any failing tests, just as we can never have any\nbugs:</p><p>As soon as any test starts failing, fixing it should be everyone‚Äôs\ntop priority. No one is allowed to deploy any code change that‚Äôs not\nabout fixing this bug. Once you let one failing test slip through the\nnet, all the other tests become worthless.</p><p>This so-called  sounds radical, but\nit really isn‚Äôt. After all, what‚Äôs the alternative?</p><blockquote><p><em>The very first version of Microsoft Word for Windows was\nconsidered a ‚Äúdeath march‚Äù project. Managers were so insistent on\nkeeping to the schedule that programmers simply rushed through the\ncoding process, writing extremely bad code, because bug-fixing was not a\npart of the formal schedule.</em><em>Indeed, the schedule became merely a checklist of features waiting\nto be turned into bugs. In the post-mortem, this was referred to as\n‚Äúinfinite defects methodology‚Äù.</em>\n‚ÄîJoel Spolsky, <a href=\"https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/\">‚ÄúThe\nJoel Test: 12 Steps to Better Code‚Äù</a></p></blockquote><p>Fixing bugs now is cheaper, quicker, and makes more business sense\nthan fixing them later. The product should be ready to ship at all\ntimes, without bugs.</p><p>If you already  a large backlog of bugs, or failing\ntests, but the company‚Äôs still in business, then maybe those bugs aren‚Äôt\nreally that critical after all. The best way out may be to declare\nvoluntary : just close all old bugs, or delete\nall failing tests. Bugs that people  care about will pretty\nsoon be re-opened.</p><p>My book <a href=\"https://bitfieldconsulting.com/books/tests\">The Power of Go: Tests</a> is all\nabout how to write  tests: not just box-ticking\nexercises to satisfy some bureaucratic manager, but tests that really\nadd value to the code, and make your work easier and more enjoyable.</p><p>Even the world‚Äôs greatest test suite does us no good, though, if it\ntakes too long to run. How long is too long? Well, if we‚Äôre running\ntests every few minutes, clearly even a few minutes is too long. We\nsimply won‚Äôt run the tests often enough to get the fast feedback we need\nfrom them.</p><blockquote><p><em>By running the test suite frequently, at least several times a\nday, you‚Äôre able to detect bugs soon after they are introduced, so you\ncan just look in the recent changes, which makes it much easier to find\nthem.</em>\n‚ÄîMartin Fowler, <a href=\"https://martinfowler.com/bliki/SelfTestingCode.html\">‚ÄúSelf-Testing\nCode‚Äù</a></p></blockquote><p>One way or the other, then, we don‚Äôt want to be more than about five\nminutes away from passing tests. So, again, how long is \nlong for a test suite to run?</p><p>Kent Beck suggests that ten minutes is a psychologically significant\nlength of time:</p><blockquote><p><em>The equivalent of 9.8 m/s¬≤ is the ten-minute test suite. Suites\nthat take longer than ten minutes inevitably get trimmed, or the\napplication tuned up, so the suite takes ten minutes again.</em>\n‚ÄîKent Beck, <a href=\"https://amzn.to/3OR9pqg\">‚ÄúTest-Driven Development\nby Example‚Äù</a></p></blockquote><p>We may perhaps call this psychological limit the .\nBeyond the ten-minute mark, the problem is so obvious to everybody that\npeople are willing to put effort into speeding up the test suite. Below\nthat time, people will probably grumble but put up with it.</p><p>That certainly doesn‚Äôt mean that a ten-minute test suite is okay:\nit‚Äôs not, for the reasons we‚Äôve discussed. Let‚Äôs look at a few simple\nways to reduce the overall run-time of the test suite to something more\nmanageable.</p><ol type=\"1\"><li><p>. The inability to run certain\ntests in parallel is usually a design smell. Refactor so that each test\nhas its own world, touches no global state, and can thus run in\nparallel. Adding parallelism to a suite that doesn‚Äôt have it should\nspeed it up by about an order of magnitude.</p></li><li><p><strong>Eliminate unnecessary I/O</strong>. Once you go off the\nchip, things get slow. Do everything on the chip as far as possible,\navoiding I/O operations such as network calls or accessing disk files.\nFor example, you could use an  as an in-memory\nfilesystem, and memory-backed s and\ns instead of real files.</p></li><li><p>. Instead of calling some\nremote API, call a local fake instead. Local networking happens right in\nthe kernel, and while it‚Äôs still not , it‚Äôs a lot faster\nthan actually going out onto the wire.</p></li><li><p><strong>Share fixtures between tests</strong>. Any time you have\nsome expensive fixture setup to do, such as loading data into a\ndatabase, try to share its cost between as many tests as possible, so\nthat they can all use it. If necessary, do the setup in a single test\nand then run a bunch of subtests against it.</p><p>However, we need to be careful that the tests don‚Äôt then become flaky\nas a result of too much fixture sharing. A flaky test is worse than a\nslow test.</p></li><li><p>. A test that can‚Äôt proceed until\nsome concurrent operation has completed should use the ‚Äúwait for\nsuccess‚Äù pattern (loop and retry, with a tiny delay, until the operation\nhas completed). This minimises wasted time, whereas a long fixed sleep\nmaximises it (or causes flaky tests, which is also bad).</p></li><li><p><strong>Throw hardware at the problem</strong>. When you‚Äôve made\nthe test suite as fast as it can go and it‚Äôs still slow, just run it on\na faster computer. If the tests are mostly CPU-bound, rent a 256-core\ncloud machine and have it pull and run the tests on demand. CPU time\ncosts a lot less than programmer time, especially since hiring cheap\nprogrammers is a false economy.</p></li><li><p>. This is a last resort,\nbut it might come to that. If you have a few tests that simply\n be speeded up any more, and they‚Äôre dragging down the\nrest of the suite, extract them to a separate ‚Äúslow test‚Äù suite, and run\nit on a schedule. Every night, perhaps; certainly no less frequently\nthan that. Even nightly isn‚Äôt great, but it‚Äôs better than not running\ntests at all.</p></li></ol>","contentLength":9340,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"A continued focus on the benefits of Go 1.24","url":"https://golangweekly.com/issues/540","date":1738108800,"author":"","guid":614,"unread":true,"content":"<li><p><a href=\"https://golangweekly.com/link/164971/rss\">SRCL</a> is a neat new suite of React components for creating webapps with a monospaced, terminal-style aesthetic.</p></li><li><p>If you ever need to work with JavaScript server-side, <a href=\"https://golangweekly.com/link/164972/rss\">Bun 1.2</a> is a huge release for an increasingly popular, high performance -based Node-a-like. It 'just works' for a lot of stuff where Node gives me&nbsp;headaches.</p></li><li><p><a href=\"https://golangweekly.com/link/164974/rss\">Take a look at every byte</a> that goes over the network when making a real Postgres query over TLS . Everything is annotated to help you understand the&nbsp;complexity.</p></li>","contentLength":483,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Go 1.24 Release Candidate 2","url":"https://golangweekly.com/issues/539","date":1737504000,"author":"","guid":613,"unread":true,"content":"<li><p><a href=\"https://golangweekly.com/link/164583/rss\">VHS 0.9</a> ‚Äì CLI 'home video recorder'. <em>\"Write terminal GIFs as code for integration testing and demoing your CLI&nbsp;tools.\"</em> v0.9 adds a  keyword for waiting for certain conditions before continuing&nbsp;.</p></li><li><p>ü§ñ <a href=\"https://golangweekly.com/link/164584/rss\">Mods 1.7</a> ‚Äì Charm's pipeline-able AI CLI client. Now with improved GitHub Copilot support and OpenAI o1&nbsp;support.</p></li><li><p>‚òéÔ∏é <a href=\"https://golangweekly.com/link/164585/rss\">phonenumbers 1.5</a> ‚Äì Go port of Google's libphonenumber library for parsing and validating phone&nbsp;numbers.</p></li><li><p><a href=\"https://golangweekly.com/link/164586/rss\">GoReleaser 2.6</a> ‚Äì Build/release binaries for multiple&nbsp;platforms. v2.6 gains Bun and Deno support.</p></li><li><p><a href=\"https://golangweekly.com/link/164588/rss\">Notify 1.3</a> ‚Äì Library to send notifications to various&nbsp;services.</p></li><li><p><a href=\"https://golangweekly.com/link/164591/rss\">sqlc 1.28</a> ‚Äì Generate type-safe Go code from&nbsp;SQL.</p></li>","contentLength":646,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["go"]}