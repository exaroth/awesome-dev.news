{"id":"KRywisgR8sLBktB","title":"JS/Frontend","displayTitle":"JS/Frontend","url":"","feedLink":"","isQuery":true,"isEmpty":false,"isHidden":false,"itemCount":8,"items":[{"title":"TypeScript: checking Map keys and Array indices","url":"https://2ality.com/2025/06/checking-map-keys-array-indices-typescript.html","date":1750464000,"author":"Dr. Axel Rauschmayer","guid":164368,"unread":true,"content":"<p>JavaScript has two common patterns:</p><ul><li>Maps: We check the existence of a key via  before retrieving the associated value via .</li><li>Arrays: We check the length of an Array before performing an indexed access.</li></ul><p>These patterns don’t work as well in TypeScript. This blog post explains why and presents alternatives.</p>","contentLength":303,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Color Everything in CSS","url":"https://css-tricks.com/color-everything-in-css/","date":1750428252,"author":"Juan Diego Rodríguez","guid":163589,"unread":true,"content":"<p>And I must admit: I didn’t know a lot about color in CSS (I still used&nbsp;, which apparently isn’t what cool people do anymore), so it has been a fun learning experience. One of the things I noticed while trying to keep up with all this new information was how long the glossary of color goes, especially the&nbsp;“color”&nbsp;concepts. There are “color spaces,” “color models,” “color gamuts,” and basically a “color” something for everything.</p><p>They are all somewhat related, and it can get confusing as you dig into using color in CSS, especially the new color functions that have been shipped lately, like  and . Hence, I wanted to make the glossary I wish I had when I was hearing for the first time about each concept, and that anyone can check whenever they forget what a specific “color” thing is.</p><p>As a disclaimer, I am not trying to explain color, or specifically, color reproduction, in this post; that would probably be impossible for a mortal like me. Instead, I want to give you a big enough picture for some technicalities behind color in CSS, such that you feel confident using functions like&nbsp;&nbsp;or&nbsp;&nbsp;while also understanding what makes them special.</p><p>Let’s slow down first. In order to understand&nbsp;&nbsp;in&nbsp;, we first need to understand the&nbsp;&nbsp;in&nbsp;.</p><blockquote><p>Light waves are out there in the world, but color happens in the interaction between light waves and the eye, brain, and mind.</p></blockquote><p>Even if color isn’t a physical thing, we still want to replicate it as reliably as possible, especially in the digital era. If we take a photo of a beautiful bouquet of lilies (like the one on my desk) and then display it on a screen, we expect to see the same colors in both the image and reality. However, “reality” here is a misleading term since, once again, the&nbsp;&nbsp;of color depends on the viewer. To solve this, we need to understand how light wavelengths (something measurable and replicable) create different color responses in viewers (something not so measurable).</p><p>Luckily, this task was already carried out 95 years ago by the International Commission on Illumination (CIE, by its French name). I wish I could get into the details of the experiment, but we haven’t gotten into our first color thingie yet. What’s important is that from these measurements, the CIE was able to map all the colors visible to the average human (in the experiment) to light wavelengths and describe them with only three values.</p><p>This new color space also has three values, X and Z represent the chromaticity of a color, while Y represents its luminance. Since it has three axes, it makes a 3D shape, but if we slice it such that its luminance is the same, we get all the visible colors for a given luminance in a figure you have probably seen before.</p><p>This is called the&nbsp; diagram&nbsp;and holds  the colors visible by the average human eye (based on the average viewer in the CIE 1931 experiment). Colors inside the shape are considered real, while those outside are deemed imaginary.</p><p>The purpose of the last explanation was to reach the CIEXYZ&nbsp;Color Space&nbsp;concept, but what exactly is a “color space”? And why is the CIEXYZ&nbsp;&nbsp;so important?</p><p>The CIEXYZ Color Space is a mapping from all the colors visible by the average human eye into a 3D coordinate system, so we only need three values to define a color. Then, a&nbsp;<strong>color space can be thought of as a general mapping of color</strong>, with no need to include every visible color, and it is usually defined through three values as well.</p><p>The most well-known color spaces are the RGB color spaces (note the plural). As you may guess from the name, here we only need the amount of red, green, and blue to describe a color. And to describe an RGB color space, we only need to define its “reddest”, “greenest”, and “bluest” values. If we use coordinates going from 0 to 1 to define a color in the RGB color space, then:</p><ul><li>&nbsp;means the reddest color.</li><li>&nbsp;means the greenest color.</li><li>&nbsp;means the bluest color.</li></ul><p>However, “reddest”, “bluest”, and “greenest” are only arbitrary descriptions of color. What makes a color the “bluest” is up to each person. For example, which of the following colors do you think is the bluest?</p><p>As you can guess, something like “bluest” is an appalling description. Luckily, we just have to look back at the CIEXYZ color space — it’s pretty useful! Here, we can define what we consider the reddest, greenest, and bluest colors just as coordinates inside the xy chromaticity diagram. That’s all it takes to create an RGB color space, and why there are so many!</p><p>In CSS, the most used color space is the standard RGB (sRGB) color space, which, as you can see in the last image, leaves a lot of colors out. However, in CSS, we can use modern RGB color spaces with a lot more colors through the&nbsp;<a href=\"https://css-tricks.com/almanac/functions/c/color/\"></a>&nbsp;function, such as&nbsp;,&nbsp;, and&nbsp;.</p><p>Notice how the ProPhoto RGB color space goes out of the visible color. This is okay. Colors outside are clamped; they aren’t new or invisible colors.</p><p>In CSS, besides sRGB, we have two more color spaces: the CIELAB color space and the Oklab color space. Luckily, once we understood what the CIEXYZ color space is, then these two should be simpler to understand. Let’s dig into that next.</p><h4>CIELAB and Oklab Color Spaces</h4><p>As we saw before, the sRGB color space lacks many of the colors visible by the average human eye. And as modern screens got better at displaying more colors, CSS needed to adopt newer color spaces to fully take advantage of those newer displays. That wasn’t the only problem with sRGB — it also lacks perceptual uniformity, meaning that changes in the color’s chromaticity also change its perceived lightness. Check, for example, this&nbsp;<a href=\"https://developer.chrome.com/docs/css-ui/high-definition-css-color-guide#overview\" rel=\"noopener\">demo by Adam Argyle</a>:</p><p>Created in 1976 by the CIE, CIELAB, derived from CIEXYZ, also encompasses all the colors visible by the human eye. It works with three coordinates: L&nbsp;for perceptual lightness, a&nbsp;for the amount of red-green, and b* for the amount of yellow-blue in the color.</p><p>It has a way better perceptual uniformity than sRGB, but it still isn’t completely uniform, especially in gradients involving blue. For example, in the following white-to-blue gradient, CIELAB shifts towards purple.</p><p>As a final improvement,&nbsp;<a href=\"https://bottosson.github.io/posts/oklab/\" rel=\"noopener\">Björn Ottosson</a>&nbsp;came up with the Oklab color space, which also holds all colors visible by the human eye while keeping a better perceptual uniformity. Oklab also uses the three&nbsp;&nbsp;coordinates. Thanks to all these improvements, it is the color space I try to use the most lately.</p><p>When I was learning about these concepts, my biggest challenge after understanding color spaces was not getting them confused with color models and color gamuts. These two concepts, while complementary and closely related to color spaces, aren’t the same, so they are a common pitfall when learning about color.</p><p>A  refers to the mathematical description of color through tuples of numbers, usually involving three numbers, but these values don’t give us an exact color until we pair them with a color space. For example, you know that in the RGB color model, we define color through three values: red, green, and blue. However, it isn’t until we match it to an RGB color space (e.g., sRGB with&nbsp;display-p3) that we have a color. In this sense, a color space can have several color models, like sRGB, which uses RGB, HSL, and HWB. At the same time, a color model can be used in several color spaces.</p><p>I found plenty of articles and tutorials where “color spaces” and “color models” were used interchangeably. And some places were they had a different definition of color spaces and models than the one provided here. For example, Chrome’s&nbsp;<a href=\"https://developer.chrome.com/docs/css-ui/high-definition-css-color-guide#what_is_a_color_space\" rel=\"noopener\">High definition CSS color guide</a>&nbsp;defines CSS’s RGB and HSL as different color spaces, while MDN’s&nbsp;<a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Color_space#rgb_color_spaces\" rel=\"noopener\">Color Space entry</a>&nbsp;does define RGB and HSL as part of the sRGB color space.</p><p>Personally, in CSS, I find it easier to understand the idea of RGB, HSL and HWB as different models to access the sRGB color space.</p><p>A  is more straightforward to explain. You may have noticed how we have talked about a color space having more colors than another, but it would be more correct to say it has&nbsp;a “wider” gamut, since a color gamut is the&nbsp;range of colors available in a color space. However, a color gamut isn’t only restricted by color space boundaries, but also by physical limitations. For example, an older screen may decrease the color gamut since it isn’t able to display each color available in a given color space. In this case where a color can’t be represented (due to physical limitation or being outside the color space itself), it’s said to be “out of gamut”.</p><p>In CSS, the only color space available used to be sRGB. Nowadays, we can work with a lot of modern color spaces through their respective color functions. As a quick reference, each of the color spaces in CSS uses the following functions:</p><ul><li>&nbsp;We can work in sRGB using the ol’ hexadecimal notation, named colors, and the&nbsp;,&nbsp;,&nbsp;,&nbsp;&nbsp;and&nbsp;&nbsp;functions.</li><li>&nbsp;Here we have the&nbsp;&nbsp;for Cartesian coordinates and&nbsp;&nbsp;for polar coordinates.</li><li>&nbsp;Similar to CIELAB, we have&nbsp;&nbsp;for Cartesian coordinates and&nbsp;&nbsp;for polar coordinates.</li><li><strong>More through the&nbsp;&nbsp;and&nbsp;.</strong>&nbsp;Outside these three color spaces, we can use many more using the&nbsp;&nbsp;and&nbsp;&nbsp;functions. Specifically, we can use the RGB color spaces:&nbsp;,&nbsp;,&nbsp;,&nbsp;,&nbsp;&nbsp;and the XYZ color space:&nbsp;,&nbsp;, or&nbsp;.</li></ul><ol><li> are a mapping between available colors and a coordinate system. In CSS, we have three main color spaces: sRGB, CIELAB, and Oklab, but many more are accessible through the&nbsp;&nbsp;function.</li><li> define color with tuples of numbers, but they don’t give us information about the actual color until we pair them with a color space. For example, the RGB model doesn’t mean anything until we assign it an RGB color space.</li><li>Most of the time, we want to talk about how many colors a color space holds, so we use the term  for the task. However, a color gamut is also tied to the physical limitations of a camera/display. A color may be out-of-gamut, meaning it can’t be represented in a given color space.</li><li>In CSS, <strong>we can access all these color spaces through color functions</strong>, of which there are many.</li><li>The  is extremely useful to define other color spaces, describe their gamuts, and convert between them.</li></ol><p> Light is the main cause of color, but color can be created by things other than light. For example, rubbing your closed eyes mechanically stimulates your retina, creating color in what’s&nbsp;<a href=\"https://en.wikipedia.org/wiki/Phosphene\" rel=\"noopener\">called phosphene</a>. <a href=\"https://css-tricks.com/color-everything-in-css/#footnote-1\">⤴️</a></p><p> If &nbsp;also makes you scratch your head, and for more info on how the CIEXYZ color space was created, I highly recommend Douglas A. Kerr&nbsp;<a href=\"http://dougkerr.net/Pumpkin/articles/CIE_XYZ.pdf\" rel=\"noopener\"><em>The CIE XYZ and xyY Color Spaces</em></a>&nbsp;paper. <a href=\"https://css-tricks.com/color-everything-in-css/#footnote-2\">⤴️</a></p><p>&nbsp;We also need to define the darkest dark color (“black”) and the lightest light color (“white”). However, for&nbsp;<a href=\"https://ninedegreesbelow.com/photography/well-behaved-profile.html\" rel=\"noopener\">well-behaved</a>&nbsp;color spaces, these two can be abstracted from the reddest, blues, and greenest colors. <a href=\"https://css-tricks.com/color-everything-in-css/#footnote-3\">⤴️</a></p>","contentLength":10838,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Dr. Axel's JavaScript flashcards","url":"https://javascriptweekly.com/issues/741","date":1750377600,"author":"","guid":163552,"unread":true,"content":"<p>🚀 Build VueJS forms your way with <a href=\"https://javascriptweekly.com/link/170775/rss\">Enforma</a> — UI-agnostic (PrimeVue, Vuetify, Quasar), schema-ready, repeatable fields, powerful&nbsp;validation.</p><p>🎤 First speakers at JSNation US: Addy Osmani, Scott Tolinski, Ryan Carniato &amp; more! Nov 17 &amp; 20 in NYC &amp; online. <a href=\"https://javascriptweekly.com/link/170776/rss\">Early Bird going&nbsp;fast!</a></p>","contentLength":283,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"CSS Color Functions","url":"https://css-tricks.com/css-color-functions/","date":1750345278,"author":"Sunkanmi Fafowora","guid":162907,"unread":true,"content":"<p>If you asked me a few months ago, “What does it take for a website to stand out?” I may have said fancy animations, creative layouts, cool interactions, and maybe just the general aesthetics, without pointing out something in particular. If you ask me now, after working on color for the better part of the year, I can confidently say&nbsp;it’s all color. Among all the aspects that make a design, a good color system will make it as beautiful as possible.</p><p>However, color in CSS can be a bit hard to fully understand since there are many ways to set the same color, and sometimes they even look the same, but underneath are completely different technologies. That’s why, in this guide, we will walk through&nbsp;&nbsp;the ways you can set up colors in CSS and&nbsp;&nbsp;the color-related properties out there!</p><p>They are in your phone, in what your eye sees, and on any screen you look at; they essentially capture everything. Design-wise, I see the amazing use of colors on sites listed over at&nbsp;<a href=\"https://www.awwwards.com/websites/colorful/\" rel=\"noopener\">awwwards.com</a>, and I’m always in awe.</p><p>Not all color is the same. In fact, similar colors can live in different worlds, known as color spaces. Take for example, sRGB, the color space used on the web for the better part of its existence and hence the most known. While it’s the most used, there are many colors that are simply missing in sRGB that new color spaces like&nbsp;<a href=\"https://en.wikipedia.org/wiki/CIELAB_color_space\" rel=\"noopener\">CIELAB</a>&nbsp;and&nbsp;<a href=\"https://en.wikipedia.org/wiki/Oklab_color_space\" rel=\"noopener\">Oklab</a>&nbsp;bring, and they cover&nbsp;<a href=\"https://rmit.pressbooks.pub/colourtheory1/chapter/colour-spaces-or-gamuts/\" rel=\"noopener\">a wider range of colors sRGB could only dream of</a>, but don’t let me get ahead of myself.</p><p>A color space is the way we arrange and represent colors that exist within a device, like printers and monitors. We have different types of color spaces that exist in media (Rec2020, Adobe RGB, etc), but not all of them are covered in CSS. Luckily, the ones we have are sufficient to produce all the awesome and beautiful colors we need. In this guide, we will be diving into the three main color spaces available in CSS: sRGB, CIELAB, and OkLab.</p><p>The sRGB is one of the first color spaces we learn. Inside, there are three color functions, which are essentially notations to define a color:&nbsp;,&nbsp;, and&nbsp;.</p><p>sRGB has been a standard color space for the web&nbsp;<a href=\"https://www.w3.org/Graphics/Color/sRGB.html\" rel=\"noopener\">since 1996</a>. However, it’s closer to how old computers represented color, rather than how humans understand it, so it had some problems like&nbsp;not being able to capture the full gamut of modern screens. Still, many modern applications and websites use sRGB, so even though it is the “old way” of doing things, it is still widely accepted and used today.</p><p>The CIELAB color space is a relatively new color space on the web that represents a wider color gamut, closer to what the human eye can see, so it holds a lot more color than the sRGB space.</p><p>Perceptual uniformity occurs when there’s a smooth change in the direction of a gradient color from one point to another. If you notice stark contrasts like the example below for&nbsp;&nbsp;when transitioning from one hue to another, that is referred to as a non-uniform perceptual colormap.</p><p>Notice how the change from one color to another is the same in&nbsp;&nbsp;without any stark contrasts as opposed to&nbsp;? Yeah, OKLab color space solves the stark contrasts present and gives you access to many more colors not present in sRGB.</p><p>OKlab actually provides a better saturation of colors while still maintaining the hue and lightness present in colors in CIELAB (and even a smoother transition between colors!).</p><p>The&nbsp;&nbsp;function allows access to colors in nine different color spaces, as opposed to the previous color functions mentioned, which only allow access to one.</p><p>To use this function, you must simply be aware of these 6 parameters:</p><ul><li>The first value specifies the&nbsp;&nbsp;you want to access colors from. They can either be , , , , , , , , or </li><li>The next three values (, , and ) specifies the coordinates in the color space for the color ranging from&nbsp;&nbsp;–&nbsp;.</li><li>The sixth and final value is its alpha value for color’s opacity. The value’s range is from&nbsp; (or )&nbsp;to&nbsp; (or ).</li></ul><p>The&nbsp;&nbsp;function mixes two colors of any type in a given color space. Basically, you can create an endless number of colors with this method and explore more options than you normally would with any other color function. A pretty powerful CSS function, I would say.</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.element {\n  color-mix(in oklab, hsl(40 20 60) 80%, red 20%);\n}</code></pre><p>You’re basically mixing two colors of any type in a color space. Do take note, the accepted color spaces here are different from the color spaces accepted in the  function.</p><p>To use this function, you must be aware of these three values:</p><ul><li>The first value&nbsp;&nbsp;specifies the interpolation method used to mix the colors, and these can be any of these 15 color spaces: , , , , , , , , , , , , , , and .</li><li>The second and third values specifies an accepted color value and a percentage from&nbsp;&nbsp;to&nbsp;.</li></ul><h2>The Relative Color Syntax</h2><p>Here’s how it works. We have:</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.element{\n  color-function(from origin-color c1 c2 c3 / alpha)\n}</code></pre><ul><li>The first value&nbsp;&nbsp;is a mandatory keyword you must set to extract the color values from&nbsp;.</li><li>The second value,&nbsp;, represents a color function or value or even another relative color that you want to get color from.</li><li>The next three values, c1, c2, and c3 represent the current color function’s color channels and they correspond with the color function’s  color values.</li><li>The sixth and final value is its alpha value for color’s opacity. The value’s range is from&nbsp; (or )&nbsp;to&nbsp; (or )&nbsp;which either set from the&nbsp;&nbsp;or set manually,</li></ul><p>Let’s take an example, say, converting a color from  to :</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.element {\n  color: lab(from rgb(255 210 01 / 0.5) l a b / a);\n}</code></pre><p>All the values above will be translated to the corresponding colors in&nbsp;. Now, let’s take a look at another example where we convert a color from  to :</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.element {\n    color: oklch(from rgb(255 210 01 / 0.5) 50% 20% h / a);\n}</code></pre><p>Although, the&nbsp;&nbsp;and&nbsp;&nbsp;values were changed, the&nbsp;&nbsp;and&nbsp;&nbsp;would be taken from the original color, which in this case is a light yellowish color in&nbsp;.</p><p>You can even be wacky and use math functions:</p><p>All CSS color functions support the <a href=\"https://www.w3.org/TR/css-color-5/#relative-colors\" rel=\"noopener\">relative color syntax</a>. The relative color syntax, simply put, is a way to access other colors in another color function or value, then translating it to the values of the current color function. It goes “from&nbsp;” to another.</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.element {\n  color: oklch(from rgb(255 210 01 / 0.5) calc(50% + var(--a)) calc(20% + var(--b)) h / a);\n}</code></pre><p>The relative color syntax is, however, different than the&nbsp;&nbsp;function in that you have to include the color space name and then fully write out the channels, like this:</p><pre rel=\"CSS\" data-line=\"\"><code markup=\"tt\">.element {\n  color: color(from origin-color colorspace c1 c2 c3 / alpha);\n}</code></pre><p>Remember, the&nbsp;&nbsp;function is not a part of this. You can have relative color functions inside the color functions you want to mix, yes, but the relative color syntax is not available in&nbsp;&nbsp;directly.</p><p>CSS is totally capable of transitioning from one color to another. See the <a href=\"https://css-tricks.com/a-complete-guide-to-css-gradients/\">“CSS Gradients Guide”</a> for a full run-down, including of the different types of gradients with examples.</p><h2>Properties that support color values</h2><p>There are&nbsp;&nbsp;of properties that support the use of color. Just so you know, this list does not contain deprecated properties.</p><h2>Related articles &amp; tutorials</h2>","contentLength":7120,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"How TypeScript solved its global Iterator name clash","url":"https://2ality.com/2025/06/typescript-iterator-types.html","date":1750204800,"author":"Dr. Axel Rauschmayer","guid":161215,"unread":true,"content":"<p>In ECMAScript 2025, JavaScript gets a class  with iterator helper methods. This class conflicts with TypeScript’s existing types for iterators. In this blog post, we explore why that is and how TypeScript solves that conflict.</p>","contentLength":228,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"This Week In React #239: ViewTransition, Suspense, TanStack, Zero, use-mcp, Compiler, Intl-T | 0.80, Stable APIs, iOS prebuilds, shadcn, Expo, InstantDB, Granite | TypeBuddy, Hono, H3, Playwright, cosmos.gl","url":"https://thisweekinreact.com/newsletter/239","date":1750204800,"author":"","guid":161337,"unread":true,"content":"<p>It's been a fairly calm week for the React ecosystem, but not for the React Native world. Meta has made an exciting announcement about the release of React Native 0.80, where they've decided to officially freeze the Old Architecture. Make sure you're ready to adapt your app to the New Architecture, as it seems like it could be the last moment to do so.</p><p>As always, thanks for supporting us on your favorite platform:</p><p><a href=\"https://coderabbit.link/6ZXULSK\" target=\"_blank\" rel=\"noopener noreferrer\">CodeRabbit</a> is the AI code review platform purpose built to speed up code reviews and improve code quality. Integrating seamlessly into git workflows and existing toolchains, it delivers codebase-aware reviews and supports all programming languages.</p><p>Now they are excited to deliver AI code reviews directly in VS Code, Cursor, and Windsurf–letting you and your team (vibe) code with confidence and review while keeping in flow.</p><p>Even better: code reviews in the IDE are free! That’s right: line-by-line reviews and one-click fixes, all in your IDE at no cost to you.&nbsp;</p><p>Want to understand where technical performance actually impacts user engagement? With Embrace Web RUM, you can connect telemetry to what users are actually experiencing, so you know what's broken, why it matters, and how to fix it.&nbsp;</p><p>Full session timelines. Core Web Vitals and JS exceptions in context. User journeys for custom flows with intelligent issue correlation. Built on OpenTelemetry for powerful integration with existing observability systems.</p><ul><li>React 19.1: Its new  API can improve the DX of error overlays.</li><li>JavaScript deep imports deprecation: You’ll have to import everything from the root  exports.</li><li>Strict TypeScript API (opt in): The Strict TypeScript API is an opt-in preview offering more accurate TypeScript types for the react-native package, generated directly from source code.</li><li>Legacy Architecture Freezing &amp; Warnings: The React Native team will now focus on the New Architecture.</li><li>iOS Prebuilds for React Native: iOS builds are roughly 12% faster thanks to shipping prebuilds for Folly and GLog rather than building them from source. In a future release, the rest of React Native core will be shipped as a prebuild.</li></ul>","contentLength":2116,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"How to Keep Up With New CSS Features","url":"https://css-tricks.com/how-to-keep-up-with-new-css-features/","date":1750165995,"author":"Sacha Greif","guid":159592,"unread":true,"content":"<p>How do you keep up with new CSS features?</p><p>Let’s say for example that, hypothetically speaking, you run a popular web development survey focused on CSS, and need to figure out what to include in this year’s edition. (In a&nbsp;&nbsp;coincidence the aforementioned State of CSS survey for this year is actually open right now —&nbsp;<a href=\"https://survey.devographics.com/en-US/survey/state-of-css/2025?source=css_tricks_keeping_up\" rel=\"noopener\">go take it to see what’s new in CSS!</a>)</p><p>You might think you can just type “new CSS features 2025” in Google and be done with it. But while this does give us a few promising leads, it also unearths a lot of cookie-cutter content that proclaims CSS Grid as the “next big thing”, despite the fact it’s been well-supported for over eight years now.&nbsp;</p><p>We need a better approach.&nbsp;</p><p><em>I’ll focus on CSS in this article, but all the resources linked here cover all web platform features, including JavaScript and HTML.</em></p><p>The browsers themselves are often a good source of what’s new and, thankfully, the big ones maintain blogs where they even cover specific CSS news.</p><p>A good general starting point is Google’s&nbsp;<a href=\"https://web.dev/blog?hl=en\" target=\"_blank\" rel=\"noreferrer noopener\">web.dev</a>&nbsp;blog, and more specifically&nbsp;<a href=\"https://bsky.app/profile/rachelandrew.bsky.social\" target=\"_blank\" rel=\"noreferrer noopener\">Rachel Andrew</a>‘s monthly web platform recaps. Here’s a small sample of those:</p><p>I’d be remiss to not mention that <a href=\"https://css-tricks.com/\" target=\"_blank\" rel=\"noreferrer noopener\">CSS-Tricks</a>&nbsp;is also a great source for up-to-date CSS knowledge, including an ever-growing <a href=\"https://css-tricks.com/almanac/\">almanac of CSS features</a>. But you probably already know that since you’re reading this.</p><p>And let’s not discount other fine publications that cover CSS. Here are just a few:</p><p>Following individual sources can get a little overwhelming, particularly when CSS is moving as fast as it is. That’s where <a href=\"https://frontenddogma.com\" rel=\"noopener\">Frontend Dogma</a> comes in with an ever-growing and updated list of curated links from these (and many other sources) in a one-stop shop.</p><p>Another very cool feature is the ability to view a feature’s adoption rate, as measured in terms of percentage of Chrome page views where that feature was used, such as here for the&nbsp;&nbsp;HTML attribute:</p><p>An important caveat: since sites like Facebook and Google account for a very large percentage of all measured page views, this metric can become skewed once one of these platforms adopts a new feature.</p><p>The Web Platform Status’s&nbsp;<a href=\"https://webstatus.dev/stats\" rel=\"noopener\">stats</a>&nbsp;section also features the “chart of shame” (according to&nbsp;<a href=\"https://bsky.app/profile/lea.verou.me/post/3lqdkh5cexc2y\" rel=\"noopener\">Lea Verou</a>), which highlights how certain browsers might be slightly lagging behind their peers in terms of new feature adoption.</p><p>That same adoption data can also be found on the&nbsp;<a href=\"https://chromestatus.com/roadmap\" target=\"_blank\" rel=\"noreferrer noopener\">Chrome Platform Status dashboard</a>, which gives you even more details, such as usage among top sites, as well as sample URLs of sites that are using a feature.&nbsp;</p><h3><a href=\"https://dev.to/sachagreif/how-to-keep-up-with-the-web-platform-506n-temp-slug-493011?preview=619f23b56568208f51ce715d46320d1ef2b4b3cdc621099b35734c635b8a9e7857bd509490d9985c09f950ad096b5e5305b236f1b3437f820b997071#polypane-experimental-chromium-features-dashboard\" rel=\"noopener\"></a>Polypane Experimental Chromium Features Dashboard</h3><h3><a href=\"https://dev.to/sachagreif/how-to-keep-up-with-the-web-platform-506n-temp-slug-493011?preview=619f23b56568208f51ce715d46320d1ef2b4b3cdc621099b35734c635b8a9e7857bd509490d9985c09f950ad096b5e5305b236f1b3437f820b997071#kevin-powell\" rel=\"noopener\"></a>Kevin Powell’s YouTube Channel</h3><p>Of course, you can always also go straight to the source and look at what the&nbsp;<a href=\"https://www.w3.org/groups/wg/css/publications/#wd\" target=\"_blank\" rel=\"noreferrer noopener\">CSS Working Group itself</a>&nbsp;has been working on! They have <a href=\"https://lists.w3.org/Archives/Public/www-style/\" rel=\"noopener\">a mailing list</a> you can subscribe to keep tabs on things straight from your inbox, as well as an <a href=\"https://www.w3.org/groups/wg/css/feed/\" rel=\"noopener\">RSS feed</a>.</p><p>Most browsers publish a set of release notes any time a new version ships. For the most part, you can get a good pulse on when new CSS features are released by following the three big names in browsers:</p><p>Another way to catch up with CSS is to just ask&nbsp;<a href=\"https://chat.openai.com/\" target=\"_blank\" rel=\"noreferrer noopener\">ChatGPT</a>! This sample prompt worked well enough for me:</p><blockquote><p>What are the latest CSS features that have either become supported by browsers in the past year, or will soon become supported?&nbsp;</p></blockquote><p>If you really want to get in the weeds, Igalia’s <a href=\"https://bcd-watch.igalia.com\" rel=\"noopener\">BCD Watch</a> displays changes to MDN’s&nbsp;<a href=\"https://github.com/mdn/browser-compat-data\" target=\"_blank\" rel=\"noreferrer noopener\">browser-compat-data repo</a>, which itself tracks which features are supported in which browsers.&nbsp;</p><p>Also, the latest editions of the HTTP Archive Web Almanac do not seem to include a CSS section specifically, but&nbsp;<a href=\"https://almanac.httparchive.org/en/2022/css\" target=\"_blank\" rel=\"noreferrer noopener\">past editions did feature one</a>, which was a great way to catch up with CSS once a year.&nbsp;</p><p>There’s also&nbsp;<a href=\"https://caniuse.com/\" target=\"_blank\" rel=\"noreferrer noopener\">caniuse</a>&nbsp;has a&nbsp;<a href=\"https://caniuse.com/ciu/news\" target=\"_blank\" rel=\"noreferrer noopener\">news section</a>&nbsp;which does not seem to be frequently updated at the moment, but could potentially become a great resource for up-to-date new feature info in the future.</p><p>And lastly, there’s a ton of folks on social media who are frequently discussing new CSS features and sharing their own thoughts and experiments with them. If you’re on Bluesky, <a href=\"https://bsky.app/starter-pack/css-tricks.com/3la2jvt37sh2s\">there’s a starter pack of CSS-Tricks authors</a> that’s a good spot to find a deep community of people.</p><p>Of course, another great way to make sure no new features are slipping through the cracks is to take the State of CSS survey once a year. I use all the resources mentioned above to try and make sure each survey includes every new important feature. What’s more, you can bookmark features by adding them to your “reading list” as you take the survey to get a nice recap at the end.</p><p>So go take this year’s&nbsp;<a href=\"https://survey.devographics.com/en-US/survey/state-of-css/2025?source=css_tricks_keeping_up\" rel=\"noopener\">State of CSS</a>&nbsp;survey and then let me know on&nbsp;<a href=\"https://bsky.app/profile/sachagreif.com\" rel=\"noopener\">Bluesky</a>&nbsp;how many new features you learned about!</p>","contentLength":4683,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"A Better API for the Resize Observer","url":"https://css-tricks.com/a-better-api-for-the-resize-observer/","date":1750078071,"author":"Zell Liew","guid":157259,"unread":true,"content":"<p>Resize Observer, Mutation Observer, and Intersection Observers are all good APIs that are more performant than their older counterparts:</p><p>The API for these three observers are quite similar (but they have their differences which we will go into later). To use an observer, you have to follow the steps below:</p><ol><li><strong>Create a new observer with the  keyword:</strong> This observer takes in an observer function to execute.</li><li><strong>Do something with the observed changes</strong>: This is done via the observer function that is passed into the observer.</li><li><strong>Observe a specific element</strong>: By using the  method.</li><li><strong>(Optionally) unobserve the element</strong>: By using the  or  method. (depending on which observer you’re using).</li></ol><p>In practice, the above steps looks like this with the .</p><pre rel=\"JavaScript\" data-line=\"\"><code markup=\"tt\">// Step 1: Create a new observer\nconst observer = new ResizeObserver(observerFn)\n\n// Step 2: Do something with the observed changes\nfunction observerFn (entries) {\n  for (let entry of entries) {\n    // Do something with entry\n  }\n}\n\n// Step 3: Observe an element\nconst element = document.querySelector('#some-element')\nobserver.observe(element);\n\n// Step 4 (optional): Disconnect the observer\nobserver.disconnect(element)</code></pre><p>This looks clear (and understandable) after the steps have been made clear. But it can look like a mess without the comments:</p><pre rel=\"JavaScript\" data-line=\"\"><code markup=\"tt\">const observer = new ResizeObserver(observerFn)\n\nfunction observerFn (entries) {\n  for (let entry of entries) {\n    // Do something with entry\n  }\n}\n\nconst element = document.querySelector('#some-element')\nobserver.observe(element);</code></pre><p>The good news is: I think we can improve the observer APIs and make them easier to use.</p><p>Let’s start with the  since it’s the simplest of them all. We’ll begin by writing a function that encapsulates the  that we create.</p><pre rel=\"JavaScript\" data-line=\"\"><code markup=\"tt\">function resizeObserver () {\n  // ... Do something\n}</code></pre><p>The easiest way to begin refactoring the  code is to put everything we’ve created into our  first.</p><pre rel=\"JavaScript\" data-line=\"\"><code markup=\"tt\">function resizeObserver () {\n  const observer = new ResizeObserver(observerFn)\n\n  function observerFn (entries) {\n    for (let entry of entries) {\n      // Do something with entry\n    }\n  }\n\n  const node = document.querySelector('#some-element')\n  observer.observe(node);\n}</code></pre><p>Next, we can pass the  into the function to make it simpler. When we do this, we can eliminate the  line.</p><pre rel=\"JavaScript\" data-line=\"\"><code markup=\"tt\">function resizeObserver (element) {\n  const observer = new ResizeObserver(observerFn)\n\n  function observerFn (entries) {\n    for (let entry of entries) {\n      // Do something with entry\n    }\n  }\n\n  observer.observe(node);\n}</code></pre><p>This makes the function more versatile since we can now pass any element into it.</p><pre rel=\"JavaScript\" data-line=\"\"><code markup=\"tt\">// Usage of the resizeObserver function\nconst node = document.querySelector('#some-element')\nconst obs = resizeObserver(node)</code></pre><p>This is already much easier than writing all of the  code from scratch whenever you wish to use it.</p><p>Next, it’s quite obvious that we have to pass in an observer function to the callback. So, we can potentially do this:</p><pre rel=\"JavaScript\" data-line=\"\"><code markup=\"tt\">// Not great\nfunction resizeObserver (node, observerFn) {\n  const observer = new ResizeObserver(observerFn)\n  observer.observe(node);\n}</code></pre><p>Since  is always the same — it loops through the  and acts on every  — we could keep the  and pass in a  to perform tasks when the element is resized.</p><pre rel=\"JavaScript\" data-line=\"\"><code markup=\"tt\">// Better \nfunction resizeObserver (node, callback) {\n  const observer = new ResizeObserver(observerFn)\n\n  function observerFn (entries) {\n    for (let entry of entries) {\n      callback(entry)\n    }\n  }\n\n  observer.observe(node);\n}</code></pre><p>To use this, we can pass  into the  — this makes  operate somewhat like an event listener which we are already familiar with.</p><pre rel=\"JavaScript\" data-line=\"\"><code markup=\"tt\">// Usage of the resizeObserver function\nconst node = document.querySelector('#some-element')\nconst obs = resizeObserver(node, entry =&gt; {\n  // Do something with each entry\n})</code></pre><p>We can make the callback slightly better by providing both  and . There’s no performance hit for passing an additional variable so there’s no harm providing more flexibility here.</p><pre rel=\"JavaScript\" data-line=\"6\"><code markup=\"tt\">function resizeObserver (element, callback) {\n  const observer = new ResizeObserver(observerFn)\n\n  function observerFn (entries) {\n    for (let entry of entries) {\n      callback({ entry, entries })\n    }\n  }\n\n  observer.observe(element);\n}</code></pre><p>Then we can grab  in the  if we need to.</p><pre rel=\"JavaScript\" data-line=\"\"><code markup=\"tt\">// Usage of the resizeObserver function\n// ...\nconst obs = resizeObserver(node, ({ entry, entries }) =&gt; {\n  // ...\n})</code></pre><p>Next, it makes sense to pass the callback as an option parameter instead of a variable. This will make  more consistent with the  and  functions that we will create in the next article.</p><pre rel=\"JavaScript\" data-line=\"1,2\"><code markup=\"tt\">function resizeObserver (element, options = {}) {\n  const { callback } = options\n  const observer = new ResizeObserver(observerFn)\n\n  function observerFn (entries) {\n    for (let entry of entries) {\n        callback({ entry, entries })\n      }\n  }\n\n  observer.observe(element);\n}</code></pre><p>Then we can use  like this.</p><pre rel=\"JavaScript\" data-line=\"\"><code markup=\"tt\">const obs = resizeObserver(node, {\n  callback ({ entry, entries }) {\n    // Do something ...\n  }\n})</code></pre><h3>The observer can take in an option too</h3><p>‘s  method can take in an <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver/observe#options\" rel=\"noopener\">options</a> object that contains one property, . This determines whether the observer will observe changes to ,  or .</p><p>So, we need to extract these options from the  object and pass them to .</p><pre rel=\"JavaScript\" data-line=\"\"><code markup=\"tt\">function resizeObserver (element, options = {}) {\n  const { callback, ...opts } = options\n  // ...\n  observer.observe(element, opts);\n}</code></pre><h3>Optional: Event listener pattern</h3><p>I prefer using  because it’s quite straightforward. But if you want to use a standard event listener pattern, we can do that, too. The trick here is to emit an event. We’ll call it  since  is already taken.</p><pre rel=\"JavaScript\" data-line=\"\"><code markup=\"tt\">function resizeObserver (element, options = {}) {\n  // ...\n  function observerFn (entries) {\n    for (let entry of entries) {\n      if (callback) callback({ entry, entries })\n      else {\n        node.dispatchEvent(\n          new CustomEvent('resize-obs', {\n            detail: { entry, entries },\n          }),\n        )\n      }\n    }\n  }\n\n  // ...\n}</code></pre><p>Then we can listen to the  event, like this:</p><pre rel=\"JavaScript\" data-line=\"\"><code markup=\"tt\">const obs = resizeObserver(node)\nnode.addEventListener('resize-obs', event =&gt; {\n  const { entry, entries } = event.detail\n})</code></pre><p>One final step is to allow the user to stop observing the element(s) when observation is no longer required. To do this, we can return two of the  methods:</p><ul><li>: Stops observing one <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element\" rel=\"noopener\"></a></li></ul><pre rel=\"JavaScript\" data-line=\"\"><code markup=\"tt\">function resizeObserver (node, options = {}) {\n  // ...\n  return {\n    unobserve(node) {\n      observer.unobserve(node)\n    },\n    \n    disconnect() {\n      observer.disconnet()\n    }\n  }\n}</code></pre><p>Both methods do the same thing for what we have built so far since we only allowed  to observe one element. So, pick whatever method you prefer to stop observing the element.</p><pre rel=\"JavaScript\" data-line=\"\"><code markup=\"tt\">const obs = resizeObserver(node, {\n  callback ({ entry, entries }) {\n    // Do something ...\n  }\n})\n\n// Stops observing all elements \nobs.disconect()</code></pre><p>With this, we’ve completed the creation of a better API for the  — the  function.</p><p>Here’s the code we’ve wrote for </p><pre rel=\"JavaScript\" data-line=\"\"><code markup=\"tt\">export function resizeObserver(node, options = {}) {\n  const observer = new ResizeObserver(observerFn)\n  const { callback, ...opts } = options\n\n  function observerFn(entries) {\n    for (const entry of entries) {\n      // Callback pattern\n      if (callback) callback({ entry, entries, observer })\n      // Event listener pattern\n      else {\n        node.dispatchEvent(\n          new CustomEvent('resize-obs', {\n            detail: { entry, entries, observer },\n          })\n        )\n      }\n    }\n  }\n \n  observer.observe(node)\n\n  return {\n    unobserve(node) {\n      observer.unobserve(node)\n    },\n    \n    disconnect() {\n      observer.disconnect()\n    }\n  }\n}</code></pre><h3>Using this in practice via Splendid Labz</h3><p>Splendid Labz has a <a href=\"https://splendidlabz.com/docs/utils\" rel=\"noopener\"></a> library that contains an enhanced version of the  we made above. You can use it if you wanna use a enhanced observer, or if you don’t want to copy-paste the observer code into your projects.</p><pre rel=\"JavaScript\" data-line=\"\"><code markup=\"tt\">import { resizeObserver } from '@splendidlabz/utils/dom'\n\nconst node = document.querySelector('.some-element')\nconst obs = resizeObserver(node, {\n  callback ({ entry, entries }) {\n    /* Do what you want here */\n  }\n})</code></pre><p> The Splendid Labz  is capable of observing multiple elements at once. It can also unobserve multiple elements at once.</p><pre rel=\"JavaScript\" data-line=\"\"><code markup=\"tt\">const items = document.querySelectorAll('.elements')\nconst obs = resizeObserver(items, {\n  callback ({ entry, entries }) {\n    /* Do what you want here */\n  }\n})\n\n// Unobserves two items at once\nconst subset = [items[0], items[1]]\nobs.unobserve(subset) </code></pre><h3>Found this refactoring helpful?</h3><p>Refactoring is ultra useful (and important) because its a process that lets us create code that’s easy to use or maintain.</p><p>If you found this refactoring exercise useful, you might just love how I teach JavaScript to budding developers in my <a href=\"https://learnjavascript.today\" rel=\"noopener\">Learn JavaScript</a> course.</p><p>In this course, you’ll learn to build 20 real-world components. For each component, we start off simple. Then we add features and you’ll learn to refactor along the way.</p><p>Hope you enjoyed this piece and see you in the next one.</p>","contentLength":8889,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["frontend"]}