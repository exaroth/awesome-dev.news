{"id":"USgKoryE83j5SszZjyr68sh7DjLn4j6MWUagcNjQES7kQ1n2HXebXN4bJpBn8stf6LqSMrbny1unc4R1hi6qmf","title":"top scoring links : golang","displayTitle":"Reddit - Go","url":"https://www.reddit.com/r/golang/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/golang/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"Early-Exit Levenshtein implementation","url":"https://www.reddit.com/r/golang/comments/1iknb1u/earlyexit_levenshtein_implementation/","date":1739021467,"author":"/u/bitreducer","guid":390,"unread":true,"content":"<p>I just released Early-Exit Levenshtein, a package for calculating the Levenshtein distance with an optional early-exit threshold. It’s based on <strong>agnivade’s implementation</strong> and behaves the same if no threshold is provided. When a threshold is set, the library stops as soon as the distance exceeds it, saving CPU time when comparing long strings. In my case, while checking for duplicate posts, I achieved over a 100x speedup. </p>","contentLength":428,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Go for backend, Nextjs for front end","url":"https://www.reddit.com/r/golang/comments/1ikefo0/go_for_backend_nextjs_for_front_end/","date":1738987049,"author":"/u/Terrible_Dimension66","guid":392,"unread":true,"content":"<p>I’m building an app that sends PDFs to Pinecone and calls OpenAI APIs. Thinking of using Next.js for the frontend and Golang for processing and API calls, but is it worth it, or should I stick with Node.js for simplicity?</p><p>Also, are there any good tutorials on connecting Next.js with a Go backend? Googled but didn’t find much. Checked older threads here but no clear answer. Appreciate your help!</p>","contentLength":400,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Simple log/slog tracing: when OpenTelemetry is too much","url":"https://www.reddit.com/r/golang/comments/1ik42qn/simple_logslog_tracing_when_opentelemetry_is_too/","date":1738958231,"author":"/u/lzap","guid":391,"unread":true,"content":"<ul><li>Simple code instrumentation.</li><li>Serialization into  (structured logging library).</li><li>Handler with multiple sub-handlers for further processing.</li><li>Simple exporting slog handler for callback-based exporters.</li><li>Adding \"trace_id\" root field to all logs for easy correlation between logs and traces.</li></ul><p>Instrumentation is very similar:</p><pre><code>span, ctx := strc.Start(ctx, \"span name\") defer span.End() </code></pre><p>I found OpenTelemetry way too big for the job, the API breaks every so often and we were only interested in tracing capabilities. Also in our use case, we do not do a lot of tracing so there is no need for a proper UI tracing server infrastructure, database, collectors and agents. So I wrote this plus a simple CLI tool for quick inspection.</p><p>I thought I would share it, might be interesting for those who already integrated log/slog into their application and would like to have a very liitle tracing capability. The idea is that there could be a slog handler for OpenTelemetry if there is a need for that in the future. If anyone finds this useful let me know and I can extract this into a separate github repo, it is part of our team common logging utilities right now.</p>","contentLength":1142,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Setting up your own Bluesky feed in Go","url":"https://dhawos.dev/site/en/articles/bluesky-custom-feeds","date":1738957117,"author":"/u/dhawos","guid":389,"unread":true,"content":"<p>Bluesky is a decentralized alternative to Twitter. It is a platform that praises itself on being more open and putting users at the center of the ecosystem. One of the features that derives from this mantra is the ability for anyone to create their own custom newsfeed. Other users can then discover those feeds and display then on their homepage.</p><p>This opens up the possibility for anyone to build their own algorithm and select content based on specific topics or based on popularity metrics such as reposts and likes.</p><p>However, making such a feed is a pretty technical task. The purpose of this blog post is to walk you through the steps required to setup your own custom newsfeed, using the Go programming language. You don’t need to be a Go expert to understand what I’m going to explain, but some level of knowledge of the language will make following through a bit easier. You should also know that the official documentation provides examples in <a href=\"https://github.com/bluesky-social/feed-generator\">Typescript</a>. There are also community made templates for <a href=\"https://github.com/MarshalX/bluesky-feed-generator\">Python</a> and <a href=\"https://github.com/mackuba/bluesky-feeds-rb\">Ruby</a></p><p>To build you own newsfeed, you will have to complete several steps:</p><p><strong>1.Register the newsfeed on your Bluesky account:</strong>\nThis part is simply about running a script that will make the correct API calls to Bluesky to register your newsfeed. You will need to have a Bluesky account as the feed will appear under your profile. You will also need a domain that you own, that will also be used to host the custom feed server later.</p><p><strong>2.Index the content created on Bluesky:</strong>\nBefore being able to choose which posts users are going to see. You must first know what posts are available. To do we will record events that occur on the Bluesky network and save them inside our database to later decide which posts a user should see on our feed.</p><p>\nThe last task will be building a web server that will listen to Bluesky specific requests (as described in the protocol). The server’s job will be to decide which posts the user should see based on the request and make that reply to Bluesky, who will take care of fetching the posts information and hydrating the view.</p><p>Let’s see that in more details</p><p>It is the simplest task in the process. For our newsfeed to be usable, it must first be registered with Bluesky. It will then show up under our profile. To do so, we will use a little script which will use the <a href=\"https://pkg.go.dev/github.com/bluesky-social/indigo\">indigo</a> library which is the Bluesky SDK for Go.</p><pre tabindex=\"0\"><code></code></pre><p>Here is what it will look like (I’m omitting a portion of the code here for the sake of clarity). You will need to declare some information that will describe your feed:</p><pre tabindex=\"0\"><code></code></pre><p>Then, we will setup our client to talk to Bluesky API. For that, you will need your Bluesky handle (our nickname + domain). In my case this is <a href=\"https://bsky.app/profile/dhawos.bsky.social\">@dhawos.bsky.social</a>. You will also need an “application password” which you can generate <a href=\"https://bsky.app/settings/privacy-and-security\">here</a></p><pre tabindex=\"0\"><code></code></pre><p>If everything went well, please save the output carefully, you will need it later.\nYou should now also be able to see your new feed on your profile.</p><h2>2. Indexing content from Bluesky</h2><p>Now that your feed is created on Bluesky’s end, you need to set it up on your side. To suggest posts to your users, you first need to know which posts exist on the network.</p><p>We’ll use <a href=\"https://docs.bsky.app/blog/jetstream\">Jetstream</a> for this purpose, an open-source service provided by Bluesky that simplifies retrieving all content produced on the network. Note, however, that this service is not part of Bluesky’s official specifications and may change in the future. For now, it’s more user-friendly than the official(<a href=\"https://docs.bsky.app/docs/advanced-guides/firehose\">Firehose</a> feed.</p><p>We’ll also need a database, which we’ll use PostgreSQL. We’ll utilize its full-text search capabilities.</p><p>To implement this, we’ll create a process that runs continuously to monitor activity on the network and save relevant information to our database. This involves defining a struct that listens for events and saves pertinent data.</p><pre tabindex=\"0\"><code></code></pre><p>Now we will instanciate the listener in our main function</p><pre tabindex=\"0\"><code></code></pre><p>We have the basic structure for our program. Now, we need to implement the function that will listen for events. Before that, let’s understand the foundation of AtProto, which is the protocol BlueSky is built on. Each user has a “repository” similar to Git. Everything you produce as a user results in a new commit within a specific collection. That is what we did when we created our feed earlier. We created a new commit in the  collection with the relevant informations</p><p>For now, we’ll focus on listening to events related to the creation of commits. Other types of events, such as updates or deletions, are not relevant for our current purpose.</p><pre tabindex=\"0\"><code></code></pre><p>We still need to write the function that will save the post to the database:</p><pre tabindex=\"0\"><code></code></pre><p>We only need to call that function at the end of our :</p><pre tabindex=\"0\"><code></code></pre><p>With that set up, and the PostgreSQL running in the background, it should be possible to start the program with the command:</p><pre tabindex=\"0\"><code></code></pre><p>If all went well, you should be able to see posts coming to your database. Be warned that it might fill up pretty quickly as there can be a lot of activity on the network. We’ll see later how we can avoid the database growing forever.</p><h2>3. Writing your custom feed server</h2><p>With our database filling up, we should be able to build the last piece of the puzzle. To do so we will write a small webserver which will have two features:</p><ul><li>Validate our identity with Bluesky</li><li>Fulfill feed requests from Bluesky</li></ul><p>First, let’s set up the building blocks for our server. We’ll write a controller that will answer requests comingin</p><pre tabindex=\"0\"><code></code></pre><p>Then in our server’s  file :</p><pre tabindex=\"0\"><code></code></pre><p>Before sending us a request for a given custom feed, Bluesky will ensure that our identity is valid. There are several methods to assert our identity, namely  and . Here we’ll use the  method as it is the easiest to setup. Be mindful that it has a limitation. It does not support domain migration, so ensure that the domain you chose is the correct one as changing it later on will prove difficult.</p><p>To assert our identity we just need to produce the correct response which in my case looks like this:</p><pre tabindex=\"0\"><code></code></pre><p>Here is the code snippet that generates such a response :</p><pre tabindex=\"0\"><code></code></pre><p>We are at the end of our little journey. We now only need to setup the actual custom feed implementation. But first let’s summarize what happens when a user requests a feed from Bluesky.</p><ul><li>The user load is newsfeed</li><li>Bluesky will fetch the information related to that feed</li><li>Bluesky will check the identity linked to that feed (which we just implemented)</li><li>Bluesky will send a request to the feed’s domain name. This request will be made against the following endpoint :</li></ul><pre tabindex=\"0\"><code></code></pre><p>Here is an example of a valid response for this request</p><pre tabindex=\"0\"><code></code></pre><p>The cursor field in the request and the response will be used for pagination. This is an opaque field that’s just generated by our server and sent back by Bluesky on the next request. This value has no meaning for Bluesky and its meaning is the responsibility of the custom feed developer. In our case we we’ll use the ID of the last post that we returned. That way, we will be able to send the next batch of posts when we receive a request for the next page.\nSince theses IDs are generated sequentially, we know for a fact that we will get the posts from newest to oldest</p><p>Here is how to generate such a response in our code.</p><pre tabindex=\"0\"><code></code></pre><p>Here is the implementation for my custom feed for posts about cycling and commuting on a bicycle:</p><pre tabindex=\"0\"><code></code></pre><p>I use  to generate the code that will execute the SQL requests. Here is the request I used (I’m not including the generated boilerplate code as it is not really relevant for this post).</p><pre tabindex=\"0\"><code></code></pre><p>This request will fetch any post in a given language, for which the ID is below the cursor. We also use the  function of PostgreSQL to perform a full text search and retrieve posts that contain terms for our query. Finally we limit the number of posts to retrieve with the given limit parameter given by Bluesky.</p><p>For the pagination to work correctly, we must ensure that the result of this request is stable and does not change over time. This is why we use the ID of the post (which is equivalent to the order in which the posts were indexed).</p><p>With that done, you should now be able to run this code and setup your domain name to point either to your local machine or to a server on which this code is deployed. Once that is done, you can go on your Bluesky profile to find your feed and navigate to it to see if everything works as expected.</p><h3>Set-up garbage collection</h3><p>If everything works well, congratulations. Although there is a last step that you must perform if you don’t want your database to grow infinitely over time. As there is quite a lot of traffic on Bluesky, the database can grow pretty quickly so regular cleanup is important.</p><p>To do so, we will simply launch a goroutine alongside the indexing process. This goroutine will simply run a cleanup command on a regular interval to delete posts older than 48 hours.</p><pre tabindex=\"0\"><code></code></pre><p>Thanks for reading along. I hope those explanations allowed you to see more clearly the tasks needed to set up your own Bluesky custom newsfeed. The complete source code is available at <a href=\"https://gitlab.com/Dhawos/bluesky-custom-feeds\">https://gitlab.com/Dhawos/bluesky-custom-feeds</a>. Don’t hesitate to take a look</p><p>You can let me know if you enjoyed this article on my Bluesky: <a href=\"https://bsky.app/profile/dhawos.bsky.social\">@dhawos.bsky.social</a>. And if it helped you build your own feed, please share it, I would love to see what you build.</p><p>If you happen to be interested in my feeds, you can find them here : (although they only show posts in French for now)</p>","contentLength":9273,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1ik3mwi/setting_up_your_own_bluesky_feed_in_go/"},{"title":"What are some things you would change about Go?","url":"https://www.reddit.com/r/golang/comments/1ik1zqx/what_are_some_things_you_would_change_about_go/","date":1738953018,"author":"/u/Jamlie977","guid":393,"unread":true,"content":"<p>what are some weird things in Go that you'd like to change?</p><p>for me, maps default to nil is a footgun</p>","contentLength":99,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Create a Server Driven CLI from your REST API","url":"https://zuplo.com/blog/2025/02/02/generate-cli-from-api-with-climate","date":1738949086,"author":"/u/ZuploAdrian","guid":388,"unread":true,"content":"<blockquote><p>This article is written by <a href=\"https://github.com/lispyclouds\">Rahul Dé</a>, a VP of\nSite Reliability Engineering at Citi and creator/maintainer of popular tools\nlike <a href=\"https://github.com/babashka/babashka\">babashka</a>,\n<a href=\"https://github.com/bob-cd/bob\">bob</a>, and now\n<a href=\"https://github.com/lispyclouds/climate\">climate</a>. All opinions expressed are\nhis own.</p></blockquote><p>APIs, specifically the REST APIs are everywhere and the\n<a href=\"https://swagger.io/specification/\">OpenAPI</a> is pretty much a standard.\nAccessing them via various means is a fairly regular thing that a lot of us do\noften and when it comes to the CLI (Command Line Interface) languages like Go,\nRust etc are quite popular choices when building. These languages are mostly of\nstatically typed in nature, favouring a closed world approach of knowing all the\ntypes and paths at compile time to be able to produce lean and efficient binary\nfor ease of deployment and use.</p><p>Like with every engineering choice, there are trade-offs. The one that's here is\nthe loss of dynamism, namely we see a lot of bespoke tooling in these languages\ndoing fundamentally the same thing: make HTTP calls and let users have a better\nexperience than making those calls themselves. The need to know all the types\nand paths beforehand causes these perceived maintenance issues:</p><ul><li>Spec duplication: the paths, the schemas etc need to be replicated on the\nclient side again. eg when using the popular <a href=\"https://cobra.dev/\">Cobra</a> lib\nfor Go, one must tell it all the possible types beforehand.</li><li>Tighter coupling of client and server: As we have to know each of the paths\nand the methods that a server expects, we need to essentially replicate that\nsame thing when making the requests making a tight coupling which is\nsusceptible to breakage when the API changes. API is a product having its own\nversioning. eg kubectl only supports\n<a href=\"https://kubernetes.io/releases/version-skew-policy/\">certain versions</a> of\nkubernetes. Similarly podman or docker CLIs.</li><li>Servers can't influence the client: Ironically to the previous point, as we\nnow have replicated the server spec on the client side we effectively have a\nsplit brain: changes on the server like needing a new parameter etc need to be\ncopied over to the client.</li></ul><p>All of this put together increases the maintenance overhead and its specially\ntrue for complex tooling like kubectl.</p><p>I work primarily on the infra side of this, namely Platform and Site Reliability\nEngineering which involves me having other developers as my users and this\ncascading effect of an API breakage is quite painful. There are way to work\naround this issue and from my experience, being\n<a href=\"https://www.atlassian.com/blog/technology/spec-first-api-development\">spec-first</a>\nseems to offer the best balance of development and maintenance velocities.</p><p>I am quite a big fan of being spec-first, mainly for the following reasons:</p><ul><li>The API spec is the single source of truth: This is what your users see and\nnot your code. Make this the first class citizen like your users and the code\nshould use this and not the other way round.</li><li>This keeps all the servers and clients in sync automatically with less\nbreakage.</li><li>This keeps a nice separation between the business logic (the API handler code)\nand the infra thereby allowing developers to focus on what's important.</li></ul><p>Another project of mine <a href=\"https://bob-cd.github.io/\">Bob</a> can be seen as an\nexample of spec-first design. All its tooling follow that idea and its\n<a href=\"https://bob-cd.github.io/cli/\">CLI</a> inspired Climate. A lot of Bob uses\n<a href=\"https://clojure.org/\">Clojure</a> a language that I cherish and who's ideas make\nme think better in every other place too.</p><p>Although codegen is one of the ways to be spec-first, I personally don't\nsubscribe to the approach of generating code:</p><ul><li>Introduces another build step adding complexity and more layers of debugging.</li><li>Makes the build more fragile in keeping up with tooling and language changes.</li><li>The generated code comes with its own opinions and is often harder to\nchange/mould to our needs.</li><li>It is static code at the end, can't do much at runtime.</li></ul><ul><li><a href=\"https://rest.sh/\">restish</a>: Inspired some of the ideas behind this. This is a\nproject with different goals of being a fully automatic CLI for an OpenAPI\nREST API and is a bit hard to use as a lib.</li><li><a href=\"https://github.com/lispyclouds/navi\">navi</a>: Server side spec-first library I\nwrote for Clojure which inspired the handler mechanism in Climate.</li></ul><p>Keeping all of the above into consideration and the fact that Go is one of the\nmost widely used CLI languages,\n<a href=\"https://github.com/lispyclouds/climate\">Climate</a> was built to address the\nissues.</p><p>As the name implies, its your mate or sidekick when building CLIs in Go with the\nintentions of:</p><ul><li>Keeping the REST API boilerplate away from you.</li><li>Keep the CLI code always in sync with the changes on the server.</li><li>Ability to bootstrap at runtime without any code changes.</li><li>Decoupling you from API machinery, allowing you to focus on just the handlers,\nbusiness logic and things that may not the part of the server calls.</li><li>It does just enough to take the machinery out and not more like making the\ncalls for you too; that's business logic.</li></ul><p>Every OpenAPI3 Schema consists of one or more\n<a href=\"https://swagger.io/docs/specification/v3_0/paths-and-operations/#operations\">Operations</a>\nhaving an . An Operation is a combination of the HTTP path, the\nmethod and some parameters.</p><p>Overall, Climate works by with these operations at its core. It:</p><ul><li>Parses these from the YAML or JSON file.</li><li>Transforms each of these into a corresponding Cobra command by looking at\nhints from the server.</li><li>Transform each of the parameters into a Flag with the type.</li><li>Build a grouped Cobra command tree and attach it to the root command.</li></ul><p>Climate allows the server to influence the CLI behaviour by using OpenAPI's\n<a href=\"https://swagger.io/docs/specification/v3_0/openapi-extensions/\">extensions</a>.\nThis is the secret of Climate's dynamism. Influenced by some of the ideas behind\n<a href=\"https://rest.sh/\">restish</a> it uses the following extensions as of now:</p><ul><li>: A list of strings which would be used as the alternate names\nfor an operation.</li><li>: A string to allow grouping subcommands together. All operations\nin the same group would become subcommands in that group name.</li><li>: A boolean to hide the operation from the CLI menu. Same\nbehaviour as a cobra command hide: it's present and expects a handler.</li><li>: A boolean to tell climate to omit the operation completely.</li><li>: A string to specify a different name. Applies to operations and\nrequest bodies as of now.</li></ul><p>As of now, only the primitive types are supported:</p><ul></ul><p>More support for\n<a href=\"https://swagger.io/docs/specification/v3_0/data-models/data-types/\">types</a> like\ncollections and composite types are planned. These are subject to limitations of\nwhat Cobra can do out of the box and what makes sense from a CLI perspective.\nThere are sensible default behaviour like for request bodies its implicity\n which handles most cases. These types are converted to Flags with the\nappropriate type checking functions and correctly coerced or the errors reported\nwhen invoked.</p><p>Checkout <a href=\"https://github.com/bob-cd/wendy\">Wendy</a> as a proper example of a\nproject built with Climate.</p><p>This assumes an installation of <a href=\"https://go.dev/doc/install\">Go 1.23+</a> is\navailable.</p><pre tabindex=\"0\"><code></code></pre><pre tabindex=\"0\"><code></code></pre><pre tabindex=\"0\"><code></code></pre><p>Define a cobra root command:</p><pre tabindex=\"0\"><code></code></pre><p>Define one or more handler functions of the following signature:</p><pre tabindex=\"0\"><code></code></pre><p>As of now, each handler is called with the cobra command it was invoked with,\nthe args and an extra , more info\n<a href=\"https://pkg.go.dev/github.com/lispyclouds/climate#pkg-types\">here</a></p><p>This can be used to query the params from the command mostly in a type safe\nmanner:</p><pre tabindex=\"0\"><code></code></pre><p>Define the handlers for the necessary operations. These map to the \nfield of each operation:</p><pre tabindex=\"0\"><code></code></pre><p>Bootstrap the root command:</p><pre tabindex=\"0\"><code></code></pre><p>Continue adding more commands and/or execute:</p><pre tabindex=\"0\"><code></code></pre><pre tabindex=\"0\"><code></code></pre><p>Climate results from my experiences of being at the confluence of many teams\ndeveloping various tools and proving the need to keep specifications at the\ncentre of things. WIth this it hopefully inspires others to adopt such\napproaches and with static tooling like Go, its still possible to make flexible\nthings which keep the users at the forefront.</p>","contentLength":7150,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1ik0dpg/create_a_server_driven_cli_from_your_rest_api/"}],"tags":["dev","reddit","go"]}